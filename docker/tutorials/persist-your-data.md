---
title: Учебник по DOCKER. часть 4. Сохранение данных
description: Узнайте, как сохранять данные в базе данных и совместно использовать каталоги в контейнере путем подключения тома.
ms.date: 08/04/2020
author: nebuk89
ms.author: ghogen
manager: jillfra
ms.technology: vs-azure
ms.topic: conceptual
ms.workload:
- azure
ms.openlocfilehash: 34b3cb9465c1efb946260917d755729e25c4e259
ms.sourcegitcommit: c4212f40df1a16baca1247cac2580ae699f97e4c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/31/2020
ms.locfileid: "89176793"
---
# <a name="persist-your-data"></a> Сохранение данных

Если вы не заметили, список TODO очищается каждый раз при запуске контейнера. Почему? Давайте рассмотрим работу контейнера.

## <a name="the-containers-filesystem"></a>Файловая система контейнера

При запуске контейнера он использует различные слои из образа для файловой системы. Каждый контейнер также получает собственный «вспомогательный» для создания, обновления или удаления файлов. Любые изменения не будут отображаться в другом контейнере, *даже если* они используют одно и то же изображение.

### <a name="see-this-in-practice"></a>См. статью на практике

Чтобы увидеть это в действии, необходимо запустить два контейнера и создать файл в каждом из них. Вы увидите, что файлы, созданные в одном контейнере, недоступны в другом.

1. Запустите `ubuntu` контейнер, который создаст файл `/data.txt` с именем случайным числом от 1 до 10000.

    ```bash
    docker run -d ubuntu bash -c "shuf -i 1-10000 -n 1 -o /data.txt && tail -f /dev/null"
    ```

    Если вы хотите узнать о команде, вы запускаете оболочку Bash и вызываете две команды (почему она есть `&&` ). Первая часть выбирает одно случайное число и записывает его в `/data.txt` . Вторая команда просто наблюдает за файлом для сохранения работоспособности контейнера.

1. Проверьте, можно просмотреть выходные данные с помощью `exec` для получения в контейнер. Для этого откройте расширение VS Code и нажмите кнопку **attach Shell (подключить оболочку** ). Будет использоваться `exec` для открытия оболочки в контейнере в VS Code терминала.

    ![VS Code открыть интерфейс командной строки в контейнере Ubuntu](media/attach_shell.png)

    Вы увидите терминал, на котором выполняется оболочка в контейнере Ubuntu. Выполните следующую команду, чтобы просмотреть содержимое `/data.txt` файла. Затем снова закройте этот терминал.

    ```bash
    cat /data.txt
    ```

    Если вы предпочитаете командную строку, можно использовать `docker exec` команду, чтобы сделать то же самое. Необходимо получить идентификатор контейнера (используйте его `docker ps` для получения) и получить содержимое с помощью следующей команды.

    ```bash
    docker exec <container-id> cat /data.txt
    ```

    Вы должны увидеть случайное число!

1. Теперь запустите другой `ubuntu` контейнер (то же самое изображение), и вы увидите, что у вас нет того же файла.

    ```bash
    docker run -it ubuntu ls /
    ```

    И посмотрите! Нет `data.txt` файла. Это обусловлено тем, что он был записан в область временных файлов только для первого контейнера.

1. Удалите первый контейнер с помощью `docker rm -f` команды.

## <a name="container-volumes"></a>Тома контейнеров

В предыдущем эксперименте вы увидели, что каждый контейнер начинается с определения образа при каждом запуске. Хотя контейнеры могут создавать, обновлять и удалять файлы, эти изменения теряются при удалении контейнера, и все изменения изолируются с этим контейнером. С помощью томов можно изменить все это.

[Тома](https://docs.docker.com/storage/volumes/) обеспечивают возможность подключения конкретных путей файловой системы к контейнеру к главному компьютеру. Если каталог в контейнере подключен, изменения в этом каталоге также будут отображаться на хост-компьютере. Если подключить этот же каталог к перезапуску контейнера, то будут отображены те же файлы.

Существует два основных типа томов. в конечном итоге будут использоваться оба, но вы начнете с **именованных томов**.

## <a name="persist-your-todo-data"></a>Сохранение данных TODO

По умолчанию приложение Todo сохраняет свои данные в [базе данных SQLite](https://www.sqlite.org/index.html) по адресу `/etc/todos/todo.db` . Если вы не знакомы с SQLite, не беспокойтесь! Это просто реляционная база данных, в которой все данные хранятся в одном файле. Хотя это и не лучше подходит для крупномасштабных приложений, оно работает для небольших демонстраций. Мы поговорим о переключении этого компонента на фактическую версию ядра СУБД позже.

Если база данных является отдельным файлом, то, если вы можете сохранить этот файл на узле и сделать его доступным для следующего контейнера, он должен иметь возможность выбрать там, где остался последний. Создавая том и присоединяя его (часто называемый "подключением") к каталогу, в котором хранятся данные, можно сохранить данные. Когда контейнер записывает данные в `todo.db` файл, он сохраняется на узле в томе.

Как уже упоминалось, вы будете использовать **именованный том**. Именованный том следует рассматривать как просто контейнер данных. DOCKER сохраняет физическое расположение на диске, и вам нужно запомнить только имя тома. При каждом использовании тома DOCKER обеспечит правильность предоставленных данных.

1. Создайте том с помощью `docker volume create` команды.

    ```bash
    docker volume create todo-db
    ```

1. Снова завершите работу контейнера приложения Todo на панели мониторинга (или с `docker rm -f <id>` ), так как он все еще выполняется без использования постоянного тома.

1. Запустите контейнер приложения Todo, но добавьте флаг, `-v` чтобы указать подключение тома. Вы будете использовать именованный том и подключит его к `/etc/todos` , который будет записывать все файлы, созданные по пути.

    ```bash
    docker run -dp 3000:3000 -v todo-db:/etc/todos getting-started
    ```

1. После запуска контейнера откройте приложение и добавьте несколько элементов в список дел.

    ![Элементы, добавленные в список дел](media/items-added.png)

1. Удалите контейнер для приложения Todo. Используйте панель мониторинга или, `docker ps` чтобы получить идентификатор, а затем `docker rm -f <id>` удалите ее.

1. Запустите новый контейнер с помощью той же команды выше.

1. Откройте приложение. Элементы должны отобразиться в списке.

1. После завершения проверки списка удалите контейнер.

Радостных! Теперь вы узнали, как сохранять данные!

> [!TIP]
> Хотя именованные тома и привязки привязываются (которые будут обсуждаться в минуту) — это два основных типа томов, поддерживаемых установкой подсистемы DOCKER по умолчанию, существует множество подключаемых модулей драйверов томов для поддержки NFS, SFTP, NetApp и других. Это будет особенно важно после запуска контейнеров на нескольких узлах в кластерной среде с помощью Swarm, Kubernetes и т. д.

## <a name="dive-into-your-volume"></a>Погрузитесь в том

Многие люди часто спрашивают: «где при использовании именованного тома *DOCKER сохраняет мои* данные?» Если вы хотите получить сведения, можно использовать `docker volume inspect` команду.

```bash
docker volume inspect todo-db
[
    {
        "CreatedAt": "2019-09-26T02:18:36Z",
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/todo-db/_data",
        "Name": "todo-db",
        "Options": {},
        "Scope": "local"
    }
]
```

`Mountpoint`— Это фактическое расположение на диске, где хранятся данные. Обратите внимание, что на большинстве компьютеров необходим корневой доступ для доступа к этому каталогу с узла. Но именно здесь это!

> [!NOTE]
> **Доступ к данным тома непосредственно на рабочем столе DOCKER** При работе в DOCKER Desktop команды DOCKER фактически выполняются внутри небольшой виртуальной машины на компьютере. Если вы хотите просмотреть фактическое содержимое каталога *mountpoint* , необходимо сначала получить его внутри виртуальной машины. В WSL 2 это находится внутри WSL 2 дистрибутив и доступ к нему можно получить с помощью проводника.

## <a name="recap"></a>Резюме

На этом этапе у вас есть работающее приложение, которое может выдерживать перезапуски. Вы можете отобразить его на инвесторов и надеюсь, что они могут перехватить ваше видение.

Однако вы уже видели, что перестроение образов для каждого изменения занимает довольно много времени. Есть лучший способ внести изменения, верно? При использовании привязок BIND (которые мы уже упоминали ранее) существует лучший способ. Давайте рассмотрим этот момент!

## <a name="next-steps"></a>Дальнейшие действия

Продолжайте работу с руководством.

> [!div class="nextstepaction"]
> [Использование подключений BIND](use-bind-mounts.md)
