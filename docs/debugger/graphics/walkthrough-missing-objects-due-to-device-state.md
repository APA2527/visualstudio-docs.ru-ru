---
title: Пошаговое руководство. Отсутствие объектов вследствие состояния устройства | Документация Майкрософт
description: Проведите анализ для обнаружения неправильно настроенного состояния устройства. В этом руководстве показано, как использовать список событий графики, окно "Этапы графического конвейера" и журнал пикселей графики.
ms.custom: SEO-VS-2020
ms.date: 11/04/2016
ms.topic: conceptual
ms.assetid: 1b0d2bbd-0729-4aa5-8308-70c5bf1468c5
author: mikejo5000
ms.author: mikejo
manager: jmartens
ms.workload:
- multiple
ms.openlocfilehash: a8eff8a088823bc46363d2e5ea7b40b3e2b8478e
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2021
ms.locfileid: "99890439"
---
# <a name="walkthrough-missing-objects-due-to-device-state"></a>Пошаговое руководство. Отсутствие объектов вследствие состояния устройства
В данном пошаговом руководстве показано, как с помощью диагностики графики [!INCLUDE[vsprvs](../../code-quality/includes/vsprvs_md.md)] исследовать объект, который отсутствует из-за неправильно настроенного состояния устройства.

 В этом пошаговом руководстве показывается:

- использование **списка событий графики** для обнаружения возможных источников проблемы;

- проверка результата вызова API Direct3D **с помощью окна** Этапы графического конвейера `DrawIndexed` ;

- использование окна **Журнал пикселей графики** для более точной локализации проблемы;

- проверка состояния устройства на наличие потенциальных проблем или неверных параметров.

## <a name="scenario"></a>Сценарий
 Одной из причин, по которой объекты не отображаются в трехмерном приложении там, где должны, является неправильная конфигурация графического устройства, из-за которой объекты исключаются из отрисовки. Например, когда порядок вращения треугольников приводит к их ошибочной отбраковке или когда из-за функции теста глубины все пиксели в объекте отклоняются.

 В сценарии, описанном в данном пошаговом руководстве, достигнут первый этап в разработке трехмерного приложения, оно готово к первоначальному тестированию. Однако при запуске приложения на экране отображается только пользовательский интерфейс. С помощью диагностики графики можно записать данные о проблеме в файл журнала графики, чтобы можно было выполнить отладку приложения. Проблема в приложении выглядит следующим образом:

 ![Приложение до исправления проблемы](media/vsg_walkthru1_firstview.png "vsg_walkthru1_firstview")

 Сведения о том, как записывать проблемы с графикой в журнал графики, см. в статье [Capturing Graphics Information](capturing-graphics-information.md).

## <a name="investigation"></a>Исследование
 С помощью средств диагностики графики можно загрузить файл журнала графики для проверки кадров, захваченных в ходе теста.

#### <a name="to-examine-a-frame-in-a-graphics-log"></a>Анализ кадра в журнале графики

1. В [!INCLUDE[vsprvs](../../code-quality/includes/vsprvs_md.md)]загрузите журнал графики, содержащий кадр, на котором видно, что модель отсутствует. В [!INCLUDE[vsprvs](../../code-quality/includes/vsprvs_md.md)]отобразится новая вкладка диагностики графики. В верхней части этой вкладки находится вывод целевого объекта отрисовки для выбранного кадра. В нижней части находится **Список кадров**, в котором каждый захваченный кадр отображается как эскиз.

2. В **списке кадров** выберите кадр, который демонстрирует, что модель не отображается. Однобуферная прорисовка обновляется, и в ней отображается выбранный кадр. В этом сценарии вкладка журнала графики выглядит следующим образом:

    ![Предварительный просмотр и список кадров буфера кадров вкладки .vsglog](media/vsg_walkthru1_experiment.png "vsg_walkthru1_experiment")

   После выбора кадра, который демонстрирует проблему, можно воспользоваться окном **Список событий графики** для ее диагностики. **Список событий графики** содержит все вызовы API Direct3D, которые были выполнены для отрисовки активного кадра, например вызовы API для настройки состояния устройства, для создания и обновления буферов, а также для рисования объектов, которые присутствуют в кадре. Многие типы вызовов представляют интерес, так как при надлежащей работе приложения часто (но не всегда) происходит соответствующее изменение в целевом объекте отрисовки. Это касается вызовов Draw, Dispatch, Copy или Clear. Особенно интересны вызовы Draw, так как каждый из них представляет геометрию, отрисованную приложением (вызовы Dispatch также могут отрисовывать геометрию).

#### <a name="to-ensure-that-draw-calls-are-being-made"></a>Как убедиться, что вызовы Draw выполняются

1. Откройте окно **Список событий графики** . На панели инструментов **Диагностика графики** выберите **Список событий**.

2. Проверьте **список событий графики** для вызовов Draw. Чтобы упростить эту задачу, введите Draw в поле **Поиск** в верхнем правом углу окна **Список событий графики** . Список будет отфильтрован и будет содержать только события, в названиях которых присутствует слово «Draw». В этом сценарии выясняется, что были выполнены несколько вызовов Draw:

    ![Список событий графики, содержащий захваченные события](media/vsg_walkthru1_.png "vsg_walkthru1_")

   После подтверждения того, что вызовы Draw выполняются, можно определить, какой из них соответствует отсутствующей геометрии. Так как известно, что отсутствующая геометрия не отрисовывается для целевого объекта (в данном случае), можно использовать окно **Этапы графического конвейера** , чтобы определить, какой из вызовов Draw соответствует отсутствующей геометрии. В окне **Этапы графического конвейера** показана геометрия, отправленная в каждый вызов Draw независимо от влияния на однобуферную прорисовку. По мере продвижения по вызовам Draw этапы конвейера обновляются для отображения геометрии, связанной с конкретным вызовом, а вывод целевого объекта отрисовки обновляется для отображения состояния целевого объекта отрисовки по завершении вызова.

#### <a name="to-find-the-draw-call-for-the-missing-geometry"></a>Поиск вызова Draw для отсутствующей геометрии

1. Откройте окно **Этапы графического конвейера** . На панели инструментов **Диагностика графики** выберите **Этапы конвейера**.

2. Перемещайтесь по каждому вызову Draw во время поиска в окне **Этапы графического конвейера** отсутствующей модели. На этапе **Сборщик входных данных** показаны необработанные модели данных. На этапе **Шейдер вершин** показаны преобразованные данные модели. На этапе **Построитель текстуры** показан результат работы построителя текстуры. На этапе **Средство слияния вывода** показан объединенный целевой объект отрисовки этого и всех предыдущих вызовов Draw.

3. Остановитесь, когда достигнете вызова Draw, соответствующего отсутствующей модели. В этом сценарии в окне **Этапы графического конвейера** показано, что геометрия была отрисована, но не отображается в целевом объекте отрисовки:

    ![Средство просмотра конвейера с отсутствующим объектом](media/vsg_walkthru1_pipeline.png "vsg_walkthru1_pipeline")

   Убедившись, что приложение отрисовало отсутствующую геометрию и обнаружен соответствующий вызов Draw, можно выбрать часть целевого объекта отрисовки, которая должна содержать отсутствующую геометрию, а затем использовать окно **Журнал пикселей графики** , чтобы узнать, почему пиксели были исключены. Журнал пикселей содержит список всех вызовов Draw, которые могли повлиять на определенный пиксель. Каждый вызов Draw в окне **Журнал пикселей графики** имеет идентификатор в виде номера, который также отображается в окне **Список событий графики** . Это помогает проверить, что пиксель отображает отсутствующую геометрию, и узнать причину исключения пикселя.

#### <a name="to-determine-why-the-pixel-was-excluded"></a>Определение причины исключения пикселя

1. Откройте окно **Журнал пикселей графики** . На панели инструментов **Диагностика графики** выберите **Журнал пикселей**.

2. На основе эскиза **построителя текстуры** выберите пиксель в выходных данных буфера кадров, которые должны содержать часть отсутствующей геометрии. В этом сценарии результат работы построителя текстуры должен покрывать большую часть целевого объекта отрисовки. После выбора пикселя окно **Журнал пикселей графики** будет выглядеть следующим образом:

    ![Окно журнала пикселей, в котором показаны соответствующие вызовы draw](media/vsg_walkthru1_hist1.png "vsg_walkthru1_hist1")

3. Убедитесь, что выбранный пиксель целевого объекта отрисовки содержит часть геометрии, сопоставив номер изучаемого вызова Draw (в окне **Список событий графики** ) с одним из вызовов Draw в окне **Журнал пикселей графики** . Если ни один из вызовов в окне **Журнал пикселей графики** не соответствует изучаемому вызову Draw, повторите эти действия (кроме шага 1), чтобы найти совпадение. В этом сценарии совпадающий вызов Draw выглядит следующим образом:

    ![Окно журнала пикселей, в котором показаны сведения о фрагменте](media/vsg_walkthru1_hist2.png "vsg_walkthru1_hist2")

4. При нахождении совпадения разверните соответствующий вызов Draw в окне **Журнал пикселей графики** и подтвердите, что пиксель был исключен. Каждый вызов Draw в окне **Журнал пикселей графики** соответствует одному или нескольким геометрическим примитивам (точки, линии или треугольники), пересекающим этот пиксель в результате геометрии соответствующего объекта. Каждое такое пересечение может влиять на окончательный цвет пикселя. Примитив, исключенный из-за непрохождения теста глубины, представлен значком с буквой Z над стрелкой, наклоненной вниз слева направо.

5. Разверните исключенный примитив для дальнейшего изучения состояния, явившегося причиной исключения. В группе **Средство слияния вывода** наведите указатель мыши на **Результаты**. Подсказка указывает, почему был исключен примитив. В этом сценарии анализ показывает, что примитив исключен, так как он не прошел тест глубины и поэтому не влияет на окончательный цвет пикселя.

   Установив, что геометрия не отображается из-за того, что ее примитивы не прошли тест глубины, следует предположить, что проблема связана с неправильно настроенным состоянием устройства. Для проверки состояния устройства и других данных объектов Direct3D можно пользоваться окном **Таблица графических объектов**.

#### <a name="to-examine-device-state"></a>Проверка состояния устройства

1. Откройте окно **Таблица графических объектов** . На панели инструментов **Диагностика графики** выберите **Таблица объектов**.

2. Найдите объект **Устройство D3D10** в **таблице графических объектов**, а затем откройте объект **Устройство D3D10** . В **откроется новая вкладка** Устройство D3D10 [!INCLUDE[vsprvs](../../code-quality/includes/vsprvs_md.md)]. Чтобы облегчить эту задачу, можно отсортировать **таблицу графических объектов** по **типу**:

    ![Таблица графических объектов и состояние связанного устройства](media/vsg_walkthru1_objtable.png "vsg_walkthru1_objtable")

3. Проверьте состояние устройства, которое отображается во вкладке **Устройство D3D10** , на наличие возможных проблем. Так как геометрия не отображается из-за того, что ее примитивы не прошли тест глубины, можно сосредоточиться на состоянии устройства, например на трафарете глубины, который влияет на тест глубины. В этом сценарии **описание трафарета глубины** (в разделе **Состояние средства слияния вывода**) содержит необычное значение члена **функции глубины** , `D3D10_COMPARISON_GREATER`:

    ![Окно устройства D3D10, содержащее сведения о трафарете глубины](media/vsg_walkthru1_devicestate.png "vsg_walkthru1_devicestate")

   Определив, что причиной проблемы отрисовки может быть неправильно настроенная функция глубины, можно использовать эту информацию совместно со знанием кода для поиска места, где функция глубины задана неправильно, и устранить проблему. Если вы не знакомы с кодом, можно выполнить поиск проблемы с помощью данных, собранных при отладке. Например, на основе **описания трафарета глубины** в этом сценарии можно в коде искать слово depth (глубина) или GREATER (больше). Внеся исправления в код, можно заново собрать его и еще раз запустить приложение, чтобы убедиться, что проблема с отрисовкой решена.

   ![Приложение после исправления проблемы](media/vsg_walkthru1_finalview.png "vsg_walkthru1_finalview")