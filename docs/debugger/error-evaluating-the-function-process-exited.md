---
title: 'Ошибка: целевой процесс завершил работу с кодом &apos;код&apos; при вычислении значения функции &apos;функция&apos; | Документация Майкрософт'
ms.date: 4/06/2018
ms.topic: error-reference
f1_keywords:
- vs.debug.error.process_exit_during_func_eval
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 94effc8a5f75e7b38fb7275d175eb324c479a7a9
ms.sourcegitcommit: de98ed7edc81383e47b87ae6e61143fbbbe7bc56
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/21/2020
ms.locfileid: "88711642"
---
# <a name="error-the-target-process-exited-with-code-39code39-while-evaluating-the-function-39function39"></a>Ошибка: Целевой процесс завершил работу с кодом code при вычислении значения функции function

Полный текст сообщения: Целевой процесс завершил работу с кодом code при вычислении функции function

Чтобы упростить проверку состояния для объектов .NET, отладчик автоматически выполняет дополнительный код в отлаживаемом процессе (обычно это методы получения свойств и функции `ToString`). В большинстве сценариев эти функции выполняются успешно или вызывают исключения, которые обрабатываются отладчиком. Но в некоторых обстоятельствах исключения невозможно перехватить: например, они пересекают границы ядра, требуют передачи сообщений пользователю или являются неустранимыми. В таком случае метод получения свойств или метод ToString, в котором выполняемый код явным образом завершает процесс (например, вызывает `ExitProcess()`) или создает необработанное исключение (например, `StackOverflowException`), автоматически завершает отлаживаемый процесс и весь сеанс отладки. Если вы увидите указанное выше сообщение об ошибке, значит возникла именно такая ситуация.

Одна из распространенных причин возникновения этой проблемы связана с тем, что отладчик пытается вычислить свойство, которое вызывает само себя, и это может привести к исключению переполнения стека. Исключение переполнения стека является неустранимым, поэтому процесс отладки завершается.

## <a name="to-correct-this-error"></a>Исправление ошибки

Для этой проблемы есть два возможных решения.

### <a name="solution-1-prevent-the-debugger-from-calling-the-getter-property-or-tostring-method"></a>Решение 1. Запрет вызова метода получения свойств или метода ToString в отладчике 

В сообщении об ошибке будет указано имя функции, которую отладчик пытался вызвать. Используя это имя функции, попробуйте повторно вычислить ее значение в окне **Интерпретация**, чтобы отладить вычисление. При вычислении в окне **Интерпретация** отладка не завершается, так как отладчик в этом случае прерывает работу по необработанным исключениям, в отличие от неявных вычислений в окнах **Видимые, Локальные, Контрольные значения**.

Если вы можете изменить эту функцию, запретите отладчику вызвать метод получения свойств или метод `ToString`. Выполните одно из следующих действий.

* Укажите в методе любой другой тип кода, кроме метода получения свойств и метода ToString, и проблема исчезнет.
    -или-
* (Для `ToString`) Определите для типа атрибут `DebuggerDisplay`, чтобы отладчик мог вычислить другое значение, кроме `ToString`.
    -или-
* (Для метода получения свойства) Установите для свойства атрибут `[System.Diagnostics.DebuggerBrowsable(DebuggerBrowsableState.Never)]`. Это может быть полезно, если какой-то из ваших методов должен оставаться свойством для обеспечения совместимости с API, хотя по сути является настоящим методом.

Если вы не можете изменить такой метод, возможно получится прервать целевой процесс по другой инструкции и повторить попытку вычисления.

### <a name="solution-2-disable-all-implicit-evaluation"></a>Решение 2. Отключение всех неявных вычислений

Если ни одно из предыдущих решений не устраняет проблему, перейдите в раздел **Средства** > **Параметры** и снимите флажок **Отладка** > **Общие** > **Включить вычисление свойства и другие неявные вызовы функций**. Это отключит большинство неявных вычислений функций, что должно устранить проблему.
