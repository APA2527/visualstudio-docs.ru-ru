---
title: Декомпилизирование кода .NET во время отладки Документы Майкрософт
ms.date: 2/2/2020
ms.topic: conceptual
dev_langs:
- CSharp
helpviewer_keywords:
- decompilation, debugger, exception
- debugging [Visual Studio], decompilation, source not found
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
monikerRange: '>= vs-2019'
ms.openlocfilehash: d63c05120842d52dd54359e128d0cc5f2a195817
ms.sourcegitcommit: cc841df335d1d22d281871fe41e74238d2fc52a6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/18/2020
ms.locfileid: "79508749"
---
# <a name="generate-source-code-from-net-assemblies-while-debugging"></a>Создание исходного кода из сборок .NET во время отладки

При отладке приложения .NET вы можете обнаружить, что вы хотите просмотреть исходный код, которого у вас нет. Например, нарушение исключения или использование стека вызовов для навигации по исходному месту.

> [!NOTE]
> * Генерация исходного кода (декомпилация) доступна только для приложений .NET и основана на проекте [ILSpy](https://github.com/icsharpcode/ILSpy) с открытым исходным кодом.
> * Декомпиляция доступна только в Visual Studio 2019 16.5 и позже.
> * Применение атрибута [SuppressIldasmAttribute](https://docs.microsoft.com/dotnet/api/system.runtime.compilerservices.suppressildasmattribute) к сборке или модулю предотвращает попытку visual Studio.

## <a name="generate-source-code"></a>Создание исходного кода

Когда вы отлажаете и исходный код не доступен, Visual Studio показывает документ **Source Not Found,** или если у вас нет символов для сборки, нет **загруженного символа символов.** Оба документа имеют опцию **исходного кода Decompile,** которая генерирует код C-кода для текущего местоположения. Сгенерированный код C's может быть использован так же, как и любой другой исходный код. Можно просматривать код, проверять переменные, устанавливать точки разрыва и так далее.

### <a name="no-symbols-loaded"></a>Нет символов загружены

На следующей иллюстрации показано сообщение **No Symbols Loaded.**

![Скриншот не символ загруженного документа](media/decompilation-no-symbol-found.png)

### <a name="source-not-found"></a>Источник не найден

На следующей иллюстрации показано сообщение **Source Not Found.**

![Скриншот источника не найденного документа](media/decompilation-no-source-found.png)

## <a name="generate-and-embed-sources-for-an-assembly"></a>Создание и встраиваемые источники для сборки

В дополнение к генерации исходного кода для определенного местоположения можно создать весь исходный код для данной сборки .NET. Для этого перейдите в окно **модулей** и из контекстного меню сборки .NET, а затем выберите команду **исходного кода Decompile.** Visual Studio генерирует файл символа для сборки, а затем встраивает источник в файл символа. На более позднем этапе можно [извлечь](#extract-and-view-the-embedded-source-code) встроенный исходный код.

![Скриншот меню контекста сборки в окне модулей с командой исходного кода decompile.](media/decompilation-decompile-source-code.png)

## <a name="extract-and-view-the-embedded-source-code"></a>Извлечение и просмотр встроенного исходного кода

Можно извлечь исходные файлы, встроенные в файл символов, используя команду **Extract Source Code** в контекстном меню окна **модулей.**

![Скриншот меню контекста сборки в окне модулей с командой источников извлечения.](media/decompilation-extract-source-code.png)

Извлеченные исходные файлы добавляются в решение как [разные файлы.](../ide/reference/miscellaneous-files.md) В Visual Studio функция «прочие файлы» отключена по умолчанию. Вы можете включить эту функцию**Environment** > из**документов среды** > **параметры** >  **инструментов** > **Показать различные файлы в checkbox Solution Explorer.** Без включения этой функции вы не сможете открыть извлеченный исходный код.

![Скриншот страницы опции инструментов с включенным вариантом различных файлов.](media/decompilation-tools-options-misc-files.png)

Извлеченные исходные файлы отображаются в разных файлах в **Solution Explorer.**

![Скриншот исследователя решения с разноместными файлами.](media/decompilation-solution-explorer.png)

## <a name="known-limitations"></a>Известные ограничения

### <a name="requires-break-mode"></a>Требуется режим перерыва

Создание исходного кода с помощью декомпиляции возможно только в том случае, если отладчик находится в режиме перерыва и приложение приостанавливается. Например, Visual Studio вводит режим перерыва, когда попадает в точку разрыва или исключение. Вы можете легко вызвать Visual Studio, чтобы сломать следующий![раз,](media/decompilation-break-all.png)когда ваш код работает с помощью команды **Break All** ( Break all icon).

### <a name="decompilation-limitations"></a>Ограничения декомпиляции

Создание исходного кода из промежуточного формата (IL), используемого в сборках .NET, имеет некоторые присущие ему ограничения. Таким образом, генерируемый исходный код не похож на исходный исходный код. Большинство различий в тех местах, где информация в исходном коде не требуется во время выполнения. Например, такие сведения, как пробелы, комментарии и имена локальных переменных, не нужны во время выполнения. Мы рекомендуем использовать генерируемый источник, чтобы понять, как программа исполняется, а не в качестве замены исходного кода.

### <a name="debug-optimized-or-release-assemblies"></a>Оптимизация или выпуск сборок

При отладке кода, который был декомпилирован из сборки, которая была составлена с помощью оптимизации компилятора, вы можете столкнуться с следующими проблемами:
- Точки разрыва не всегда могут связываться с соответствующим местоположением источников.
- Шаг не всегда может перейти к правильному местоположению.
- Локальные переменные могут не иметь точных имен.
- Некоторые переменные могут быть недоступны для оценки.

Более подробную информацию можно найти в выпуске GitHub: [ICSharpCode.Decompiler интеграции в VS Debugger](https://github.com/icsharpcode/ILSpy/issues/1901).

### <a name="decompilation-reliability"></a>Надежность декомпилации

Относительно небольшой процент попыток декомпилации может привести к сбою. Это связано с ошибкой нулевой ссылки точки последовательности в ILSpy.  Мы смягчили неудачу, поймав эти проблемы и изящно провалив попытку декомпилации.

Более подробную информацию можно найти в выпуске GitHub: [ICSharpCode.Decompiler интеграции в VS Debugger](https://github.com/icsharpcode/ILSpy/issues/1901).

### <a name="limitations-with-async-code"></a>Ограничения с кодом async

Результаты декомпиляции модулей с шаблонами кода async/await могут быть неполными или полностью сбойными. Внедрение ILSpy async/await and yield state-machines осуществляется лишь частично. 

Более подробную информацию можно найти в выпуске GitHub: [PdB Generator Status](https://github.com/icsharpcode/ILSpy/issues/1422).

### <a name="just-my-code"></a>Только мой код

Настройки [Just My Code (JMC)](https://docs.microsoft.com/visualstudio/debugger/just-my-code) позволяют Visual Studio перешагнуть через систему, фреймворк, библиотеку и другие непользовательские звонки. Во время сеанса отладки окно **модулей** показывает, какие модули кода отладчик рассматривает как My Code (код пользователя).

Декомпилация оптимизированных или высвободительных модулей производит непользовательский код. Например, если отладчик ломается в декомпилированном непользовательском коде, появляется окно **No Source.** Чтобы отключить just My Code, перейдите к **опционам инструментов** > **Options** (или**вариантам** **оттачивания),** >  > > **отладить****общее**, а затем отменить **включение просто мой код**.

### <a name="extracted-sources"></a>Извлеченные источники

Исходный код, извлеченный из сборки, имеет следующие ограничения:
- Имя и местоположение генерируемых файлов не настраивается.
- Файлы являются временными и будут удалены Visual Studio.
- Файлы размещаются в одной папке, и любая иерархия папок, которая была использована в исходных источниках, не используется.
- Имя файла для каждого файла содержит хэш хэш файла проверки.

### <a name="generated-code-is-c-only"></a>Сгенерированный код — это только C
Декомпиляция генерирует только файлы исходного кода в C. Нет возможности создавать файлы на любом другом языке.
