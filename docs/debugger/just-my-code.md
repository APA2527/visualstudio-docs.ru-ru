---
title: Отладка пользовательского кода с помощью Только мой код | Документация Майкрософт
ms.date: 02/13/2019
ms.topic: conceptual
ms.assetid: 0f0df097-bbaf-46ad-9ad1-ef5f40435079
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 9c1d474b388dd8f116eb53febb8a472d4c5b8150
ms.sourcegitcommit: 08c144d290da373df841f04fc799e3133540a541
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/17/2019
ms.locfileid: "72535993"
---
# <a name="debug-only-user-code-with-just-my-code"></a>Отладка только пользовательского кода с помощью Только мой код

*Только мой код* — это функция отладки Visual Studio, которая автоматически перебирает вызовы к системе, платформе и другим непользовательским кодом. В окне **Стек вызовов** только мой код сворачивает эти вызовы в фреймы **[внешний код]** .

Только мой код работает иначе в проектах .NET, C++и JavaScript.

## <a name="BKMK_Enable_or_disable_Just_My_Code"></a> Включение или отключение режима "Только мой код"

Для большинства языков программирования Только мой код включен по умолчанию.

- Чтобы включить или отключить Только мой код в Visual Studio, в **разделе сервис**  > **Параметры** (или**Параметры** **отладки**  > ) > **Отладка**  > **Общие**, установите или снимите флажок **включить только мой код**.

![Включение Только мой код в диалоговом окне «Параметры»](../debugger/media/dbg_justmycode_options.png "Включить только мой код.")

> [!NOTE]
> **Включение только мой код** является глобальным параметром, который применяется ко всем проектам Visual Studio на всех языках.

## <a name="just-my-code-debugging"></a>отладка "Только мой код"

Во время сеанса отладки в окне **модули** отображаются модули кода, которые отладчик расходуют как мой код (пользовательский код), а также состояние загрузки символов. Дополнительные сведения см. в разделе [Узнайте больше о том, как отладчик прикрепляется к вашему приложению](../debugger/debugger-tips-and-tricks.md#modules_window).

![Пользовательский код в окне "модули"](../debugger/media/dbg_justmycode_module.png "Пользовательский код в окне "модули"")

В окне **Стек вызовов** или **задачи** только мой код сворачивает код, не являющийся пользовательским, в серый фрейм кода с заметками `[External Code]`.

![Внешний фрейм кода в окне "стек вызовов"](../debugger/media/dbg_justmycode_externalcode.png "Внешний фрейм кода")

>[!TIP]
>Чтобы открыть **модули**, **Стек вызовов**, **задачи**или большинство других окон отладки, необходимо находиться в сеансе отладки. Во время отладки в разделе **отладка**  > **Windows**выберите окна, которые нужно открыть.

<a name="BKMK_Override_call_stack_filtering"></a>Чтобы просмотреть код в свернутом фрейме **[внешний код]** , щелкните правой кнопкой мыши в окне **Стек вызовов** или **задач** и выберите в контекстном меню команду **Показать внешний код** . Развернутые строки внешнего кода заменяют фрейм **[внешний код**].

![Отображение внешнего кода в окне "стек вызовов"](../debugger/media/dbg_justmycode_showexternalcode.png "Показать внешний код")

> [!NOTE]
> **Отобразить внешний код** — это текущий параметр профилировщика пользователя, который применяется ко всем проектам на всех языках, открываемых пользователем.

Дважды щелкнув развернутую внешнюю строку кода в окне **Стек вызовов** , вы выделяете строку вызывающего кода, зеленую в исходном коде. Для библиотек DLL или других модулей, которые не найдены или не загружены, может открыться страница "символ" или "источник не найден".

## <a name="BKMK__NET_Framework_Just_My_Code"></a>Только мой код .NET

В проектах .NET Только мой код использует файлы символов ( *. pdb*) и оптимизации программы для классификации пользовательского и кода, не являющегося пользовательским. Отладчик .NET считает оптимизированные двоичные файлы и незагруженные *pdb* -файл непользовательским кодом.

Три атрибута компилятора также влияют на то, что отладчик .NET считает кодом пользователя:

- <xref:System.Diagnostics.DebuggerNonUserCodeAttribute> сообщает отладчику, что код, к которому он применяется, не является пользовательским кодом.
- <xref:System.Diagnostics.DebuggerHiddenAttribute> скрывает код от отладчика, даже если режим "Только мой код" включен.
- <xref:System.Diagnostics.DebuggerStepThroughAttribute> сообщает отладчику о пошаговом выполнении кода, к которому он применяется, а не по поэтапному выполнению кода.

Отладчик .NET считает весь Остальный код пользовательским кодом.

Во время отладки .NET:

- **Отладка**  > **шаг** с заходом (или **F11**) в коде, не относящемся к пользователю, пошаговое описание кода до следующей строки пользовательского кода.
- **Отладка**  > **Шаг с выходом** (или **SHIFT** +**F11**) в коде, который не является пользовательским, выполняется на следующей строке пользовательского кода.

Если код пользователя больше не существует, отладка будет продолжаться до конца, она достигнет другой точки останова или выдаст ошибку.

<a name="BKMK_NET_Breakpoint_behavior"></a>Если отладчик прерывается в коде, отличном от пользователя (например, если используется **отладка**  > **прерывать все** и приостанавливать в коде, отличном от пользователя), то окно **без исходного** кода отображается. Затем можно использовать команду **отладка**  > **шага** , чтобы перейти к следующей строке пользовательского кода.

Если необработанное исключение возникает в коде, отличном от пользователя, отладчик прерывает работу в строке кода пользователя, где было создано исключение.

Если для исключения разрешены первые исключения, вызывающая строка пользовательского кода выделяется зеленым цветом в исходном коде. В окне **Стек вызовов** отображается рамка с заметками **[внешний код]** .

## <a name="BKMK_C___Just_My_Code"></a> "Только мой код" в C++

Начиная с Visual Studio 2017 версии 15,8, также поддерживается Только мой код для пошагового выполнения кода. Эта функция также требует использования переключателя компилятора [/жмк (только мой код отладки)](/cpp/build/reference/jmc) . Параметр включен по умолчанию в C++ проектах. Для окна **стека вызовов** и поддержки стека вызовов в только мой код параметр/жмк не требуется.

<a name="BKMK_CPP_User_and_non_user_code"></a>Для классификации в качестве пользовательского кода PDB-файл для двоичного файла, содержащего пользовательский код, должен быть загружен отладчиком (для проверки это используется окно " **модули** ").

Для поведения стека вызовов, например в окне **стека вызовов** , только мой код C++ учитывает только эти функции как код, *не являющийся пользовательским*:

- Функции с открытой исходной информацией в файле символов.
- Функции, в которых файлы символов указывают, что исходный файл, соответствующий кадру стека, отсутствует.
- Функции, указанные в файлах *\*. натжмк* в папке *%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers* .

Для поведения пошагового кода Только мой код в C++ рассматривает только эти функции как *код, не являющийся пользовательским*:

- Функции для, для которых соответствующий PDB-файл не был загружен в отладчик.
- Функции, указанные в файлах *\*. натжмк* в папке *%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers* .

> [!NOTE]
> Для поддержки пошагового выполнения кода в C++ только мой код код должен быть скомпилирован с помощью компиляторов компилятором MSVC в Visual Studio 15,8 Preview 3 или более поздней версии, а параметр компилятора/жмк должен быть включен (по умолчанию включен). Дополнительные сведения см. в этой [записи блога](https://devblogs.microsoft.com/cppblog/announcing-jmc-stepping-in-visual-studio/): [Настройка C++ стека вызовов и поведение пошагового выполнения кода](#BKMK_CPP_Customize_call_stack_behavior). Для кода, скомпилированного с помощью более старой версии компилятора, *натстепфилтер* -файлы являются единственным способом настройки пошагового выполнения кода, который не зависит от только мой код. См. раздел [Настройка C++ пошагового поведения](#BKMK_CPP_Customize_stepping_behavior).

<a name="BKMK_CPP_Stepping_behavior"></a>Во C++ время отладки:

- **Отладка**  > **шаг** с заходом (или **F11**) в коде, не относящемся к пользователю, пошаговое описание кода до следующей строки пользовательского кода.
- **Отладка**  > **Шаг с выходом** (или **SHIFT** +**F11**) в коде, который не является пользовательским, выполняется на следующей строке пользовательского кода.

Если код пользователя больше не существует, отладка будет продолжаться до конца, она достигнет другой точки останова или выдаст ошибку.

Если отладчик прерывается в коде, отличном от пользователя (например, если используется **отладка**  > **прерывать все** и приостанавливать в коде, отличном от пользователя), пошаговое выполнение продолжится в коде, не являющемся пользователем.

Если отладчик обращается к исключению, он останавливается на исключении, независимо от того, находится ли оно в пользовательском или непользовательском коде. **Необработанные пользователем** параметры в диалоговом окне " **параметры исключений** " игнорируются.

### <a name="BKMK_CPP_Customize_call_stack_behavior"></a>Настройка C++ поведения стека вызовов и пошагового выполнения кода

Для C++ проектов можно указать модули, исходные файлы и функции, которые окно **стека вызовов** обрабатывает как код, не являющийся пользовательским, указав их в файлах *\*. натжмк* . Эта настройка также применяется к пошаговому выполнению кода, если используется последняя версия компилятора [ C++ ](#BKMK_CPP_User_and_non_user_code)(см. только мой код).

- Чтобы указать непользовательский код для всех пользователей компьютера с Visual Studio, добавьте файл *.natjmc* в папку *%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers*.
- Чтобы указать непользовательский код для отдельного пользователя, добавьте *натжмк* -файл в папку *%USERPROFILE%\My documents \\ < Visual Studio Version \> \висуализерс* .

Файл *натжмк* — это XML-файл с таким синтаксисом:

```xml
<?xml version="1.0" encoding="utf-8"?>
<NonUserCode xmlns="http://schemas.microsoft.com/vstudio/debugger/jmc/2015">

  <!-- Modules -->
  <Module Name="ModuleSpec" />
  <Module Name="ModuleSpec" Company="CompanyName" />

  <!-- Files -->
  <File Name="FileSpec"/>

  <!-- Functions -->
  <Function Name="FunctionSpec" />
  <Function Name="FunctionSpec" Module ="ModuleSpec" />
  <Function Name="FunctionSpec" Module ="ModuleSpec" ExceptionImplementation="true" />

</NonUserCode>

```

 **Атрибуты элементов модуля**

|Атрибут|Описание|
|---------------|-----------------|
|`Name`|Обязательный. Полный путь к модулю или модулям. Можно использовать подстановочные знаки Windows `?` (ноль или один символ) и `*` (ноль или более символов). Например, примененная к объекту директива<br /><br /> `<Module Name="?:\3rdParty\UtilLibs\*" />`<br /><br /> указывает отладчику, что необходимо рассматривать все модули в *\3rdParty\UtilLibs* на любом диске как внешний код.|
|`Company`|Необязательный. Название компании, публикующей модуль, внедренный в исполняемый файл. Этот атрибут можно использовать для устранения неоднозначности модулей.|

 **Атрибуты элементов файла**

|Атрибут|Описание|
|---------------|-----------------|
|`Name`|Обязательный. Полный путь к файлу или файлам исходного кода, который необходимо считать внешним кодом. При задании пути можно использовать следующие подстановочные знаки Windows: `?` и `*`.|

 **Атрибуты элементов функций**

|Атрибут|Описание|
|---------------|-----------------|
|`Name`|Обязательный. Полное имя функции, которую необходимо рассматривать как внешний код.|
|`Module`|Необязательный. Имя модуля или полный путь к модулю, содержащему эту функцию. Этот атрибут можно использовать для устранения неоднозначности функций с одинаковыми именами.|
|`ExceptionImplementation`|Если задано значение `true`, стек вызовов отображает функцию, которая создала исключение, а не данную функцию.|

### <a name="BKMK_CPP_Customize_stepping_behavior"></a>Настройка C++ поведения пошагового выполнения независимо от параметров только мой код

В C++ проектах можно указать функции для пошагового перехода, перечисляя их как код, не являющийся пользовательским, в файле *\*. натстепфилтер* . Функции, перечисленные в файле *\*. натстепфилтер* , не зависят от параметров только мой код.

- Чтобы указать код, не являющийся пользовательским, для всех локальных пользователей Visual Studio, добавьте *натстепфилтер* -файл в папку *%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers* .
- Чтобы указать непользовательский код для отдельного пользователя, добавьте *натстепфилтер* -файл в папку *%USERPROFILE%\My documents \\ < Visual Studio Version \> \висуализерс* .

Файл *натстепфилтер* — это XML-файл с таким синтаксисом:

```xml
<?xml version="1.0" encoding="utf-8"?>
<StepFilter xmlns="http://schemas.microsoft.com/vstudio/debugger/natstepfilter/2010">
    <Function>
        <Name>FunctionSpec</Name>
        <Action>StepAction</Action>
    </Function>
    <Function>
        <Name>FunctionSpec</Name>
        <Module>ModuleSpec</Module>
        <Action>StepAction</Action>
    </Function>
</StepFilter>

```

|Элемент|Описание|
|-------------|-----------------|
|`Function`|Обязательный. Указывает одну или несколько функций как функцию, не написанную пользователем.|
|`Name`|Обязательный. Регулярное выражение в формате ECMA-262, содержащее полное имя функции для сопоставления. Пример:<br /><br /> `<Name>MyNS::MyClass.*</Name>`<br /><br /> сообщает отладчику, что все методы в `MyNS::MyClass`, должны считаться кодом, не написанным пользователем. Сопоставление учитывает регистр.|
|`Module`|Необязательный. Регулярное выражение в формате ECMA-262, указывающее полный путь к модулю, содержащему функцию. Сопоставление не учитывает регистр.|
|`Action`|Обязательный. Одно из следующих чувствительных к регистру значений:<br /><br /> `NoStepInto` — указывает отладчику выполнить шаг с обходом функции.<br /> `StepInto` — указывает отладчику выполнить шаг с заходом в функцию, переопределив все остальные `NoStepInto` для соответствующей функции.|

## <a name="BKMK_JavaScript_Just_My_Code"></a> "Только мой код" в JavaScript

<a name="BKMK_JS_User_and_non_user_code"></a> Режим "Только мой код" в JavaScript управляет пошаговым выполнением и отображением стека вызовов путем распределения кода по одной из следующих классификаций:

|||
|-|-|
|**MyCode**|Код пользователя, которым вы распоряжаетесь и управляете.|
|**LibraryCode**|Непользовательский код из библиотек, которые вы регулярно используете, и ваше приложение использует для правильной работы (например, WinJS или jQuery).|
|**UnrelatedCode**|Непользовательский код в вашем приложении, который вы не владеете и ваше приложение не использует для правильной работы. Например, пакет SDK для рекламы, отображающий рекламу, может быть UnrelatedCode. В проектах UWP любой код, загружаемый в приложение из URI HTTP или HTTPS, также считается UnrelatedCode.|

Отладчик JavaScript классифицирует код как пользователь или не пользователь в следующем порядке:

1. Классификации по умолчанию.
   - Скрипт, выполняемый передачей строки в предоставленную ведущим `eval` функцию, — **myCode**.
   - Скрипт, выполняемый путем передачи строки в конструктор `Function`, — **LibraryCode**.
   - Скрипт в справочнике по платформе, например WinJS или Azure SDK, — это **LibraryCode**.
   - Скрипт, выполняемый передачей строки в `setTimeout`, `setImmediate` или функции `setInterval`, — это **UnrelatedCode**.

2. Классификации, указанные для всех проектов Visual Studio JavaScript в файле *%всинсталлдиректори%\жаваскрипт\жустмикоде\микоде.дефаулт.ВВА.жсон* .

3. Классификации в файле *myCode. JSON* текущего проекта.

Каждый шаг классификации переопределяет предыдущие шаги.

Весь остальной код классифицируется как **MyCode**.

Можно изменить классификации по умолчанию и классифицировать конкретные файлы и URL-адреса в качестве пользовательского или кода, не являющегося пользовательским кодом, добавив *JSON* -файл с именем *myCode. JSON* в корневую папку проекта JavaScript. См. раздел [Настройка JavaScript только мой код](#BKMK_JS_Customize_Just_My_Code).

<a name="BKMK_JS_Stepping_behavior"></a>Во время отладки JavaScript:

- Если функция не является пользовательским кодом, **отладка**  > **шаг** с заходом (или **F11**) ведет себя так же, как **Отладка**  > **Шаг с обходом** (или **F10**).
- Если шаг начинается в коде, не являющемся пользователем (**LibraryCode** или **UnrelatedCode**), пошаговое выполнение временно ведет себя так, как если бы только мой код не была включена. При переходе к пользовательскому коду Только мой код шаг с заходом снова включается.
- Когда шаг пользовательского кода выходит из текущего контекста выполнения, отладчик останавливается на следующем выполненной строке кода пользователя. Например, если обратный вызов выполняется в коде **LibraryCode**, отладчик продолжает выполнение, пока не будет выполнена следующая строка кода пользователя.
- **Шаг с выходом** (или **SHIFT** +**F11**) останавливается на следующей строке пользовательского кода.

Если код пользователя больше не существует, отладка будет продолжаться до конца, она достигнет другой точки останова или выдаст ошибку.

Точки останова, заданные в коде, всегда обрабатываются, но код классифицируется.

- Если ключевое слово `debugger` встречается в **LibraryCode**, отладчик всегда останавливается.
- Если ключевое слово `debugger` встречается в **UnrelatedCode**, отладчик не останавливается.

<a name="BKMK_JS_Exception_behavior"></a>Если необработанное исключение возникает в коде **myCode** или **LibraryCode** , отладчик всегда останавливается.

Если необработанное исключение возникает в **UnrelatedCode**, а **myCode** или **LibraryCode** находится в стеке вызовов, отладчик прерывает работу.

Если для исключения включены исключения first-шанса, а исключение возникает в **LibraryCode** или **UnrelatedCode**:

- Если исключение обрабатывается, отладчик не останавливается.
- Если исключение не обрабатывается, отладчик останавливается.

### <a name="BKMK_JS_Customize_Just_My_Code"></a>Настройка JavaScript Только мой код

Чтобы классифицировать пользовательский и непользовательский код для одного проекта JavaScript, можно добавить *JSON* -файл с именем *myCode. JSON* в корневую папку проекта.

Спецификации в этом файле переопределяют классификации по умолчанию и файл *myCode. Default. ВВА. JSON* . Файлу *myCode. JSON* не требуется выводить все пары "ключ — значение". **MyCode**, **библиотеки**и **несвязанные** значения могут быть пустыми массивами.

В файлах *myCode. JSON* используется следующий синтаксис:

```json
{
    "Eval" : "Classification",
    "Function" : "Classification",
    "ScriptBlock" : "Classification",
    "MyCode" : [
        "UrlOrFileSpec",
        . . .
        "UrlOrFileSpec"
    ],
    "Libraries" : [
        "UrlOrFileSpec",
        . .
        "UrlOrFileSpec"
    ],
    "Unrelated" : [
        "UrlOrFileSpec",
        . . .
        "UrlOrFileSpec"
    ]
}

```

**"Eval", "Function" и "ScriptBlock"**

Пары "ключ-значение" **Eval**, **Function** и**ScriptBlock** определяют, как классифицируется динамически создаваемый код:

|||
|-|-|
|**Eval**|Скрипт, который выполняется путем передачи строки предоставленной хостом функции `eval`. По умолчанию скрипт Eval классифицируется как **MyCode**.|
|**Function**|Скрипт, который выполняется путем передачи строки конструктору `Function`. По умолчанию скрипт Function классифицируется как **LibraryCode**.|
|**ScriptBlock**|Скрипт, который выполняется путем передачи строки функциям `setTimeout`, `setImmediate` или `setInterval`. По умолчанию скрипт ScriptBlock классифицируется как **UnrelatedCode**.|

Можно изменить это значение на одно из следующих ключевых слов:

- `MyCode` классифицирует скрипт как **MyCode**.
- `Library` классифицирует скрипт как **LibraryCode**.
- `Unrelated` классифицирует скрипт как **UnrelatedCode**.

**"MyCode", "Libraries" и "Unrelated"**

Пары "ключ-значение" **MyCode**, **Libraries** и **Unrelated** определяют URL-адреса или файлы, которые нужно включить в классификацию:

|||
|-|-|
|**MyCode**|Массив URL-адресов или файлы, которые классифицируются как **MyCode**.|
|**Libraries**|Массив URL-адресов или файлы, которые классифицируются как **LibraryCode**.|
|**Unrelated**|Массив URL-адресов или файлы, которые классифицируются как **UnrelatedCode**.|

URL-адрес или строка файла может содержать один или несколько символов `*`, которые соответствуют нулю или более символам. `*` совпадает с `.*`ом регулярного выражения.
