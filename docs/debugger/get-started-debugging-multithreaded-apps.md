---
title: Изучение отладки многопоточных приложений
description: Отладка с использованием параллельных стеков и окон параллельных контрольных значений в Visual Studio
ms.custom: ''
ms.date: 02/14/2020
ms.topic: conceptual
dev_langs:
- CSharp
- VB
- FSharp
- C++
helpviewer_keywords:
- multithreaded debugging, tutorial
- tutorials, multithreaded debugging
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: f280a93022342fd9ca4dcae5cdac1de919fe1657
ms.sourcegitcommit: 6ef52c2030b37ea7a64fddb32f050ecfb77dd918
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/17/2020
ms.locfileid: "77416411"
---
# <a name="get-started-debugging-multithreaded-applications-c-visual-basic-c"></a>Начало отладки многопоточных приложений (C#Visual Basic,) C++

Visual Studio предоставляет несколько средств и элементов пользовательского интерфейса, помогающих в отладке многопоточных приложений. В этом руководстве показано, как использовать маркеры потоков, окно " **Параллельные стеки** ", окно " **контроль параллельных значений** ", условные точки останова и фильтры точек останова. В этом учебнике мы познакомимся с функциями Visual Studio для отладки многопоточных приложений.

В этих двух разделах содержатся дополнительные сведения об использовании других средств многопотоковой отладки.

- Сведения об использовании панели инструментов " **Расположение отладки** " и окна " **потоки** " см. в разделе [Пошаговое руководство. Отладка многопоточного приложения](../debugger/how-to-use-the-threads-window.md).

- Пример, использующий <xref:System.Threading.Tasks.Task> (управляемый код) и среда выполнения с параллелизмом (C++), см. в разделе [Пошаговое руководство: Отладка параллельного приложения](../debugger/walkthrough-debugging-a-parallel-application.md). Для общих советов по отладке, которые относятся к большинству типов многопоточных приложений, ознакомьтесь с этим разделом и.

Сначала требуется проект многопоточного приложения. Это представлено в примере ниже.

## <a name="create-a-multithreaded-app-project"></a>Создание проекта многопоточного приложения

1. Откройте Visual Studio и создайте новый проект.

   ::: moniker range=">=vs-2019"

   Если окно запуска не открыто, выберите **Файл** > **Окно запуска**.

   На начальном экране выберите **Создать проект**.

   В поле поиска окна **Создание проекта** введите *консоль*. Затем выберите **C#** , **C++** или **Visual Basic** из списка языков, а затем выберите **Windows** из списка платформа. 

   После применения фильтров языка и платформы выберите **консольное приложение (.NET Core)** или, для C++, шаблон **консольного приложения** , а затем нажмите кнопку **Далее**.

   > [!NOTE]
   > Если нужный шаблон не отображается, перейдите в **меню сервис** > **получить средства и компоненты...** , после чего откроется Visual Studio Installer. Выберите рабочую нагрузку **Разработка классических приложений .NET** или **Разработка классических приложений на C++** , а затем нажмите кнопку **Изменить**.

   В окне **Настройка нового проекта** введите или введите *мисреадвалксраугхапп* в поле **имя проекта** . Затем нажмите **Создать**.

   ::: moniker-end
   ::: moniker range="vs-2017"
   В верхней строке меню выберите **Файл** > **Создать** > **Проект**. В левой области диалогового окна **Новый проект** выберите следующие действия.

   - Для приложения C# в разделе **визуальный C#** элемент выберите **Рабочий стол Windows**, а затем в средней области выберите **консольное приложение (.NET Framework)** .
   - Для Visual Basic приложения в разделе **Visual Basic**выберите **Рабочий стол Windows**, а затем в средней области выберите **консольное приложение (.NET Framework)** .
   - Для приложения C++ в разделе **визуальный C++** элемент выберите **Рабочий стол Windows**, а затем выберите **консольное приложение Windows**.

   Если **консольное приложение (.NET Core)** не отображается C++или для шаблона проекта **консольного приложения** , выберите **Сервис** > **получить средства и компоненты...** , открывающий Visual Studio Installer. Выберите рабочую нагрузку **Разработка классических приложений .NET** или **Разработка классических приложений на C++** , а затем нажмите кнопку **Изменить**.

   Затем введите имя, например *мисреадвалксраугхапп* , и нажмите кнопку **ОК**.

   Нажмите кнопку **ОК**.
   ::: moniker-end

   Появится новый проект консольного приложения. После создания проекта появится исходный файл. В зависимости от выбранного языка исходный файл может называться *Program.CS*, *мисреадвалксраугхапп. cpp*или *Module1. vb*.

1. Удалите код, который отображается в исходном файле, и замените его соответствующим образцом кода ниже.

    ```csharp
    using System;
    using System.Threading;

    public class ServerClass
    {

        static int count = 0;
        // The method that will be called when the thread is started.
        public void InstanceMethod()
        {
            Console.WriteLine(
                "ServerClass.InstanceMethod is running on another thread.");

            int data = count++;
            // Pause for a moment to provide a delay to make
            // threads more apparent.
            Thread.Sleep(3000);
            Console.WriteLine(
                "The instance method called by the worker thread has ended. " + data);
        }
    }

    public class Simple
    {
        public static void Main()
        {
            for (int i = 0; i < 10; i++)
            {
                CreateThreads();
            }
        }
        public static void CreateThreads()
        {
            ServerClass serverObject = new ServerClass();

            Thread InstanceCaller = new Thread(new ThreadStart(serverObject.InstanceMethod));
            // Start the thread.
            InstanceCaller.Start();

            Console.WriteLine("The Main() thread calls this after "
                + "starting the new InstanceCaller thread.");

        }
    }
    ```

    ```C++
    // #include "pch.h" // Use with pre-compiled header
    #include <thread>
    #include <iostream>
    #include <vector>
    #include <string>

    int count = 0;

    void doSomeWork() {

        std::cout << "The doSomeWork function is running on another thread." << std::endl;
        int data = count++;
        // Pause for a moment to provide a delay to make
        // threads more apparent.
        std::this_thread::sleep_for(std::chrono::seconds(3));
        std::string str = std::to_string(data);
        std::cout << "The function called by the worker thread has ended. " + str<< std::endl;
    }

    int main() {
        std::vector<std::thread> threads;

        for (int i = 0; i < 10; ++i) {

            threads.push_back(std::thread(doSomeWork));
            std::cout << "The Main() thread calls this after starting the new thread" << std::endl;
    }

    for (auto& thread : threads) {
        thread.join();
    }

    return 0;
    }
    ```

    ```VB
    Imports System.Threading

    Public Class ServerClass
        ' The method that will be called when the thread is started.
        Public count = 0
        Public Sub InstanceMethod()
            Console.WriteLine(
                    "ServerClass.InstanceMethod is running on another thread.")

            Dim data = count + 1
            ' Pause for a moment to provide a delay to make
            ' threads more apparent.
            Thread.Sleep(3000)
            Console.WriteLine(
                    "The instance method called by the worker thread has ended. " + data)
        End Sub

    End Class

    Public Class Simple

        Public Shared Sub Main()

            Dim ts As New ThreadStarter
            For index = 1 To 10
                ts.CreateThreads()
            Next

        End Sub

    End Class
    Public Class ThreadStarter
        Public Sub CreateThreads()
            Dim serverObject As New ServerClass()

            ' Create the thread object, passing in the
            ' serverObject.InstanceMethod method using a
            ' ThreadStart delegate.
            Dim InstanceCaller As New Thread(AddressOf serverObject.InstanceMethod)

            ' Start the thread.
            InstanceCaller.Start()

            Console.WriteLine("The Main() thread calls this after " _
                        + "starting the new InstanceCaller thread.")

        End Sub
    End Class
    ```

1. В меню **Файл** выберите команду **Сохранить все**.

1. (Только Visual Basic) В обозреватель решений (правая область) щелкните правой кнопкой мыши узел проекта и выберите пункт **Свойства**. На вкладке **приложение** измените **объект запуска** на **простой**.

## <a name="debug-the-multithreaded-app"></a>Отладка многопоточного приложения

1. В редакторе исходного кода найдите один из следующих фрагментов кода:

    ```csharp
    Thread.Sleep(3000);
    Console.WriteLine();
    ```

    ```C++
    std::this_thread::sleep_for(std::chrono::seconds(3));
    std::cout << "The function called by the worker thread has ended." << std::endl;
    ```

    ```VB
    Thread.Sleep(3000)
    Console.WriteLine()
    ```

1. Щелкните левой кнопкой мыши в левом углу инструкции `Thread.Sleep` или `std::this_thread::sleep_for`, чтобы вставить новую точку останова.

    В области переплета красный кружок означает, что точка останова задана в этом месте.

2. В меню **Отладка** выберите команду **начать отладку** (**F5**).

    Visual Studio создаст решение, приложение начнет работать с подключенным отладчиком, а затем приложение остановится в точке останова.

3. В редакторе исходного кода нахождение строки, содержащей точку останова.

### <a name="ShowThreadsInSource"></a>Обнаружение маркера потока  

1. На панели инструментов Отладка нажмите кнопку **Показывать потоки в исходном** виде ![отобразить потоки в исходном потоке](../debugger/media/dbg-multithreaded-show-threads.png "среадмаркер").

2. Нажмите клавишу **F11** один раз, чтобы передвинуть отладчик на одну строку кода.

3. Посмотрите на переплет в левой части окна. В этой строке отображается ![маркер потока](../debugger/media/dbg-thread-marker.png "среадмаркер") значок *маркера* , который напоминает два витой потока. маркер потока указывает, что некий поток остановлен в этом месте.

    Маркер потока может быть частично скрыт точкой останова.

4. Наведите указатель мыши на маркер потока. Появится подсказка, сообщающая имя и идентификатор потока для каждого остановленного потока. В этом случае имя, вероятно, `<noname>`.

5. Выберите маркер потока, чтобы просмотреть доступные параметры в контекстном меню.

### <a name="ParallelStacks"></a>Просмотр расположений потоков

В окне **Параллельные стеки** можно переключаться между представлением потоков и представлением задач (для программирования на основе задач), а также просматривать сведения о стеке вызовов для каждого потока. В этом приложении можно использовать представление "потоки".

1. Откройте окно **Параллельные стеки** , выбрав **Отладка** > **Windows** > **Параллельные стеки**. Вы должны увидеть нечто вроде следующего. Точная информация будет отличаться в зависимости от текущего расположения каждого потока, оборудования и языка программирования.

    ![Окно параллельных стеков](../debugger/media/dbg-multithreaded-parallel-stacks.png "параллелстакксвиндов")

    В этом примере слева направо отображаются следующие сведения об управляемом коде:

    - Главный поток (левая сторона) остановлен на `Thread.Start`, где точка остановки обозначается ![маркером потока](../debugger/media/dbg-thread-marker.png "среадмаркер")значка маркера потока.
    - В `ServerClass.InstanceMethod`были введены два потока, один из которых является текущим потоком (желтая стрелка), а другой поток остановлен в `Thread.Sleep`.
    - Новый поток (справа) также запускается, но останавливается на `ThreadHelper.ThreadStart`.

2. Щелкните правой кнопкой мыши записи в окне **Параллельные стеки** , чтобы просмотреть доступные параметры контекстного меню.

    Из этих контекстных меню можно выполнять различные действия, но в этом учебнике эти сведения будут показаны в окне " **контроль параллельных** данных" (следующие разделы).

    > [!NOTE]
    > Чтобы просмотреть список со сведениями о каждом потоке, используйте окно **потоки** . См. раздел [Пошаговое руководство. Отладка многопоточного приложения](../debugger/how-to-use-the-threads-window.md).

### <a name="set-a-watch-on-a-variable"></a>Установка контрольного значения для переменной

1. Откройте окно **Параллельные контрольные значения** , выбрав **Отладка** > **Windows** > **параллельное наблюдение** > **параллельное наблюдение 1**.

2. Выберите ячейку, в которой отображается `<Add Watch>` текст (или пустая ячейка заголовка в 4-ом столбце) и введите `data`.

    Значения переменной данных для каждого потока отображаются в окне.

3. Выберите ячейку, в которой отображается `<Add Watch>` текст (или пустая ячейка заголовка в 5-й колонке) и введите `count`.

    Значения для переменной `count` для каждого потока отображаются в окне. Если вы еще не видите эту информацию, попробуйте несколько раз нажать клавишу **F11** , чтобы переместить выполнение потоков в отладчике.

    ![Окно "контроль параллельных значений"](../debugger/media/dbg-multithreaded-parallel-watch.png "параллелватчвиндов")

4. Щелкните правой кнопкой мыши одну из строк в окне, чтобы просмотреть доступные параметры.

### <a name="flag-and-unflag-threads"></a>Установка и снятие отметки для потока
Можно помечать потоки для наблюдения за важными потоками и пропускать другие потоки.

1. В окне " **контроль параллельных** данных" нажмите и удерживайте клавишу **SHIFT** и выберите несколько строк.

2. Щелкните правой кнопкой мыши и выберите **флаг**.

    Все выбранные потоки помечаются флагами. Теперь можно выполнить фильтрацию, чтобы отображались только отмеченные потоки.

3. В окне **контроль параллельных значений** установите флажок **Показывать только отмеченные потоки** , чтобы ![отобразить помеченные потоки](../debugger/media/dbg-threads-show-flagged.png "среадмаркер").

    В списке отображаются только отмеченные потоки.

    > [!TIP]
    > После пометки некоторых потоков можно щелкнуть правой кнопкой мыши строку кода в редакторе кода и выбрать пункт **выполнять помеченные потоки в курсор**. Обязательно выберите код, к которому будут обращаться все отмеченные потоки. Visual Studio приостанавливает потоки в выбранной строке кода, что упрощает управление порядком выполнения путем [замораживания и разморозки потоков](#bkmk_freeze).

4. Снова нажмите кнопку **Показать только помеченные потоки** , чтобы вернуться в режим **Показать все потоки** .

5. Чтобы снять флаги потоков, щелкните правой кнопкой мыши один или несколько помеченных потоков в окне **контроль параллельных значений** и выберите снять **пометку**.

### <a name="bkmk_freeze"></a>Замораживание и разморозка выполнения потоков

> [!TIP]
> Можно заморозить и разморозить (приостанавливать и возобновлять) потоки для управления порядком выполнения потоков. Это поможет устранить проблемы параллелизма, такие как взаимоблокировки и состояния гонки.

1. В окне " **контроль параллельных значений** " со всеми выбранными строками щелкните правой кнопкой мыши и выберите пункт **заморозить**.

    Во втором столбце для каждой строки отображается значок паузы. Значок приостановки указывает, что поток заморожен.

2. Отмените выбор всех остальных строк, выбрав только одну строку.

3. Щелкните правой кнопкой мыши строку и выберите команду **разморозить**.

    Значок паузы исчезает из этой строки, указывая, что поток больше не заморожен.

4. Перейдите в редактор кода и нажмите клавишу **F11**. Выполняется только незамороженный поток.

    Приложение также может создавать экземпляры некоторых новых потоков. Все новые потоки не помечаются и не фиксируются.

### <a name="bkmk_follow_a_thread"></a>Следование одному потоку с условными точками останова

Может быть полезно следовать за выполнением одного потока в отладчике. Одним из способов сделать это является замораживание потоков, которые вас не интересуют. В некоторых сценариях может потребоваться выполнить отдельный поток, не заморозяя другие потоки, например для воспроизведения определенной ошибки. Чтобы подписаться на поток, не прерывая работу других потоков, необходимо избежать появления кода, за исключением интересующего вас потока. Это можно сделать, задав [условную точку останова](../debugger/using-breakpoints.md#BKMK_Specify_a_breakpoint_condition_using_a_code_expression).

Можно задать точки останова в различных условиях, например имя потока или идентификатор потока. Может быть полезно задать условие для данных, которые уникальны для каждого потока. Это распространенный сценарий отладки, в котором более интересно иметь определенное значение данных, чем в каком-либо конкретном потоке.

1. Щелкните правой кнопкой мыши созданную ранее точку останова и выберите пункт **условия**.

2. В окне **Параметры точки останова** введите `data == 5` для условного выражения.

    ![Условная точка останова](../debugger/media/dbg-multithreaded-conditional-breakpoint.png "кондитионалбреакпоинт")

    > [!TIP]
    > Если вы больше заинтересованы в конкретном потоке, используйте для условия имя потока или идентификатор потока. Для этого в окне **Параметры точки останова** выберите **Фильтр** вместо **условного выражения**и следуйте советам по фильтрации. При перезапуске отладчика можно присвоить имена потокам в коде приложения, когда идентификаторы потоков изменятся.

3. Закройте окно **Параметры точки останова** .

4. Нажмите кнопку перезапустить ![приложение](../debugger/media/dbg-tour-restart.png "RestartApp") , чтобы перезапустить сеанс отладки.

    Вы разбиваете код на поток, где значение переменной данных равно 5. В окне **контроль параллельных значений** Найдите желтую стрелку, указывающую текущий контекст отладчика.

5. Теперь можно пошагово пройти код (**F10**) и выполнить шаг с заходом в код (**F11**) и следовать за выполнением одного потока.

    До тех пор, пока условие точки останова является уникальным для потока, и отладчик не может попасть в другие точки останова в других потоках (может потребоваться отключить их), можно пошагово выполнить код и пошаговое выполнение кода без переключения на другие потоки.

    > [!NOTE]
    > При перезапуске отладчика будут выполняться все потоки. Однако отладчик не будет разбиваться на код в других потоках, если только один из других потоков не достигнет точки останова.

## <a name="see-also"></a>См. также раздел

- [Отладка многопоточных приложений](../debugger/debug-multithreaded-applications-in-visual-studio.md)
- [Практическое руководство. Переключение на другой поток при отладке](../debugger/how-to-switch-to-another-thread-while-debugging.md)
- [Как использовать окно "параллельный стек"](../debugger/using-the-parallel-stacks-window.md)
- [Практическое руководство. Использование окна "Контроль параллельных данных"](../debugger/how-to-use-the-parallel-watch-window.md)