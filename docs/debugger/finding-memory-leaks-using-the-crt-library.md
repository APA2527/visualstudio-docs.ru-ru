---
title: Поиск утечек памяти с помощью библиотеки CRT | Документация Майкрософт
ms.date: 10/04/2018
ms.topic: conceptual
dev_langs:
- CSharp
- VB
- FSharp
- C++
helpviewer_keywords:
- breakpoints, on memory allocation
- _CrtMemState
- _CrtMemCheckpoint
- memory leaks
- _CrtMemDifference
- memory leaks, detecting and isolating
- _CrtDumpMemoryLeaks
- _CrtSetBreakAlloc
- _crtBreakAlloc
- _CrtSetReportMode
- memory, debugging
- _CrtMemDumpStatistics
- debugging memory leaks
- _CRTDBG_MAP_ALLOC
- _CrtSetDbgFlag
ms.assetid: cf6dc7a6-cd12-4283-b1b6-ea53915f7ed1
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: eb2729dcaf0da41c0adac24b0e1909a6d2697eb6
ms.sourcegitcommit: 697f2ab875fd789685811687387e9e8e471a38c4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/05/2019
ms.locfileid: "74829948"
---
# <a name="find-memory-leaks-with-the-crt-library"></a>Нахождение утечек памяти с помощью библиотеки CRT

Утечки памяти представляют собой наиболее слабые и сложные для обнаружения ошибки в C/C++ приложениях. Утечки памяти в результате сбоя, чтобы правильно освободить память, которая была выделена ранее. Небольшая утечка памяти, возможно, не будет замечена первыми, но со временем могут возникать симптомы от низкой производительности до аварийного завершения работы приложения из-за нехватки памяти. Утечка приложения, использующего всю доступную память, может привести к сбою других приложений, создавая путаницу, которую несет приложение. Даже небезопасные утечки памяти могут указывать на другие проблемы, которые следует исправить.

 Отладчик [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)] и библиотека времени выполнения C (CRT) позволяют обнаруживать и выявлять утечки памяти.

## <a name="enable-memory-leak-detection"></a>Включить обнаружение утечек памяти

Основными средствами для обнаружения утечек памяти являются C/C++ отладчик и отладочные функции кучи библиотеки времени выполнения c (CRT).

Чтобы включить все отладочные функции кучи, включите в C++ программу следующие инструкции в следующем порядке:

```cpp
#define _CRTDBG_MAP_ALLOC
#include <stdlib.h>
#include <crtdbg.h>
```

Оператор `#define` сопоставляет базовые версии функций кучи CRT соответствующим отладочным версиям. Если вы оставляете инструкцию `#define`, дамп утечки памяти будет [менее подробным](#interpret-the-memory-leak-report).

Включение *Crtdbg. h* сопоставляет функции `malloc` и `free` с их отладочными версиями, [_malloc_dbg](/cpp/c-runtime-library/reference/malloc-dbg) и [_free_dbg](/cpp/c-runtime-library/reference/free-dbg), которые отправляют выделение и освобождение памяти. Это сопоставление используется только в отладочных построениях, в которых определен `_DEBUG`. В окончательных построениях используются первоначальные функции `malloc` и `free` .

После включения функций отладочной кучи с помощью приведенных выше инструкций поместите вызов [_CrtDumpMemoryLeaks](/cpp/c-runtime-library/reference/crtdumpmemoryleaks) перед точкой выхода приложения, чтобы отобразить отчет об утечке памяти при выходе из приложения.

```cpp
_CrtDumpMemoryLeaks();
```

Если приложение имеет несколько выходов, вам не нужно вручную размещать `_CrtDumpMemoryLeaks` в каждой точке выхода. Чтобы автоматический вызов `_CrtDumpMemoryLeaks` в каждой точке выхода, поместите вызов `_CrtSetDbgFlag` в начале приложения с помощью битовых полей, показанных ниже:

```cpp
_CrtSetDbgFlag ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );
```

По умолчанию `_CrtDumpMemoryLeaks` выводит отчет об утечке памяти в область **Отладка** окна **Вывод** . Если используется библиотека, она может переустановить вывод в другое расположение.

`_CrtSetReportMode` можно использовать для перенаправления отчета в другое расположение или обратно в окно **вывода** , как показано ниже:

```cpp
_CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_DEBUG );
```

## <a name="interpret-the-memory-leak-report"></a>Интерпретировать отчет об утечке памяти

Если приложение не определяет `_CRTDBG_MAP_ALLOC`, [_CrtDumpMemoryLeaks](/cpp/c-runtime-library/reference/crtdumpmemoryleaks) отображает отчет об утечке памяти, который выглядит следующим образом:

```cmd
Detected memory leaks!
Dumping objects ->
{18} normal block at 0x00780E80, 64 bytes long.
 Data: <                > CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD
Object dump complete.
```

Если приложение определяет `_CRTDBG_MAP_ALLOC`, отчет об утечке памяти выглядит следующим образом:

```cmd
Detected memory leaks!
Dumping objects ->
c:\users\username\documents\projects\leaktest\leaktest.cpp(20) : {18}
normal block at 0x00780E80, 64 bytes long.
 Data: <                > CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD
Object dump complete.
```

Во втором отчете отображается имя файла и номер строки, где сначала была выделена утечка памяти.

Независимо от того, определен ли `_CRTDBG_MAP_ALLOC`, в отчете об утечке памяти отображается следующее:

- Номер выделения памяти, который `18` в примере
- Тип блока, `normal` в примере.
- Шестнадцатеричное расположение в памяти, `0x00780E80` в примере.
- Размер блока, `64 bytes` в примере.
- Первые 16 байт данных в блоке, в шестнадцатеричном формате.

Типы блоков памяти — *Обычная*, *Клиентская*или *CRT*. *Обычный блок* — это обыкновенная память, выделенная программой. *Клиентский блок* — особый тип блока памяти, используемой программами MFC для объектов, для которых требуется деструктор. Оператор `new` в MFC создает либо обычный, либо клиентский блок, в соответствии с создаваемым объектом.

*Блок CRT* — это блок памяти, выделенной библиотекой CRT для внутреннего использования. Библиотека CRT обрабатывает освобождение этих блоков, поэтому CRT-блоки не будут отображаться в отчете об утечке памяти, если нет серьезных проблем с библиотекой CRT.

Существуют два других типа блоков памяти, которые никогда не отображаются в отчетах об утечке памяти. *Свободный блок* — это память, которая была освобождена, поэтому по определению не было утечки. *Игнорируемый блок* — это память, которая явно помечена для исключения из отчета об утечке памяти.

Описанные выше методы обозначают утечки памяти для памяти, выделенной с помощью стандартной функции `malloc` CRT. Если программа выделяет память с помощью оператора C++ `new`, то вы можете увидеть только имя файла и номер строки, где `operator new` вызывает `_malloc_dbg` в отчете об утечке памяти. Чтобы создать более полезный отчет об утечке памяти, можно написать макрос следующего вида, чтобы сообщить о строке, в которой было выполнено выделение:

```cpp
#ifdef _DEBUG
    #define DBG_NEW new ( _NORMAL_BLOCK , __FILE__ , __LINE__ )
    // Replace _NORMAL_BLOCK with _CLIENT_BLOCK if you want the
    // allocations to be of _CLIENT_BLOCK type
#else
    #define DBG_NEW new
#endif
```

Теперь можно заменить оператор `new` с помощью макроса `DBG_NEW` в коде. В отладочных сборках `DBG_NEW` использует перегрузку глобальных `operator new`, которая принимает дополнительные параметры для типа блока, файла и номера строки. Перегрузка `new` вызывает `_malloc_dbg` для записи дополнительных сведений. Отчеты об утечке памяти показывают имя файла и номер строки, в которой были выделены утечки объектов. Сборки выпуска по-прежнему используют `new`по умолчанию. Ниже приведен пример метода.

```cpp
// debug_new.cpp
// compile by using: cl /EHsc /W4 /D_DEBUG /MDd debug_new.cpp
#define _CRTDBG_MAP_ALLOC
#include <cstdlib>
#include <crtdbg.h>

#ifdef _DEBUG
    #define DBG_NEW new ( _NORMAL_BLOCK , __FILE__ , __LINE__ )
    // Replace _NORMAL_BLOCK with _CLIENT_BLOCK if you want the
    // allocations to be of _CLIENT_BLOCK type
#else
    #define DBG_NEW new
#endif

struct Pod {
    int x;
};

void main() {
    Pod* pPod = DBG_NEW Pod;
    pPod = DBG_NEW Pod; // Oops, leaked the original pPod!
    delete pPod;

    _CrtDumpMemoryLeaks();
}
```

При запуске этого кода в отладчике Visual Studio вызов `_CrtDumpMemoryLeaks` создает отчет в окне **вывода** , который выглядит примерно так:

```Output
Detected memory leaks!
Dumping objects ->
c:\users\username\documents\projects\debug_new\debug_new.cpp(20) : {75}
 normal block at 0x0098B8C8, 4 bytes long.
 Data: <    > CD CD CD CD
Object dump complete.
```

Эти выходные данные сообщают о том, что утечка памяти находилась на строке 20 *DEBUG_NEW. cpp*.

>[!NOTE]
>Не рекомендуется создавать макрос препроцессора с именем `new`или любое другое ключевое слово языка.

## <a name="set-breakpoints-on-a-memory-allocation-number"></a>Установка точек останова для номера выделения памяти

Номер выделения памяти сообщает, когда был выделен утекающий блок памяти. Например, блок с номером выделения памяти 18 — 18-й блок памяти, выделенный во время выполнения приложения. Отчет CRT учитывает все выделения блоков памяти во время выполнения, включая выделение памяти библиотекой CRT и других библиотек, таких как MFC. Таким образом, блок выделения памяти с номером 18, вероятно, не является 18 блоком памяти, выделенным вашим кодом.

Номер выделения можно использовать для того, чтобы задать точку останова в том месте, где выделяется память.

**Установка точки останова для выделения памяти с помощью окна контрольных значений:**

1. Установите точку останова рядом с началом приложения и начните отладку.

1. Когда приложение приостанавливается в точке останова, откройте окно **контрольных значений** , выбрав **Отладка** > **Windows** > **Контрольные значения 1** (или **Контрольные значения 2**, **Контрольные значения 3**или **Контрольные значения 4**).

1. В окне **Контрольные значения** введите `_crtBreakAlloc` в столбце **имя** .

   Если используется многопоточная версия DLL библиотеки CRT (параметр/MD), добавьте оператор контекста: `{,,ucrtbased.dll}_crtBreakAlloc`
   
   Убедитесь, что отладочные символы загружены. В противном случае `_crtBreakAlloc` будет отмечен как *неидентифицированный*.

1. Нажмите клавишу **ВВОД**.

   Отладчик выполнит оценку вызова и поместит результат в столбец **Значение** . Это значение будет равно **–1**, если в местах выделения памяти не задано ни одной точки останова.

1. В столбце **значение** замените значение номером выделения памяти, в котором отладчик должен прерывать работу.

После установки точки останова в номере выделения памяти продолжайте отладку. Убедитесь, что выполнение выполняется с теми же условиями, поэтому номер выделения памяти не изменится. При прерывании программы на заданном выделении памяти используйте окно **Стек вызовов** и другие окна отладчика, чтобы определить условия, при которых память была выделена. Затем можно продолжить выполнение, чтобы увидеть, что происходит с объектом и определить причину неправильного освобождения.

Иногда может быть полезно задать точку останова по данным на самом объекте. Для получения дополнительной информации см. раздел [Использование точек останова](../debugger/using-breakpoints.md).

Точки останова для выделения памяти можно также задать в коде. Можно установить следующие значения:

```cpp
_crtBreakAlloc = 18;
```

 или

```cpp
_CrtSetBreakAlloc(18);
```

## <a name="compare-memory-states"></a>Сравнение состояний памяти
 Другая технология для обнаружения утечек памяти включает получение "снимков" состояния памяти приложения в ключевых точках. Чтобы сделать моментальный снимок состояния памяти в заданной точке приложения, создайте структуру `_CrtMemState` и передайте ее в функцию `_CrtMemCheckpoint`.

```cpp
_CrtMemState s1;
_CrtMemCheckpoint( &s1 );
```

Функция `_CrtMemCheckpoint` заполняет структуру моментальным снимком текущего состояния памяти.

Чтобы вывести содержимое структуры `_CrtMemState`, передайте эту структуру функции `_ CrtMemDumpStatistics`:

```cpp
_CrtMemDumpStatistics( &s1 );
```

`_ CrtMemDumpStatistics` выводит дамп состояния памяти, который выглядит следующим образом:

```cmd
0 bytes in 0 Free Blocks.
0 bytes in 0 Normal Blocks.
3071 bytes in 16 CRT Blocks.
0 bytes in 0 Ignore Blocks.
0 bytes in 0 Client Blocks.
Largest number used: 3071 bytes.
Total allocations: 3764 bytes.
```

Чтобы определить, произошла ли утечка памяти на отрезке кода, можно сделать снимок состояния памяти перед ним и после него, а затем сравнить оба состояния с помощью функции `_ CrtMemDifference` :

```cpp
_CrtMemCheckpoint( &s1 );
// memory allocations take place here
_CrtMemCheckpoint( &s2 );

if ( _CrtMemDifference( &s3, &s1, &s2) )
   _CrtMemDumpStatistics( &s3 );
```

`_CrtMemDifference` сравнивает состояния памяти `s1` и `s2` и возвращает результат в (`s3`), который является разностью между `s1` и `s2`.

Один из способов поиска утечек памяти начинается с размещения `_CrtMemCheckpoint` вызовов в начале и в конце приложения, а затем с помощью `_CrtMemDifference` для сравнения результатов. Если `_CrtMemDifference` показывает утечку памяти, можно добавить дополнительные `_CrtMemCheckpoint` вызовы, чтобы разделить программу с помощью двоичного поиска, пока не будет изолирован источник утечек.

## <a name="false-positives"></a>Ложные срабатывания
 `_CrtDumpMemoryLeaks` может дать ложные признаки утечки памяти, если библиотека помечает внутренние выделения как обычные блоки, а не блоки CRT или клиентские блоки. В таком случае функция `_CrtDumpMemoryLeaks` не может различать пользовательские выделения и внутренние выделения библиотеки. Если глобальные деструкторы для выделений библиотеки выполняются после точки вызова функции `_CrtDumpMemoryLeaks`, каждое внутреннее выделение библиотеки принимается за утечку памяти. Версии стандартной библиотеки шаблонов, предшествующей Visual Studio .NET, могут привести к тому, что `_CrtDumpMemoryLeaks` сообщать о таких ложных срабатываниях.

## <a name="see-also"></a>См. также:
- [Сведения о куче отладки CRT](../debugger/crt-debug-heap-details.md)
- [Безопасность отладчика](../debugger/debugger-security.md)
- [Отладка машинного кода](../debugger/debugging-native-code.md)
