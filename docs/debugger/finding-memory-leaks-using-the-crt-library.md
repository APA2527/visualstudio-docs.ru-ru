---
title: Находить утечки памяти с помощью библиотеки CRT | Документация Майкрософт
ms.date: 10/04/2018
ms.topic: conceptual
dev_langs:
- CSharp
- VB
- FSharp
- C++
helpviewer_keywords:
- breakpoints, on memory allocation
- _CrtMemState
- _CrtMemCheckpoint
- memory leaks
- _CrtMemDifference
- memory leaks, detecting and isolating
- _CrtDumpMemoryLeaks
- _CrtSetBreakAlloc
- _crtBreakAlloc
- _CrtSetReportMode
- memory, debugging
- _CrtMemDumpStatistics
- debugging memory leaks
- _CRTDBG_MAP_ALLOC
- _CrtSetDbgFlag
ms.assetid: cf6dc7a6-cd12-4283-b1b6-ea53915f7ed1
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: e7fdfedbb2f632bdb0fcaa05c7f0fb282a8fcd2b
ms.sourcegitcommit: 94b3a052fb1229c7e7f8804b09c1d403385c7630
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62849965"
---
# <a name="find-memory-leaks-with-the-crt-library"></a>Нахождение утечек памяти с помощью библиотеки CRT

Утечки памяти являются наиболее заметно и жестких в обнаружении ошибок в приложениях C/C++. Результат после сбоя при освобождении памяти, который ранее был выделен утечки памяти. Небольшая утечка памяти, могут остаться незамеченными на первый, но со временем может привести к симптомы от низкой производительности до аварийного завершения приложения не хватает памяти. Утечкой памяти приложения, которое использует всю доступную память может вызвать аварийное завершение работы других приложений, создание сомнения, какое приложение отвечает. Даже взгляд утечка памяти могут свидетельствовать о других проблемах, которые должны быть исправлены.

 [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)] Отладчика и библиотеки времени выполнения C (CRT) может помочь обнаружить и выявить утечки памяти.

## <a name="enable-memory-leak-detection"></a>Включение обнаружения утечек памяти

Основным средством для обнаружения утечек памяти является отладчик C/C++ и библиотека времени выполнения C (CRT) отладочные функции кучи.

Чтобы включить все отладочные функции кучи, включите следующие инструкции в программе C++, в следующем порядке:

```cpp
#define _CRTDBG_MAP_ALLOC
#include <stdlib.h>
#include <crtdbg.h>
```

Оператор `#define` сопоставляет базовые версии функций кучи CRT соответствующим отладочным версиям. Если опустить `#define` инструкции, что дамп утечки памяти будет [меньший](#interpret-the-memory-leak-report).

Включая *crtdbg.h* сопоставляет `malloc` и `free` функций с их отладочными версиями [_malloc_dbg](/cpp/c-runtime-library/reference/malloc-dbg) и [_free_dbg](/cpp/c-runtime-library/reference/free-dbg), которые отслеживают памяти Выделение и освобождение. Это сопоставление используется только в отладочных построениях, в которых определен `_DEBUG`. В окончательных построениях используются первоначальные функции `malloc` и `free` .

После включения отладочные функции кучи с помощью предыдущие инструкции, поместите вызов [_CrtDumpMemoryLeaks](/cpp/c-runtime-library/reference/crtdumpmemoryleaks) перед точкой выхода приложения для отображения отчета об утечке памяти, при выходе из приложения.

```cpp
_CrtDumpMemoryLeaks();
```

Если приложение имеет несколько завершает работу, не требуется вручную размещать `_CrtDumpMemoryLeaks` в каждой точке выхода. Чтобы привести к автоматическому вызову функции `_CrtDumpMemoryLeaks` в каждой точке выхода, поместите вызов `_CrtSetDbgFlag` в начале приложения с помощью показанных здесь битовых поля:

```cpp
_CrtSetDbgFlag ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );
```

По умолчанию `_CrtDumpMemoryLeaks` выводит отчет об утечке памяти в область **Отладка** окна **Вывод** . Если используется библиотека, она может переустановить вывод в другое расположение.

Можно использовать `_CrtSetReportMode` для перенаправления отчета в другое расположение или обратно в **вывода** окна, как показано ниже:

```cpp
_CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_DEBUG );
```

## <a name="interpret-the-memory-leak-report"></a>Интерпретация отчета об утечке памяти

Если ваше приложение не определяет `_CRTDBG_MAP_ALLOC`, [_CrtDumpMemoryLeaks](/cpp/c-runtime-library/reference/crtdumpmemoryleaks) отображает отчет об утечке памяти, который выглядит следующим образом:

```cmd
Detected memory leaks!
Dumping objects ->
{18} normal block at 0x00780E80, 64 bytes long.
 Data: <                > CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD
Object dump complete.
```

Если ваше приложение определяет `_CRTDBG_MAP_ALLOC`, отчет об утечке памяти выглядит как:

```cmd
Detected memory leaks!
Dumping objects ->
c:\users\username\documents\projects\leaktest\leaktest.cpp(20) : {18}
normal block at 0x00780E80, 64 bytes long.
 Data: <                > CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD
Object dump complete.
```

Во втором отчете показано имя файла и номер строки, где сначала выделяется утечки памяти.

Ли вы определить `_CRTDBG_MAP_ALLOC`, в отчете об утечке памяти:

- Номер выделения памяти, который является `18` в примере
- Тип блока, `normal` в примере.
- Расположение памяти в шестнадцатеричном формате, `0x00780E80` в примере.
- Размер блока, `64 bytes` в примере.
- Первые 16 байт данных в блоке, в шестнадцатеричном формате.

Типы блоков памяти являются *обычный*, *клиента*, или *CRT*. *Обычный блок* — это обыкновенная память, выделенная программой. *Клиентский блок* — особый тип блока памяти, используемой программами MFC для объектов, для которых требуется деструктор. Оператор `new` в MFC создает либо обычный, либо клиентский блок, в соответствии с создаваемым объектом.

*Блок CRT* — это блок памяти, выделенной библиотекой CRT для внутреннего использования. Освобождение этих блоков производится библиотекой CRT, поэтому блоки CRT не будет отображаться в отчете об утечке памяти, если существуют серьезные проблемы с библиотекой CRT.

Существуют два других типа блоков памяти, которые никогда не отображаются в отчетах об утечке памяти. Объект *свободных блоков* памяти, которая была освобождена, поэтому по определению не утечки. *Пропускаемый блок* — это память, вы специально помеченная для исключения из отчета об утечке памяти.

Выше методы определения утечки памяти для памяти, выделенной с помощью стандартных CRT `malloc` функции. Если программа выделяет память с помощью C++ `new` оператор, однако вы можете увидеть только имя файла и номер строки, где `operator new` вызовы `_malloc_dbg` в отчете об утечке памяти. Чтобы создать более отчет об утечке памяти, можно написать макрос следующим сообщить о строке, внесенные выделение:

```cpp
#ifdef _DEBUG
    #define DBG_NEW new ( _NORMAL_BLOCK , __FILE__ , __LINE__ )
    // Replace _NORMAL_BLOCK with _CLIENT_BLOCK if you want the
    // allocations to be of _CLIENT_BLOCK type
#else
    #define DBG_NEW new
#endif
```

Теперь вы можете заменить `new` оператора с помощью `DBG_NEW` макрос в коде. В отладочных сборках `DBG_NEW` используется перегруженная версия глобального `operator new` , принимает дополнительные параметры для типа блока, файла и номер строки. Перегрузка `new` вызовы `_malloc_dbg` для записи дополнительных сведений. Отчеты об утечке памяти Показать имя файла и номер строки, где были выделены потерянные объекты. Сборки выпуска, по-прежнему используют значение по умолчанию `new`. Ниже приведен пример этого метода:

```cpp
// debug_new.cpp
// compile by using: cl /EHsc /W4 /D_DEBUG /MDd debug_new.cpp
#define _CRTDBG_MAP_ALLOC
#include <cstdlib>
#include <crtdbg.h>

#ifdef _DEBUG
    #define DBG_NEW new ( _NORMAL_BLOCK , __FILE__ , __LINE__ )
    // Replace _NORMAL_BLOCK with _CLIENT_BLOCK if you want the
    // allocations to be of _CLIENT_BLOCK type
#else
    #define DBG_NEW new
#endif

struct Pod {
    int x;
};

void main() {
    Pod* pPod = DBG_NEW Pod;
    pPod = DBG_NEW Pod; // Oops, leaked the original pPod!
    delete pPod;

    _CrtDumpMemoryLeaks();
}
```

При выполнении этого кода в Visual Studio отладчика, вызов `_CrtDumpMemoryLeaks` создает отчет в **вывода** окно, которое выглядит так:

```Output
Detected memory leaks!
Dumping objects ->
c:\users\username\documents\projects\debug_new\debug_new.cpp(20) : {75}
 normal block at 0x0098B8C8, 4 bytes long.
 Data: <    > CD CD CD CD
Object dump complete.
```

Эти выходные данные отчетов, что утечка выделение было предназначено в строке 20 *debug_new.cpp*.

>[!NOTE]
>Мы не рекомендуем создать макрос препроцессора с именем `new`, или другие ключевое слово языка.

## <a name="set-breakpoints-on-a-memory-allocation-number"></a>Установите точки останова для номера выделения памяти

Номер выделения памяти сообщает, когда был выделен утекающий блок памяти. Блок с номером выделения памяти 18 — например, — 18-й блок памяти, выделенной во время выполнения приложения. В отчете CRT учитываются все выделения блоков памяти во время выполнения, включая выделения, произведенные библиотекой CRT и другие библиотеки, например MFC. Таким образом эта память номер выделения блока 18, вероятно, станет 18-й блок памяти, выделенным вашим кодов.

Номер выделения можно использовать для того, чтобы задать точку останова в том месте, где выделяется память.

**Установка точки останова для выделения памяти с помощью окна контрольных значений:**

1. Установите точку останова недалеко от начала приложения и начните отладку.

1. Когда приложение приостанавливается в точке останова, откройте **Watch** окно, выбрав **Отладка** > **Windows** > **Контрольные значения 1** (или **Контрольные значения 2**, **Контрольное значение 3**, или **Контрольные значения 4**).

1. В **Watch** введите `_crtBreakAlloc` в **имя** столбца.

   Если используется многопоточная версия DLL библиотеки CRT (параметр/MD), добавьте контекстный оператор: `{,,ucrtbased.dll}_crtBreakAlloc`

1. Нажмите клавишу **ВВОД**.

   Отладчик выполнит оценку вызова и поместит результат в столбец **Значение** . Это значение будет равно **–1**, если в местах выделения памяти не задано ни одной точки останова.

1. В **значение** столбца, замените значение номером выделения памяти, где требуется останов отладчика.

После выбора точки останова для номера выделения памяти, продолжите отладку. Убедитесь в том, что для запуска под тем же условиям, поэтому номер выделения памяти не изменяется. Когда выполнение программы будет приостановлено на заданном выделении памяти, используйте **стек вызовов** окно и других окон отладчика определите условия, при которых была выделена память. Затем можно продолжить выполнение, чтобы посмотреть, что происходит на объект и определить, почему он не освобождается неправильно.

Иногда может быть полезно задать точку останова по данным на самом объекте. Для получения дополнительной информации см. раздел [Использование точек останова](../debugger/using-breakpoints.md).

Точки останова для выделения памяти можно также задать в коде. Можно установить следующие значения:

```cpp
_crtBreakAlloc = 18;
```

 или

```cpp
_CrtSetBreakAlloc(18);
```

## <a name="compare-memory-states"></a>Сравнение состояний памяти
 Другая технология для обнаружения утечек памяти включает получение "снимков" состояния памяти приложения в ключевых точках. Чтобы получить снимок состояния памяти в заданной точке приложения, создайте `_CrtMemState` структурировать и передать его в `_CrtMemCheckpoint` функции.

```cpp
_CrtMemState s1;
_CrtMemCheckpoint( &s1 );
```

`_CrtMemCheckpoint` Функция поместит в структуру снимок текущего состояния памяти.

Чтобы вывести содержимое `_CrtMemState` структуры, передайте ее `_ CrtMemDumpStatistics` функции:

```cpp
_CrtMemDumpStatistics( &s1 );
```

`_ CrtMemDumpStatistics` Выводит дамп состояния памяти, который выглядит следующим образом:

```cmd
0 bytes in 0 Free Blocks.
0 bytes in 0 Normal Blocks.
3071 bytes in 16 CRT Blocks.
0 bytes in 0 Ignore Blocks.
0 bytes in 0 Client Blocks.
Largest number used: 3071 bytes.
Total allocations: 3764 bytes.
```

Чтобы определить, произошла ли утечка памяти на отрезке кода, можно сделать снимок состояния памяти перед ним и после него, а затем сравнить оба состояния с помощью функции `_ CrtMemDifference` :

```cpp
_CrtMemCheckpoint( &s1 );
// memory allocations take place here
_CrtMemCheckpoint( &s2 );

if ( _CrtMemDifference( &s3, &s1, &s2) )
   _CrtMemDumpStatistics( &s3 );
```

`_CrtMemDifference` Сравнивает состояния памяти `s1` и `s2` и возвращает результат в (`s3`) является различие между `s1` и `s2`.

Еще один способ поиска утечек памяти заключается в размещении `_CrtMemCheckpoint` вызовы в начале и конце приложения, затем с помощью `_CrtMemDifference` сравнить результаты. Если `_CrtMemDifference` показывает утечку памяти, можно добавить несколько `_CrtMemCheckpoint` вызовы, чтобы разделить программу с помощью двоичного поиска, пока вы определили, что источник утечки.

## <a name="false-positives"></a>Ложные срабатывания
 `_CrtDumpMemoryLeaks` можно дать ошибочно диагностировать утечку памяти, если библиотеку внутренние выделения как обычных блоков вместо блоки CRT или клиентские блоки. В таком случае функция `_CrtDumpMemoryLeaks` не может различать пользовательские выделения и внутренние выделения библиотеки. Если глобальные деструкторы для выделений библиотеки выполняются после точки вызова функции `_CrtDumpMemoryLeaks`, каждое внутреннее выделение библиотеки принимается за утечку памяти. Версии библиотеки стандартных шаблонов раньше, чем Visual Studio .NET может привести к `_CrtDumpMemoryLeaks` сообщить о таких ложных положительных результатов.

## <a name="see-also"></a>См. также
- [Сведения о куче отладки CRT](../debugger/crt-debug-heap-details.md)
- [Безопасность отладчика](../debugger/debugger-security.md)
- [Отладка машинного кода](../debugger/debugging-native-code.md)
