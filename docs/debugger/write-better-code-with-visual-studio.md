---
title: Методы и инструменты отладки
description: Написание лучшего кода с меньшими ошибками с помощью Visual Studio для исправления исключений, исправления ошибок и улучшения кода
ms.custom:
- debug-experiment
- seodec18
ms.date: 01/24/2019
ms.topic: conceptual
helpviewer_keywords:
- debugger
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: b1fe0a9bb1e966bd1451bb5d816eaab814071fb5
ms.sourcegitcommit: 7825d4163e52d724e59f6c0da209af5fbef673f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/07/2019
ms.locfileid: "72000177"
---
# <a name="debugging-techniques-and-tools-to-help-you-write-better-code"></a>Методы и средства отладки, помогающие писать более эффективный код

Устранение ошибок и ошибок в коде может быть трудоемкой и иногда неприятной задачей. Чтобы научиться эффективно выполнять отладку, требуется время, но мощная интегрированная среда разработки, например Visual Studio, может сделать вашу работу гораздо проще. Интегрированная среда разработки позволяет быстрее исправлять ошибки и выполнять отладку кода, но это также может помочь в написании лучшего кода с меньшим количеством ошибок. Нашей целью в этой статье является комплексное представление процесса исправления ошибок, поэтому вы будете видеть, когда следует использовать анализатор кода, когда использовать отладчик, как исправить исключения и как код для намерения. Если вы уже знакомы с использованием отладчика, см. статью [Знакомство](../debugger/debugger-feature-tour.md)с отладчиком.

В этой статье мы поговорим об использовании интегрированной среды разработки для повышения производительности сеансов программирования. Мы расскажем о нескольких задачах, например:

* Подготовка кода к отладке с помощью анализатора кода интегрированной среды разработки

* Исправление исключений (ошибки времени выполнения)

* Как сокращать ошибки путем написания кода для намерения (с помощью Assert)

* Когда следует использовать отладчик

Чтобы продемонстрировать эти задачи, мы покажем несколько наиболее распространенных типов ошибок и ошибок, которые возникают при попытке отладки приложений. Хотя пример кода — C#, концептуальные сведения обычно применимы к C++, Visual Basic, JavaScript и другим языкам, поддерживаемым Visual Studio (за исключением случаев, когда отмечено). На снимках экрана представлены примеры на C#.

## <a name="create-a-sample-app-with-some-bugs-and-errors-in-it"></a>Создание примера приложения с некоторыми ошибками и ошибками в нем

В следующем коде есть некоторые ошибки, которые можно исправить с помощью интегрированной среды разработки Visual Studio. Здесь приложение представляет собой простое приложение, которое имитирует получение данных JSON из некоторой операции, десериализацию данных в объект и обновление простого списка новыми данными.

Создание приложения:

1. Откройте Visual Studio и выберите **файл** > **Новый** > **проект**. В **разделе C#визуальный** элемент выберите **Рабочий стол Windows** или **.NET Core**, а затем в средней области выберите **консольное приложение**.

    > [!NOTE]
    > Если шаблон проекта **Консольное приложение** отсутствует, щелкните ссылку **Открыть Visual Studio Installer** в левой области диалогового окна **Создание проекта**. Запускается Visual Studio Installer. Выберите рабочую нагрузку **Разработка классических приложений .NET** или **Кроссплатформенная разработка .NET Core**, а затем щелкните **Изменить**.

2. В поле **имя** введите **Console_Parse_JSON** и нажмите кнопку **ОК**. Visual Studio создаст проект.

3. Замените код по умолчанию в файле *Program.CS* проекта на пример кода ниже.

```csharp
using System;
using System.Collections.Generic;
using System.Runtime.Serialization.Json;
using System.Runtime.Serialization;
using System.IO;

namespace Console_Parse_JSON
{
    class Program
    {
        static void Main(string[] args)
        {
            var localDB = LoadRecords();
            string data = GetJsonData();

            User[] users = ReadToObject(data);

            UpdateRecords(localDB, users);

            for (int i = 0; i < users.Length; i++)
            {
                List<User> result = localDB.FindAll(delegate (User u) {
                    return u.lastname == users[i].lastname;
                    });
                foreach (var item in result)
                {
                    Console.WriteLine($"Matching Record, got name={item.firstname}, lastname={item.lastname}, age={item.totalpoints}");
                }
            }

            Console.ReadKey();
        }

        // Deserialize a JSON stream to a User object.
        public static User[] ReadToObject(string json)
        {
            User deserializedUser = new User();
            User[] users = { };
            MemoryStream ms = new MemoryStream(Encoding.UTF8.GetBytes(json));
            DataContractJsonSerializer ser = new DataContractJsonSerializer(users.GetType());

            users = ser.ReadObject(ms) as User[];

            ms.Close();
            return users;
        }

        // Simulated operation that returns JSON data.
        public static string GetJsonData()
        {
            string str = "[{ \"points\":4o,\"firstname\":\"Fred\",\"lastname\":\"Smith\"},{\"lastName\":\"Jackson\"}]";
            return str;
        }

        public static List<User> LoadRecords()
        {
            var db = new List<User> { };
            User user1 = new User();
            user1.firstname = "Joe";
            user1.lastname = "Smith";
            user1.totalpoints = 41;

            db.Add(user1);

            User user2 = new User();
            user2.firstname = "Pete";
            user2.lastname = "Peterson";
            user2.totalpoints = 30;

            db.Add(user2);

            return db;
        }
        public static void UpdateRecords(List<User> db, User[] users)
        {
            bool existingUser = false;

            for (int i = 0; i < users.Length; i++)
            {
                foreach (var item in db)
                {
                    if (item.lastname == users[i].lastname && item.firstname == users[i].firstname)
                    {
                        existingUser = true;
                        item.totalpoints += users[i].points;

                    }
                }
                if (existingUser == false)
                {
                    User user = new User();
                    user.firstname = users[i].firstname;
                    user.lastname = users[i].lastname;
                    user.totalpoints = users[i].points;

                    db.Add(user);
                }
            }
        }
    }

    [DataContract]
    internal class User
    {
        [DataMember]
        internal string firstname;

        [DataMember]
        internal string lastname;

        [DataMember]
        // internal double points;
        internal string points;

        [DataMember]
        internal int totalpoints;
    }
}
```

## <a name="find-the-red-and-green-squiggles"></a>Найдите красную и зеленую волнистую линию!

Прежде чем пытаться запустить пример приложения и запустить отладчик, проверьте код в редакторе кода на наличие красных и зеленых волнистых линий. Они представляют ошибки и предупреждения, определяемые анализатором кода интегрированной среды разработки. Красные волнистые линии — ошибки времени компиляции, которые необходимо исправить, прежде чем можно будет запустить код. Зеленые волнистые линии — это предупреждения. Хотя вы часто можете запускать приложение без исправления предупреждений, они могут быть источником ошибок и часто экономить время и проблемы, изучая их. Эти предупреждения и ошибки также отображаются в окне **Список ошибок** , если предпочитаете представление списка.

В примере приложения вы увидите несколько красных волнистых линий, которые необходимо исправить, и одну зеленую, которая будет выглядеть. Первая ошибка.

![Ошибка при отображении красной волнистой линией](../debugger/media/write-better-code-red-squiggle.png)

Чтобы устранить эту ошибку, просмотрите другую функцию интегрированной среды разработки, представленную значком лампочки.

## <a name="check-the-light-bulb"></a>Проверьте лампочку.

Первая красная волнистая линия представляет ошибку во время компиляции. Наведите на него указатель мыши и отобразится сообщение ```The name `Encoding` does not exist in the current context```.

Обратите внимание, что эта ошибка отображается в нижнем левом углу значка лампочки. Вместе с значком отвертки ![значок отвертки](../ide/media/screwdriver-icon.png)значок лампочки ![значок лампочки](../ide/media/light-bulb-icon.png) представляет быстрые действия, которые могут помочь при исправлении или реструктуризации кода. Лампочка представляет проблемы, которые *следует* исправить. Отвертка предназначена для устранения проблем, которые можно выбрать для исправления. Чтобы устранить эту ошибку, используйте первое предлагаемое исправление, нажав кнопку **использовать System. Text** слева.

![Исправление кода с помощью лампочки](../debugger/media/write-better-code-missing-include.png)

Если щелкнуть этот элемент, Visual Studio добавит инструкцию `using System.Text` в верхней части файла *Program.CS* , а красная волнистая линия исчезнет. (Если вы не уверены, какое действие будет предложено, щелкните ссылку **Предварительный просмотр изменений** справа перед применением исправления.)

Описанная выше ошибка является распространенной, которая обычно исправляется путем добавления в код новой инструкции `using`. Существует несколько распространенных подобных ошибок, таких как ```The type or namespace `Name` cannot be found.``` такие ошибки могут указывать на отсутствующую ссылку на сборку (щелкните правой кнопкой мыши проект, выберите пункт **добавить** > **ссылку**), неправильно написанное имя или отсутствующую библиотеку, которую необходимо добавить (для C#щелкните правой кнопкой мыши проект и выберите пункт **Управление пакетами NuGet**).

## <a name="fix-the-remaining-errors-and-warnings"></a>Исправление оставшихся ошибок и предупреждений

В этом коде есть несколько волнистых линий для просмотра. Здесь отображается ошибка преобразования общего типа. При наведении указателя мыши на волнистую линию видно, что код пытается преобразовать строку в тип int, что не поддерживается, если не добавить явный код для преобразования.

![Ошибка преобразования типа](../debugger/media/write-better-code-conversion-error.png)

Поскольку анализатор кода не может угадать ваше намерение, у вас нет лампочки, которые помогут вам в этом времени. Чтобы устранить эту ошибку, необходимо знать назначение кода. В этом примере не слишком сложно увидеть, что `points` должно быть числовым (целочисленным) значением, так как вы пытаетесь добавить `points` `totalpoints`.

Чтобы устранить эту ошибку, измените элемент `points` класса `User` следующим образом:

```csharp
[DataMember]
internal string points;
```

к этому:

```csharp
[DataMember]
internal int points;
```

Красные волнистые линии в редакторе кода исчезают.

Затем наведите указатель мыши на зеленую волнистую линию в объявлении элемента данных `points`. Анализатор кода сообщает, что переменной никогда не присвоено значение.

![Предупреждающее сообщение для неназначенной переменной](../debugger/media/write-better-code-warning-message.png)

Как правило, это представляет проблему, которую необходимо исправить. Однако в примере приложения вы фактически сохраняете данные в переменной `points` в процессе десериализации, а затем добавляете это значение в `totalpoints`ный элемент данных. В этом примере вы узнали назначение кода и можете спокойно проигнорировать предупреждение. Однако если вы хотите устранить это предупреждение, можно заменить следующий код:

```csharp
item.totalpoints = users[i].points;
```

следующим кодом:

```csharp
item.points = users[i].points;
item.totalpoints += users[i].points;
```

Зеленая волнистая линия исчезает.

## <a name="fix-an-exception"></a>Исправление исключения

Если вы устранили все красные волнистые линии и разрешили их, или по крайней мере, проверьте все зеленые волнистые линии, вы можете запустить отладчик и запустить приложение.

Нажмите клавишу **F5** (**Отладка > Начать отладку**) или кнопку **Начать отладку** ![Начать отладку](../debugger/media/dbg-tour-start-debugging.png "Начать отладку ") на панели инструментов отладки.

На этом этапе пример приложения создает исключение `SerializationException` (ошибка времени выполнения). Это значит, что приложение выполняет треппинг для данных, которые он пытается сериализовать. Так как приложение было запущено в режиме отладки (подключен отладчик), вспомогательный метод исключения отладчика принимает вас справа на код, который выдал исключение, и предоставляет полезное сообщение об ошибке.

![Происходит SerializationException](../debugger/media/write-better-code-serialization-exception.png)

Сообщение об ошибке указывает, что значение `4o` не может быть проанализировано как целое число. Итак, в этом примере вы узнали, что данные повреждены: `4o` должны быть `40`. Но если вы не контролируете данные в реальной ситуации (скажем, вы получаете их из веб-службы), что делать с ней? Как это исправить?

При возникновении исключения необходимо задать пару вопросов (и ответить на них):

* Является ли это исключение просто ошибкой, которую можно исправить? Или

* Это исключение может возникнуть у пользователей?

Если это первое, исправьте ошибку. (В примере приложения это означает исправление неверных данных.) Если это последнее, может потребоваться обрабатывайте исключение в коде, используя блок `try/catch` (мы рассмотрим другие возможные стратегии в следующем разделе). В примере приложения замените следующий код:

```csharp
users = ser.ReadObject(ms) as User[];
```

следующим кодом:

```csharp
try
{
    users = ser.ReadObject(ms) as User[];
}
catch (SerializationException)
{
    Console.WriteLine("Give user some info or instructions, if necessary");
    // Take appropriate action for your app
}
```

Блок `try/catch` имеет некоторые затраты на производительность, поэтому вы хотите использовать их только тогда, когда они действительно нужны, то есть, где (а) они могут возникнуть в окончательной версии приложения, и где (b) документация по методу указывает, что необходимо проверить наличие исключения (предполагая, что документация завершена). Во многих случаях можно соответствующим образом обойти исключение, и пользователю никогда не нужно знать о нем.

Ниже приведены несколько важных советов по обработке исключений.

* Старайтесь не использовать пустой блок catch, например `catch (Exception) {}`, который не принимает соответствующие действия для предоставления или обработки ошибки. Пустой или неинформативный блок catch может скрывать исключения и может усложнить отладку кода, а не упростить процесс отладки.

* Используйте `try/catch` блок вокруг конкретной функции, которая вызывает исключение (`ReadObject`, в примере приложения). Если вы используете его с большим фрагментом кода, вы в итоге скройтее расположение ошибки. Например, не используйте `try/catch` блок вокруг вызова родительской функции `ReadToObject`, как показано здесь, или вы не узнаете точно, где произошло исключение.

    ```csharp
    // Don't do this
    try
    {
        User[] users = ReadToObject(data);
    }
    catch (SerializationException)
    {
    }
    ```

* Для незнакомых функций, включенных в приложение, особенно взаимодействующих с внешними данными (например, с веб-запросом), ознакомьтесь с документацией, чтобы узнать, какие исключения может вызывать функция. Это может быть важной информацией для правильной обработки ошибок и отладки приложения.

Для примера приложения исправьте `SerializationException` в методе `GetJsonData`, изменив `4o` на `40`.

## <a name="clarify-your-code-intent-by-using-assert"></a>Уточнение цели кода с помощью Assert

Нажмите кнопку **Перезапустить** ![Перезапустить приложение](../debugger/media/dbg-tour-restart.png "Перезапустить приложение") на панели инструментов отладки (**CTRL** + **SHIFT** + **F5**). Это приведет к перезапуску приложения за меньшее количество шагов. В окне консоли вы увидите следующие выходные данные.

![Значение NULL в выходных данных](../debugger/media/write-better-code-using-assert-null-output.png)

В выходных данных можно увидеть, что что-то неверно. **имя** и **Фамилия** третьей записи пусты.

Это хороший момент, когда мы поговорим о полезном подходе к написанию кода, который часто используется, что заключается в использовании `assert` операторов в функциях. Добавив следующий код, вы включите проверку среды выполнения, чтобы убедиться, что `firstname` и `lastname` не `null`. Замените следующий код в методе `UpdateRecords`:

```csharp
if (existingUser == false)
{
    User user = new User();
    user.firstname = users[i].firstname;
    user.lastname = users[i].lastname;
```

следующим кодом:

```csharp
// Also, add a using statement for System.Diagnostics at the start of the file.
Debug.Assert(users[i].firstname != null);
Debug.Assert(users[i].lastname != null);
if (existingUser == false)
{
    User user = new User();
    user.firstname = users[i].firstname;
    user.lastname = users[i].lastname;
```

Добавив такие инструкции `assert` в функции в процессе разработки, можно указать назначение кода. В предыдущем примере мы указываем следующее:

* Для первого имени требуется допустимая строка
* Для последнего имени требуется допустимая строка

Указав цель таким образом, вы придаете необходимые требования. Это простой и удобный метод, который можно использовать для отображения ошибок во время разработки. (`assert` операторы также используются в качестве главного элемента в модульных тестах.)

Нажмите кнопку **Перезапустить** ![Перезапустить приложение](../debugger/media/dbg-tour-restart.png "Перезапустить приложение") на панели инструментов отладки (**CTRL** + **SHIFT** + **F5**).

> [!NOTE]
> Код `assert` активен только в отладочной сборке.

При перезапуске отладчик приостанавливается на операторе `assert`, поскольку выражение `users[i].firstname != null` вычисляется как `false` вместо `true`.

![Assert разрешается в значение false](../debugger/media/write-better-code-using-assert.png)

Ошибка `assert` сообщает о проблеме, которую необходимо изучить. `assert` может охватывать множество сценариев, в которых не всегда отображается исключение. В этом примере пользователь не увидит исключение, а `null` значение добавляется как `firstname` в список записей. Это может вызвать проблемы позже (например, в выходных данных консоли) и может быть труднее для отладки.

> [!NOTE]
> В сценариях, где вызывается метод для значения `null`, `NullReferenceException` результаты. Обычно следует избегать использования блока `try/catch` для общего исключения, то есть исключения, не привязанного к определенной функции библиотеки. Любой объект может вызывать `NullReferenceException`. Если вы не уверены, проверьте документацию по библиотечной функции.

Во время процесса отладки рекомендуется использовать определенную инструкцию `assert`, пока не будет известно, что ее нужно заменить на реальное исправление кода. Допустим, вы решили, что пользователь может столкнуться с исключением в сборке выпуска приложения. В этом случае необходимо выполнить рефакторинг кода, чтобы убедиться в том, что приложение не создает неустранимое исключение или приводит к возникновению какой-либо другой ошибки. Итак, чтобы исправить этот код, замените следующий код:

```csharp
if (existingUser == false)
{
    User user = new User();
```

следующим кодом:

```csharp
if (existingUser == false && users[i].firstname != null && users[i].lastname != null)
{
    User user = new User();
```

С помощью этого кода можно выполнить требования к коду и убедиться, что запись с `firstname` или `lastname` значение `null` не добавлена в данные.

В этом примере мы добавили две инструкции `assert` в цикле. Как правило, при использовании `assert`рекомендуется добавлять операторы `assert` в точке входа (начиная с начала) функции или метода. В настоящее время вы ищете метод `UpdateRecords` в примере приложения. В этом методе вы можете столкнуться с проблемами, если какой-либо из аргументов метода имеет `null`, поэтому проверьте их и с помощью инструкции `assert` в точке входа функции.

```csharp
public static void UpdateRecords(List<User> db, User[] users)
{
    Debug.Assert(db != null);
    Debug.Assert(users != null);
```

Для предыдущих инструкций ваша цель заключается в том, что вы загружаете существующие данные (`db`) и получаете новые данные (`users`) перед обновлением.

`assert` можно использовать с любым видом выражения, которое разрешается в `true` или `false`. Например, можно добавить оператор `assert`, как показано далее.

```csharp
Debug.Assert(users[0].points > 0);
```

Приведенный выше код полезен, если необходимо указать следующее намерение: для обновления записи пользователя требуется новое значение точки больше нуля (0).

## <a name="inspect-your-code-in-the-debugger"></a>Проверка кода в отладчике

Итак, теперь, когда вы устранили все критические проблемы с примером приложения, вы можете перейти на другие важные вещи!

Мы увидели вспомогательный метод исключения отладчика, но отладчик является гораздо более мощным средством, которое также позволяет выполнять другие действия, такие как пошаговое выполнение кода и изучение его переменных. Эти более эффективные возможности полезны во многих сценариях, особенно в следующих случаях:

* Вы пытаетесь изолировать ошибку времени выполнения в коде, но не можете сделать это с помощью методов и средств, описанных выше.

* Вы хотите проверить код, то есть следить за его запуском, чтобы убедиться, что он работает так, как вы ждете, и сделать то, что вы хотите.

    Это дает возможность отслеживать код во время его выполнения. Вы можете получить дополнительные сведения о коде таким образом и часто определить ошибки до того, как они проявляются очевидными симптомами.

Сведения об использовании ключевых функций отладчика см. в разделе [Отладка для](../debugger/debugging-absolute-beginners.md)начинающих.

## <a name="fix-performance-issues"></a>Исправление проблем производительности

Ошибки другого типа включают неэффективный код, который вызывает медленное выполнение приложения или использование слишком большого объема памяти. Как правило, оптимизация производительности — это то, что можно сделать позже при разработке приложений. Однако на ранних этапах можно столкнуться с проблемами производительности (например, вы видите, что часть приложения работает медленнее), и вам может потребоваться протестировать приложение с помощью средств профилирования на раннем этапе. Дополнительные сведения о средствах профилирования, таких как средство загрузки ЦП и анализатор памяти, см. в разделе [Знакомство со средствами профилирования](../profiling/profiling-feature-tour.md).

## <a name="next-steps"></a>Следующие шаги

В этой статье вы узнали, как избежать и устранить многие распространенные ошибки в коде и когда использовать отладчик. Далее Узнайте больше об использовании отладчика Visual Studio для исправления ошибок.

> [!div class="nextstepaction"]
> [Отладка для начинающих](../debugger/debugging-absolute-beginners.md)
