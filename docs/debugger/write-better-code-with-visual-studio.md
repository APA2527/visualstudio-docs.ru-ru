---
title: Методы и инструменты отладки
description: Напишите лучший код с меньшим количеством ошибок, используя Visual Studio для исправления исключений, исправления ошибок и улучшения кода
ms.custom:
- debug-experiment
- seodec18
ms.date: 02/14/2020
ms.topic: conceptual
helpviewer_keywords:
- debugger
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 2ac595098d793e44d65312a09fc8857225f150ef
ms.sourcegitcommit: 95f26af1da51d4c83ae78adcb7372b32364d8a2b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/13/2020
ms.locfileid: "79301023"
---
# <a name="debugging-techniques-and-tools-to-help-you-write-better-code"></a>Методы и инструменты отладки, которые помогут вам написать лучший код

Исправление ошибок и ошибок в коде может занять много времени, а иногда и неприятно- Требуется время, чтобы научиться эффективно отладиться, но мощная IDE, такая как Visual Studio, может сделать вашу работу намного проще. IDE может помочь вам исправить ошибки и отладить код быстрее, и не только это, но он также может помочь вам написать лучший код с меньшим количеством ошибок. Наша цель в этой статье состоит в том, чтобы дать вам целостное представление о процессе «фиксации ошибок», чтобы вы знали, когда использовать анализатор кода, когда использовать отладчик, как исправить исключения и как кодировать для намерения. Если вы уже знаете, что вам нужно использовать отладчик, смотрите [первый взгляд на отладчик](../debugger/debugger-feature-tour.md).

В этой статье мы говорим о использовании IDE, чтобы сделать ваши сеансы кодирования более продуктивными. Мы касаемся нескольких задач, таких как:

* Подготовьте код для отладки, используя анализатор кода IDE

* Как исправить исключения (ошибки времени выполнения)

* Как свести к минимуму ошибки путем кодирования для намерения (с помощью assert)

* Когда использовать отладчик

Чтобы продемонстрировать эти задачи, мы показываем несколько наиболее распространенных типов ошибок и ошибок, с которыми вы столкнетесь при попытке отладить приложения. Несмотря на то, что пример кода является C, концептуальная информация, как правило, применима к СЗ, Visual Basic, JavaScript и другим языкам, поддерживаемым Visual Studio (за исключением отмеченных). На снимках экрана представлены примеры на C#.

## <a name="create-a-sample-app-with-some-bugs-and-errors-in-it"></a>Создайте пример приложения с некоторыми ошибками и ошибками в нем

Следующий код имеет некоторые ошибки, которые можно исправить с помощью Visual Studio IDE. Приложение здесь представляет собой простое приложение, которое имитирует получение данных JSON от некоторых операций, десериализации данных на объект, и обновление простого списка с новыми данными.

Создание приложения.

1. Необходимо установить Visual Studio и либо **разработать кроссплатформу .NET Core,** либо загрузить рабочую нагрузку **на рабочий стол .NET,** в зависимости от типа приложения, который вы хотите создать.

    Если вы еще не установили Visual Studio, перейдите на страницу visual [Studio,](https://visualstudio.microsoft.com/downloads/)чтобы установить ее бесплатно.

    Если вам нужно установить рабочую нагрузку, но у вас уже есть Visual Studio, нажмите **Инструменты** > **Получить инструменты и функции.** Запускается Visual Studio Installer. Выберите **кросс-платформную разработку .NET Core** или рабочую нагрузку для **разработки рабочего стола .NET,** а затем выберите **Modify**.

1. Запустите Visual Studio.

    ::: moniker range=">=vs-2019"
    На стартовом окне выберите **Создать новый проект.** Введите **консоль** в поле поиска и выберите **Консольное приложение (.NET Core)** или **Консольное приложение (.NET Framework)**. Выберите **следующий**. Введите имя проекта, как **Console_Parse_JSON** и нажмите **Создать**.
    ::: moniker-end
    ::: moniker range="vs-2017"
    Из верхней панели меню, выберите **Файл** > **Новый** > **проект**. В левом стекле нового диалогового окна **проекта,** под **Visual C ,** выберите **консоль App**, а затем в середине панели выбрать либо **консоль App (.NET Core)** или **консоль App (.NET Framework)**. Введите имя, как **Console_Parse_JSON** и нажмите **OK**.
    ::: moniker-end

    Если вы не видите шаблон проекта **Console App (.NET Core)** или **Console App (.NET Framework),** перейдите на инструменты**и функции,** **Tools** > который открывает установщик Visual Studio. Выберите рабочую нагрузку **Разработка кроссплатформенных приложений .NET Core** или **Разработка классических приложений .NET Core**, а затем выберите **Изменить**.

    Visual Studio создаст консольный проект и откроет его в обозревателе решений (правая область).

1. Замените код по умолчанию в *Program.cs* файле проекта с приведенным ниже примером кода.

```csharp
using System;
using System.Collections.Generic;
using System.Runtime.Serialization.Json;
using System.Runtime.Serialization;
using System.IO;

namespace Console_Parse_JSON
{
    class Program
    {
        static void Main(string[] args)
        {
            var localDB = LoadRecords();
            string data = GetJsonData();

            User[] users = ReadToObject(data);

            UpdateRecords(localDB, users);

            for (int i = 0; i < users.Length; i++)
            {
                List<User> result = localDB.FindAll(delegate (User u) {
                    return u.lastname == users[i].lastname;
                    });
                foreach (var item in result)
                {
                    Console.WriteLine($"Matching Record, got name={item.firstname}, lastname={item.lastname}, age={item.totalpoints}");
                }
            }

            Console.ReadKey();
        }

        // Deserialize a JSON stream to a User object.
        public static User[] ReadToObject(string json)
        {
            User deserializedUser = new User();
            User[] users = { };
            MemoryStream ms = new MemoryStream(Encoding.UTF8.GetBytes(json));
            DataContractJsonSerializer ser = new DataContractJsonSerializer(users.GetType());

            users = ser.ReadObject(ms) as User[];

            ms.Close();
            return users;
        }

        // Simulated operation that returns JSON data.
        public static string GetJsonData()
        {
            string str = "[{ \"points\":4o,\"firstname\":\"Fred\",\"lastname\":\"Smith\"},{\"lastName\":\"Jackson\"}]";
            return str;
        }

        public static List<User> LoadRecords()
        {
            var db = new List<User> { };
            User user1 = new User();
            user1.firstname = "Joe";
            user1.lastname = "Smith";
            user1.totalpoints = 41;

            db.Add(user1);

            User user2 = new User();
            user2.firstname = "Pete";
            user2.lastname = "Peterson";
            user2.totalpoints = 30;

            db.Add(user2);

            return db;
        }
        public static void UpdateRecords(List<User> db, User[] users)
        {
            bool existingUser = false;

            for (int i = 0; i < users.Length; i++)
            {
                foreach (var item in db)
                {
                    if (item.lastname == users[i].lastname && item.firstname == users[i].firstname)
                    {
                        existingUser = true;
                        item.totalpoints += users[i].points;

                    }
                }
                if (existingUser == false)
                {
                    User user = new User();
                    user.firstname = users[i].firstname;
                    user.lastname = users[i].lastname;
                    user.totalpoints = users[i].points;

                    db.Add(user);
                }
            }
        }
    }

    [DataContract]
    internal class User
    {
        [DataMember]
        internal string firstname;

        [DataMember]
        internal string lastname;

        [DataMember]
        // internal double points;
        internal string points;

        [DataMember]
        internal int totalpoints;
    }
}
```

## <a name="find-the-red-and-green-squiggles"></a>Найти красный и зеленый squiggles!

Прежде чем пытаться запустить пример приложения и запустить отладчик, проверьте код в редакторе кода для красных и зеленых squiggles. Они представляют ошибки и предупреждения, которые идентифицируются анализатором кода IDE. Красные завихри — это ошибки компиляции времени, которые необходимо исправить, прежде чем запустить код. Зеленые завихри являются предупреждениями. Хотя вы часто можете запустить приложение без исправления предупреждений, они могут быть источником ошибок, и вы часто экономите время и проблемы, исследуя их. Эти предупреждения и ошибки также отображаются в окне **списка ошибок,** если вы предпочитаете представление списка.

В примере приложения вы видите несколько красных завихрений, которые необходимо исправить, и один зеленый, который вы будете смотреть. Вот первая ошибка.

![Ошибка, показывающая как красный squiggle](../debugger/media/write-better-code-red-squiggle.png)

Чтобы исправить эту ошибку, вы посмотрите на другую особенность IDE, представленную значок лампочки.

## <a name="check-the-light-bulb"></a>Проверь лампочку!

Первый красный завихрение представляет собой ошибку времени компиляции. Нависте над ним, и вы видите сообщение ```The name `Encoding` does not exist in the current context```.

Обратите внимание, что эта ошибка показывает значок лампочки в левом нижнем нижнем. Наряду с значком ![](../ide/media/screwdriver-icon.png)отвертки значок отвертки,](../ide/media/light-bulb-icon.png) значок лампочки ![лампочки лампочки лампочки лампочки лампочки лампочки света представляет Быстрые действия, которые могут помочь вам исправить или рефакторный код вставка. Лампочка представляет проблемы, которые вы *должны* исправить. Отвертка предназначена для проблем, которые вы можете решить для исправления. Используйте первое предложенное исправление для устранения этой ошибки, нажав **с помощью System.Text** слева.

![Используйте лампочку, чтобы исправить код](../debugger/media/write-better-code-missing-include.png)

При нажатии на этот элемент `using System.Text` Visual Studio добавляет заявление в верхней части *файла Program.cs,* и красный squiggle исчезает. (Когда вы не уверены, что будет делать предлагаемое исправление, выберите ссылку **на изменения предварительного просмотра** справа, прежде чем применять исправление.)

Предыдущая ошибка является общей ошибкой, которую `using` обычно исправляемые, добавляя новую выписку в код. Есть несколько распространенных, аналогичные ```The type or namespace `Name` cannot be found.``` ошибки, такие как эти виды ошибок могут указывать на недостающие ссылки сборки (право нажмите на проект, выберите **Добавить** > **ссылку**), неправильное имя, или отсутствует библиотека, которую вам нужно добавить (для C , право нажмите на проект и выбрать **Управление NuGet пакеты**).

## <a name="fix-the-remaining-errors-and-warnings"></a>Исправление оставшихся ошибок и предупреждений

Есть еще несколько squiggles смотреть на в этом коде. Здесь вы видите распространенную ошибку преобразования типа. Когда вы нависаете над завихрением, вы видите, что код пытается преобразовать строку в int, которая не поддерживается, если вы не добавите явный код, чтобы сделать преобразование.

![Ошибка преобразования типа](../debugger/media/write-better-code-conversion-error.png)

Потому что анализатор кода не может угадать ваши намерения, Есть нет лампочек, чтобы помочь вам на этот раз. Чтобы исправить эту ошибку, необходимо знать о намерении кода. В этом примере не так уж `points` трудно увидеть, что должно быть числовое (множество) `points` `totalpoints`значение, так как вы пытаетесь добавить к .

Чтобы исправить эту ошибку, `points` `User` измените член класса из этого:

```csharp
[DataMember]
internal string points;
```

на такой:

```csharp
[DataMember]
internal int points;
```

Красные squiggly линии в редакторе кода уходят.

Далее, нависните над зеленым `points` squiggle в декларации члена данных. Анализатор кода говорит вам, что переменная никогда не назначается значением.

![Предупреждающее сообщение для неназначенной переменной](../debugger/media/write-better-code-warning-message.png)

Как правило, это представляет собой проблему, которую необходимо устранить. Однако в примере приложения вы фактически храните данные в `points` переменной в процессе `totalpoints` десериализации, а затем добавляете это значение члену данных. В этом примере вы знаете о цели кода и можете безопасно игнорировать предупреждение. Однако, если вы хотите устранить предупреждение, вы можете заменить следующий код:

```csharp
item.totalpoints = users[i].points;
```

следующим кодом:

```csharp
item.points = users[i].points;
item.totalpoints += users[i].points;
```

Зеленый squiggle уходит.

## <a name="fix-an-exception"></a>Исправление исключения

Когда вы исправили все красные squiggles и решены - или по крайней мере исследовал - все зеленые squiggles, вы готовы начать отладчик и запустить приложение.

Нажмите **F5** **(Debug > начать отладку)** или кнопку **Start Debugging** ![Начало отладки](../debugger/media/dbg-tour-start-debugging.png "Начать отладку") в панели инструментов Debug.

На этом этапе приложение образец бросает `SerializationException` исключение (ошибка выполнения). То есть, приложение душит на данные, которые он пытается сериализации. Поскольку приложение запустилось в режиме отладки (прикрепляется отладчик), помощник по исключению отладчика переносит вас прямо к коду, который бросил исключение и дает вам полезное сообщение об ошибке.

![Происходит исключение сериализации](../debugger/media/write-better-code-serialization-exception.png)

Сообщение об ошибке инструктирует вас, что значение `4o` не может быть разогнано как целый ряд. Таким образом, в этом примере, `4o` вы `40`знаете, данные плохо: должно быть . Однако, если вы не контролируете данные в реальном сценарии (скажем, вы получаете их от веб-сервиса), что вы с этим делаете? Как это исправить?

При нажмете исключение, вам нужно задать (и ответить) на несколько вопросов:

* Является ли это исключение просто ошибка, которую можно исправить? или

* Является ли это исключение чем-то, с чем могут столкнуться пользователи?

Если это первый, исправить ошибку. (В примере приложения это означает исправление плохих данных.) Если это последнее, возможно, потребуется обрабатывать исключение в `try/catch` коде с помощью блока (мы рассмотрим другие возможные стратегии в следующем разделе). В примере приложения замените следующий код:

```csharp
users = ser.ReadObject(ms) as User[];
```

следующим:

```csharp
try
{
    users = ser.ReadObject(ms) as User[];
}
catch (SerializationException)
{
    Console.WriteLine("Give user some info or instructions, if necessary");
    // Take appropriate action for your app
}
```

Блок `try/catch` имеет некоторую стоимость производительности, так что вы хотите использовать их только тогда, когда вы действительно в них нуждается, то есть, где (а) они могут произойти в версии релиза приложения, и где (b) документация для метода указывает, что вы должны проверить исключение (при условии, что документация завершена!). Во многих случаях вы можете обрабатывать исключение надлежащим образом, и пользователю никогда не нужно будет знать об этом.

Вот несколько важных советов по обработке исключений:

* Избегайте использования пустого `catch (Exception) {}`блока улова, например, который не предпринимает надлежащих действий для разоблачения или обработки ошибки. Пустой или неинформативный блок улова может скрыть исключения и сделать код более сложным для отладки, а не проще.

* Используйте `try/catch` блок вокруг конкретной функции,`ReadObject`которая бросает исключение (, в примере приложения). Если вы используете его вокруг большего фрагмента кода, вы в конечном итоге скрываете местоположение ошибки. Например, не используйте `try/catch` блок вокруг вызова родительской функции, `ReadToObject`показанный здесь, или вы не будете точно знать, где произошло исключение.

    ```csharp
    // Don't do this
    try
    {
        User[] users = ReadToObject(data);
    }
    catch (SerializationException)
    {
    }
    ```

* Для незнакомых функций, которые вы включаете в приложение, особенно те, которые взаимодействуют с внешними данными (например, веб-запрос), проверьте документацию, чтобы увидеть, какие исключения функция может бросить. Это может быть важной информацией для правильной обработки ошибок и для отладки приложения.

Для примера приложения `SerializationException` исправьте `GetJsonData` `4o` метод, изменив его на `40`.

## <a name="clarify-your-code-intent-by-using-assert"></a>Уточните намерение кода с помощью assert

Нажмите кнопку **Перезапустить** ![Перезапустить приложение](../debugger/media/dbg-tour-restart.png "RestartApp") на панели инструментов отладки (**CTRL** + **SHIFT** + **F5**). Это перезапускает приложение в меньшем количестве шагов. В окне консоли можно увидеть следующий выход.

![Нулевая стоимость в выходе](../debugger/media/write-better-code-using-assert-null-output.png)

Вы можете увидеть что-то в этом выходе, что не совсем правильно. **имя** и **фамилия** для третьей записи пусты!

Это хорошее время, чтобы поговорить о полезной практике кодирования, `assert` часто недостаточно используется, которая заключается в использовании инструкций в ваших функциях. Добавляя следующий код, вы включаете проверку `firstname` `lastname` времени `null`выполнения, чтобы убедиться, что это и не являются. Замените следующий `UpdateRecords` код в методе:

```csharp
if (existingUser == false)
{
    User user = new User();
    user.firstname = users[i].firstname;
    user.lastname = users[i].lastname;
```

следующим кодом:

```csharp
// Also, add a using statement for System.Diagnostics at the start of the file.
Debug.Assert(users[i].firstname != null);
Debug.Assert(users[i].lastname != null);
if (existingUser == false)
{
    User user = new User();
    user.firstname = users[i].firstname;
    user.lastname = users[i].lastname;
```

Добавляя `assert` такие операторы в свои функции в процессе разработки, можно помочь указать цель кода. В предыдущем примере мы указывать следующее:

* Действительная строка требуется для имени
* Действительная строка требуется для фамилии

Указывая намерение таким образом, вы обеспечиваете соблюдение ваших требований. Это простой и удобный метод, который можно использовать для поверхности ошибок во время разработки. (заявления`assert` также используются в качестве основного элемента в модульных тестах.)

Нажмите кнопку **Перезапустить** ![Перезапустить приложение](../debugger/media/dbg-tour-restart.png "RestartApp") на панели инструментов отладки (**CTRL** + **SHIFT** + **F5**).

> [!NOTE]
> Код `assert` активен только в сборке Debug.

При перезагрузке отладчик `assert` приостанавливает работу оператора, так `users[i].firstname != null` как `false` выражение `true`оценивается вместо .

![Утверждение решает ложные](../debugger/media/write-better-code-using-assert.png)

Ошибка `assert` говорит вам, что есть проблема, которую необходимо исследовать. `assert`может охватывать множество сценариев, где не обязательно видеть исключение. В этом примере пользователь не увидит исключение, `null` и значение `firstname` добавляется как в список записей. Это может вызвать проблемы в дальнейшем (например, вы видите на выходе консоли) и может быть труднее отладить.

> [!NOTE]
> В сценариях, где вы `null` называете `NullReferenceException` метод на значение, результаты. Обычно требуется избежать использования `try/catch` блока для общего исключения, т.е. исключения, не привязанного к конкретной функции библиотеки. Любой объект `NullReferenceException`может бросить . Проверьте документацию для функции библиотеки, если вы не уверены.

Во время процесса отладки хорошо хранить `assert` конкретное утверждение до тех пор, пока вы не узнаете, что необходимо заменить его фактическим исправлением кода. Допустим, вы решили, что пользователь может столкнуться с исключением в сборке приложения. В этом случае необходимо рефакторинг кода, чтобы убедиться, что ваше приложение не выбрасывает фатальное исключение или приводит к какой-либо другой ошибке. Итак, чтобы исправить этот код, замените следующий код:

```csharp
if (existingUser == false)
{
    User user = new User();
```

следующим:

```csharp
if (existingUser == false && users[i].firstname != null && users[i].lastname != null)
{
    User user = new User();
```

Используя этот код, вы выполняете требования к коду `firstname` `lastname` и `null` убедитесь, что запись с или значение не добавляется к данным.

В этом примере мы `assert` добавили два утверждения внутри цикла. Как правило, `assert`при использовании, `assert` лучше добавить операторы в точке входа (начало) функции или метода. В настоящее время `UpdateRecords` вы изучаете метод в примере приложения. В этом методе, вы знаете, что вы находитесь в беде, если любой из аргументов `null`метода, так что проверить их обоих с заявлением `assert` в точке входа функции.

```csharp
public static void UpdateRecords(List<User> db, User[] users)
{
    Debug.Assert(db != null);
    Debug.Assert(users != null);
```

Для предыдущих инструкций, ваше намерение состоит`db`в том, что`users`вы загружаете существующие данные () и извлекаете новые данные () перед обновлением чего-либо.

Вы можете `assert` использовать с любым видом `true` `false`выражения, которое решает или . Так, например, вы `assert` можете добавить заявление, как это.

```csharp
Debug.Assert(users[0].points > 0);
```

Предыдущий код полезен, если вы хотите указать следующее намерение: для обновления записи пользователя требуется новое значение точки, превышающее значение нуля (0).

## <a name="inspect-your-code-in-the-debugger"></a>Проверка кода в отладчике

Хорошо, теперь, когда вы исправили все критические, что не так с образцом приложения, вы можете перейти на другие важные вещи!

Мы показали вам помощника по исключению отладчика, но отладчик является гораздо более мощным инструментом, который также позволяет делать другие вещи, как шаг через ваш код и проверить его переменные. Эти более мощные возможности полезны во многих сценариях, особенно следующие:

* Вы пытаетесь изолировать ошибку во времени выполнения в коде, но не можете сделать это с помощью методов и инструментов, которые обсуждались ранее.

* Вы хотите проверить свой код, то есть, смотреть его в то время как он работает, чтобы убедиться, что он ведет себя так, как вы ожидаете, и делать то, что вы хотите его.

    Это поучительно, чтобы посмотреть ваш код во время его запуска. Вы можете узнать больше о вашем коде таким образом и часто можете определить ошибки, прежде чем они проявляются какие-либо очевидные симптомы.

Чтобы узнать, как использовать основные функции отладчика, [см.](../debugger/debugging-absolute-beginners.md)

## <a name="fix-performance-issues"></a>Исправление проблем производительности

Ошибки другого рода включают неэффективный код, который заставляет приложение работать медленно или использовать слишком много памяти. Как правило, оптимизация производительности — это то, что вы делаете позже в разработке приложения. Тем не менее, вы можете столкнуться с проблемами производительности на ранней стадии (например, вы видите, что какая-то часть приложения работает медленно), и вам может потребоваться проверить ваше приложение с помощью инструментов профилирования на ранней стадии. Для получения дополнительной информации о инструментах профилирования, таких как инструмент использования процессора и анализатор памяти, [см.](../profiling/profiling-feature-tour.md)

## <a name="next-steps"></a>Дальнейшие действия

В этой статье вы узнали, как избежать и исправить многие распространенные ошибки в коде и когда использовать отладчик. Далее, узнайте больше об использовании Visual Studio отладчик для исправления ошибок.

> [!div class="nextstepaction"]
> [Отладка для начинающих](../debugger/debugging-absolute-beginners.md)
