---
title: Настройка окна свойств
ms.date: 11/04/2016
ms.topic: conceptual
helpviewer_keywords:
- Domain-Specific Language, Properties window
author: gewarren
ms.author: gewarren
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 613f8828cf7e966fb66468588c73e1a8b9dbdd3d
ms.sourcegitcommit: 47eeeeadd84c879636e9d48747b615de69384356
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "63414740"
---
# <a name="customizing-the-properties-window"></a>Настройка окна свойств
Можно настроить внешний вид и поведение окна свойств в доменный язык (DSL) в Visual Studio. В определении DSL определить свойства домена для каждого класса домена. По умолчанию при выборе экземпляра класса на схеме или в обозревателе моделей, каждое свойство домена отображается в окне «Свойства». Это позволяет просмотреть и изменить значения свойств домена, даже если они не были сопоставлены с полями фигуры на схеме.

## <a name="names-descriptions-and-categories"></a>Имена, описания и категории
 **Имя и отображаемое имя**. В определении свойства домена отображаемое имя свойства является имя, которое отображается во время выполнения в окне «Свойства». В отличие от этого имя используется при написании программного кода для обновления свойства. Имя должно быть правильно буквенно-цифровое имя среды CLR, но отображаемое имя может содержать пробелы.

 Если имя свойства задаются в определении DSL, его отображаемое имя автоматически присваивается имя копии. Если имя блока языка Pascal, например «FuelGauge», отображаемое имя автоматически будет содержать пробел: «Топливный датчик». Тем не менее можно явно задать отображаемое имя с другим значением.

 **Описание**. Описание свойства домена, которое будет отображаться в двух местах:

- В нижней части окна свойств, когда пользователь выбирает свойство. Его можно использовать, чтобы отобразить для пользователя свойство представляет.

- В коде сгенерированную программу. Если вы используете средства документации для извлечения документации по API, он будет отображаться как описание этого свойства в API.

  **Категория**. Категория — заголовок окна "Свойства".

## <a name="exposing-style-features"></a>Предоставление доступа к функции стиля
 Некоторые средства динамического графических элементов могут быть представлены или *предоставляются* как свойства домена. Это функция, которая предоставила таким образом можно обновить пользователем и могут более легко обновляться через программный код.

 Щелкните правой кнопкой мыши фигуру класса в определении DSL, выберите пункт **добавить предоставленный**, а затем выберите компонент.

 На фигурах может предоставлять **FillColor**, **OutlineColor**, **TextColor**, **OutlineDashStyle**,  **OutlineThickness** и **FillGradientMode** свойства. Для соединителей можно предоставить **цвет**`,`**TextColor**, **DashStyle**, и **толщину** свойства. На диаграммах можно предоставить **FillColor** и **TextColor** свойства.

## <a name="forwarding-displaying-properties-of-related-elements"></a>Перенаправление: Отображение свойств связанных элементов
 При пользователь вашего DSL выбирает элемент в модели, в окне «Свойства» отображаются свойства этого элемента. Тем не менее можно также отобразить свойства заданного связанных элементов. Это полезно, если вы определили группу элементов, совместную работу. Например можно определить главный элемент и необязательный элемент подключаемого модуля. Если основной элемент сопоставлен с фигурой, а другой — нет, полезно просмотреть все их свойства, как если бы они находились в один элемент.

 Этот эффект называется *свойство переадресации*, и это происходит автоматически в нескольких случаях. В других случаях можно добиться свойство пересылки, определяя дескриптор типа домена.

### <a name="default-property-forwarding-cases"></a>По умолчанию свойство переадресации случаях
 Когда пользователь выбирает фигуру или соединитель или элемент в обозревателе, в окне «Свойства» отображаются следующие свойства:

- Свойства домена, которые определены в классе домена элемента модели, включая те, которые определены в базовых классах. Исключение составляют свойства домена, для которых вы задали **возможность просмотра** для `False`.

- Имена элементов, которые связаны с помощью связей с кратностью 0.. 1. Это обеспечивает, что удобно при необходимости просмотра связанных элементов, даже если вы не определили сопоставление соединителя для связи.

- Свойства домена, целевым объектом отношения внедрения. Поскольку отношения внедрения обычно не отображаются явным образом, это позволяет пользователю видеть их свойства.

- Свойства домена, определенные для выбранной фигуры или соединителя.

### <a name="adding-property-forwarding"></a>Добавление свойства переадресации
 Для переадресации свойство, нужно определить дескриптор типа домена. При наличии доменной связи между двумя доменными классами, дескриптор типа домена можно использовать для задания свойства домена первого класса, чтобы значение свойства домена второго класса домена. Например, если у вас есть отношение между **книги** доменного класса и **автор** доменного класса можно использовать дескриптор типа домена, чтобы сделать **имя** свойство Книги **автор** отображаются в окне «Свойства», когда пользователь выбирает книги.

> [!NOTE]
> Свойство переадресации влияет на окне свойств, когда пользователь редактирует модель. Он не определяет свойство домена на принимающего класса. Если вы хотите получить доступ к свойству перенаправленных домена в других частях определения DSL или в программном коде, необходимо получить доступ к элемент переадресации.

 В следующей процедуре предполагается, что вы создали DSL. Первые несколько шаги приведены предварительные требования.

##### <a name="to-forward-a-property-from-another-element"></a>Для пересылки свойство из другого элемента

1. Создание [!INCLUDE[dsl](../modeling/includes/dsl_md.md)] решение, которое содержит по крайней мере два класса, которые в этом примере вызываются **книги** и **автор**. Должна существовать связь любого рода между **книги** и **автор**.

    Кратность роли источника (роли **книги** стороны) должно быть от 0 до 1 или 1.. "1", чтобы каждая **книги** имеет один **автор**.

2. В **обозреватель DSL**, щелкните правой кнопкой мыши **книги** доменного класса, а затем щелкните **добавить новый DomainTypeDescriptor**.

    Узел с именем **пути из пользовательских дескрипторов свойств** подчеркивается **дескрипторе настраиваемого типа** узла.

3. Щелкните правой кнопкой мыши **дескрипторе настраиваемого типа** узел, а затем щелкните **добавить новый PropertyPath**.

    Новый путь к свойству подчеркивается **пути из пользовательских дескрипторов свойств** узла.

4. Выберите новый путь к свойству и в **свойства** окне **путь к свойству** путь к соответствующей модели элемента.

    Щелкните стрелку вниз справа от этого свойства можно изменить путь в виде дерева. Дополнительные сведения о пути к доменам, см. в разделе [синтаксис пути домена](../modeling/domain-path-syntax.md). При редактировании его путь должен выглядеть **BookReferencesAuthor.Author/! Автор**.

5. Задайте **свойство** для **имя** свойство домена **автор**.

6. Задайте **отображаемое имя** для **создавать имя**.

7. Преобразовать все шаблоны, постройте и запустите DSL.

8. В схеме модели создайте книгу, автор и связать их с помощью ссылочное отношение. Выберите элемент книги, и в окне свойств вы увидите имя автора наряду со свойствами книги. Измените имя связанного автора или связать книги с другим именем и обратите внимание, что изменяется имя автора книги.

## <a name="custom-property-editors"></a>Пользовательских редакторов свойств
 В окне свойств предоставляет используемого по умолчанию, использование редакторов для типа каждого свойства домена. Например для перечисляемого типа, пользователь видит стрелку раскрывающегося списка и числовые свойства, пользователь может ввести цифр. Это верно только для встроенных типов. Если указать внешний тип, пользователь будет иметь возможность см. в разделе значений свойства, но не изменить его.

 Тем не менее можно указать следующие типы и редакторы:

1. Другой редактор, который используется с помощью стандартного типа. Например можно указать редактор пути файлов для строкового свойства.

2. Внешний тип для свойства домена и редактор для него.

3. Редактор .NET, такие как редактор пути файла, или можно создать пользовательское свойство редактор.

    Преобразование между внешнего типа и типа, например строку, которая содержит редактор по умолчанию.

   В DSL *внешний тип* — это любой тип, который не является одним из простых типов (например, логическое значение или Int32) или строка.

#### <a name="to-define-a-domain-property-that-has-an-external-type"></a>Для определения свойства домена, который имеет внешний тип

1. В **обозревателе решений**, добавьте ссылку на сборку (DLL), содержащий внешний тип, в **Dsl** проекта.

    Сборка может быть сборкой .NET или сборки, указанные вами.

2. Добавьте тип в **типов домена** список, если вы не сделали.

   1. Откройте файл DslDefinition.dsl, а затем в **обозреватель DSL**, щелкните правой кнопкой мыши корневой узел и нажмите кнопку **добавить новый внешний тип**.

        Появится новый элемент под **типов домена** узла.

       > [!WARNING]
       > Элемент меню не в корневом узле DSL, **типов домена** узла.

   2. В окне свойств задайте имя и пространство имен нового типа.

3. Добавьте свойство домена класса домена в обычном режиме.

    В окне «Свойства» выберите внешний тип в раскрывающемся списке в **типа** поля.

   На этом этапе пользователи могут просматривать значения свойства, но они не могут изменять ее. Отображаемые значения извлекаются из `ToString()` функции. Можно написать программный код, который задает значение свойства, например в команде или правило.

### <a name="setting-a-property-editor"></a>Настройка редактора свойств
 Добавьте атрибут CLR для свойства домена, в следующей форме:

```csharp
[System.ComponentModel.Editor (
   typeof(AnEditor),
   typeof(System.Drawing.Design.UITypeEditor))]
```

 Атрибут можно задать для свойства с помощью **пользовательский атрибут** запись в окне «Свойства».

 Тип `AnEditor` должен быть производным от типа, указанного в качестве второго параметра. Второй параметр должен быть либо <xref:System.Drawing.Design.UITypeEditor> или <xref:System.ComponentModel.ComponentEditor>. Дополнительные сведения см. в разделе <xref:System.ComponentModel.EditorAttribute>.

 Можно указать собственный редактор или редактор, указанное в [!INCLUDE[dnprdnshort](../code-quality/includes/dnprdnshort_md.md)], такие как <xref:System.Windows.Forms.Design.FileNameEditor> или <xref:System.Drawing.Design.ImageEditor>. Например используйте следующую процедуру, должен иметь свойство, в котором пользователь может ввести имя файла.

##### <a name="to-define-a-file-name-domain-property"></a>Для определения свойства домена имя файла

1. Добавьте свойство домена доменного класса в определении DSL.

2. Выберите новое свойство. В **пользовательский атрибут** поле в окне «Свойства», введите следующий атрибут. Чтобы ввести этот атрибут, щелкните кнопку с многоточием **[...]**  и введите имя атрибута, а также параметры отдельно:

    ```csharp
    [System.ComponentModel.Editor (
       typeof(System.Windows.Forms.Design.FileNameEditor)
       , typeof(System.Drawing.Design.UITypeEditor))]

    ```

3. Оставьте значения по умолчанию тип свойства домена **строка**.

4. Чтобы проверить редактора, убедитесь, что пользователи могут открывать редактор имя файла для редактирования свойства домена.

    1. Нажмите клавиши CTRL + F5 или F5. В решение для отладки откройте файл теста. Создание элемента доменного класса и выберите его.

    2. В окне «Свойства» выберите свойство домена. В нем значение отображается многоточие **[...]** .

    3. Нажмите кнопку с многоточием. Появится диалоговое окно файла. Выберите файл и закрыть диалоговое окно. Путь к файлу теперь является значение свойства домена.

### <a name="defining-your-own-property-editor"></a>Определение собственный редактор свойств
 Вы можете определить собственный редактор. Этого разрешения пользователю, либо для изменения типа, который вы определили, либо для изменения стандартного типа особым образом. Например можно разрешить пользователю ввести строку, представляющую формулы.

 Определение редактора, написав класс, производный от <xref:System.Drawing.Design.UITypeEditor>. Ваш класс должен переопределять:

- <xref:System.Drawing.Design.UITypeEditor.EditValue%2A>, для взаимодействия с пользователем и обновите значение свойства.

- <xref:System.Drawing.Design.UITypeEditor.GetEditStyle%2A>, чтобы указать, редактора откройте диалоговое окно, или предоставить раскрывающегося меню.

  Вы также можете предоставить графическое представление значения свойства, которое будет отображаться в сетке свойств. Чтобы сделать это, переопределите `GetPaintValueSupported`, и `PaintValue`.  Дополнительные сведения см. в разделе <xref:System.Drawing.Design.UITypeEditor>.

> [!NOTE]
> Добавьте код в отдельном файле кода в **Dsl** проекта.

 Пример:

```csharp
internal class TextFileNameEditor : System.Windows.Forms.Design.FileNameEditor
{
  protected override void InitializeDialog(System.Windows.Forms.OpenFileDialog openFileDialog)
  {
    base.InitializeDialog(openFileDialog);
    openFileDialog.Filter = "Text files(*.txt)|*.txt|All files (*.*)|*.*";
    openFileDialog.Title = "Select a text file";
  }
}
```

 Чтобы использовать этот редактор, задайте **пользовательский атрибут** свойства домена:

```csharp
[System.ComponentModel.Editor (
   typeof(MyNamespace.TextFileNameEditor)
   , typeof(System.Drawing.Design.UITypeEditor))]
```

 Дополнительные сведения см. в разделе <xref:System.Drawing.Design.UITypeEditor>.

## <a name="providing-a-drop-down-list-of-values"></a>Предоставление раскрывающегося списка значений
 Можно предоставить список значений для пользователя на выбор.

> [!NOTE]
> Этот метод предоставляет список значений, которые могут изменяться во время выполнения. Если вы хотите предоставить список, который остается неизменным, вместо этого рекомендуется с помощью перечисляемый тип как тип свойства домена.

 Чтобы определить список стандартных значений, необходимо добавить свойство домена атрибут CLR, который имеет следующий вид:

```csharp
[System.ComponentModel.TypeConverter
(typeof(MyTypeConverter))]
```

 Определите класс, производный от класса <xref:System.ComponentModel.TypeConverter>. Добавьте код в отдельном файле в **Dsl** проекта. Пример:

```csharp
/// <summary>
/// Type converter that provides a list of values
/// to be displayed in the property grid.
/// </summary>
/// <remarks>This type converter returns a list
/// of the names of all "ExampleElements" in the
/// current store.</remarks>
public class MyTypeConverter : System.ComponentModel.TypeConverter
{
  /// <summary>
  /// Return true to indicate that we return a list of values to choose from
  /// </summary>
  /// <param name="context"></param>
  public override bool GetStandardValuesSupported
    (System.ComponentModel.ITypeDescriptorContext context)
  {
    return true;
  }

  /// <summary>
  /// Returns true to indicate that the user has
  /// to select a value from the list
  /// </summary>
  /// <param name="context"></param>
  /// <returns>If we returned false, the user would
  /// be able to either select a value from
  /// the list or type in a value that is not in the list.</returns>
  public override bool GetStandardValuesExclusive
      (System.ComponentModel.ITypeDescriptorContext context)
  {
    return true;
  }

  /// <summary>
  /// Return a list of the values to display in the grid
  /// </summary>
  /// <param name="context"></param>
  /// <returns>A list of values the user can choose from</returns>
  public override StandardValuesCollection GetStandardValues
      (System.ComponentModel.ITypeDescriptorContext context)
  {
    // Try to get a store from the current context
    // "context.Instance"  returns the element(s) that
    // are currently selected i.e. whose values are being
    // shown in the property grid.
    // Note that the user could have selected multiple objects,
    // in which case context.Instance will be an array.
    Store store = GetStore(context.Instance);

    List<string> values = new List<string>();

    if (store != null)
    {
      values.AddRange(store.ElementDirectory
        .FindElements<ExampleElement>()
        .Select<ExampleElement, string>(e =>
      {
        return e.Name;
      }));
    }
    return new StandardValuesCollection(values);
  }

  /// <summary>
  /// Attempts to get to a store from the currently selected object(s)
  /// in the property grid.
  /// </summary>
  private Store GetStore(object gridSelection)
  {
    // We assume that "instance" will either be a single model element, or
    // an array of model elements (if multiple items are selected).

    ModelElement currentElement = null;

    object[] objects = gridSelection as object[];
    if (objects != null && objects.Length > 0)
    {
      currentElement = objects[0] as ModelElement;
    }
    else
    {
        currentElement = gridSelection as ModelElement;
    }

    return (currentElement == null) ? null : currentElement.Store;
  }

}
```

## <a name="see-also"></a>См. также

- [Перемещение по модели и обновление модели в коде программы](../modeling/navigating-and-updating-a-model-in-program-code.md)