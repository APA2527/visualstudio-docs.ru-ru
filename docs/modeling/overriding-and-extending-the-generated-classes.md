---
title: Переопределение и расширение созданных классов
ms.date: 11/04/2016
ms.topic: conceptual
helpviewer_keywords:
- Domain-Specific Language, providing overridable classes
author: gewarren
ms.author: gewarren
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 9aa4f39fb54617ae1dbf048a1e13f009c8df5185
ms.sourcegitcommit: 94b3a052fb1229c7e7f8804b09c1d403385c7630
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62814241"
---
# <a name="override-and-extend-the-generated-classes"></a>Переопределение и расширение созданных классов

Определение DSL — это платформа, на которой можно создавать мощный набор средств, которые основаны на доменном языке. Многие расширения и адаптации можно выполнить, переопределение и расширение классов, которые создаются из определения DSL. Эти классы включают не только доменных классов, явно определенных в схеме определения DSL, но другие классы, которые определяют область элементов, обозреватель, сериализации и т. д.

## <a name="extensibility-mechanisms"></a>Механизмы расширяемости

Несколько механизмов, позволяющих позволяют расширить созданный код.

### <a name="override-methods-in-a-partial-class"></a>Переопределите методы в разделяемом классе

Определения разделяемого класса разрешать классам быть определен в нескольких местах. Это дает возможность разделения автоматически созданного кода код, который вы напишете самостоятельно. В коде, созданных вручную вы можете переопределить классов, унаследованных созданный код.

Например, если в определении DSL определяет доменный класс с именем `Book`, можно написать пользовательский код, который добавляет методы переопределения:

```csharp
public partial class Book
{
   protected override void OnDeleting()
   {
      MessageBox.Show("Deleting book " + this.Title);
      base.OnDeleting();
   }
}
```

> [!NOTE]
> Для переопределения методов в созданном классе, следует всегда писать код в файле, который отделен от созданных файлов. Как правило файл хранится в папке с именем значение CustomCode. При внесении изменений в созданный код, они будут потеряны при повторном создании кода из определения DSL.

Чтобы узнать, какие методы можно переопределить, введите **переопределить** в классе, разделенных пробелами. Подсказка IntelliSense поможет определить, какие методы можно переопределить.

### <a name="double-derived-classes"></a>Классы, производные от Double

Большинство методов в созданных классах наследуются из фиксированного набора классов в пространствах имен моделирования. Тем не менее некоторые методы определяются в созданном коде. Как правило это означает, что нельзя переопределить. в один разделяемый класс не может переопределить методы, которые определены в другом частичном определении того же класса.

Тем не менее, эти методы можно переопределить, задав **создает двойную производную** флаг для доменного класса. Это вызывает два создавать классы, были абстрактного базового класса из других. Все определения методов и свойств, в базовом классе, и только конструктор находится в производном классе.

Например, в образце Library.dsl `CirculationBook` имеет доменный класс `Generates``Double Derived` свойство значение `true`. Созданный код для этого класса домена содержит два класса:

- `CirculationBookBase`, который является абстрактным, и который содержит все методы и свойства.

- `CirculationBook`, который является производным от `CirculationBookBase`. Он пуст, за исключением конструкторов.

Чтобы переопределить любой метод, создайте частичное определение производного класса например `CirculationBook`. Вы можете переопределить созданные методы и методы, унаследованные от платформа моделирования.

Этот метод можно использовать со всеми типами элемента, включая элементы модели, отношения, фигуры, схемы и соединители. Также можно переопределить методы другими классами. Некоторые созданные классы, такие как ToolboxHelper, всегда двойным наследованием.

### <a name="custom-constructors"></a>Пользовательские конструкторы

Конструктор не может переопределить. Даже в двойным наследованием классов конструктор не должен иметь в производном классе.

Если вы хотите предоставить собственный конструктор, это можно сделать, задав `Has Custom Constructor` для доменного класса в определении DSL. При нажатии кнопки **преобразовать все шаблоны**, созданный код не будет содержать конструктор для этого класса. Сюда входят вызов конструктора отсутствует. Отчет об ошибке в результате при построении решения. Дважды щелкните отчет об ошибках, чтобы увидеть комментарий в созданный код, чтобы понять, которую следует предоставить.

Записи определение разделяемого класса в файл, который отделен от созданных файлов и обеспечение конструктора.

### <a name="flagged-extension-points"></a>Помеченные точки расширения

Точки расширения, помеченные — это место, в определении DSL, где можно задать свойства или типа "флажок" для указания, что предоставите пользовательский метод. Пользовательские конструкторы являются одним из примеров. Другие примеры включают параметр `Kind` свойства домена Calculated или пользовательские хранилища или параметр **является настраиваемым** флаг в построитель подключений.

В каждом из случаев когда задан флаг и повторно создать код, приведет к ошибке построения. Дважды щелкните ошибку в комментарий, поясняющий, что вы должны предоставить см. в разделе.

### <a name="rules"></a>Правила

Диспетчер транзакций позволяет определить правил, которые выполняются до окончания транзакции, в котором указанного события, такого как изменение свойства. Правила обычно используются для поддержания synchronism между различными элементами в хранилище. Например чтобы убедиться в том, что в диаграмме отображается текущее состояние модели используются правила.

Правила определяются на основе каждого класса, таким образом, чтобы у вас нет кода, который регистрирует правила для каждого объекта. Дополнительные сведения см. в разделе [распространение изменений в модели правил](../modeling/rules-propagate-changes-within-the-model.md).

### <a name="store-events"></a>События Store

Хранилище моделирования предоставляет механизм событий, которые можно использовать для прослушивания изменений в хранилище, включая добавление и удаление элементов, изменения значений свойств, определенных типов и т. д. Обработчики событий вызываются после закрытия транзакции, в котором были внесены изменения. Как правило эти события используются для обновления ресурсов за пределами хранилища.

### <a name="net-events"></a>События .NET

Можно подписаться на события на фигурах. Например можно прослушивать щелчков мыши на фигуре. Вам нужно написать код, который подписывается на событие для каждого объекта. Этот код могут быть написаны на переопределение InitializeInstanceResources().

Некоторые события создаются на которым ShapeFields, используемый для рисования декораторов для фигуры. Пример см. в статье [Практическое руководство. Перехват щелчка фигуры или декоратора](../modeling/how-to-intercept-a-click-on-a-shape-or-decorator.md).

Обычно эти события не происходят внутри транзакции. Следует создать транзакцию, если вы хотите внести изменения в хранилище.