---
title: Соглашения об именовании в .NET для файлов EditorConfig
ms.date: 11/20/2017
ms.topic: reference
helpviewer_keywords:
- naming conventions [EditorConfig]
- EditorConfig naming conventions
author: gewarren
ms.author: gewarren
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 68840957a0c152add06804eac58f3d24afa1e846
ms.sourcegitcommit: 117ece52507e86c957a5fd4f28d48a0057e1f581
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/28/2019
ms.locfileid: "66261966"
---
# <a name="net-naming-conventions-for-editorconfig"></a>Соглашения об именовании в среде .NET для EditorConfig

Соглашения об именовании связаны с названиями элементов кода, таких как классы, методы и свойства. Например, вы можете указать, что открытые члены должны начинаться с прописной буквы, а асинхронные методы заканчиваться на Async. Вы можете принудительно применить эти правила, указав их в [файле с расширением ".editorconfig"](../ide/create-portable-custom-editor-options.md). Нарушения правил именования отображаются в **списке ошибок** или в виде предложений под именем в зависимости от назначенной серьезности правила. Чтобы увидеть нарушения, сборка проекта не требуется.

Соглашения об именовании следует упорядочить от наиболее конкретных к наименее конкретным в файле EditorConfig. Применяться будет только первое обнаруженное правило. Но при наличии множества *свойств* правил с одним и тем же именем приоритет будет иметь последнее обнаруженное свойство с таким именем. См. подробнее об [иерархии файлов и приоритетности](create-portable-custom-editor-options.md#file-hierarchy-and-precedence).

Для каждого соглашения об именовании нужно указать рассматриваемые им символы, стиль именования и степень серьезности правила с помощью описанных ниже свойств. Порядок свойств не имеет значения.

Сначала выберите название правила именования, которое будет использоваться в каждом из свойств, необходимых для полного описания правила. Пример хорошего описательного имени для правила именования: `public_members_must_be_capitalized`. Подставляйте выбранное вами имя вместо **<namingRuleTitle\>** в следующих разделах.

## <a name="symbols"></a>Символы

Сначала определите группу символов, к которой будет применяться правило именования. Это свойство должно иметь следующий формат:

`dotnet_naming_rule.<namingRuleTitle>.symbols = <symbolTitle>`

Дайте имя группе символов, заменив значение **<symbolTitle\>** описательным названием, например `public_symbols`. Значение **<symbolTitle\>** будет использоваться в именах трех свойств, описывающих, к каким символам применяется правило (типы символов, уровни доступа и модификаторы).

### <a name="kinds-of-symbols"></a>Типы символов

Чтобы описать тип символов, к которому применяется правило именования, укажите свойство в следующем формате:

`dotnet_naming_symbols.<symbolTitle>.applicable_kinds = <values>`

Допустимые значения представлены в списке ниже. Вы можете указать несколько значений через запятую.

- \* (используйте это значение, чтобы указать все символы)
- namespace
- класс
- структура
- интерфейс
- перечисление
- свойство;
- метод
- поле
- событие
- делегат
- параметр
- type_parameter
- локальные
- local_function

### <a name="accessibility-levels-of-symbols"></a>Уровни доступа для символов

Чтобы задать уровни доступа для символов, к которым будет применяться правило именования, укажите имя свойства в следующем формате:

`dotnet_naming_symbols.<symbolTitle>.applicable_accessibilities = <values>`

Допустимые значения представлены в списке ниже. Вы можете указать несколько значений через запятую.

- \* (используйте это значение, чтобы указать все уровни доступа)
- public
- internal или friend
- private
- protected
- protected\_internal или protected_friend
- private\_protected
- локальные

   Уровень специальных возможностей `local` применяется к символам, определенным в методе. Это полезно при определении соглашений об именовании для символов, специальные возможности которых не могут быть указаны в коде. Например, если вы укажете `applicable_accessibilities = local` в соглашении об именовании констант (`required_modifiers = const`), правило будет применятся только к константам, определенным в методе, а не к константам, определенным в типе.

   ```csharp
   class TypeName
   {
     // Constant defined in a type.
     const int X = 3;

     void Method()
     {
       // Constant defined in a method with "local" accessibility.
       const int Y = 4;
     }
   }
   ```

### <a name="symbol-modifiers-optional"></a>Модификаторы символов (необязательно)

Чтобы задать модификаторы символов, к которым будет применяться правило именования, укажите имя свойства в следующем формате:

`dotnet_naming_symbols.<symbolTitle>.required_modifiers = <values>`

Допустимые значения представлены в списке ниже (можно указать несколько значений через запятую).

- `abstract` или `must_inherit`
- `async`
- `const`
- `readonly`
- `static` или `shared`

   > [!NOTE]
   > Если у вас есть правило именования для символов `static` или `shared`, то оно также применяется к символам `const`, так как они косвенно являются статическими. Если вы не хотите, чтобы правило именования `static` применялось к символам `const`, создайте отдельное правило именования для символов `const`.

Правило именования будет соответствовать только сигнатурам, которые содержат *все* модификаторы, указанные в `required_modifiers`. Если опустить это свойство, используется значение по умолчанию пустого списка, то есть для сопоставления не требуются особые модификаторы. Это означает, что модификаторы символов не оказывают влияния на применение этого правила.

> [!TIP]
> Не указывайте значение `*` для `required_modifiers`. Вместо этого вовсе не указывайте свойство `required_modifiers` и правило именования будет применяться к любого рода модификаторам.

## <a name="style"></a>Стиль

Теперь, когда мы определили группу символов, к которым будет применяться правило именования, необходимо описать стиль именования. Стиль может предписывать использование в имени определенного префикса или суффикса или, например, разделение слов каким-то символом. Вы можете также указать стиль для регистра букв. Свойство стиля имеет следующий формат:

`dotnet_naming_rule.<namingRuleTitle>.style = <styleTitle>`

Задайте имя стиля, заменив значение **<styleTitle\>** описательным названием, например `first_word_upper_case_style`. Значение **<styleTitle\>** будет использоваться в именах свойств, которые описывают стиль именования (префикс, суффикс, символ разделения слов и регистр букв). Используйте любые из этих свойств, чтобы описать стиль, который вам нужен.

### <a name="require-a-prefix"></a>Требование префикса

Чтобы указать, что имена должны начинаться с определенных символов, используйте это свойство:

`dotnet_naming_style.<styleTitle>.required_prefix = <prefix>`

### <a name="require-a-suffix"></a>Требование суффикса

Чтобы указать, что имена должны заканчиваться определенными символами, используйте это свойство:

`dotnet_naming_style.<styleTitle>.required_suffix = <suffix>`

### <a name="require-a-certain-word-separator"></a>Требование определенного разделителя слов

Чтобы указать, что отдельные слова в именах должны разделяться определенным символом, используйте это свойство:

`dotnet_naming_style.<styleTitle>.word_separator = <separator character>`

### <a name="require-a-capitalization-style"></a>Требование стиля регистра букв

Чтобы указать определенный стиль регистра букв для имен, используйте это свойство:

`dotnet_naming_style.<styleTitle>.capitalization = <value>`

Допустимые значения для этого свойства:

- pascal_case
- camel_case
- first\_word_upper
- all\_upper
- all_lower

> [!NOTE]
> Указать регистр букв для стиля именования обязательно, в противном случае ваш стиль может игнорироваться.

## <a name="severity"></a>Серьезность

Чтобы задать серьезность нарушения правила именования, укажите свойство в следующем формате:

`dotnet_naming_rule.<namingRuleTitle>.severity = <value>`

В следующей таблице показаны допустимые значения серьезности и что они означают:

Серьезность | Действие
------------ | -------------
none или silent | Если стиль не соблюдается, пользователь не будет уведомляться об этом, однако автоматически создаваемый код следует этому стилю.
suggestion | Если этот стиль не соблюдается, он будет показан пользователю как предложение, в виде точек под первыми двумя символами. Это никак не проявляется во время компиляции.
warning | Если этот стиль не соблюдается, выводится предупреждение компилятора в **списке ошибок**.
error | Если этот стиль не соблюдается, компилятор выводит ошибку в **списке ошибок**.

> [!NOTE]
> Чтобы увидеть нарушения правил именования, сборка проекта не требуется. Они появляются при редактировании кода в **списке ошибок** или в виде предложения.

## <a name="example"></a>Пример

Ниже представлен файл *EDITORCONFIG* с соглашением об именовании, в котором указано, что общедоступные свойства, методы, поля, события и делегаты должны начинаться с прописной буквы. Обратите внимание, что это соглашение об именовании указывает несколько типов символов, к которым применяется правило, через запятую.

```ini
# Public members must be capitalized (public_members_must_be_capitalized)
[*.{cs,vb}]
dotnet_naming_rule.public_members_must_be_capitalized.symbols   = public_symbols
dotnet_naming_symbols.public_symbols.applicable_kinds           = property,method,field,event,delegate
dotnet_naming_symbols.public_symbols.applicable_accessibilities = public
dotnet_naming_symbols.public_symbols.required_modifiers         = readonly

dotnet_naming_rule.public_members_must_be_capitalized.style    = first_word_upper_case_style
dotnet_naming_style.first_word_upper_case_style.capitalization = first_word_upper

dotnet_naming_rule.public_members_must_be_capitalized.severity = suggestion
```

На приведенном ниже снимке экрана показано, как это соглашение об именовании отражается в редакторе. Имена двух общедоступных переменных не начинаются с прописной буквы. Тип одной переменной — `const`, другой — `readonly`. Так как правило именования применяется исключительно к символам `readonly`, предложение правила именования выдается только для переменной `readonly`.

![Предложение правила именования](media/editorconfig-naming-rule-suggestion.png)

Теперь изменим серьезность нарушения на `warning`:

```ini
dotnet_naming_rule.public_members_must_be_capitalized.severity = warning
```

Если вы закроете и снова откроете файл с кодом, в нем не будет предложения. Нарушение имени будет подчеркнуто зеленой волнистой линией, а в **списке ошибок** появится предупреждение:

![Предупреждение правила именования](media/editorconfig-naming-rule-warning.png)

## <a name="see-also"></a>См. также

- [Соглашения об именовании для Roslyn](https://github.com/dotnet/roslyn/blob/master/.editorconfig#L63)
- [Соглашения по оформлению и написанию кода на .NET](../ide/editorconfig-code-style-settings-reference.md)
- [Создание переносимых, настраиваемых параметров редактора](../ide/create-portable-custom-editor-options.md)
