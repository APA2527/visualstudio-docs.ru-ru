---
title: Анализаторы Roslyn и кода-библиотека для immutablearrays с | Документация Майкрософт
ms.date: 11/04/2016
ms.topic: conceptual
ms.assetid: 0b0afa22-3fca-4d59-908e-352464c1d903
author: gregvanl
ms.author: gregvanl
manager: jillfra
ms.workload:
- vssdk
ms.openlocfilehash: 28ddaafc8ab4ddbaef1d7e42faedc2229664c6e6
ms.sourcegitcommit: 94b3a052fb1229c7e7f8804b09c1d403385c7630
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62433335"
---
# <a name="roslyn-analyzers-and-code-aware-library-for-immutablearrays"></a>Анализаторы Roslyn и кода-библиотека для immutablearrays с

[.NET Compiler Platform](https://github.com/dotnet/roslyn) («Roslyn») позволяет создавать библиотеки с кодом. С кодом библиотеки не предоставляет функциональные возможности, которые можно использовать и набор инструментов (анализаторов Roslyn), чтобы помочь вам использовать библиотеку в лучшим способом избежать ошибок. В этом разделе показано, как создавать реальные анализатор Roslyn для перехвата распространенных ошибок при использовании [System.Collections.Immutable](https://www.nuget.org/packages/System.Collections.Immutable) пакет NuGet. В примере также как обеспечить исправление кода для решения проблемы кода, обнаруженных анализатором. Пользователи увидят средства исправления кода в Visual Studio лампочки пользовательского интерфейса и автоматически применить исправление кода.

## <a name="get-started"></a>Начало работы

Вам понадобятся следующие сборки этого примера:

* Visual Studio 2015 (не экспресс-выпуск) или более поздней версии. Можно воспользоваться бесплатным [Visual Studio Community Edition](https://visualstudio.microsoft.com/vs/community/)
* [Visual Studio SDK](../extensibility/visual-studio-sdk.md). Можно также, при установке Visual Studio, проверить **средств расширения Visual Studio** под **Общие средства** установить пакет SDK, в то же время. Если вы уже установили Visual Studio, можно также установить этот пакет SDK, выбрав в главном меню **файл** > **New** > **проекта**, Выбор **C#** в левой области навигации, а затем выбирая **расширяемости**. При выборе "**Установка средств расширения Visual Studio**" шаблон проекта навигации, вам будет предложено загрузить и установить пакет SDK.
* [Платформа компилятора .NET («Roslyn») SDK](https://aka.ms/roslynsdktemplates). Вы также можете установить этот пакет SDK, выбрав в главном меню **файл** > **New** > **проекта**, нажимая кнопку **C#** в левой области навигации, а затем выбирая **расширяемости**. При выборе "**скачивание пакета SDK для платформы компилятора .NET**" шаблон проекта навигации, вам будет предложено загрузить и установить пакет SDK. Этот пакет SDK включает в себя [визуализаторе синтаксиса Roslyn](https://github.com/dotnet/roslyn/wiki/Syntax%20Visualizer). Это полезное средство поможет выяснить, какие типы модели кода следует искать в ваш анализатор. Вызовы инфраструктуры анализатора в код для конкретного кода типов моделей, поэтому ваш код выполняется при необходимости и сосредоточиться только на анализ соответствующий код.

## <a name="whats-the-problem"></a>В чем проблема?

Представьте себе предоставление библиотеки с ImmutableArray (например, <xref:System.Collections.Immutable.ImmutableArray%601?displayProperty=fullName>) поддержки. Разработчики на C# имеется значительный опыт с массивами .NET. Тем не менее из-за природы immutablearrays с и оптимизации методы, используемые в реализации, intuitions разработчика C# вызвать пользователей библиотеки для записи неработающий код, как описано ниже. Кроме того пользователи не видят ошибок до времени выполнения, которая имеет небольшой качество работы, в котором они используются в Visual Studio с помощью .NET.

Пользователи знакомы с написания кода следующим образом:

```csharp
var a1 = new int[0];
Console.WriteLine("a1.Length = { 0}", a1.Length);
var a2 = new int[] { 1, 2, 3, 4, 5 };
Console.WriteLine("a2.Length = { 0}", a2.Length);
```

Создание пустых массивов должен заполнить последующих строк кода и с использованием синтаксиса инициализатора коллекции знакомые C# разработчиков. Однако же написание кода для ImmutableArray аварийно завершает работу во время выполнения:

```csharp
var b1 = new ImmutableArray<int>();
Console.WriteLine("b1.Length = { 0}", b1.Length);
var b2 = new ImmutableArray<int> { 1, 2, 3, 4, 5 };
Console.WriteLine("b2.Length = { 0}", b2.Length);
```

Первая ошибка связана с ImmutableArray реализации с помощью структуры программы-оболочки для базового хранилища данных. Структуры должны иметь конструкторы без параметров, чтобы `default(T)` выражения могут возвращать структуры со всеми ноль или значение null, членов. Когда код обращается к `b1.Length`, есть время выполнения разыменования ошибка из-за не базовый массив хранилища в структуре ImmutableArray. Правильным способом для создания пустой ImmutableArray является `ImmutableArray<int>.Empty`.

Происходит ошибка с инициализаторами коллекций, потому что `ImmutableArray.Add` метод возвращает новые экземпляры при каждом ее вызове. Поскольку immutablearrays с никогда не меняются, при добавлении нового элемента, вы получаете обратно объект ImmutableArray (который может предоставлять хранилища из соображений производительности существующих ImmutableArray). Так как `b2` указывает на первый ImmutableArray перед вызовом `Add()` пять раз `b2` ImmutableArray настройки по умолчанию. Вызов длины на нем также аварийных завершений пустая разыменования ошибки. Правильный способ инициализировать ImmutableArray без вручную вызова Add заключается в использовании `ImmutableArray.CreateRange(new int[] {1, 2, 3, 4, 5})`.

## <a name="find-relevant-syntax-node-types-to-trigger-your-analyzer"></a>Найти соответствующий синтаксис типов узлов, чтобы активировать ваш анализатор

 Чтобы приступить к созданию анализатор, сначала понять, какого рода узел синтаксиса, вам нужно искать. Запустите **визуализатор синтаксиса** меню **представление** > **Other Windows** > **визуализаторе синтаксиса Roslyn**.

Поместите курсор редактора в строке, которая объявляет `b1`. Появится визуализатор синтаксиса показан в `LocalDeclarationStatement` узел дерева синтаксиса. Этот узел содержит `VariableDeclaration`, который в свою очередь имеет `VariableDeclarator`, который в свою очередь имеет `EqualsValueClause`и наконец, имеется `ObjectCreationExpression`. Щелкните в дереве визуализатор синтаксиса узлов, синтаксис в окне редактора светлые тона к показан код, представленный данным узлом. Имена типов sub узел синтаксиса совпадают с именами, используемый в грамматике C#.

## <a name="create-the-analyzer-project"></a>Создайте проект анализатора

В главном меню выберите **файл** > **New** > **проекта**. В **новый проект** диалогового окна в разделе **C#** проектов на панели навигации слева, выберите **расширяемости**и в области справа выберите **анализатора с Код исправления** шаблона проекта. Введите имя и диалоговое окно подтверждения.

Шаблон откроется *DiagnosticAnalyzer.cs* файла. Выберите вкладку буфера для этого редактора. Этот файл содержит класс анализатора (сформировано из имени вы присвоили проекта), производный от `DiagnosticAnalyzer` (тип Roslyn API). Новый класс имеет `DiagnosticAnalyzerAttribute` объявление ваш анализатор подходит для языка C#, чтобы компилятор находит и загружает ваш анализатор.

```csharp
[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class ImmutableArrayAnalyzerAnalyzer : DiagnosticAnalyzer
{}
```

Можно реализовать с помощью Visual Basic, который предназначен для кода C#, анализатор и наоборот. Более важно в DiagnosticAnalyzerAttribute выбрать ли ваш анализатор предназначен для одного языка, или оба. Более сложные анализаторы, требующих подробные моделирования языка можно ориентироваться только один язык. Если ваш анализатор, например, только проверяет имена типов или имена открытый член, возможно, можно использовать общие модели языка, предлагаемых Roslyn в Visual Basic и C#. Например, FxCop предупреждает, что класс реализует <xref:System.Runtime.Serialization.ISerializable>, но класс не имеет <xref:System.SerializableAttribute> атрибут независимый от языка и работает для отладки кода Visual Basic и C#.

## <a name="initialize-the-analyzer"></a>Инициализировать анализатор

 Прокрутите вниз содержимое немного `DiagnosticAnalyzer` класс `Initialize` метод. Компилятор вызывает этот метод при активации анализатор. Этот метод принимает `AnalysisContext` объект, который позволяет ваш анализатор для получения сведений о контексте и регистрация обратных вызовов для событий для типов кода, которые необходимо проанализировать.

```csharp
public override void Initialize(AnalysisContext context) {}
```

Открыть новую строку в этот метод и тип «контекст». Чтобы просмотреть список завершения IntelliSense. Вы увидите в списке завершения существует много `Register...` методы для обработки различных типов событий. Например, первый, `RegisterCodeBlockAction`, обратный вызов кода для блока, который обычно расположены между фигурными скобками. Регистрация для блока также обратный вызов в код для инициализатора поля, значение, заданное на атрибут или значение необязательного параметра.

Другой пример: `RegisterCompilationStartAction`, обратный вызов кода в начале компиляции, что полезно, если вам нужно собирать состояния через различных расположений. Можно создать структуру данных, скажем, для сбора всех символов, используемых, и каждый раз, когда ваш анализатор обратного вызова для некоторых синтаксис или символ, можно сохранить сведения о каждом расположении в структуре данных. Когда пригласят обратно из-за завершения компиляции, вы можете анализировать все расположения, можно сохранить, например, сообщить о какие символы в коде используется из каждого `using` инструкции.

С помощью **визуализатор синтаксиса**, вы узнали, что вы хотите быть вызывается, когда компилятор обрабатывает ObjectCreationExpression. Чтобы настроить обратного вызова, используйте следующий код:

```csharp
context.RegisterSyntaxNodeAction(c => AnalyzeObjectCreation(c),
                                 SyntaxKind.ObjectCreationExpression);
```

Можно зарегистрироваться для получения синтаксический узел и фильтр для только объект создания синтаксических узлов. По соглашению авторы анализатора использовать лямбда-выражения, при регистрации действий, которые помогает поддерживать анализаторы без отслеживания состояния. Можно использовать функции Visual Studio **создание в результате использования** для создания `AnalyzeObjectCreation` метод. Это приводит к возникновению ошибки правильный тип параметр контекста для вас слишком.

## <a name="set-properties-for-users-of-your-analyzer"></a>Задание свойств для пользователей вашей анализатора

Таким образом, чтобы ваш анализатор отображается в пользовательском Интерфейсе Visual Studio соответствующим образом, найдите и измените следующую строку кода для обозначения ваш анализатор:

```csharp
internal const string Category = "Naming";
```

Изменение `"Naming"` для `"API Guidance"`.

Затем найдите и откройте *Resources.resx* файл в проект с помощью **обозревателе решений**. Можно поместить в описание ваш анализатор, title и т. д. Можно изменить значение для всех потоков для `"Don't use ImmutableArray<T> constructor"` сейчас. Вы можете поместить аргументы в строке форматирования строк ({0}, {1}т. д.) и более поздние версии, при вызове `Diagnostic.Create()`, можно указать `params` массив аргументов для передачи.

## <a name="analyze-an-object-creation-expression"></a>Анализ выражения создания объекта

`AnalyzeObjectCreation` Метод принимает другой тип контекста, предоставленного платформой анализатора кода. `Initialize` Метода `AnalysisContext` позволяет регистрировать ответным вызовом действий для настройки вашей анализатора. `SyntaxNodeAnalysisContext`, Например, имеет `CancellationToken` , можно обойти. Если пользователь начинает ввод в редакторе, Roslyn отменит работающей анализаторы, чтобы сохранить работу и производительность. Другой пример: этот контекст имеет свойство узла, которое возвращает узел синтаксис для создания объекта.

Получение узла, который можно предположить, — это тип, для которого отфильтрованные действие узла синтаксиса:

```csharp
var objectCreation = (ObjectCreationExpressionSyntax)context.Node;
```

### <a name="launch-visual-studio-with-your-analyzer-the-first-time"></a>Visual Studio с помощью вашей анализатора первого запуска

Запустите Visual Studio, построения и выполнения ваш анализатор (нажмите клавишу **F5**). Так как начальный проект в **обозревателе решений** является проект VSIX, под управлением сборки кода, кода и VSIX и затем запускает Visual Studio с помощью VSIX, что установлен. При запуске Visual Studio таким образом, он запускается с куст реестра distinct, таким образом, не будут затронуты главного использование Visual Studio путем тестирования экземпляров при построении анализаторы. При первом запуске таким образом, Visual Studio выполняет несколько инициализаций, аналогичную при первом запуске Visual Studio после его установки.

Создайте консольный проект, а затем введите код массива в методе Main приложения консоли:

```csharp
var b1 = new ImmutableArray<int>();
Console.WriteLine("b1.Length = {0}", b1.Length);
var b2 = new ImmutableArray<int> { 1, 2, 3, 4, 5 };
Console.WriteLine("b2.Length = {0}", b2.Length);
```

В строках кода с `ImmutableArray` имеют волнистые линии, так как вам нужно получить неизменяемый пакет NuGet, а затем добавить `using` в код оператор. Нажмите правую кнопку указателя на узел проекта в **обозревателе решений** и выберите **управление пакетами NuGet**. В диспетчер NuGet, введите «Неизменяемые» в поле поиска и выберите элемент **System.Collections.Immutable** (не выбирайте **Microsoft.Bcl.Immutable**) в левой панели и нажмите клавишу  **Установка** кнопку в правой области. Установка пакета добавляет ссылку в ссылки проекта.

Вы по-прежнему см. в разделе красные волнистые линии под `ImmutableArray`, поэтому поместите курсор внутрь этого идентификатора и нажмите клавишу **Ctrl**+**.** (период), чтобы открыть меню предложенного исправления и добавить соответствующий `using` инструкции.

**Сохранить все и закрыть** второй экземпляр Visual Studio сейчас позволит вам в исходное состояние, чтобы продолжить.

## <a name="finish-the-analyzer-using-edit-and-continue"></a>Завершить анализатора, с помощью изменить и продолжить

В первом экземпляре Visual Studio, установите точку останова в начале вашей `AnalyzeObjectCreation` метод, нажав клавишу **F9** , когда курсор находится в первой строке.

Запустите ваш анализатор еще раз с **F5**и в второй экземпляр Visual Studio, откройте приложение консоли, вы создали время последнего.

Вы вернетесь в первый экземпляр Visual Studio в точке останова, так как компилятор Roslyn видели выражения создания объекта и вызывается в ваш анализатор.

**Получает узел создания объекта.** Шаг с обходом строку, которая задает `objectCreation` переменных, нажав клавишу **F10**, а затем в **окно "Интерпретация"** выражение `"objectCreation.ToString()"`. Вы увидите, что переменная указывает на узел синтаксического код `"new ImmutableArray<int>()"`, только что вы ищете.

**Получить ImmutableArray < T\> объекта типа.** Необходимо проверить, является ли тип создаваемой ImmutableArray. Во-первых вы получаете объект, представляющий этот тип. Проверка типов с помощью семантической модели, чтобы у вас есть точно подходящего типа, а не сравнивает строку из `ToString()`. Введите следующую строку кода в конце функции:

```csharp
var immutableArrayOfTType =
    context.SemanticModel
           .Compilation
           .GetTypeByMetadataName("System.Collections.Immutable.ImmutableArray`1");
```

Необходимо назначить универсальных типов в метаданные с помощью обратных апострофа (') и число универсальных параметров. Именно поэтому вы не видите «... ImmutableArray\<T >» в имени метаданных.

Семантическая модель содержит много полезных вещей, позволяющие получить ответы на вопросы символы, поток данных, время существования переменной и т. д. Roslyn разделяет синтаксических узлов семантическую модель по различным причинам engineering (производительность, моделирование ошибочный код и т. д.). Требуется, чтобы модель компиляции для поиска информации, содержащейся в ссылки для точное сравнение.

В левой части окна редактора можно перетаскивать указатель желтый выполнения. Перетащите его вверх на ту строку, которая задает `objectCreation` переменной и шаг с обходом новая строка кода с помощью **F10**. При наведении указателя мыши на переменную `immutableArrayOfType`, вы увидите, что мы обнаружили точный тип в семантической модели.

**Получите тип выражения для создания объектов.** «Type» используется несколькими способами, в этой статье, но это означает, что при наличии «новый Foo» выражения, необходимо получить модель Foo. Необходимо получить тип выражения создания объекта, находится ли он ImmutableArray\<T > тип. Снова используйте семантическую модель для получения сведений о символах для типа символа (ImmutableArray) в выражение создания объекта. Введите следующую строку кода в конце функции:

```csharp
var symbolInfo = context.SemanticModel.GetSymbolInfo(objectCreation.Type).Symbol as INamedTypeSymbol;
```

Так как ваш анализатор должен обрабатывать неполных или неверных кода в буферы редактора (например, отсутствует `using` инструкции), необходимо проверить `symbolInfo` , `null`. Необходимо получить именованный тип (INamedTypeSymbol) из объекта сведения символ завершения анализа.

**Сравнение типов.** Поскольку имеется открытый универсальный тип T, который мы ищем и тип в коде — конкретный универсальный тип, запрос сведений о символах для типа создается на основе (открытым универсальным типом) и сравнить результат с `immutableArrayOfTType`. Введите следующий текст в конец метода:

```csharp
if (symbolInfo != null &&
    symbolInfo.ConstructedFrom.Equals(immutableArrayOfTType))
{}
```

**Отчет диагностики.** Reporting диагностики не представляет труда. Можно использовать правила, созданные в шаблон проекта, который определяется перед метод Initialize. Так как такой ситуации, в коде происходит ошибка, можно изменить строку, которая инициализируется правило для замены `DiagnosticSeverity.Warning` (зеленая волнистая линия) с `DiagnosticSeverity.Error` (красной волнистой линией). Остальная часть правила инициализирует из ресурсов, измененные в начале этого пошагового руководства. Вам также необходимо получить расположение для пометки, в которой находится спецификация типа выражения создания объекта. Введите следующий код в `if` блок:

```csharp
context.ReportDiagnostic(Diagnostic.Create(Rule, objectCreation.Type.GetLocation()));
```

Функция должна выглядеть следующим образом (Возможно форматирование по-разному):

```csharp
private void AnalyzeObjectCreation(SyntaxNodeAnalysisContext context)
{
    var objectCreation = (ObjectCreationExpressionSyntax)context.Node;
    var immutableArrayOfTType =
        context.SemanticModel
               .Compilation
               .GetTypeByMetadataName(
                   "System.Collections.Immutable.ImmutableArray`1");
    var symbolInfo = context.SemanticModel.GetSymbolInfo(objectCreation.Type).Symbol as
        INamedTypeSymbol;
    if (symbolInfo != null &&
        symbolInfo.ConstructedFrom.Equals(immutableArrayOfTType))
    {
        context.ReportDiagnostic(
            Diagnostic.Create(Rule, objectCreation.Type.GetLocation()));
    }
}
```

Удалите точку останова, чтобы вы можете просмотреть в рабочее analyzer (и остановить возврат к первому экземпляру Visual Studio). Перетащите указатель выполнения в начало метода и нажмите клавишу **F5** следует продолжить выполнение. При переключении обратно в второй экземпляр Visual Studio, компилятор будет запущен снова изучить код, и оно будет вызывать ваш анализатор. Отобразится волнистая линия под `ImmutableType<int>`.

## <a name="adding-a-code-fix-for-the-code-issue"></a>Добавление «Исправление кода» для ее кода

Прежде чем начать, закройте второй экземпляр Visual Studio и остановить отладку в первом экземпляре Visual Studio (где вы разрабатываете анализатор).

**Добавьте новый класс.** Используйте контекстное меню (правую кнопку указателя) на узел проекта в **обозревателе решений** и выберите Добавление нового элемента. Добавьте класс с именем `BuildCodeFixProvider`. Этот класс должно быть производным от `CodeFixProvider`, и необходимо будет использовать **Ctrl**+**.** (период) для вызова исправления кода, который добавляет правильные `using` инструкции. Этот класс также должен сопровождаться атрибутом `ExportCodeFixProvider` атрибут и вам нужно будет добавить `using` инструкцию, чтобы разрешить `LanguageNames` перечисления. Файл класса следующим кодом, в нем должно быть:

```csharp
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CodeFixes;

namespace ImmutableArrayAnalyzer
{
    [ExportCodeFixProvider(LanguageNames.CSharp)]
    class BuildCodeFixProvider : CodeFixProvider
    {}
```

**Заглушки для унаследованных членов.** Теперь поместите курсор редактора в идентификаторе `CodeFixProvider` и нажмите клавишу **Ctrl**+**.** (точка) для заглушки для реализации этого абстрактного базового класса. Это создает свойство и метод.

**Реализует свойство.** Заполните `FixableDiagnosticIds` свойства `get` текст следующим кодом:

```csharp
return ImmutableArray.Create(ImmutableArrayAnalyzerAnalyzer.DiagnosticId);
```

Roslyn объединяет в себе диагностики и исправления, сопоставляя эти идентификаторы, которые являются просто строки. Шаблон проекта создается идентификатор диагностики, и вы можете изменить его. Код в свойстве просто возвращает идентификатор класса анализатора.

**Метод RegisterCodeFixAsync принимает контекст.** Контекст важно в тех случаях, поскольку исправления кода можно применить к нескольким диагностики или в строке кода может быть несколько проблем. Если ввести «контекст». в теле метода список завершения IntelliSense покажу некоторые полезные элементы. Есть элемент CancellationToken, можно проверить, см. в разделе, если что-то хочет отменить исправления. Отсутствует элемент документа, который содержит множество полезных элементов, а также использовать для объектов модели проекта и решения. Есть элемент Span, являющийся началом и конец расположение кода указано, если вы отправляли диагностики.

**Сделайте метод являются асинхронными.** Первое, что необходимо сделать — объявление созданного метода необходимо исправить `async` метод. Исправление кода для создание заглушек для реализации абстрактного класса не включает в себя `async` несмотря на то, что метод возвращает ключевое слово `Task`.

**Получите корень дерева синтаксиса.** Для изменения кода, необходимые для создания нового дерева синтаксиса с учетом изменений, делает код исправления. Вам потребуется `Document` из контекста для вызова `GetSyntaxRootAsync`. Это асинхронный метод, так как неизвестный действий для получения дерева синтаксиса, возможно, включающий начало файла с диска, его анализ и создание модели кода Roslyn для него. В течение этого времени, в которых использование пользовательского интерфейса Visual Studio должны быть быстро реагирующих `async` позволяет. Замените строку кода в методе следующее:

```csharp
var root = await context.Document
                        .GetSyntaxRootAsync(context.CancellationToken);
```

**Найти узел с проблемой.** Вы передаете диапазона контекста, но узел, которую вы найдете не может быть код, который необходимо изменить. Зарегистрированное диагностическое событие диапазон предоставляется только для идентификатора типа (где принадлежал волнистую линию), но вам нужно заменить выражение создания весь объект, включая `new` ключевое слово в начале и в конце круглые скобки. Добавьте следующий код в метод (и использовать **Ctrl**+**.** Чтобы добавить `using` инструкции для `ObjectCreationExpressionSyntax`):

```csharp
var objectCreation = root.FindNode(context.Span)
                         .FirstAncestorOrSelf<ObjectCreationExpressionSyntax>();
```

**Зарегистрируйте исправление кода для лампочки пользовательского интерфейса.** При регистрации исправления кода Roslyn автоматически подключается к лампочки в Visual Studio пользовательского интерфейса. Конечные пользователи будут видеть, они могут использовать **Ctrl**+**.** (точка), если ваш анализатор волнистых линий недействительная `ImmutableArray<T>` используйте конструктор. Так как ваш поставщик исправлений кода выполняется только в том случае, если имеется проблема, можно предположить, что у вас есть выражение создания объекта, который вы искали. Из параметра контекста, вы можете зарегистрировать новое исправление кода, добавив следующий код в конец `RegisterCodeFixAsync` метод:

```csharp
context.RegisterCodeFix(
            CodeAction.Create("Use ImmutableArray<T>.Empty",
                              c => ChangeToImmutableArrayEmpty(objectCreation,
                                                               context.Document,
                                                               c)),
            context.Diagnostics[0]);
```

Необходимо поместить курсор редактора в идентификаторе, `CodeAction`, затем с помощью **Ctrl**+**.** (период), чтобы добавить соответствующий `using` инструкции для этого типа.

Поместите курсор в редакторе в `ChangeToImmutableArrayEmpty` идентификатора и использование **Ctrl**+**.** еще раз, чтобы создать заглушку этого метода для вас.

Этот последний фрагмент кода, который вы добавили регистрирует исправления кода путем передачи `CodeAction` и идентификатор диагностики для типа обнаруженной проблемы. В этом примере имеется только один идентификатор диагностики, который предоставляет этот код исправления, поэтому можно просто передать первый элемент массива идентификаторов диагностики. При создании `CodeAction`, передается в текст, который «лампочку» пользовательского интерфейса следует использовать как описание исправление кода. Можно также передать в функцию, которая принимает CancellationToken и возвращает новый документ. Новый документ будет содержать новое дерево синтаксиса, включающее Исправлен код, вызывающий `ImmutableArray.Empty`. Этот фрагмент кода использует лямбда-выражение, чтобы его можно закрыть узел objectCreation и контекста документа.

**Создает новое дерево синтаксиса.** В `ChangeToImmutableArrayEmpty` метод которого заглушки, созданный ранее, введите в строку кода: `ImmutableArray<int>.Empty;`. При просмотре **визуализатор синтаксиса** окно инструментов, вы увидите этот синтаксис является узлом SimpleMemberAccessExpression. Это, что этот метод должен создавать и возвращать в новый документ.

Первое изменение, чтобы `ChangeToImmutableArrayEmpty` является добавление `async` перед `Task<Document>` так, как генераторы кода нельзя предполагать, метод должен быть async.

Укажите в тексте со следующим кодом, таким образом, ваш метод выглядел следующим образом:

```csharp
private async Task<Document> ChangeToImmutableArrayEmpty(
    ObjectCreationExpressionSyntax objectCreation, Document document,
    CancellationToken c)
{
    var generator = SyntaxGenerator.GetGenerator(document);
    var memberAccess =
        generator.MemberAccessExpression(objectCreation.Type, "Empty");
    var oldRoot = await document.GetSyntaxRootAsync(c);
    var newRoot = oldRoot.ReplaceNode(objectCreation, memberAccess);
    return document.WithSyntaxRoot(newRoot);
}
```

Необходимо поместить курсор редактора в `SyntaxGenerator` идентификатора и использование **Ctrl**+**.** (период), чтобы добавить соответствующий `using` инструкции для этого типа.

Этот код использует `SyntaxGenerator`, являющийся типом полезно для создания нового кода. После получение генератор для документа, который имеет проблемы кода, `ChangeToImmutableArrayEmpty` вызовы `MemberAccessExpression`, передав тип, который содержит член, необходимо получить доступ и имя члена как строка.

Затем метод извлекает корень документа, и так как это может включать произвольное работы в общем случае, код ожидает этот вызов и передает токен отмены. Модели кода Roslyn являются неизменяемыми, как и при работе со строкой .NET; При обновлении строки, вы получите новый строковый объект в ответ. При вызове `ReplaceNode`, вы получаете новый корневой узел. Большая часть дерева синтаксиса используется совместно (так как он станет неизменяемым), но `objectCreation` узел заменяется `memberAccess` узла, а также все родительские узлы вплоть до корневого элемента дерева синтаксиса.

## <a name="try-your-code-fix"></a>Попробуйте исправление кода

Теперь можно нажать клавиши **F5** для выполнения вашей анализатора во втором экземпляре Visual Studio. Откройте проект, который мы использовали раньше. Теперь вы должны увидеть лампочки отображаются, где в выражение создания нового объекта для `ImmutableArray<int>`. Если нажать клавишу **Ctrl**+**.** (период) вы увидите исправить код, и вы увидите автоматически созданный код-различие предварительной версии, в «лампочку» пользовательского интерфейса. Roslyn создает это для вас.

**Совет по PRO.** Если запустить второй экземпляр Visual Studio, и вы не видите лампочку с исправления кода, может потребоваться очистить кэш компонента Visual Studio. Очистка кэша вынуждает Visual Studio, чтобы вы пересмотрели компоненты, поэтому Visual Studio должен затем получить последнюю компонента. Во-первых завершение работы второй экземпляр Visual Studio. Затем в **Windows Explorer**, перейдите к *%LOCALAPPDATA%\Microsoft\VisualStudio\16.0Roslyn\\*. («16.0» меняется от версии к версии с помощью Visual Studio.) Удалить этот подкаталог *ComponentModelCache*.

## <a name="talk-video-and-finish-code-project"></a>Обсуждение видео и завершить проект кода

Этот пример разработан и рассматривается далее в [в этом докладе](https://channel9.msdn.com/events/Build/2015/3-725). Беседа демонстрирует работу анализатора, а также для его создания.

Вы увидите готовый код [здесь](https://github.com/DustinCampbell/CoreFxAnalyzers/tree/master/Source/CoreFxAnalyzers). Вложенные папки *DoNotUseImmutableArrayCollectionInitializer* и *DoNotUseImmutableArrayCtor* иметь файл C# для поиска проблем и файл C#, реализующий код исправления, которые показывают в Visual Studio лампочки пользовательского интерфейса. Обратите внимание, что готовый код имеет немного дополнительные абстракции, чтобы избежать выборка ImmutableArray\<T > снова и снова типа object. Она использует вложенные действия, зарегистрированного для сохранения типа объекта в контексте, который доступен всякий раз, когда действия sub (анализ создания объектов и анализировать инициализации коллекции) выполнения.

## <a name="see-also"></a>См. также

* [\\\Build 2015 ток](https://channel9.msdn.com/events/Build/2015/3-725)
* [Полный код на GitHub](https://github.com/DustinCampbell/CoreFxAnalyzers/tree/master/Source/CoreFxAnalyzers)
* [Несколько примеров на GitHub, сгруппированы в три вида анализаторы](https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Analyzer%20Samples.md)
* [Другие документы на сайте GitHub OSS](https://github.com/dotnet/roslyn/tree/master/docs/analyzers)
* [Правила FxCop, реализовано с помощью анализаторов Roslyn на GitHub](https://github.com/dotnet/roslyn/tree/master/src/Diagnostics/FxCop)
