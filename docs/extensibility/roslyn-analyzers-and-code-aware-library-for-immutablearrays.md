---
title: Анализаторы Roslyn и библиотека с поддержкой кода для Иммутаблеаррайс | Документация Майкрософт
ms.date: 11/04/2016
ms.topic: conceptual
ms.assetid: 0b0afa22-3fca-4d59-908e-352464c1d903
author: madskristensen
ms.author: madsk
manager: jillfra
ms.workload:
- vssdk
ms.openlocfilehash: 8665a37e4afd387ff4f77a8bdb5da430d773ae1d
ms.sourcegitcommit: c150d0be93b6f7ccbe9625b41a437541502560f5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/10/2020
ms.locfileid: "75848718"
---
# <a name="roslyn-analyzers-and-code-aware-library-for-immutablearrays"></a>Анализаторы Roslyn и библиотека с поддержкой кода для Иммутаблеаррайс

[.NET Compiler Platform](https://github.com/dotnet/roslyn) ("Roslyn") помогает создавать библиотеки с поддержкой кода. Библиотека с поддержкой кода предоставляет функциональные возможности, которые можно использовать и средства (Roslyn Analyzer), которые помогут вам использовать библиотеку наиболее эффективно или избежать ошибок. В этом разделе показано, как создать реальный Roslyn анализатор для перехвата распространенных ошибок при использовании пакета [System. Collections. неизменяемый](https://www.nuget.org/packages/System.Collections.Immutable) пакет NuGet. В примере также показано, как предоставить исправление кода для проблемы с кодом, обнаруженной анализатором. Пользователи видят исправления кода в пользовательском интерфейсе лампочки Visual Studio и могут автоматически применить исправление для кода.

## <a name="get-started"></a>Приступая к работе

Для сборки этого примера необходимо следующее:

* Visual Studio 2015 (не экспресс-выпуск) или более поздней версии. Вы можете использовать бесплатный [выпуск Visual Studio Community Edition](https://visualstudio.microsoft.com/vs/community/)
* [Visual Studio SDK](../extensibility/visual-studio-sdk.md). При установке Visual Studio также можно проверить **средства расширения Visual Studio** в разделе **Общие средства** для установки пакета SDK одновременно. Если вы уже установили Visual Studio, можно также установить этот пакет SDK, перейдя к главному **файлу** меню > **Новый** > **проект**, **C#** выбрав в левой области навигации, а затем выбрав пункт **расширяемость**. При выборе шаблона проекта "**установить средства расширения Visual Studio**" будет предложено скачать и установить пакет SDK.
* [Пакет SDK .NET Compiler Platform ("Roslyn")](https://marketplace.visualstudio.com/items?itemName=VisualStudioProductTeam.NETCompilerPlatformSDK). Вы также можете установить этот пакет SDK, перейдя в главный **файл** меню > новый **проект** > , **C#** выбрав в левой области навигации, а затем выбрав пункт **расширяемость**. При выборе шаблона проект иерархического проекта "**скачать .NET COMPILER Platform SDK**" будет предложено скачать и установить пакет SDK. Этот пакет SDK включает [Syntax Visualizer Roslyn](https://github.com/dotnet/roslyn/wiki/Syntax%20Visualizer). Это полезное средство поможет понять, какие типы модели кода следует искать в анализаторе. Инфраструктура анализатора обращается к коду для конкретных типов моделей кода, поэтому код выполняется только при необходимости и может сосредоточиться только на анализе соответствующего кода.

## <a name="whats-the-problem"></a>Чем вызвана эта проблема?

Представьте, что вы предоставляете библиотеку с ImmutableArray (например, <xref:System.Collections.Immutable.ImmutableArray%601?displayProperty=fullName>). C#Разработчики имеют много опыта с массивами .NET. Однако из-за природы методов Иммутаблеаррайс и оптимизации, используемых в реализации, C# разработчик интуитионс приводил к написанию неработающего кода в вашей библиотеке, как описано ниже. Более того, пользователи не видят свои ошибки до времени выполнения, а это не то, что используется в Visual Studio с .NET.

Пользователи знакомы с написанием кода следующим образом:

```csharp
var a1 = new int[0];
Console.WriteLine("a1.Length = { 0}", a1.Length);
var a2 = new int[] { 1, 2, 3, 4, 5 };
Console.WriteLine("a2.Length = { 0}", a2.Length);
```

Создание пустых массивов для заполнения с помощью последующих строк кода и использование синтаксиса инициализатора коллекции C# знакомо разработчикам. Однако при написании того же кода для ImmutableArray сбой во время выполнения:

```csharp
var b1 = new ImmutableArray<int>();
Console.WriteLine("b1.Length = { 0}", b1.Length);
var b2 = new ImmutableArray<int> { 1, 2, 3, 4, 5 };
Console.WriteLine("b2.Length = { 0}", b2.Length);
```

Первая ошибка возникает из-за того, что в реализации ImmutableArray используется структура для упаковки базового хранилища данных. Структуры должны иметь конструкторы без параметров, чтобы `default(T)` выражения могли возвращать структуры со всеми нулевыми или нулевыми членами. Когда код обращается к `b1.Length`, возникает ошибка разыменования NULL во время выполнения, так как в структуре ImmutableArray нет базового массива хранения данных. Правильный способ создания пустого ImmutableArray — `ImmutableArray<int>.Empty`.

Ошибка с инициализаторами коллекций происходит из-за того, что метод `ImmutableArray.Add` возвращает новые экземпляры каждый раз при его вызове. Поскольку Иммутаблеаррайс никогда не изменяются, при добавлении нового элемента вы получаете новый объект ImmutableArray (который может использовать хранилище для обеспечения производительности с ранее существующим ImmutableArray). Поскольку `b2` указывает на первый ImmutableArray до вызова `Add()` пять раз, `b2` является ImmutableArray по умолчанию. Кроме того, длина вызова в нем завершается сбоем с ошибкой разыменования null. Правильный способ инициализации ImmutableArray без вызова Add вручную — использовать `ImmutableArray.CreateRange(new int[] {1, 2, 3, 4, 5})`.

## <a name="find-relevant-syntax-node-types-to-trigger-your-analyzer"></a>Поиск соответствующих типов узлов синтаксиса для активации анализатора

 Чтобы начать сборку анализатора, сначала выясните, какой тип SyntaxNode необходимо найти. Запустите **Syntax Visualizer** из **представления** меню > другие Syntax Visualizer **Windows** > **Roslyn**.

Поместите курсор редактора в строку, которая объявляет `b1`. Вы увидите, Syntax Visualizer отобразится `LocalDeclarationStatement` узел дерева синтаксиса. Этот узел имеет `VariableDeclaration`, который, в свою очередь, имеет `VariableDeclarator`, который, в свою очередь, имеет `EqualsValueClause`и, наконец, есть `ObjectCreationExpression`. При щелчке Syntax Visualizer дереве узлов в окне редактора выделяется код, представленный этим узлом. Имена подтипов SyntaxNode соответствуют именам, используемым в C# грамматике.

## <a name="create-the-analyzer-project"></a>Создание проекта анализатора

В главном меню выберите **файл** > **Новый** > **проект**. В диалоговом окне **Новый проект** в **C#** разделе проекты на панели навигации слева выберите **расширяемость**, а затем в области справа выберите шаблон проект **с исправлением кода** . Введите имя и подтвердите диалоговое окно.

Шаблон открывает файл *DiagnosticAnalyzer.CS* . Выберите вкладку буфер редактора. Этот файл содержит класс анализатора (сформированный на основе имени, присвоенного проекту), производного от `DiagnosticAnalyzer` (тип API Roslyn). Новый класс имеет `DiagnosticAnalyzerAttribute` объявляя анализатор, относится к C# языку, чтобы компилятор обнаруживает и загружает анализатор.

```csharp
[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class ImmutableArrayAnalyzerAnalyzer : DiagnosticAnalyzer
{}
```

Анализатор можно реализовать с помощью Visual Basic, предназначенного C# для кода, и наоборот. В Диагностиканализераттрибуте важнее выбрать, предназначен ли анализатору один язык или оба. Более сложные анализаторы, требующие подробного моделирования языка, могут ориентироваться только на один язык. Если анализатор, например, проверяет только имена типов или имена открытых членов, можно использовать стандартную модель CLR Roslyn в Visual Basic и C#. Например, FxCop предупреждает, что класс реализует <xref:System.Runtime.Serialization.ISerializable>, но класс не имеет атрибута <xref:System.SerializableAttribute> не зависит от языка и работает как для Visual Basic, так и C# для кода.

## <a name="initialize-the-analyzer"></a>Инициализация анализатора

 Прокрутите вниз немного в классе `DiagnosticAnalyzer`, чтобы увидеть метод `Initialize`. Компилятор вызывает этот метод при активации анализатора. Метод принимает объект `AnalysisContext`, позволяющий анализатору получать сведения о контексте и регистрировать обратные вызовы для событий для типов кода, которые требуется проанализировать.

```csharp
public override void Initialize(AnalysisContext context) {}
```

Откройте новую строку в этом методе и введите "Context". для просмотра списка завершения IntelliSense. В списке завершения можно увидеть множество `Register...` методов для управления событиями различных типов. Например, первый из них, `RegisterCodeBlockAction`, выполняет обратный вызов к коду блока, который обычно является кодом между фигурными скобками. Регистрация для блока также выполняет обратный вызов к коду для инициализатора поля, значения, заданного для атрибута, или значения необязательного параметра.

Другой пример, `RegisterCompilationStartAction`, выполняет обратный вызов к коду в начале компиляции, что полезно, когда необходимо получить состояние во многих местах. Можно создать структуру данных, например, чтобы собираются все используемые символы, и при каждом вызове анализатора для некоторого синтаксиса или символа можно сохранить сведения о каждом расположении в структуре данных. При вызове обратно из-за завершения компиляции можно проанализировать все сохраненные расположения, например, чтобы сообщить, какие символы использует код из каждой инструкции `using`.

С помощью **Syntax Visualizer**вы узнали, что вы хотите вызывать, когда компилятор обрабатывает обжекткреатионекспрессион. Этот код используется для настройки обратного вызова:

```csharp
context.RegisterSyntaxNodeAction(c => AnalyzeObjectCreation(c),
                                 SyntaxKind.ObjectCreationExpression);
```

Вы регистрируетесь на узле синтаксиса и фильтруете только узлы синтаксиса создания объектов. По соглашению авторы анализаторов используют лямбда-выражение при регистрации действий, которое помогает в анализе анализаторов без отслеживания состояния. Для создания метода `AnalyzeObjectCreation` можно использовать функцию Visual Studio **Generated Usage** . Это также создает правильный тип параметра контекста.

## <a name="set-properties-for-users-of-your-analyzer"></a>Задание свойств для пользователей анализатора

Чтобы анализатор был правильно отображен в пользовательском интерфейсе Visual Studio, найдите и измените следующую строку кода, чтобы определить анализатор:

```csharp
internal const string Category = "Naming";
```

Изменение `"Naming"` для `"API Guidance"`.

Затем найдите и откройте в проекте файл *Resources. resx* с помощью **Обозреватель решений**. Можно добавить описание для анализатора, заголовка и т. д. Вы можете изменить значение для всех этих элементов на "`"Don't use ImmutableArray<T> constructor"` сейчас". Можно указать аргументы форматирования строки в строке ({0}, {1}и т. д.), а позднее при вызове `Diagnostic.Create()`можно предоставить `params` массив передаваемых аргументов.

## <a name="analyze-an-object-creation-expression"></a>Анализ выражения создания объекта

Метод `AnalyzeObjectCreation` принимает другой тип контекста, предоставляемый платформой анализатора кода. `AnalysisContext` метода `Initialize` позволяет регистрировать обратные вызовы действий для настройки анализатора. `SyntaxNodeAnalysisContext`, например, имеет `CancellationToken`, который можно передать. Если пользователь начинает вводить текст в редакторе, Roslyn отменяет выполнение анализаторов для сохранения работы и повышения производительности. В качестве другого примера этот контекст имеет свойство Node, которое возвращает узел синтаксиса создания объекта.

Получите узел, который можно предположить, — это тип, для которого отфильтровано действие узла синтаксиса:

```csharp
var objectCreation = (ObjectCreationExpressionSyntax)context.Node;
```

### <a name="launch-visual-studio-with-your-analyzer-the-first-time"></a>Запуск Visual Studio с анализатором в первый раз

Запустите Visual Studio, создав и выполнив анализатор (нажмите клавишу **F5**). Поскольку запускаемый проект в **Обозреватель решений** является проектом VSIX, при выполнении кода выполняется сборка кода и VSIX, а затем запускается Visual Studio с установленным VSIX. При таком запуске Visual Studio запускается с отдельным кустом реестра, чтобы при создании анализаторов не повлияло на использование Visual Studio при тестировании экземпляров. При первом запуске такого способа Visual Studio выполняет несколько инициализаций, аналогичных при первом запуске Visual Studio после его установки.

Создайте консольный проект, а затем введите код массива в метод Main для консольных приложений:

```csharp
var b1 = new ImmutableArray<int>();
Console.WriteLine("b1.Length = {0}", b1.Length);
var b2 = new ImmutableArray<int> { 1, 2, 3, 4, 5 };
Console.WriteLine("b2.Length = {0}", b2.Length);
```

Строки кода с `ImmutableArray` имеют волнистые линии, так как вам нужно получить неизменяемый пакет NuGet и добавить в код инструкцию `using`. Нажмите кнопку с правом указателя в узле проекта в **Обозреватель решений** и выберите **Управление пакетами NuGet**. В диспетчере NuGet введите "неизменяемый" в поле поиска и выберите элемент **System. Collections. unmutable** (не выбирайте **Microsoft. BCL. unmutable**) на левой панели и нажмите кнопку **установить** в правой области. При установке пакета добавляется ссылка на ссылки проекта.

В разделе `ImmutableArray`по-прежнему отображаются красные волнистые линии, поэтому поместите курсор в этот идентификатор и нажмите клавиши **Ctrl**+ **.** (точка) для открытия предлагаемого меню исправления и добавления соответствующей инструкции `using`.

**Сохраните все и закройте** второй экземпляр Visual Studio, чтобы перейти в режим очистки, чтобы продолжить.

## <a name="finish-the-analyzer-using-edit-and-continue"></a>Завершение работы с анализатором с помощью команды "изменить и продолжить"

В первом экземпляре Visual Studio установите точку останова в начале метода `AnalyzeObjectCreation`, нажав клавишу **F9** на первой строке.

Запустите анализатор снова с помощью **F5**, а во втором экземпляре Visual Studio снова откройте консольное приложение, созданное в последний раз.

Вы вернетесь к первому экземпляру Visual Studio в точке останова, так как компилятор Roslyn обнаружил выражение создания объекта и вызываемое в анализатор.

**Возвращает узел создания объекта.** Проведите шаг над строкой, которая задает переменную `objectCreation`, нажав клавишу **F10**, и в **окне Интерпретация** Вычислите `"objectCreation.ToString()"`выражения. Вы видите, что узел синтаксиса, на который указывает переменная, — это код, `"new ImmutableArray<int>()"`, что вы ищете.

**Получение объекта ImmutableArray < T\> типа.** Необходимо проверить, является ли создаваемый тип ImmutableArray. Сначала вы получаете объект, представляющий этот тип. Вы проверяете типы с помощью семантической модели, чтобы убедиться в том, что имеется именно правильный тип, и не сравниваете строку из `ToString()`. В конце функции введите следующую строку кода:

```csharp
var immutableArrayOfTType =
    context.SemanticModel
           .Compilation
           .GetTypeByMetadataName("System.Collections.Immutable.ImmutableArray`1");
```

Вы назначаете универсальные типы в метаданных с обратными импульсами (') и числом универсальных параметров. Именно поэтому вы не видите "... ImmutableArray\<T > "в имени метаданных.

Семантическая модель имеет много полезных вещей, которые позволяют задавать вопросы о символах, потоке данных, времени жизни переменных и т. д. Roslyn отделяет синтаксические узлы от семантической модели для различных инженерных целей (производительность, моделирование ошибочного кода и т. д.). Необходимо, чтобы модель компиляции выполняла поиск информации, содержащейся в ссылках, для точного сравнения.

Желтый указатель выполнения можно перетащить в левой части окна редактора. Перетащите его в строку, которая задает переменную `objectCreation` и проведите шаг над новой строкой кода с помощью клавиши **F10**. Если навести указатель мыши на переменную `immutableArrayOfType`, вы увидите, что в семантической модели обнаружен точный тип.

**Возвращает тип выражения создания объекта.** "Тип" используется несколькими способами в этой статье, но это означает, что при наличии выражения "New foo" необходимо получить модель foo. Необходимо получить тип выражения создания объекта, чтобы проверить, является ли он типом ImmutableArray\<T >. Используйте семантическую модель еще раз, чтобы получить символьную информацию для символа типа (ImmutableArray) в выражении создания объекта. В конце функции введите следующую строку кода:

```csharp
var symbolInfo = context.SemanticModel.GetSymbolInfo(objectCreation.Type).Symbol as INamedTypeSymbol;
```

Так как анализатору требуется обработку неполного или неверного кода в буферах редактора (например, отсутствует инструкция `using`), следует проверить `symbolInfo` `null`. Чтобы завершить анализ, необходимо получить именованный тип (Инамедтипесимбол) из объекта символьной информации.

**Сравните типы.** Поскольку существует открытый универсальный тип T, который мы ищем, а тип в коде является конкретным универсальным типом, вы запрашиваете сведения о символах для того, как создается тип (открытый универсальный тип), и сравниваете результат с `immutableArrayOfTType`. В конце метода введите следующую команду:

```csharp
if (symbolInfo != null &&
    symbolInfo.ConstructedFrom.Equals(immutableArrayOfTType))
{}
```

**Сообщите о диагностике.** Создание отчетов о диагностике довольно просто. Созданное вами правило используется в шаблоне проекта, который определен перед методом Initialize. Так как такая ситуация в коде является ошибкой, можно изменить строку, инициализированную правилом, чтобы заменить `DiagnosticSeverity.Warning` (Зеленая волнистая линия) `DiagnosticSeverity.Error` (красной волнистой линией). Оставшаяся часть правила инициализируется из ресурсов, измененных в начале этого пошагового руководства. Также необходимо сообщить расположение волнистой линии, которая является расположением спецификации типа выражения создания объекта. Введите этот код в блок `if`:

```csharp
context.ReportDiagnostic(Diagnostic.Create(Rule, objectCreation.Type.GetLocation()));
```

Функция должна выглядеть следующим образом (возможно, отформатированным по-другому):

```csharp
private void AnalyzeObjectCreation(SyntaxNodeAnalysisContext context)
{
    var objectCreation = (ObjectCreationExpressionSyntax)context.Node;
    var immutableArrayOfTType =
        context.SemanticModel
               .Compilation
               .GetTypeByMetadataName(
                   "System.Collections.Immutable.ImmutableArray`1");
    var symbolInfo = context.SemanticModel.GetSymbolInfo(objectCreation.Type).Symbol as
        INamedTypeSymbol;
    if (symbolInfo != null &&
        symbolInfo.ConstructedFrom.Equals(immutableArrayOfTType))
    {
        context.ReportDiagnostic(
            Diagnostic.Create(Rule, objectCreation.Type.GetLocation()));
    }
}
```

Удалите точку останова, чтобы убедиться, что анализатор работает (и прекращает возврат к первому экземпляру Visual Studio). Перетащите указатель выполнения в начало метода и нажмите клавишу **F5** , чтобы продолжить выполнение. При переключении обратно на второй экземпляр Visual Studio компилятор начнет изучать код еще раз и будет вызывать анализатор. В разделе `ImmutableType<int>`можно увидеть волнистую линию.

## <a name="adding-a-code-fix-for-the-code-issue"></a>Добавление "исправления кода" для проблемы с кодом

Прежде чем начать, закройте второй экземпляр Visual Studio и завершите отладку в первом экземпляре Visual Studio (на котором разрабатывается анализатор).

**Добавьте новый класс.** Используйте контекстное меню (кнопка с правой кнопкой мыши) в узле проекта в **Обозреватель решений** и выберите Добавить новый элемент. Добавьте класс с именем `BuildCodeFixProvider`. Этот класс должен быть производным от `CodeFixProvider`, и необходимо использовать **сочетание клавиш Ctrl**+ **.** (точка) для вызова исправления кода, добавляющего правильную инструкцию `using`. Этот класс также необходимо снабдить атрибутом `ExportCodeFixProvider`, и необходимо добавить инструкцию `using`, чтобы разрешить `LanguageNames` перечисление. У вас должен быть файл класса со следующим кодом:

```csharp
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CodeFixes;

namespace ImmutableArrayAnalyzer
{
    [ExportCodeFixProvider(LanguageNames.CSharp)]
    class BuildCodeFixProvider : CodeFixProvider
    {}
```

**Заглушка для производных членов.** Теперь поместите курсор редактора в идентификатор `CodeFixProvider` и нажмите клавиши **Ctrl**+ **.** (точка) для создания заглушки реализации для этого абстрактного базового класса. При этом создается свойство и метод.

**Реализуйте свойство.** Заполните текст `get` свойства `FixableDiagnosticIds` следующим кодом:

```csharp
return ImmutableArray.Create(ImmutableArrayAnalyzerAnalyzer.DiagnosticId);
```

Roslyn объединяет диагностику и исправления, сопоставляя эти идентификаторы, которые являются просто строками. Шаблон проекта создал идентификатор диагностики, и вы можете изменить его. Код в свойстве просто возвращает идентификатор из класса Analyzer.

**Метод Регистеркодефиксасинк принимает контекст.** Контекст важен, поскольку исправление кода может применяться к нескольким диагностическим сведениям, или в одной строке кода может быть несколько проблем. Если ввести "Context". в теле метода в списке завершения IntelliSense будут показаны некоторые полезные члены. Существует элемент CancellationToken, который позволяет проверить, нужно ли отменить исправление. Существует элемент документа, который имеет множество полезных элементов и позволяет перейти к объектам модели проекта и решения. Существует элемент span, который является началом и концом расположения кода, указанного при обнаружении диагностики.

**Сделайте метод асинхронным.** Первое, что нужно сделать, это исправить объявление созданного метода как метод `async`. Исправление кода для создание заглушек реализации абстрактного класса не включает ключевое слово `async`, хотя метод возвращает `Task`.

**Возвращает корень дерева синтаксиса.** Чтобы изменить код, необходимо создать новое дерево синтаксиса с изменениями, которые делает исправление кода. Для вызова `GetSyntaxRootAsync`требуется `Document` из контекста. Это асинхронный метод, поскольку неизвестна работа по получению дерева синтаксиса, возможно, включая получение файла с диска, его синтаксический анализ и сборку модели кода Roslyn. В это время пользовательский интерфейс Visual Studio должен отвечать на запросы, что позволяет использовать `async`. Замените строку кода в методе следующим:

```csharp
var root = await context.Document
                        .GetSyntaxRootAsync(context.CancellationToken);
```

**Найдите узел с проблемой.** Вы передаете диапазон контекста, но искомый узел может не быть кодом, который необходимо изменить. Сообщаемая диагностическая диагностика предоставляла только диапазон для идентификатора типа (где наступил длинный волнистой линией), но необходимо заменить все выражение создания объекта, включая ключевое слово `new` в начале и круглые скобки в конце. Добавьте в метод следующий код (и используйте **сочетание клавиш Ctrl**+ **.** чтобы добавить инструкцию `using` для `ObjectCreationExpressionSyntax`), сделайте следующее:

```csharp
var objectCreation = root.FindNode(context.Span)
                         .FirstAncestorOrSelf<ObjectCreationExpressionSyntax>();
```

**Зарегистрируйте исправление кода для пользовательского интерфейса лампочки.** При регистрации исправления кода Roslyn автоматически подключается к пользовательскому интерфейсу лампочки Visual Studio. Конечные пользователи увидят, что они смогут использовать **сочетание клавиш Ctrl**+ **.** (период) при неправильном использовании конструктора `ImmutableArray<T>` анализатором волнистой линией. Поскольку поставщик исправления кода выполняется только при возникновении проблемы, можно предположить, что у вас есть искомое выражение для создания объектов. В параметре context можно зарегистрировать новое исправление кода, добавив следующий код в конец метода `RegisterCodeFixAsync`:

```csharp
context.RegisterCodeFix(
            CodeAction.Create("Use ImmutableArray<T>.Empty",
                              c => ChangeToImmutableArrayEmpty(objectCreation,
                                                               context.Document,
                                                               c)),
            context.Diagnostics[0]);
```

Необходимо поместить курсор редактора в идентификатор, `CodeAction`, а затем использовать **сочетание клавиш Ctrl**+ **.** (точка) для добавления соответствующей инструкции `using` для этого типа.

Затем поместите курсор редактора в идентификатор `ChangeToImmutableArrayEmpty` и используйте **сочетание клавиш Ctrl**+ **.** Опять же, для создания этой заглушки метода.

Последний добавленный фрагмент кода регистрирует исправление кода, передав `CodeAction` и идентификатор диагностики для обнаруженного типа проблемы. В этом примере существует только один идентификатор диагностики, в котором этот код предоставляет исправления для, поэтому можно просто передать первый элемент массива идентификаторов диагностики. При создании `CodeAction`передается текст, который пользовательский интерфейс лампочки должен использовать в качестве описания исправления кода. Вы также передаете функцию, которая принимает CancellationToken и возвращает новый документ. Новый документ содержит новое дерево синтаксиса, содержащее исправленный код, который вызывает `ImmutableArray.Empty`. Этот фрагмент кода использует лямбда-выражение, чтобы его можно было закрыть через узел Обжекткреатион и документ контекста.

**Создайте новое дерево синтаксиса.** В методе `ChangeToImmutableArrayEmpty`, заглушка которого была создана ранее, введите строку кода: `ImmutableArray<int>.Empty;`. При повторном просмотре окна инструментов **Syntax Visualizer** можно увидеть, что этот синтаксис является симплемемберакцессекспрессион узлом. Именно этот метод должен создавать и возвращать новый документ.

Первым изменением `ChangeToImmutableArrayEmpty` является добавление `async` перед `Task<Document>`, поскольку генераторы кода не могут предположить, что метод должен быть асинхронным.

Заполните текст следующим кодом, чтобы метод выглядел примерно следующим образом:

```csharp
private async Task<Document> ChangeToImmutableArrayEmpty(
    ObjectCreationExpressionSyntax objectCreation, Document document,
    CancellationToken c)
{
    var generator = SyntaxGenerator.GetGenerator(document);
    var memberAccess =
        generator.MemberAccessExpression(objectCreation.Type, "Empty");
    var oldRoot = await document.GetSyntaxRootAsync(c);
    var newRoot = oldRoot.ReplaceNode(objectCreation, memberAccess);
    return document.WithSyntaxRoot(newRoot);
}
```

Необходимо перевести курсор редактора в идентификатор `SyntaxGenerator` и использовать **сочетание клавиш Ctrl**+ **.** (точка) для добавления соответствующей инструкции `using` для этого типа.

В этом коде используется `SyntaxGenerator`, который является полезным типом для создания нового кода. После получения генератора для документа, в котором возникла ошибка кода, `ChangeToImmutableArrayEmpty` вызывает `MemberAccessExpression`, передавая тип, имеющий элемент, к которому нужно получить доступ, и передав имя члена в виде строки.

Затем метод извлекает корневой элемент документа, и так как это может привести к произвольной работе в общем случае, код ожидает этот вызов и передает токен отмены. Модели кода Roslyn являются неизменяемыми, как и при работе со строкой .NET. При обновлении строки возвращается новый строковый объект. При вызове `ReplaceNode`возвращается новый корневой узел. Большая часть синтаксического дерева является общей (так как она неизменяема), но `objectCreation` узел заменяется `memberAccess`ным узлом, а также всеми родительскими узлами вплоть до корня дерева синтаксиса.

## <a name="try-your-code-fix"></a>Попробуйте исправить код

Теперь можно нажать клавишу **F5** , чтобы запустить анализатор во втором экземпляре Visual Studio. Откройте проект консоли, который вы использовали ранее. Теперь вы увидите лампочку, где новое выражение создания объекта предназначено для `ImmutableArray<int>`. При нажатии клавиши **Ctrl**+ **.** (period) вы увидите исправление кода, и вы увидите в пользовательском интерфейсе "лампочка" предварительный просмотр разницы в коде. Roslyn создает это.

**Совет по Pro:** Если вы запускаете второй экземпляр Visual Studio и не видите лампочку с исправлением кода, вам может потребоваться очистить кэш компонентов Visual Studio. Очистка кэша заставляет Visual Studio повторно исследовать компоненты, поэтому Visual Studio должен выбрать последний компонент. Сначала завершите работу второго экземпляра Visual Studio. Затем в **проводнике Windows**перейдите к *%LocalAppData%\Microsoft\VisualStudio\16.0Roslyn\\* . (Значение "16,0" меняется с версии на версию до версии Visual Studio.) Удалите подкаталог *компонентмоделкаче*.

## <a name="talk-video-and-finish-code-project"></a>Проект кода для видео и завершения проекта

Вы можете увидеть, что этот пример был разработан и обсуждается далее в [этом разговоре](https://channel9.msdn.com/events/Build/2015/3-725). В этом разговоре демонстрируется работающий анализатор и пошаговое руководство по его созданию.

Весь готовый код можно просмотреть [здесь](https://github.com/DustinCampbell/CoreFxAnalyzers/tree/master/Source/CoreFxAnalyzers). Вложенные папки *донотусеиммутаблеаррайколлектионинитиализер* и *донотусеиммутаблеаррайктор* имеют C# файл для поиска проблем и C# файл, который реализует исправления кода, отображаемые в пользовательском интерфейсе лампочки Visual Studio. Обратите внимание, что завершенный код имеет немного более абстракцию, чтобы избежать повторной выборки объекта ImmutableArray\<T > типа. Он использует вложенные зарегистрированные действия для сохранения объекта типа в контексте, который доступен при выполнении вложенных действий (анализ создания объекта и анализ инициализации коллекции).

## <a name="see-also"></a>См. также:

* [\\\Буилд 2015](https://channel9.msdn.com/events/Build/2015/3-725)
* [Завершенный код на GitHub](https://github.com/DustinCampbell/CoreFxAnalyzers/tree/master/Source/CoreFxAnalyzers)
* [Несколько примеров на сайте GitHub, сгруппированных в три вида анализаторов](https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Analyzer%20Samples.md)
* [Другие документы на сайте OSS для GitHub](https://github.com/dotnet/roslyn/tree/master/docs/analyzers)
* [Правила FxCop, реализованные с анализаторами Roslyn на GitHub](https://github.com/dotnet/roslyn/tree/master/src/Diagnostics/FxCop)
