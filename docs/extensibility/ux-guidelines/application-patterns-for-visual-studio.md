---
title: Шаблоны приложений для визуальной студии Документы Майкрософт
ms.date: 04/26/2017
ms.topic: conceptual
ms.assetid: 8ed68602-4e28-46fe-b39f-f41979b308a2
author: acangialosi
ms.author: anthc
manager: jillfra
ms.workload:
- vssdk
ms.openlocfilehash: 036c95951fe3dc9e65a0f3338f75ae9867d721c3
ms.sourcegitcommit: 16a4a5da4a4fd795b46a0869ca2152f2d36e6db2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2020
ms.locfileid: "80698600"
---
# <a name="application-patterns-for-visual-studio"></a>Шаблоны приложений для Visual Studio
## <a name="window-interactions"></a><a name="BKMK_WindowInteractions"></a>Взаимодействия окон

### <a name="overview"></a>Обзор
Двумя основными типами окон, используемыми в Visual Studio, являются редакторы документов и окна инструментов. Редкие, но возможные, большие безрежимные диалоги. Хотя все они невозможны в оболочке, их модели принципиально отличаются. Этот раздел охватывает разницу между окнами документов, окнами инструментов и безрежимными диалогами. Шаблоны модальных диалогов описаны в [Диалогах.](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Dialogs)

### <a name="comparing-window-usage-patterns"></a>Сравнение шаблонов использования окон
**Окна документов** почти всегда хорошо отображаются в документе. Это дает редактору документов "центральную стадию", чтобы организовать дополнительные окна инструмента вокруг.

**Окно инструмента** чаще всего отображается как отдельное, меньшее окно, обложенное к краю IDE. Это может быть видимым, скрытым или автоматически скрытым. Однако иногда окна инструментов хорошо представлены в документе, отображая свойство **Window/Docking** на окне. Это приводит к большему большему набору недвижимости, но также и к общему дизайнерским решениям: при попытке интеграции в Visual Studio необходимо решить, следует ли отображать окно инструмента или окно документа.

В Visual Studio не рекомендуется делать **диалоги** без режима. Большинство безрежимных диалогов, по определению, плавающие окна инструмента и должны быть реализованы таким образом. Безмерные диалоги допускаются в тех случаях, когда размер нормального окна инструмента, пристыкованного к боковой стороне оболочки, будет слишком ограниченным. Они также допускаются в тех случаях, когда пользователь, скорее всего, переведет диалог на вторичный монитор.

Тщательно продумайте, какой тип контейнера вам нужен. Общие соображения шаблона использования для разработки uI приведены в следующей таблице.

||Окно документа|Окно инструмента|Безрежимный диалог|
|-|---------------------|-----------------|---------------------|
| **Положение** | Всегда расположен в документе хорошо и не стыковки по краям IDE. Его можно «снять» так, чтобы он плавал отдельно от основной оболочки. | Как правило, вкладка-док по краям IDE, но могут быть настроены, чтобы быть плавающим, автоматически скрытые (незакрепленные), или состыкован в документе хорошо.|Большое плавающее окно отдельно от IDE. |
| **Модель фиксации** | *Задержка коммит*<br /><br /> Чтобы сохранить данные в документе, пользователь должен выдать **файл &gt; Сохранить,** **Сохранить как**, или сохранить **все** команды. Окно документа имеет понятие данных внутри него, которые "загрязняются", а затем совершаются в одной из команд сохранения. При закрытии окна документа все содержимое либо сохраняется на диске, либо теряется. | *Немедленный коммит*<br /><br /> Нет модели сохранения. Для окон инструментов для инспекторов, которые помогают в редактировании файла, файл должен быть открыт в активном редакторе или конструкторе, а редактор или дизайнер владеет сохранением. | *Задержка или немедленный коммит*<br /><br /> Чаще всего большой диалог без бесрежимного требует действия для фиксации изменений и допускает операцию "Отмена", которая откатывает любые изменения, внесенные в сеанс диалога.  Это отличает бесрежимный диалог из окна инструмента в окнах инструментов, которые всегда имеют модель немедленного коммита. |
| **Видимость** | *Открыть/создать (файл) и закрыть*<br /><br /> Открытие окон документа осуществляется либо путем открытия существующего документа, либо с помощью шаблона для создания нового документа. Нет никакой \<команды "Открытый конкретный редактор>". | *Скрыть и показать*<br /><br /> Окна инструмента одного экземпляра могут быть скрыты или показаны. Содержимое и состояния в окне инструмента сохраняются независимо от того, находятся ли они в поле зрения или скрыты. Окна инструмента с несколькими экземплярами могут быть закрыты, а также скрыты. При закрытии окна инструмента нескольких экземпляров содержимое и состояние в окне инструмента отбрасываются. | *Запущен из команды*<br /><br /> Диалоги запускаются с командой, основанной на задачах. |
| **Экземпляры** | *Мульти-инстанции*<br /><br /> Несколько редакторов могут быть открыты одновременно и редактировать различные файлы, в то время как некоторые редакторы также позволяют один и тот же файл быть открытым в более чем одном редакторе (с помощью команды **Window &gt; New Window).**<br /><br /> Один редактор может редактировать один или несколько файлов одновременно (конструктор проекта). | *Одиночный или мульти-экземпляр*<br /><br /> Содержимое изменяется, чтобы отразить контекст (как в браузере свойств) или нажмите фокус/контекст на другие окна (Список задач, исследователь решений).<br /><br /> Окна инструментов с одним экземпляром и несколькими экземплярами должны быть связаны с активным окном документа, если нет веских причин не делать этого. | *Одноэкземпляр* |
| **Примеры** | **Текстовые редакторы,** как и редактор кода<br /><br /> **Поверхность конструкции,** как конструктор формы или поверхность моделировать<br /><br /> **Макеты управления, похожие на диалоги,** такие как Manifest Designer | Solution **Explorer** предоставляет решение и проекты, содержащиеся в решении<br /><br /> **Исследователь сервера** предоставляет иерархическое представление серверов и соединений данных, которые пользователь выбирает для открытия в окне. Открытие объекта из иерархии базы данных, например запроса, открывает окно документа и позволяет пользователю отсеивать запрос.<br /><br /> **Браузер свойств** отображает свойства для объекта, выбранного в окне документа, либо в другом окне инструмента. Свойства представлены либо в иерархической представлении сетки, либо в сложных диалоговых элементах управления и позволяют пользователю устанавливать значения для этих свойств. | |

## <a name="tool-windows"></a><a name="BKMK_ToolWindows"></a>Окна инструментов

### <a name="overview"></a>Обзор
Окна инструментов поддерживают работу пользователя, которая происходит в окнах документов. Они могут быть использованы для отображения иерархии, представляющей фундаментальный корневой объект, которым предоставляет Visual Studio, и которым можно манипулировать.

При рассмотрении нового окна инструмента в IDE авторы должны:

- Используйте соответствующие задаче существующие окна инструментов, а не создавайте новые окна с аналогичной функциональностью. Новые окна инструментов должны быть созданы только в том случае, если они предлагают значительно иной «инструмент» или функциональность, которые не могут быть интегрированы в аналогичное окно, или путем превращения существующего окна в поворотный концентратор.

- При необходимости используйте стандартную панель команд в верхней части окна инструмента.

- Будьте в соответствии с шаблонами, уже присутствующими в других окнах инструментов для представления управления и навигации клавиатуры.

- Будьте в соответствии с презентацией управления в других окнах инструментов.

- При этом окна инструментов для конкретных документов автоматически видны, чтобы они появлялись только при активации родительского документа.

- Убедитесь, что их содержимое окна является судоходным на клавиатуре (поддержка клавиш со стрелками).

#### <a name="tool-window-states"></a>Состояния окна инструмента
Окна инструментов Visual Studio имеют различные состояния, некоторые из которых активируются пользователем (например, функция автоматической скрытности). Другие состояния, такие как автоматически видимые, позволяют окнам инструментов отображаться в правильном контексте и скрываться, когда это необходимо. Есть пять состояний окна инструмента в общей сложности.

- **Пристыкованные/закрепленные** окна инструмента могут быть прикреплены к любой из четырех сторон области документа. Значок pushpin отображается в панели заголовка окна инструмента. Окно инструмента может быть пристыковано горизонтально или вертикально вдоль края оболочки и других окон инструмента, а также может быть связано с вкладками.

- **Окна с автоматической скрытой** орудием не закреплены. Окно может выскользнуть из поля зрения, оставляя вкладку (с именем окна инструмента и его значок) на краю области документа. Окно инструмента выскальзывает, когда пользователь парит над вкладкой.

- **Автоматически видимые** окна инструментов автоматически появляются при запуске другой части uI, например редактора, или в фокусе.

- **Плавающие** окна инструмента парят за пределами IDE. Это полезно для конфигураций с несколькими мониторами.

- Окна инструментария **с вкладками** могут быть хорошо пристыкованы к документу. Это полезно для больших окон инструментов, таких как Object Browser, которые нуждаются в большем количестве недвижимости, чем стыковка к краям кадра позволяет.

![Состояния окна инструментов в Visual Studio](../../extensibility/ux-guidelines/media/0702-01_toolwindowstates.png "0702-01_ToolWindowStates")<br />Состояния окна инструментов в Visual Studio

#### <a name="single-instance-and-multi-instance"></a>Одноэкземплярный и мульти-экземпляр
Окна инструментов — это либо один экземпляр, либо несколько экземпляров. Некоторые окна инструментов с одним экземпляром могут быть связаны с активным окном документа, в то время как окна инструментов нескольких экземпляров — нет. Окна инструментов с несколькими экземплярами реагируют на команду **Window &gt; New Window,** создавая новый экземпляр окна. Следующее изображение иллюстрирует окно инструмента, позволяющее команде New Window при активной активности экземпляра окна:

![Окно инструмента, включившее команду «Новое окно» при активной](../../extensibility/ux-guidelines/media/0702-02_toolwindowenablingcommand.png "0702-02_ToolWindowEnablingCommand")<br />Окно инструмента, включившее команду «Новое окно» при активной

Окна инструментов с одним экземпляром могут быть скрыты или отображены, в то время как окна инструментов с несколькими экземплярами могут быть закрыты, а также скрыты. Все окна инструментов могут быть пристыкованы, связаны с вкладками, плавающими или установлены в виде окна для детей с несколькими документами (MDI) (по аналогии с окном документа). Все окна инструментов должны отвечать соответствующим командам управления окнами в меню Window:

![Команды управления окнами в меню окна Visual Studio](../../extensibility/ux-guidelines/media/0702-03_windowmanagementcontrols.png "0702-03_WindowManagementControls")<br />Команды управления окнами в меню окна Visual Studio

#### <a name="document-specific-tool-windows"></a>Окна инструментов для конкретных документов
Некоторые окна инструментов предназначены для изменения на основе данного типа документа. Эти окна постоянно обновляются, чтобы отразить функциональность, применимую к активному окну документа в IDE.

Примерами окон инструментов, содержимое которых изменяется, чтобы отразить выбранный редактор, являются Toolbox и Outline. Эти окна показывают водяной знак, когда редактор имеет фокус, который не предлагает контекст к окну.

#### <a name="navigable-list-tool-windows"></a>Окна инструментов с навигационным списком
В некоторых окнах инструментов отображается список навигационных элементов, с которыми пользователь может взаимодействовать. В этом типе окна всегда должна быть обратная связь для текущего элемента в списке, даже если окно неактивно. Список должен отвечать на команды **GoToNextLocation** и **GoToPrevLocation,** также изменяя выбранный в настоящее время элемент в окне

Примерами навигационных окон списка инструментов являются Solution Explorer и окно поиска результатов.

### <a name="tool-window-types"></a>Типы окнонов инструментов

#### <a name="common-tool-windows-and-their-functions"></a>Общие окна инструментов и их функции

**Иерархические окна инструментов**

| Окно инструмента | Функция |
| --- | --- |
| Обозреватель решений | Иерархическое дерево, отображаев список документов, содержащихся в проектах, различных файлах и элементах решения. Отображение элементов в проектах определяется пакетом, владеющим типом проекта (например, на основе справочных, каталогных или смешанных типов). |
| Представление классов | Иерархическое дерево классов и различные элементы в рабочем наборе документов, независимо от самих файлов. |
| Обозреватель серверов | Иерархическое дерево, отображаевое все серверы и соединения данных в решении. |
| Структура документа | Иерархическая структура активного документа. |

**Окна электроинструмента**

| Окно инструмента | Функция |
| --- | --- |
| Свойства | Сетка, отображая список свойств для выбранного объекта, а также сборщики значений для отправления этих свойств. |
| список задач | Сетка, которая позволяет пользователю создавать/отсеивать/удалять задачи и комментарии. |

**Окна инструментов содержимого**

| Окно инструмента | Функция |
| --- | --- |
| Справка | Окно, которое позволяет пользователям получить доступ к различным методам получения помощи, от "Как я?" видео на форумах MSDN. |
| Динамическая справка | Окно инструмента, отображающие ссылки для помощи тем, применимых к текущему выбору. |
| Обозреватель объектов | Двухкомпонентный кадр со списком компонентов иерархического объекта в левом стене и свойствами и методами объекта в правой колонке. |

**Окна инструментов Dialog**

| Окно инструмента | Функция |
| --- | --- |
| Поиск | Диалог, который позволяет пользователю найти или найти и заменить в различных файлах в рамках решения. |
| Расширенный поиск | Диалог, который позволяет пользователю найти или найти и заменить в различных файлах в рамках решения. |

**Другие окна инструмента**

::: moniker range="vs-2017"

| Окно инструмента | Функция |
| --- | --- |
| Панель элементов | Окно инструмента, используемое для хранения элементов, которые будут сброшены на поверхность дизайна, обеспечивая последовательный источник сопротивления для всех дизайнеров. |
| Начальная страница | Портал пользователя в Visual Studio, с доступом к каналам новостей разработчика, Visual Studio помощь, и последние проекты. Пользователи также могут создавать пользовательские стартовые страницы, копируя файл StartPage.xaml из каталога файлов программы "Common7-IDE"StartPages\" Visual Studio в папку StartPages в каталоге документов Visual Studio, а затем либо редактируя XAML вручную, либо открывая его в Visual Studio или другом редакторе кода. |

::: moniker-end

::: moniker range=">=vs-2019"

| Окно инструмента | Функция |
| --- | --- |
| Панель элементов | Окно инструмента, используемое для хранения элементов, которые будут сброшены на поверхность дизайна, обеспечивая последовательный источник сопротивления для всех дизайнеров. |

::: moniker-end

**Окна инструментов debugger**

| Окно инструмента | Функция |
| --- | --- |
| Автоматические ||
| Немедленно ||
| Вывод | Выходное окно может использоваться всякий раз, когда у вас есть текстовые события или статус для декларировать. |
| Память ||
| Точки останова ||
| Запущен ||
| Документы ||
| Стек вызовов ||
| Локальные ||
| Часы ||
| Дизассемблированный код ||
| Регистры ||
| Потоки ||

## <a name="document-editor-conventions"></a><a name="BKMK_DocumentEditorConventions"></a>Конвенции редактора документов

### <a name="document-interactions"></a>Взаимодействие документов
"Документ хорошо" является крупнейшим пространством в рамках IDE и где пользователь, как правило, сосредоточилсвое свое внимание, с тем чтобы завершить свои задачи, при содействии дополнительных окон инструмента. Редакторы документов представляют основные единицы работы, которые пользователь открывает и сохраняет в Visual Studio. Они сохраняют сильное чувство выбора, связанное с Solution Explorer или другими окнами активной иерархии. Пользователь должен иметь возможность указать на одно из окон иерархии и знать, где содержится документ и его связь либо с решением, проектом, либо с другим корневым объектом, предоставленным пакетом Visual Studio.

Редактирование документов требует постоянного пользовательского опыта. Чтобы позволить пользователю сосредоточиться на задаче, а не на управлении окнами и поиске команд, выберите стратегию представления документов, которая наилучшим образом соответствует задачам пользователя для редактирования этого типа документа.

#### <a name="common-interactions-for-the-document-well"></a>Общие взаимодействия для документа хорошо

- Поддержание последовательной модели взаимодействия в общем опыте **нового файла** и **открытого файла.**

- Обновление связанных функций в соответствующих окнах и меню при открытии окна документа.

- Команды меню соответствующим образом интегрированы в общие меню, такие как **Edit,** **Format**и **View..** Если имеется значительное количество специализированных команд, то может быть создано новое меню. Это новое меню должно быть видно только тогда, когда документ имеет фокус.

- Встроенная панель инструментов может быть помещена в верхней части редактора. Это предпочтительнее иметь отдельную панель инструментов, которая появляется за пределами редактора.

- Всегда поддерживайте выделение в окне Solution Explorer или аналогичном окне активной иерархии.

- Двойное нажатие документа в Solution Explorer должно выполнять те же действия, что и **Open.**

- Если в типе документа может использоваться несколько редакторов, пользователь должен иметь возможность переопределить или сбросить действие по умолчанию на данном типе документа с помощью окна **Open With** dialog путем нажатия правого нажатия на файл и выбора **Open With** из меню ярлыка.

- Не создавайте мастера в документе хорошо.

### <a name="user-expectations-for-specific-document-types"></a>Ожидания пользователей в отношении конкретных типов документов
Существует несколько различных основных типов редакторов документов, и каждый из них имеет набор взаимодействий, которые согласуются с другими одним и тем же типом.

- **Текстовый редактор:** редактор кода, файлы журналов

- **Поверхность конструкции:** WPF формирует дизайнера, формы Windows

- **Редактор в стиле диалогов:** Манифест Дизайнер, свойства проекта

- **Модельный дизайнер:** дизайнер рабочего процесса, кодовая карта, архитектурная диаграмма, прогрессия

Есть также несколько типов нередактора, которые хорошо используют документ. Хотя они сами не отсеивают документы, им необходимо следовать стандартным взаимодействиям для окон документов.

- **Отчеты:** Отчет IntelliTrace, отчет Hyper-V, отчет профайлера

- **Панель мониторинга:** Диагностический концентратор

#### <a name="text-based-editors"></a>Текстовые редакторы

- Документ участвует в модели вкладки предварительного просмотра, что позволяет просматривать документ без его открытия.

- Структура документа может быть представлена в окне сопутствующего инструмента, например, в контуре документа.

- IntelliSense (при необходимости) будет вести себя последовательно с другими редакторами кода.

- Всплывающие действия или вспомогательный uI следуют схожим стилям и шаблонам для существующего аналогичного uI, например CodeLens.

- Сообщения о статусе документа будут представлены в управлении infobar в верхней части документа или в панели статуса.

- Пользователь должен иметь возможность настроить внешний вид шрифтов и цветов с помощью **страницы Tools > Options,** либо общей страницы шрифтов и цветов, либо страницы, конкретной для редактора.

#### <a name="design-surfaces"></a>Поверхность дизайна

- Пустой конструктор должен иметь водяной знак на поверхности с указанием, как начать работу.

- Механизмы переключения представления будут следовать существующим шаблонам, таким как двойное нажатие кнопки, чтобы открыть редактор кода, или вкладки в окне документа, позволяющие взаимодействовать с обеими стеклами.

- Добавление элементов на поверхность конструкции должно осуществляться через Toolbox, за исключением случаев, когда требуется специальное окно инструмента.

- Элементы на поверхности будут следовать последовательной модели выбора.

- Встроенные панели инструментов содержат только команды, связанные с документами, а не общие команды, такие как **Save.**

#### <a name="dialog-style-editors"></a>Редакторы в стиле диалогов

- Схема управления должна следовать обычным конвенциям компоновки диалога.

- Вкладки в редакторе не должны соответствовать внешнему виду вкладок документа, они должны соответствовать одному из двух разрешенных стилей вкладок интерьера.

- Пользователи должны иметь возможность взаимодействовать с элементами управления только с помощью клавиатуры; либо путем активации редактора и табуирования через элементы управления или с помощью стандартной мнемоники.

- Дизайнер должен использовать общую модель Сохранить. На поверхности не следует размещать кнопки общего сохранения или фиксации, хотя другие кнопки могут быть уместными.

#### <a name="model-designers"></a>Модельные дизайнеры

- Пустой конструктор должен иметь водяной знак на поверхности с указанием, как начать работу.

- Добавление элементов на поверхность конструкции должно осуществляться через Toolbox.

- Элементы на поверхности будут следовать последовательной модели выбора.

- Встроенные панели инструментов содержат только команды, связанные с документами, а не общие команды, такие как **Save.**

- Легенда может появиться на поверхности, как показательный, так и водяной знак.

- Пользователь должен иметь возможность настроить внешний вид шрифтов/цветов с помощью **страницы «Инструменты > варианты»,** либо общей страницы шрифтов и цветов, либо страницы, конкретной для редактора.

#### <a name="reports"></a>Отчеты

- Отчеты обычно являются информационными и не участвуют в модели «Сохранение». Тем не менее, они могут включать взаимодействие, такое как ссылки на другую соответствующую информацию или разделы, которые расширяются и разрушаются.

- Большинство команд на поверхности должны быть гиперссылки, а не кнопки.

- Планировка должна включать заголовок и следовать стандартным рекомендациям по планировке отчета.

#### <a name="dashboards"></a>Панели мониторинга

- Панели мониторинга сами не имеют модели взаимодействия, но служат средством для предложения различных других инструментов.

- Они не участвуют в модели Save.

- Пользователи должны иметь возможность взаимодействовать с элементами управления только с помощью клавиатуры, либо путем активации редактора и табуирования через элементы управления или с помощью стандартных мнемоники.

## <a name="dialogs"></a><a name="BKMK_Dialogs"></a>Диалоги

### <a name="introduction"></a>Введение
Диалоги в Visual Studio, как правило, должны поддерживать одну дискретную единицу работы пользователя, а затем быть уволены.

Если вы определили, что вам нужен диалог, у вас есть три варианта, в порядке предпочтения:

1. Интегрируйте свои функции в один из общих диалогов в Visual Studio.

2. Создайте свой собственный диалог, используя шаблон, найденный в существующем аналогичном диалоге.

3. Создайте новый диалог, следуя рекомендациям по взаимодействию и планировке.

В этом разделе описывается, как выбрать правильный шаблон диалога в рабочих процессах Visual Studio и общих конвенциях для проектирования диалогов.

### <a name="themes"></a>Темы
Диалоги в Visual Studio следуют одному из двух основных стилей:

#### <a name="standard-unthemed"></a>Стандартный (нетематический)
Большинство диалогов являются стандартными утилитами и должны быть неподтеченными. Не повторно шаблон общие элементы управления или попытки создать стилизованные "современные" кнопки или элементы управления. Элементы управления и хромированный внешний вид следуют [стандартным рекомендациям по взаимодействию Windows Desktop для диалоговых коробок.](/windows/desktop/uxguide/win-dialog-box)

#### <a name="themed"></a>Тематические
Специальные "подпись" диалоги могут быть тематические. Тематические диалоги имеют отчетливый внешний вид, который также имеет некоторые специальные модели взаимодействия, связанные со стилем. Тема вашего диалога только в том случае, если он отвечает этим требованиям:

- Диалог является общим опытом, который будет рассматриваться и использоваться часто или многими пользователями (например, **диалог нового проекта.**

- Диалог содержит видные элементы бренда продукта (например, диалог **настроек учетных записей).**

- Диалог отображается как неотъемлемая часть большего потока, включающий другие тематические диалоги (например, диалог **add Connected Service).**

- Диалог является важной частью опыта, который играет стратегическую роль в продвижении или дифференциации версии продукта.

При создании тематизированного диалога используйте соответствующие цвета среды и следуйте правильному макету и шаблонам взаимодействия. (См. [Layout для визуальной студии](../../extensibility/ux-guidelines/layout-for-visual-studio.md).)

### <a name="dialog-design"></a>Дизайн диалогов
Хорошо продуманные диалоги учитывают следующие элементы:

- Поддерживаемая задача пользователя

- Стиль диалога текста, язык и терминология

- Контроль выбора и конвенций uI

- Спецификация визуального макета и выравнивание управления

- Доступ с клавиатуры

#### <a name="content-organization"></a>Организация контента
Рассмотрим различия между этими основными типами диалогов:

- [Простые диалоги](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_SimpleDialogs) представляют элементы управления в одном модальном окне. Презентация может включать вариации сложных шаблонов управления, включая сборщик полей или панель значков.

- [Слойные диалоги](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_LayeredDialogs) используются для максимальной отдачи от экранной недвижимости, когда одна часть uI состоит из нескольких групп элементов управления. Группы диалога «слоисты» проходят через элементы управления вкладками, элементы управления списками навигации или кнопки, чтобы пользователь мог выбрать, какую группировку видеть в любой момент времени.

- [Мастера](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Wizards) полезны для направления пользователя через логическую последовательность шагов к завершению задачи. Ряд вариантов предлагается в последовательных панелей, иногда вводя различные рабочие процессы ("ветви") в зависимости от выбора, сделанного в предыдущей панели.

#### <a name="simple-dialogs"></a><a name="BKMK_SimpleDialogs"></a>Простые диалоги
Простой диалог — это презентация элементов управления в одном модальном окне. Эта презентация может включать вариации сложных шаблонов управления, таких как сборщик полей. Для простых диалогов следуйте стандартной общей планировке, а также любому конкретному макету, необходимому для сложных групп управления.

![>Создать сильный ключ имя является примером простого диалога в Visual Studio.](../../extensibility/ux-guidelines/media/0704-01_createstrongnamekey.png "0704-01_CreateStrongNameKey")<br />Создать сильный ключ имя является примером простого диалога в Visual Studio.

#### <a name="layered-dialogs"></a><a name="BKMK_LayeredDialogs"></a>Многоуровневые диалоги
Слойные диалоги включают вкладки, панели мониторинга и встроенные деревья. Они используются для максимизации недвижимости, когда есть несколько групп элементов управления, предлагаемых в одной части uI. Группы слоистые, так что пользователь может выбрать, какую группировку видеть в любой момент времени.

В самом простом случае механизм переключения между группировками является элементом управления вкладками. Есть несколько вариантов. Ознакомьтесь с приоритетами и наслоением, как выбрать наиболее подходящий стиль.

Диалог ** &gt; «Параметры инструментов»** является примером многослойного диалога с использованием встроенного дерева:

![Инструменты > опции является примером многоуровневого диалога в Visual Studio.](../../extensibility/ux-guidelines/media/0704-02_toolsoptions.png "0704-02_ToolsOptions")<br />Инструменты > опции является примером многоуровневого диалога в Visual Studio.

#### <a name="wizards"></a><a name="BKMK_Wizards"></a>Мастера
Мастера полезны для направляя пользователя через логическую последовательность шагов в выполнении задачи. Ряд вариантов предлагается в последовательных панелей, и пользователь должен продолжать через каждый шаг, прежде чем перейти к следующему. После того, как доступны достаточные значения по умолчанию, кнопка **«Завершение»** включена.

 Мастера модальных способов используются для задач, которые:

- Содержат ветвления, где предлагаются различные пути в зависимости от выбора пользователя

- Содержите зависимости между шагами, где последующие шаги зависят от ввода пользователя из предыдущего шага (ы)

- Достаточно сложны, что uI должен использоваться для объяснения предлагаемых вариантов и возможных результатов на каждом этапе

- Являются транзакционными, требующими выполнения набора шагов в полном объеме до внесения каких-либо изменений

### <a name="common-conventions"></a>Общие конвенции
Для достижения оптимального дизайна и функциональности с помощью диалогов следуйте этим конвенциям по размеру диалога, положению, стандартам, конфигурации управления и выравниванию, тексту uI, заголовокбаров, кнопкам управления и клавишам доступа.

Для руководства по конкретным рекомендациям по макету [см.](../../extensibility/ux-guidelines/layout-for-visual-studio.md)

#### <a name="size"></a>Размер
Диалоги должны соответствовать как минимум разрешению экрана 1024x768, а первоначальный размер диалога не должен превышать 900х700 пикселей. Диалоги могут быть изменяемыми, но это не является требованием.

Есть две рекомендации для многоразовых диалогов:

1. Это минимальный размер определяется для диалога, который будет оптимизировать для набора управления без отсечения, и настроить для размещения разумного роста локализации.

2. Этот размер в масштабе пользователя сохраняется от сеанса к сеансу. Например, если пользователь масштабирует диалог до 150%, то последующий запуск диалога будет отображаться на 150%.

#### <a name="position"></a>Положение
Диалоги должны отображаться по центру IDE при первом запуске. Последняя позиция неизменяемых диалогов не требуется, поэтому они будут отображаться по центру последующих запусков.

Для многоизооточенных диалогов размер должен сохраняться при последующих запусках. Для изменяемых модальных диалогов позиция не должна сохраняться. Отображение их по центру IDE предотвращает возможность появления диалога в непредсказуемом или непригодном для пользователя положении при изменении конфигурации дисплея пользователя.

Для безрежимных диалогов, которые могут быть перемещены, позиция пользователя должна быть сохранена при последующих запусках, так как диалог может часто использоваться как неотъемлемая часть большего рабочего процесса.

Когда диалоги должны породить другие диалоги, верхний диалог должен каскадироваться вправо и вниз от родителя, так что пользователю очевидно, что они перешли на новое место.

#### <a name="modality"></a>Модальности
Быть модальным означает, что пользователи должны завершить или отменить диалог перед продолжением. Поскольку модальные диалоги блокируют взаимодействие пользователя с другими частями среды, поток задач объекта должен использовать их как можно экономно. При необходимости операции модальной информации Visual Studio имеет ряд общих диалогов, в которые можно интегрировать свои функции. Если необходимо создать новый диалог, следуйте шаблону взаимодействия существующего диалога с аналогичной функциональностью.

Когда пользователям необходимо выполнять сразу два действия, такие как **«Найти** и **заменить»** при написании нового кода, диалог должен быть беспрезорным, чтобы пользователь мог легко переключаться между ними. Visual Studio обычно использует окна инструментов для такого рода связанных задач, связанных с поддержкой редактора.

#### <a name="control-configuration"></a>Конфигурация управления
Согласуйтесь с существующими конфигурациями управления, которые выполняют то же самое в Visual Studio.

#### <a name="title-bars"></a>Заголовки окна

- Текст в заглавной панели должен отражать название команды, которая запустила его.

- Ни одна значок не должна использоваться в барах заголовков диалогов. В тех случаях, когда система требует одного, используйте логотип Visual Studio.

- Диалоги не должны иметь минимизировать или максимизировать кнопки.

- Кнопки помощи в заглавной панели были унижаются. Не добавляйте их в новые диалоги. Когда они существуют, они должны запустить тему справки, которая концептуально имеет отношение к задаче.

  ![Руководящие спецификации для титульных баров в диалогах Visual Studio](../../extensibility/ux-guidelines/media/0704-03_titlebarspecs.png "0704-03_TitleBarSpecs")<br />Руководящие спецификации для титульных баров в диалогах Visual Studio

#### <a name="control-buttons"></a>Кнопки управления
В общем, **OK,** **Отмена,** и **кнопки справки** должны быть расположены горизонтально в правом нижнем углу диалога. Альтернативный вертикальный стек разрешен, если диалог имеет несколько других кнопок в нижней части диалога, которые представляют визуальную путаницу с кнопками управления.

![Приемлемые конфигурации для кнопок управления в диалогах Visual Studio](../../extensibility/ux-guidelines/media/0704-04_controlbuttonconfig.png "0704-04_ControlButtonConfig")<br />Приемлемые конфигурации для кнопок управления в диалогах Visual Studio

Диалог должен содержать кнопку управления по умолчанию. Чтобы определить, что лучше всего использовать команду по умолчанию, выберите из следующих вариантов (перечисленных в порядке приоритета):

- Выберите самую безопасную и безопасную команду по умолчанию. Это означает, что выбор команды, скорее всего, предотвратит потерю данных и избежит непреднамеренного доступа к системе.

- Если потеря данных и безопасность не являются факторами, выберите команду по умолчанию на основе удобства. Включение наиболее вероятной команды по умолчанию улучшит рабочий процесс пользователя, когда диалог поддерживает частые или повторяющиеся задачи.

Избегайте выбора постоянно разрушительного действия для команды по умолчанию. Если такая команда присутствует, выберите более безопасную команду в качестве по умолчанию.

#### <a name="access-keys"></a>Ключи доступа
Не используйте клавиши доступа для **OK,** **Отмена,** или **Помощь** кнопки. Эти кнопки отображаются для клавиш исключаемых по умолчанию:

| Имя кнопки | Сочетания клавиш |
| --- | --- |
| OK | Введите: |
| Отмена | ESC |
| Справка | F1 |

#### <a name="imagery"></a>Изображения
Используйте изображения экономно в диалогах. Не используйте большие значки в диалогах только для того, чтобы использовать пространство. Используйте изображения только в том случае, если они являются важной частью передачи сообщения пользователю, например, значки предупреждений или анимация состояния.

### <a name="prioritizing-and-layering"></a><a name="BKMK_PrioritizingAndLayering"></a>Приоритеты и наслоения

#### <a name="prioritizing-your-ui"></a>Приоритетное использование вашего uI
Возможно, потребуется вывести определенные элементы uI на передний план и поместить более продвинутое поведение и параметры (включая неясные команды) в диалоги. Выведите широко используемую функциональность на передний план, опередив ее, и сделав ее видимой по умолчанию в uI с текстовой меткой при показе диалога.

#### <a name="layering-your-ui"></a>Укладка вашего uI
Если вы определили, что диалог необходим, но связанные с ним функциональные возможности, которые вы хотите представить пользователю, выходят за рамки того, что может отображаться в простом диалоге, то вам нужно слой пользовательского интерфейса. Наиболее распространенными методами наслоения Visual Studio являются вкладки и коридоры или панели мониторинга. В некоторых случаях регионы, которые могут расширяться и разрушаться, могут быть уместными. Адаптивный интерфейс обычно не рекомендуется в Visual Studio.

Существуют преимущества и недостатки различных методов наложения uI через элементы управления, похожие на вкладки. Просмотрите список ниже, чтобы убедиться, что вы выбираете метод слоев, который подходит для вашей ситуации.

##### <a name="tabbing"></a>Переход по клавише TAB

| Механизм переключения | Преимущества и надлежащее использование | Недостатки и ненадлежащее использование |
| --- | --- | --- |
| Элемент управления табуляции | Логически групповые страницы диалога в связанные наборы<br /><br />Полезно для менее чем пяти (или количество вкладок, которые вписываются в один ряд в диалоге) страниц связанных элементов управления в диалоге<br /><br />Метки вкладок должны быть короткими: одно или два слова, которые могут легко определить содержимое<br /><br />Общий стиль диалога системы<br /><br />Пример: **Свойства &gt; элемента исследователя файлов** | Создание описательных коротких меток может быть затруднено<br /><br />Как правило, не масштабируется последние пять вкладок в одном диалоге<br /><br />Неуместно, если у вас слишком много вкладок для одной строки (использовать альтернативный метод наслоения)<br /><br />Не расширяемый |
| Боковая панель навигации | Простое устройство переключения, которое может вместить больше категорий, чем вкладки<br /><br />Плоский список категорий (без иерархии)<br /><br />Расширение<br /><br />Пример: **Настройте... Добавление &gt; команды** | Не очень хорошее использование горизонтального пространства, если существует менее трех групп<br /><br />Задача может быть лучше подходит для падения вниз |
| Элемент управления "Дерево" | Позволяет для неограниченных категорий<br /><br />Позволяет группировать и/или иерархию категорий<br /><br />Расширение<br /><br />Пример: ** &gt; Параметры инструментов** | Сильно вложенные иерархии могут привести к чрезмерной горизонтальной прокрутке<br /><br />Visual Studio имеет переизбыток видов деревьев |
| Мастер | Помогает с завершением задачи, направляя пользователя через задачи на основе последовательных шагов: мастер представляет задачу высокого уровня, а отдельные панели представляют подзадачи, необходимые для выполнения общей задачи<br /><br />Полезно, когда задача пересекает границы Ui, как, когда пользователь в противном случае придется использовать несколько редакторов и окон инструментов для выполнения задачи<br /><br />Полезно, когда задача требует ветвления<br /><br />Полезно, когда задача содержит зависимости между шагами<br /><br />Полезно, когда несколько аналогичных задач с одной вилкой решения могут быть представлены в одном диалоге, чтобы уменьшить количество различных подобных диалогов | Не подходит для любой задачи, не требуя последовательного рабочего процесса<br /><br />Пользователи могут стать перегружены и путают мастера слишком много шагов<br /><br />Волшебники по своей сути ограниченный экран недвижимости |

##### <a name="hallways-or-dashboards"></a>Прихожие или приборные панели
Прихожие и панели мониторинга представляют собой диалоги или панели, которые служат отправными точками для других диалогов и окон. Хорошо продуманный «коридор» сразу же всплывает только на наиболее распространенные варианты, команды и настройки, что позволяет пользователю легко выполнять общие задачи. Как в реальном мире коридор обеспечивает дверные проемы для доступа к комнатам позади них, здесь менее распространенный uI собирается в отдельные "комнаты" (часто другие диалоги) связанных функций, которые могут быть доступны из главного коридора.

Кроме того, uI, который предлагает все доступные функциональные возможности в одной коллекции, а не рефакторинг менее распространенных функциональных возможностей в отдельные места просто панель мониторинга.

![Концепция прихожей для разоблачения дополнительного uI в Outlook](../../extensibility/ux-guidelines/media/0704-08_hallway.png "0704-08_Hallway")<br />Концепция прихожей для разоблачения дополнительного uI в Outlook

##### <a name="adaptive-ui"></a>Адаптивный пользовательский интерфейс
Отображение или сокрытие пользовательского интерфейса на основе использования или самостоятельного опыта пользователя является еще одним способом представления необходимого пользовательского интерфейса при сокрытии других частей. Это не рекомендуется в Visual Studio, так как алгоритмы для принятия решения о том, когда показывать или скрывать uI, могут быть сложными, и правила всегда будут неправильными для некоторых наборов случаев.

## <a name="projects"></a><a name="BKMK_Projects"></a>Проектов

### <a name="projects-in-the-solution-explorer"></a>Проекты в исследователе решений
Большинство проектов классифицируются как справочные, основанные на каталогах или смешанные. Все три типа проектов поддерживаются одновременно в Solution Explorer. Корень пользовательского опыта работы с проектами происходит внутри этого окна. Хотя различные узлы проекта являются эталонными, каталогными или смешанными типами проектов, существует общий шаблон взаимодействия, который должен быть применен в качестве отправной точки, прежде чем расходиться на шаблоны пользователей, специфичных для проекта.

Проекты всегда должны:

- Поддержка возможности добавления папок проекта для организации содержимого проекта

- Поддержание последовательной модели для сохранения проекта

Проекты должны также поддерживать согласованные модели взаимодействия для:

- Удаление элементов проекта

- Сохранение документов

- Редактирование свойств проекта

- Редактирование проекта в альтернативном представлении

- Операции перетаскивания

### <a name="drag-and-drop-interaction-model"></a>Модель взаимодействия перетаскивания
Проекты обычно классифицируют себя как справочные (способные сохранять только ссылки на элементы проекта в хранилище), основанные на каталоге (способные сохранять только элементы проекта, физически хранящиеся в иерархии проекта), или смешанные (способные сохранять ссылки или физические элементы). IDE вмещает все три типа проектов одновременно в **рамках Solution Explorer.**

С точки зрения перетаскивания, следующие характеристики должны применяться к каждому типу проекта в **рамках Solution Explorer:**

- **Справочный проект:** Ключевым моментом является то, что проект перетаскивает ссылку на элемент в хранилище. Когда эталонный проект выступает в качестве источника для операции перемещения, он должен только удалить ссылку на элемент из проекта. Элемент не должен быть удален с жесткого диска. Когда эталонный проект выступает в качестве мишени для операции перемещения (или копирования), он должен добавить ссылку на исходный элемент, не делая частную копию элемента.

- **Проект на основе каталога:** С точки зрения перетаскивания проект перетаскивается вокруг физического элемента, а не ссылки. Когда проект на основе каталога выступает в качестве источника для операции перемещения, он должен в конечном итоге удалить физический элемент из жесткого диска, а также удалить его из проекта. Когда проект, основанный на каталоге, выступает в качестве мишени для операции перемещения (или копирования), он должен сделать копию элемента исходного кода в его целевом местоположении.

- **Проект смешанного целевого замысла:** С точки зрения перетаскивания поведение этого типа проекта основано на характере перетаскивания элемента (либо ссылка на элемент в хранилище, либо на сам элемент). Правильное поведение для ссылок и физических элементов описано выше.

Если бы в **Solution Explorer**был только один тип проекта, то операции перетаскивания были бы простыми. Поскольку каждая проектная система имеет возможность определять свое собственное поведение перетаскивания, следует соблюдать определенные рекомендации (основанные на поведении Windows Explorer для перетаскивания и падения), чтобы обеспечить предсказуемый пользовательский опыт:

- Неизмененная операция перетаскивания в **Solution Explorer** (когда ни клавиши Ctrl, ни Shift не удерживаются) должна привести к операции перемещения.

- Операция перетаскивания также должна привести к операции перемещения.

- Операция Ctrl-drag должна привести к операции копирования.

- Системы справочных и смешанных проектов поддерживают идею добавления ссылки (или ссылки) на исходный элемент. Когда эти проекты являются целью операции перетаскивания (когда **Ctrl и Shift** удерживается), это должно привести к ссылке на элемент, добавленный в проект

Не все операции перетаскивания являются разумными в различных сочетаниях базисных, основанных на каталогах и смешанных проектов. В частности, проблематично делать вид, что можно разрешить операцию перемещения между исходным проектом на основе каталога и целевым проектом на основе справочника, поскольку проект на основе исходного каталога должен будет удалить исходный элемент по завершении переезда. Затем целевой справочный проект будет в конечном итоге со ссылкой на удаленный элемент.

Также вводит в заблуждение делать вид, что она позволяет копировать операцию между этими типами проектов, поскольку целевой справочный проект не должен делать независимую копию исходного элемента. Аналогичным образом, не допускается перетаскивание ctrl и Shift в целевой проект на основе каталога, поскольку проект на основе каталога не может сохранять ссылки. В тех случаях, когда операция «перетаскивание и падение» не поддерживается, IDE должен запретить падение и показать пользователю курсор без капли (показано в таблице указателей ниже).

Для правильной реализации поведения перетаскивания исходный проект перетаскивания должен донести его характер до целевого проекта. (Например, это ссылка или каталог основе?) Эта информация указана в формате буфера обмена, который предлагает сяоч. В качестве источника операции перетаскивания (или копирования `CF_VSREFPROJECTITEMS` `CF_VSSTGPROJECTITEMS` буфера обмена) проект должен предлагать либо или соответственно, в зависимости от того, основан ли проект на основе справочных или каталогов. Оба этих формата имеют одинаковое содержимое данных, что похоже на `CF_HDROP` формат Windows, за исключением`NULL` того, что `Projref` списки строк, вместо того, чтобы быть именами файлов, представляют собой двойной список строк (как возвращены из `IVsSolution::GetProjrefOfItem` или `::GetProjrefOfProject` по мере необходимости).

В качестве цели падения (или операции буфера обмена), `CF_VSREFPROJECTITEMS` проект `CF_VSSTGPROJECTITEMS`должен принимать как, так и, хотя точная обработка операции перетаскивания варьируется в зависимости от характера целевого проекта и исходного проекта. Проект-источник декларирует свою природу, независимо от того, предлагает `CF_VSREFPROJECTITEMS` он или `CF_VSSTGPROJECTITEMS`. Цель капли понимает свою собственную природу и, таким образом, имеет достаточно информации для принятия решений о том, следует ли выполнять перемещение, копирование или ссылку. Пользователь также изменяет, какие операции перетаскивания должны быть выполнены, нажав клавиши Ctrl, Shift или как Ctrl, так и Shift. Важно, чтобы цель падения правильно указала, какая операция `DragEnter` будет `DragOver` выполнена заранее в ее методах. Solution **Explorer** автоматически знает, являются ли исходный проект и целевой проект одинаковым.

Перетаскивание элементов проекта в экземплярах Visual Studio (например, от одного экземпляра devenv.exe к другому) специально не поддерживается. **Исследователь решений** также непосредственно отстраняет это.

Пользователь всегда должен быть в состоянии определить эффект операции перетаскивания, выбрав элемент, перетащив его в целевое место и наблюдая, какие из следующих указателей мыши отображались до того, как элемент будет удален:

| Указатель мыши | Команда | Описание |
| :---: | --- | --- |
| ![Значок мыши "Не бросать"](../../extensibility/ux-guidelines/media/0706-01_mousenodrop.png "0706-01_MouseNoDrop") | Нет капли | Элемент не может быть удален в указанное место. |
| ![Значок мыши "Копировать"](../../extensibility/ux-guidelines/media/0706-02_mousecopy.png "0706-02_MouseCopy") | Копировать | Элемент будет скопирован в целевое место. |
| ![Значок мыши "Переместить"](../../extensibility/ux-guidelines/media/0706-03_mousemove.png "0706-03_MouseMove") | Переместить | Элемент будет перемещен в целевое место. |
| ![Значок мыши "Добавить ссылку" ](../../extensibility/ux-guidelines/media/0706-04_mouseaddref.png "0706-04_MouseAddRef") | Ссылка, которую нужно добавить | Ссылка на выбранный элемент будет добавлена к целевому местоположению. |

#### <a name="reference-based-projects"></a>Справочные проекты
 В следующей таблице кратко излагаются операции «перетаскивание и падение» (а также операции «перетаскивание/копия/вставки», которые должны выполняться в зависимости от характера исходного элемента и клавиш модификатора, нажатых на целевые проекты, основанные на ссылках:

| Модификатор | Категория | Источник: Ссылка / Ссылка | Элемент источника: Физический элемент`CF_HDROP`или файловая система ( ) |
| --- | --- | --- | --- |
| Нет модификатора | Действие | Переместить | Ссылка |
| Нет модификатора | Назначение | Добавлена ссылка на исходный элемент | Добавлена ссылка на исходный элемент |
| Нет модификатора | Источник | Удаляет ссылку на исходный элемент | Сохраняет исходный элемент |
| Нет модификатора | Результат | `DROPEFFECT_MOVE`возвращается как `::Drop` действие от и элемент остается в исходном месте в хранилище | `DROPEFFECT_LINK`возвращается как `::Drop` действие от и элемент остается в исходном месте в хранилище |
| Сдвиг-Драг | Действие | Переместить | Нет капли |
| Сдвиг-Драг | Назначение | Добавлена ссылка на исходный элемент | Нет капли |
| Сдвиг-Драг | Источник | Удаляет ссылку на исходный элемент | Нет капли |
| Сдвиг-Драг | Результат | `DROPEFFECT_MOVE`возвращается как `::Drop` действие от и элемент остается в исходном месте в хранилище | Нет капли |
| Ctrl-Drag | Действие | Копировать | Нет капли |
| Ctrl-Drag | Назначение | Добавлена ссылка на исходный элемент | Нет капли |
| Ctrl-Drag | Источник | Сохраняет ссылку на исходный элемент | Нет капли |
| Ctrl-Drag | Результат | `DROPEFFECT_COPY`возвращается как `::Drop` действие от и элемент остается в исходном месте в хранилище | Нет капли |
| Ctrl-Shift-Drag | Действие | Ссылка | Ссылка |
| Ctrl-Shift-Drag | Назначение | Добавлена ссылка на исходный элемент | Добавлена ссылка на исходный элемент |
| Ctrl-Shift-Drag | Источник | Сохраняет ссылку на исходный элемент | Сохраняет исходный элемент |
| Ctrl-Shift-Drag | Результат | `DROPEFFECT_LINK`возвращается как `::Drop` действие от и элемент остается в исходном месте в хранилище | `DROPEFFECT_LINK`возвращается как `::Drop` действие от и элемент остается в исходном месте в хранилище |
| Ctrl-Shift-Drag | Примечание | То же самое, что и поведение перетаскивания для ярлыков в Windows Explorer. ||
| Вырезать /вставить | Действие | Переместить | Ссылка |
| Вырезать /вставить | Назначение | Добавлена ссылка на исходный элемент | Добавлена ссылка на исходный элемент |
| Вырезать /вставить | Источник | Сохраняет ссылку на исходный элемент|Сохраняет исходный элемент |
| Вырезать /вставить | Результат | Элемент остается в исходном месте в хранилище | Элемент остается в исходном месте в хранилище |
| Копия/вставить | Действие | Копировать | Ссылка |
| Копия/вставить | Источник | Добавлена ссылка на исходный элемент | Добавлена ссылка на исходный элемент |
| Копия/вставить | Результат | Сохраняет ссылку на исходный элемент | Сохраняет исходный элемент |
| Копия/вставить | Действие | Элемент остается в исходном месте в хранилище | Элемент остается в исходном месте в хранилище |

#### <a name="directory-based-projects"></a>Проекты, основанные на каталогах
В следующей таблице кратко излагаются операции «перетаскивание и падение» (а также операции «вырез/копия/вставки», которые должны выполняться в зависимости от характера исходного элемента и клавиш модификатора, нажатых для целевых проектов на основе каталогов:

| Модификатор | Категория | Источник: Ссылка / Ссылка | Элемент источника: Физический элемент`CF_HDROP`или файловая система ( ) |
|-----------------|----------| - | - |
| Нет модификатора | Действие | Переместить | Переместить |
| Нет модификатора | Назначение | Копирует элемент в целевое местоположение | Копирует элемент в целевое местоположение |
| Нет модификатора | Источник | Удаляет ссылку на исходный элемент | Удаляет ссылку на исходный элемент |
| Сдвиг-Драг | Действие | Переместить | Переместить |
| Сдвиг-Драг | Назначение | Копирует элемент в целевое местоположение | Копирует элемент в целевое местоположение |
| Сдвиг-Драг | Источник | Удаляет ссылку на исходный элемент | Удаляет элемент из исходного местоположения |
| Сдвиг-Драг | Результат | `DROPEFFECT_MOVE`возвращается как `::Drop` действие от и элемент остается в исходном месте в хранилище | `DROPEFFECT_MOVE`возвращается как `::Drop` действие от и элемент остается в исходном месте в хранилище |
| Ctrl-Drag | Действие | Копировать | Копировать |
| Ctrl-Drag | Назначение | Копирует элемент в целевое местоположение | Копирует элемент в целевое местоположение |
| Ctrl-Drag | Источник | Сохраняет ссылку на исходный элемент | Сохраняет ссылку на исходный элемент |
| Ctrl-Drag | Результат | `DROPEFFECT_COPY`возвращается как `::Drop` действие от и элемент остается в исходном месте в хранилище | `DROPEFFECT_COPY`возвращается как `::Drop` действие от и элемент остается в исходном месте в хранилище |
| Ctrl-Shift-Drag | | Нет капли | Нет капли |
| Вырезать /вставить | Действие | Переместить | Переместить |
| Вырезать /вставить | Назначение | Копирует элемент в целевое местоположение | Копирует элемент в целевое местоположение |
| Вырезать /вставить | Источник | Удаляет ссылку на исходный элемент | Удаляет элемент из исходного местоположения |
| Вырезать /вставить | Результат | Элемент остается в исходном месте в хранилище | Элемент удаляется из исходного местоположения в хранилище |
| Копия/вставить | Действие | Копировать | Копировать |
| Копия/вставить | Назначение | Добавлена ссылка на исходный элемент | Копирует элемент в целевое местоположение |
| Копия/вставить | Источник | Сохраняет исходный элемент | Сохраняет исходный элемент |
| Копия/вставить | Результат | Элемент остается в исходном месте в хранилище | Элемент остается в исходном месте хранения ins |

#### <a name="mixed-target-projects"></a>Проекты смешанного целевого класса
В следующей таблице кратко излагаются операции «перетаскивание и падение» (а также операции «перетаскивание/копия/вставки», которые должны выполняться в зависимости от характера исходного элемента и клавиш модификатора, нажатых для проектов смешанного целевого характера:

| Модификатор | Категория | Источник: Ссылка / Ссылка | Элемент источника: Физический элемент`CF_HDROP`или файловая система ( ) |
| --- | --- | --- | --- |
| Нет модификатора | Действие | Переместить | Переместить |
| Нет модификатора | Назначение | Добавлена ссылка на исходный элемент | Копирует элемент в целевое местоположение |
| Нет модификатора | Источник | Удаляет ссылку на исходный элемент | Удаляет ссылку на исходный элемент |
| Нет модификатора | Результат | `DROPEFFECT_ MOVE`возвращается как `::Drop` действие от и элемент остается в исходном месте в хранилище | `DROPEFFECT_ MOVE`возвращается как `::Drop` действие из и элемент удаляется из исходного местоположения в хранилище |
| Сдвиг-Драг | Действие | Переместить | Переместить |
| Сдвиг-Драг | Назначение | Добавлена ссылка на исходный элемент | Копирует элемент в целевое местоположение |
| Сдвиг-Драг | Источник | Удаляет ссылку на исходный элемент | Удаляет элемент из исходного местоположения |
| Сдвиг-Драг | Результат | `DROPEFFECT_ MOVE`возвращается как `::Drop` действие от и элемент остается в исходном месте в хранилище | `DROPEFFECT_ MOVE`возвращается как `::Drop` действие из и элемент удаляется из исходного местоположения в хранилище |
| Ctrl-Drag | Действие | Копировать | Копировать |
| Ctrl-Drag | Назначение | Добавлена ссылка на исходный элемент | Копирует элемент в целевое местоположение |
| Ctrl-Drag | Источник | Сохраняет ссылку на исходный элемент | Сохраняет исходный элемент |
| Ctrl-Drag | Результат | `DROPEFFECT_ COPY`возвращается как `::Drop` действие от и элемент остается в исходном месте в хранилище | `DROPEFFECT_ COPY`возвращается как `::Drop` действие от и элемент остается в исходном месте в хранилище |
| Ctrl-Shift-Drag | Действие | Ссылка | Ссылка |
| Ctrl-Shift-Drag | Назначение | Добавлена ссылка на исходный элемент | Добавлено ссылка на исходный элемент исходного кода |
| Ctrl-Shift-Drag | Источник | Сохраняет ссылку на исходный элемент | Сохраняет исходный элемент |
| Ctrl-Shift-Drag | Результат | `DROPEFFECT_ LINK`возвращается как `::Drop` действие от и элемент остается в исходном месте в хранилище | `DROPEFFECT_ LINK`возвращается как `::Drop` действие от и элемент остается в исходном месте в хранилище |
| Вырезать /вставить | Действие | Переместить | Переместить |
| Вырезать /вставить | Назначение | Копирует элемент в целевое местоположение | Копирует элемент в целевое местоположение |
| Вырезать /вставить | Источник | Удаляет ссылку на исходный элемент | Удаляет элемент из исходного местоположения |
| Вырезать /вставить | Результат | Элемент остается в исходном месте в хранилище | Элемент удаляется из исходного местоположения в хранилище |
| Копия/вставить | Действие | Копировать | Копировать |
| Копия/вставить | Назначение | Добавлена ссылка на исходный элемент | Копирует элемент в целевое местоположение |
| Копия/вставить | Источник | Сохраняет исходный элемент | Сохраняет исходный элемент |
| Копия/вставить | Результат | Элемент остается в исходном месте в хранилище | Элемент остается в исходном месте в хранилище |

Эти детали должны быть приняты во внимание при реализации перетаскивания в **Solution Explorer:**

- Дизайн для нескольких сценариев выбора.

- Имена файлов (полный путь) должны быть уникальными в целевом проекте, иначе падение не должно быть разрешено.

- Имена Фолдера должны быть уникальными (нечувствительными) на уровне, на уровне их откаженного.

- Существуют различия в поведении между файлами, которые открыты или закрыты во время перетаскивания (не упомянутые в сценариях выше).

- Файлы верхнего уровня ведут себя несколько иначе, чем файлы в папках.

Еще одна проблема, о которых следует знать, заключается в том, как обрабатывать операции перемещения по элементам, которые имеют открытые дизайнеры или редакторы. Ожидаемое поведение следующим образом (это относится ко всем типам проектов):

1. Если открытый редактор/дизайнер не имеет каких-либо несохраненных изменений, то окно редактора/дизайнера должно быть молча закрыто.

2. Если у открытого редактора/дизайнера есть несохраненные изменения, то источник перетаскивания должен ждать, пока произойдет падение, а затем попросить пользователя сохранить незафиксированные изменения в открытых документах перед закрытием окна с подсказкой, аналогичной следующему:

    ```
    ==========================================================
         One or more open documents have unsaved changes.
    Do you want to save uncommitted changes before proceeding?
                      [Yes]  [No]  [Cancel]
    ==========================================================
    ```

Это дает пользователю возможность сохранить незавершенную работу до того, как цель сделает свои копии. Для обеспечения такой обработки был добавлен новый метод. `IVsHierarchyDropDataSource2::OnBeforeDropNotify`

Цель будет копировать состояние элемента, как он находится в хранилище (не включая несохраненные изменения в редакторе, если пользователь выбрал **Нет).** После того, как цель завершила копирование (в), `IVsHierarchyDropDataSource::Drop`источник получает возможность завершить удалить `IVsHierarchyDropDataSource::OnDropNotify`часть операции перемещения (в).

Любые редакторы с не сохраненными изменениями должны быть оставлены открытыми. Для этих документов с не сохраненными изменениями это означает, что часть копирования операции перемещения будет выполнена, но часть удаления будет прервана. В сценарии нескольких выборов, когда пользователь выбирает **Нет,** эти документы с не сохраненными изменениями не должны быть закрыты или удалены, но те, которые не сохранили изменения, должны быть закрыты и удалены.
