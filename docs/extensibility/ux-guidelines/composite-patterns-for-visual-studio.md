---
title: Композитные шаблоны для визуальной студии Документы Майкрософт
ms.date: 11/04/2016
ms.topic: conceptual
ms.assetid: e48ecfb2-f4b5-4d3a-b4a2-7a4d62fa4ec0
author: acangialosi
ms.author: anthc
manager: jillfra
ms.workload:
- vssdk
ms.openlocfilehash: 500ea8ffe7c33c1d747590ea074bff43fa1a3ab3
ms.sourcegitcommit: 16a4a5da4a4fd795b46a0869ca2152f2d36e6db2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2020
ms.locfileid: "80698620"
---
# <a name="composite-patterns-for-visual-studio"></a>Составные шаблоны для Visual Studio
Композитные узоры сочетают элементы взаимодействия и дизайна в различных конфигурациях. Некоторые из наиболее важных составных моделей в Visual Studio в отношении согласованности включают в себя:

- [Визуализация данных](../../extensibility/ux-guidelines/composite-patterns-for-visual-studio.md#BKMK_DataVisualization)

- [На объекте uI и заглядывая](../../extensibility/ux-guidelines/composite-patterns-for-visual-studio.md#BKMK_OnObjectUI)

- [Модели выбора](../../extensibility/ux-guidelines/composite-patterns-for-visual-studio.md#BKMK_SelectionModels)

- [Настойчивые и сохраняющие настройки](../../extensibility/ux-guidelines/composite-patterns-for-visual-studio.md#BKMK_PersistenceAndSavingSettings)

- [Сенсорный ввод](../../extensibility/ux-guidelines/composite-patterns-for-visual-studio.md#BKMK_TouchInput)

## <a name="data-visualization"></a><a name="BKMK_DataVisualization"></a>Визуализация данных

### <a name="overview"></a>Обзор
 Диаграммы являются визуальным способом агрегирования и визуализации данных в целях повышения эффективности принятия решений. Они могут помочь пользователям, столкнувшимся с большим количеством данных, но мало смысла видеть, что заслуживает внимания и что, возможно, потребуется действие.

 Пользователь получит выгоду от диаграммы, если какое-либо из следующих условий верно:

- Поможет ли диаграмма пользователям определить задачи, по которой они могут выполнять задачи?

- Позволит ли диаграмма пользователям прогнозировать последствия потенциальных изменений?

- Поможет ли диаграмма пользователям обнаружить тенденции и выявить закономерности?

- Позволит ли диаграмма пользователям принимать более обоснованные решения?

- Поможет ли диаграмма ответить на конкретный вопрос, который может возникнуть у пользователей в данном контексте?

#### <a name="general-rules-for-charts"></a>Общие правила для диаграмм

- Четко метки данных. Иллюстрации без объяснения причин просто красивые фотографии.

- Начните оси с нуля, чтобы избежать перекоса пропорций. Длина строки и размер бара являются важными визуальными сигналами для понимания взаимосвязей между точками данных.

- Создавайте диаграммы, а не инфографику. Инфографика является художественным представлением данных, и их основной целью является визуальное повествование. Диаграммы могут (и должны) быть визуально привлекательными, но пусть данные говорят сами за себя.

- Избегайте скеморфизма, живописных графиков баров, контрастных хэш-меток и других инфографических штрихов.

- Не используйте 3D эффекты в качестве декоративного элемента. Используйте их только в том случае, если они действительно являются неотъемлемой частью способности пользователя осмыслить информацию.

- Избегайте использования нескольких линий и заливок, так как более двух цветов могут сделать этот тип диаграммы трудно читать и интерпретировать правильно.

- Не используйте диаграмму (или любую иллюстрацию) в качестве единственного средства понимания концепции или взаимодействия с данными. Это создает трудности для пользователей с нарушениями зрения.

- Не используйте диаграммы в качестве безвозмездных или декоративных элементов на странице. Другими словами, если диаграмма не добавляет никакой ценности или не помогает пользователям решить проблему, не используйте ее.

### <a name="chart-types"></a>Типы диаграмм
 Типы диаграмм, используемых в Visual Studio, включают диаграммы баров, линейные диаграммы, измененную круговую диаграмму, известную как кольцевая диаграмма или «чарт пончика», временные шкалы, рассеивание участков (также называемых «кластерными диаграммами») и диаграммы Gantt. Каждый тип диаграммы полезен для передачи различных типов информации.

### <a name="other-charting-considerations"></a>Другие соображения, намечающие графики

#### <a name="color"></a>Color
 Существует определенная палитра цветов, определенных для использования в Visual Studio. Палитра доступна для основных типов цветовой слепоты, и цвета могут быть дифференцированы даже при использовании в качестве очень узких ломтиков цвета. Вы можете использовать эти цвета в любой комбинации для любого типа диаграммы или графика в вашем uI. Вам не нужно использовать все семь цветов, если вам не нужно, что многие различные цвета. Эти цвета не были разработаны для использования с любыми элементами переднего плана, поэтому не размещайте текст или глифы поверх этих цветов. Эти оттенки должны быть жестко закодированы и подвергаться настройке пользователя в рамках **«Инструменты > варианты»** (см. [Разоблачать цвета для конечных пользователей).](../../extensibility/ux-guidelines/colors-and-styling-for-visual-studio.md#BKMK_ExposingColorsForEndUsers)

|Образец|Hex|RGB|
|------------|---------|---------|
|![Палитра 71B252](../../extensibility/ux-guidelines/media/0711_71b252.png "0711_71B252")|#71B252|113,178,82|
|![Палитра BF3F00](../../extensibility/ux-guidelines/media/0711_bf3f00.png "0711_BF3F00")|#BF3F00|191,63,0|
|![Палитра FCB714](../../extensibility/ux-guidelines/media/0711_fcb714.png "0711_FCB714")|#FCB714|252,183,20|
|![Палитра 903F8B](../../extensibility/ux-guidelines/media/0711_903f8b.png "0711_903F8B")|#903F8B|144,63,139|
|![Палитра 117AD1](../../extensibility/ux-guidelines/media/0711_117ad1.png "0711_117AD1")|#117AD1|17,122,209|
|![Палитра 79D7F2](../../extensibility/ux-guidelines/media/0711_79d7f2.png "0711_79D7F2")|#79D7F2|121,215,242|
|![Палитра B5B5B5](../../extensibility/ux-guidelines/media/0711_b5b5b5.png "0711_B5B5B5")|#B5B5B5|181,181,181|

## <a name="on-object-ui-and-peeking"></a><a name="BKMK_OnObjectUI"></a>На объекте uI и заглядывая
 Этот раздел дает контекст для заглядывая, также известный как код заглянуть зрения, тип на объекте UI, уникальный для Visual Studio.

### <a name="overview"></a>Обзор

- Пользовательский интерфейс on-object должен предоставить пользователю больше информации или интерактивности, не умаляя его основной задачи.

- Основной шаблон для на-объектный uI в Visual Studio известен как "информация в точке внимания".

- На объекте UI в Visual Studio является либо входящим, либо плавающим и либо прочным, либо временным.

  - Вид кода peek, тип на-объектный uI в Visual Studio, является внеочередным и прочным.

  - CodeLens, тип на объекте UI в Visual Studio, плавает и преходящий

  Понимание того, как работает часть кода, или поиск сведений об этом коде часто требует от разработчика переключения контекста и перехода к другому содержимому или другому окну. Эти изменения контекста могут быть разрушительными, потому что пользователи могут потерять фокус на своей первоначальной задаче, если они покидают свое основное окно. Кроме того, вернуть исходный контекст может быть затруднено, особенно если переключение окон привело к тому, что их исходный код был заслонен другим ими.

  UI on-object следует шаблону, называемому «информация в точке внимания». Эти сообщения, всплывающие окна и диалоговые окна дают пользователям дополнительную, актуальную информацию, которая добавляет разъяснения или интерактивность, не теряя при этом фокуса на их главной задаче. Примеры пользовательского интерфейса на объекте включают всплывающие окна, которые появляются, когда пользователь парит указатель над значком в области уведомлений, красный squiggle под неправильное слово, и взгляд зрения введены в Visual Studio 2013.

### <a name="decision-points"></a>Точки принятия решений
 В Visual Studio существует несколько способов использования этой модели информации в точке внимания. Выбор правильного механизма и его внедрение последовательным и предсказуемым образом имеет важное значение для общего опыта. В противном случае пользователям может быть представлен запутанный или непоследовательный опыт, который отвлекает внимание от самого содержимого.

#### <a name="relationships-between-master-and-detail-content"></a>Отношения между мастером и детальным контентом
 Информация в точке внимания используется для отображения взаимосвязи между контентом, на который ориентирован пользователь ("мастер" содержание) и дополнительным соответствующим содержанием ("детальное" содержимое). В этом шаблоне подробное содержимое явно связано с содержимым, с которым работает пользователь, и может отображаться близко к главному содержимому. Дополнительная информация или информация, которые не могут быть обобщены без подавляющего основного содержимого, должны следовать другому шаблону, например окну инструмента.

- **Всегда** отображайте содержимое детали в непосредственной близости от основного содержимого.

- **Всегда** убедитесь, что подробное содержимое по-прежнему позволяет пользователю оставаться сосредоточенным на главном содержимом. Часто лучший способ достичь этого — сделать содержимое детали как можно ближе к основному содержимому. Это можно сделать, передав содержимое детали во всплывающее окно рядом с мастер-контентом или передав содержимое детали, содеябивое содержимое под основной содержимое.

- **Никогда не** используйте информацию в точке внимания, которая отнимает пользователя от основного содержимого. Если пользователям необходимо просматривать содержимое детали отдельно, навязайте явное действие, которое позволяет пользователю сделать это.

#### <a name="design-details"></a>Детали дизайна
 После того как вы определили, что на объекте UI является правильным выбором, Есть четыре основных соображения дизайна:

1. **Настойчивость:** содержание, как ожидается, будет прочным или переходным?
   Захотят ли пользователи сохранить видимую информацию для обозначения или взаимодействия с ней? Или пользователи захотят быстро взглянуть на информацию, а затем продолжить свою основную задачу?

2. **Тип содержимого:** будет ли контент информационным, действияным или навигационным?
   Нужны ли пользователю дополнительные сведения о главном контенте? Нужно ли пользователю выполнить задачу, которая влияет на основной контент? Или пользователь должен быть направлен на другой ресурс?

3. **Тип индикатора:** имеет ли смысл индикатор окружающей среды?
   Можно ли обобщить информацию полезным способом и отображать без подавляющего основного контента?

4. **жесты:** какие жесты будут использоваться для вызывать и увольнять uI?
   Как пользователь будет поднимать подробное содержимое и отправлять его? Есть ли ценность в добавлении жеста, такого как закрепление для переключения между временными и долговечными состояниями?

   Каждый из этих четырех пунктов принятия решений будет иметь влияние на основные компоненты на объекте UI.

### <a name="on-object-ui-components"></a>Компоненты на объекте uI

1. Тип контейнера (докладчика содержимого)

    - Числа с плавающей запятой

    - Встроенный

2. Тип содержимого

    - Информационные: данные, которые могут быть статичными или динамическими

    - Действия: команды, изменяющие основной контент

    - Навигация: ссылки, которые переходят пользователя в другое окно или приложение, например MSDN

3. Жесты

    - Вызов

    - Увольнения

    - Закрепление

    - Другие взаимодействия

4. Модель настойчивости и фиксации

    - Промежуточный

    - durable

    - Автоматически

    - По запросу

5. Амбиентные индикаторы (необязательно)

    - Squiggle подчеркнуть

    - Значок смарт-тега

    - Прочие индикаторы

#### <a name="container-content-presenter-type"></a>Тип контейнера (докладчика содержимого)
 Есть два основных варианта, доступных для представления содержания в точке внимания:

1. **Inline:** внештатный ведущий, такой как взгляд, который был представлен в редакторе кода Visual Studio 2013, создает пространство для нового контента, перемещая существующий контент.

    - **Предпочитают** внеочередные докладчики, если вы ожидаете, что пользователи захотят потратить значительное количество времени, ссылаясь на содержимое, которое вы представляете, или взаимодействуете с ним.

    - **Избегайте** внеочередных докладчиков, если вы ожидаете, что пользователи захотят взглянуть на информацию, которую вы представляете, а затем продолжить свою основную задачу с минимальными нарушениями.

2. **Плавающий:** плавающий ведущий расположен как можно ближе к выбранного содержимому, но не изменяет расположение существующего содержимого. Различные стратегии могут быть использованы, например, отображение плавающей панели содержимого над ближайшим доступным белым пространством для выбранного символа.

    - **Предпочитают** плавающие докладчики, если вы ожидаете, что пользователи захотят взглянуть на информацию, которую вы представляете, а затем продолжить свою основную задачу с минимальными нарушениями.

    - **Избегайте** плавающих докладчиков, если вы ожидаете, что пользователи захотят потратить значительное количество времени, ссылаясь на или взаимодействуя с контентом, который вы представляете.

#### <a name="content-type"></a>Тип содержимого
 Существует три основных типа содержимого, которые могут отображаться внутри любого контейнера для uI на объекте. Любая комбинация этих типов информации может быть показана. Эти три типа:

1. **Информационный:** большинство контейнеров для uI будут отображать какой-то информационный контент. Содержимое может представлять информацию о нынешнем состоянии окружающей среды или может представлять информацию о потенциальном будущем состоянии окружающей среды. Например, он может использоваться для отображания влияния определенной команды, например рефакторинга, на существующий код.

    - **Всегда** используйте каноническое представление отображаемых данных. Например, код должен выглядеть как код, в комплекте с выделением синтаксиса, и должен уважать любые настройки шрифта и других параметров среды, установленных пользователем.

    - **Всегда** подумайте о поддержке любых действий по поводу информационного контента, которые были бы возможны, если бы та же информация была представлена в качестве основного контента. Например, если он представляет существующий код в контейнере uI на объекте, настоятельно рассмотрите возможность просмотра и изменения этого кода.

    - **Всегда** рассматривайте использовать другой цвет фона если представление информационного содержания которое представляет потенциальное будущее положение.

2. Действия: некоторые контейнеры для uI на объекте обеспечат возможность выполнения некоторых действий по поводу основного содержимого, например, выполнения операции рефакторинга.

    - **Всегда** позиционировать действия команды отдельно от информационного содержания.

    - **Всегда** включайте и отключайте действия, когда это необходимо.

    - **Всегда** ссылайтесь на стандартные руководящие принципы для представления команд внутри диалоговых коробок.

    - **Всегда** свести количество действий, которые разоблачаются в контейнере uI на объекте, до абсолютного минимума. Взаимодействие с интерфейсом on-object должно быть легким и быстрым опытом. Пользователю не следует расходовать энергию на управление самим контейнером пользовательского интерфейса на объекте.

    - **Всегда** подумайте, как и когда контейнер uI на объекте будет закрыт или отклонен. В качестве наилучшей практики любое действие, заключавщее диалог между мастером и детальным содержанием, должно также закрывать контейнер для чата на объекте при вызове этого действия.

3. **Навигационные:** некоторые контейнеры пользовательского интерфейса на объекте включают ссылки, которые переходят пользователя в другое окно или приложение, например, открытие статьи MSDN в веб-браузере пользователя.

    - **Всегда** готовим любую навигационную ссылку с "Открытой", чтобы пользователи не были удивлены переходом на какой-то другой контент.

    - **Всегда** отделяйте навигационные ссылки от действия ссылок.

#### <a name="ambient-indicators-optional"></a>Амбиентные индикаторы (необязательно)
 Амбициозные индикаторы могут быть тонкими, включая текст, представленный в контрастном цвете от остальной части кода, или очевидные, включая символы щекотки, такие как squiggle подчеркивания и смарт-значки тегов. Ambient индикаторы сообщают о наличии дополнительной, соответствующей информации. В идеале они предоставляют полезную информацию, даже не требуя от пользователя взаимодействовать с ними.

- **Всегда** расположите индикатор окружающей среды таким образом, чтобы он не отвлекал или не подавлял пользователя. Если таким образом невозможно позиционировать индикатор окружающей среды, рассмотрите другое решение.

- **Всегда** расположите индикатор окружающего как можно ближе к содержимому, с которым он связан.

- **Всегда** старайтесь создать индикатор, который обобщает информацию, которую он предоставляет. Рассмотрите возможность подсчета количества доступных элементов данных (например, "3 ссылки" вместо просто "Справочников") или придумайте другой способ обобщения данных.

  - В тех случаях, когда данные для индикатора не всегда могут быть вычислены и отображены, немедленно рассмотрите возможность обеспечения прогрессивной обратной связи по мере вычисления значений. Например, следует осмотреть аниматурные изменения, отражающие обновления доступных данных, подобно тому, как обновляется живая плитка электронной почты на Windows Phone по мере увеличения количества непрочитаных писем.

- **Никогда не** добавляйте больше индикаторов, чем пользователь может разумно принять для данного фрагмента содержимого. Амбиентные индикаторы должны быть полезны, не требуя какого-либо взаимодействия с пользователем. Индикаторы теряют свою атмосферу, если они требуют переполнения и других средств управления, чтобы привести их в поле зрения.

#### <a name="gestures"></a>Жесты
 Ключевым аспектом, позволяющим пользователю сохранять фокус на основной контент, является поддержка правильных жестов, чтобы открыть и отклонить дополнительное содержание деталей.

- **Всегда** требуйте от пользователя выполнения некоторых явных жестов, чтобы открыть дополнительное содержимое. Общие открытые жесты включают в себя:

  - **Hover:** инструменты или неинтерактивный информационный контент

  - **Явная команда:** внеливый докладчик

  - **Дважды щелкните индикатор окружающей среды:** Всплывающее окно CodeLens

- **Всегда** отклоняйте содержание деталей всякий раз, когда пользователь нажимает на ключ Esc.

- **Всегда** учитывайте контекст на объекте uI. Для докладчиков контента, которые позволяют взаимодействовать в контейнере, тщательно продумайте, следует ли показывать дополнительную информацию о навистии, что может нанести непосредствение рабочему процессу пользователя.

- **Никогда не** отображайте содержимое на нависке, которое кажется отображенным, или не предлагает взаимодействия с пользователем. Такое поведение может сорвать пользователей, если они пытаются переместить курсор по содержимому детали, так как стандартное поведение для инструмента заключается в том, чтобы немедленно уволить, когда курсор больше не над мастер-контентом, который его произвел.

## <a name="selection-models"></a><a name="BKMK_SelectionModels"></a>Модели выбора

### <a name="overview"></a>Обзор
 Модель выбора — это механизм, используемый для указания и подтверждения операций на одном или нескольких объектах, представляющих интерес в пользовательском интерфейсе. Эта тема обсуждает шаблоны взаимодействия выбора в редакторах документов Visual Studio: текстовые редакторы, поверхности дизайна и поверхности моделирования.

 Пользователи должны иметь способ указывать Visual Studio, над чем они работают, а Visual Studio должна предсказуемо реагировать с обратной связью с пользователями о том, на что она работает. Различия или недопонимание между пользователем и пользовательским интерфейсом могут привести к тому, что пользователь не замечает действия, которые могут иметь непредвиденные последствия. Часто ошибка остается незамеченной до тех пор, пока пользователь не увидит, что что-то отсутствует или изменилось. Поэтому модели выбора являются одним из наиболее важных элементов дизайна пользовательского интерфейса. Хотя модели выбора в Visual Studio согласуются с Windows, есть небольшие вариации.

 В Visual Studio, как и в Windows, модели выбора различаются в зависимости от контекста, в котором происходит взаимодействие. Выбор может происходить в четырех типах объектов:

- Text

- Графические объекты

- Списки и деревья

- Сетки

  В этих объектах существует три типа выделений:

- Смежных

- Непересекающиеся

- Регион

#### <a name="scope"></a>Область
 Наиболее важным компонентом выбора является обеспечение того, чтобы пользователь знал, в каком окне он работает (активация) и где находится фокус (выбор). Visual Studio расширяет функциональность управления окнами в Windows, но схема активации одинакова: взаимодействие с окном придает фокус окну. Visual Studio имеет два индикатора для активации: один для окон документов и один для окон инструментов.

 Для окон документов активное окно указывается вкладкой окна документа, поступающей на переднюю часть и меняющей цвет фона:

 ![Выбор активной вкладки в Visual Studio](../../extensibility/ux-guidelines/media/0713-01_activetab.png "0713-01_ActiveTab")

 **Активный выбор вкладок**

 Для окон инструмента активное окно указывается на изменение цвета области заголовка панели окна инструмента:

 ![Выбор активного окна инструментов в Visual Studio](../../extensibility/ux-guidelines/media/0713-02_activetoolwindow.png "0713-02_ActiveToolWindow")

 **Окно активного инструмента, показывающее первичный выбор узла**

 ![Выбор неактивного окна инструментов в Visual Studio](../../extensibility/ux-guidelines/media/0713-03_inactivetoolwindow.png "0713-03_InactiveToolWindow")

 **Неактивное окно инструмента, показывающее скрытый выбор узла**

 Как только окно активится, его фокус указывается в соответствии с моделями отбора, изложенными в данном разделе руководящих принципов.

#### <a name="context"></a>Контекст
 Visual Studio была разработана, чтобы сохранить сильную концепцию контекста, отслеживая, где работает пользователь. Активен только одно окно, будь то инструмент или окно документа. Однако верхнее окно документа всегда сохраняет скрытый выбор. Хотя фокус может находиться в окне инструмента, окно документа, которое в последний раз активно, отображает выделение, даже в неактивном состоянии. Это делается для того, чтобы сохранить контекст пользователя в редактировании документа, показывая ему, что Visual Studio сохранила свое состояние, чтобы они могли легко вернуться и плавно перемещаться между окнами инструментов и окнами документов.

### <a name="text-selection"></a>Выбор текста
 Редакторы Visual Studio, которые строго текстовы, такие как встроенный текстовый редактор, используют ту же модель выбора текста и внешний вид, описанный на странице [Мыши и Указатели](/windows/desktop/uxguide/inter-mouse) Руководства windows User Experience Взаимодействия на MSDN. Фокус ввода в текстовом редакторе указывается вертикальной панелью, называемой точкой вставки. Точка вставки представляет собой один пиксель толщиной и цветным, как обратное все, что появляется за ним. Он мигает в соответствии со скоростью, установленной **курсом моргания Cursor** в вкладке **Скорость** **клавиатуры** applet в панели управления.

#### <a name="contiguous-and-disjoint-selection"></a>Смежный и разрозненный отбор
 Выбор в текстовом редакторе только смежный. Разрозненные выборы текста не допускаются, но должны быть рассмотрены в графических редакторах объектов. Когда указатель мыши пользователя находится над текстовой областью, курсор изменяется на I-луч. Одним щелчком мыши точка вставки в текстовом редакторе находится в месте нажатия кнопки. Удерживая кнопку мыши вниз начинает выделение выделить и освобождение кнопки мыши заканчивается выделение выделить.

#### <a name="region-selection-box-selection"></a>Выбор региона (выбор коробки)
 Visual Studio поддерживает выбор региона в текстовом редакторе, и это называется выбором коробки. Выбор коробки позволяет пользователю выбрать область текста, которая не соответствует обычному текстовому потоку. Как и в стандартном выборе текста, выбор должен быть смежным. Выбор коробки инициируется путем удержания ключа Alt при перетаскивании с помощью мыши. Выбор коробки также может быть инициирован, удерживая клавиши Alt и Shift при использовании клавиш со стрелками для обозначения региона выбора. Выбор коробки использует обычную выделение выделения и показывает курсор точки вставки, мигающий в конце области выбора.

 ![Региональный &#40;&#41; выбор в Visual Studio](../../extensibility/ux-guidelines/media/0713-04_boxselection.png "0713-04_BoxSelection")

 **Регион (коробка) выбор в Visual Studio**

#### <a name="text-selection-appearance"></a>Внешний вид выбора текста
 Цвета, используемые для активного и неактивного выбора в редакторе, могут быть настроены. Чтобы настроить внешний вид редактора, пользователь может перейти к **Tools > options,** а затем заглянуть под **среду > шрифты и цвета > текстовый редактор**.

### <a name="graphical-selection"></a>Графический отбор

#### <a name="interaction"></a>Взаимодействие
 Выбор графических объектов может быть сложным и зависит от ряда факторов:

- **Основная модель выбора редактора.** Редакторы, содержащие графические объекты, также могут использоваться для редактирования текста или сеток. Например, редактор может быть текстовым редактором, который также поддерживает размещение графических объектов, таких как visual Studio XAML designer. Поддержка нескольких типов объектов может повлиять на то, как пользователь выбирает группы, состоящие из различных типов объектов.

- **Поддержка первичных и вторичных состояний отбора.** Редактор может предоставить первичные и вторичные состояния выбора, чтобы объекты могли редактироваться в унисон, выровнять друг с другом, изменять вместе и так далее.

- **Поддержка редактирования на месте.** Редакторы также могут разрешить редактировать содержимое своих графических объектов. Например, форма прямоугольника может также содержать текст внутри, который может быть изменен пользователем. Кроме того, этот текст может быть сосредоточен или оправдан. Редактирование на месте включает в себя более подробный уровень взаимодействия с пользователем и, следовательно, требует соответствующего набора визуальных сигналов для представления информации о состоянии пользователю.

#### <a name="mouse-interaction"></a>Взаимодействие с мышью

|Входные данные|Результат|
|-----------|------------|
|Нажмите на невыбранный объект|Выберите объект и отображает пунктирной линии и выбора ручки, если объект является изрешеченным.|
|Нажмите на выбранный объект|Активирует редактирование на месте, если объект поддерживает его. Нажатие за пределами объекта отключает режим редактирования на месте.|
|Дважды щелкните объект|Открывает код позади объекта для редактирования и при необходимости может вставить обработчик события по умолчанию.|
|Указать на объект|Изменяет указатель на курсор перемещения. Внешний вид объекта, например его светимость или цвет, может измениться.|
|Укажите на ручку выбора|Изменяет указатель на курсор изменения размера. Для объектов, поддерживающих вращение, некоторые ручки выбора могут изменить указатель на курсор поворота, поскольку указатель расположен по-разному (например, перемещен дальше) в отношении ручки выбора.|
|Перетаскивание|Даже если объект не выбран ранее, изменяйте указатель на курсор перемещения и перемещает объект.|
|Редактор теряет фокус|Деактивирует режим редактирования на месте, хотя объект сохраняет содержимое и внешний вид, который он имел во время последнего состояния операции/выбора.|
|Выбор объектов|Показаны границы, пунктирной линии, или другой визуально различные обработки, чтобы выделить границу объекта.|
|Изменить размер выбранного объекта|Показано ручками выбора.<br /><br /> Изрешеченный объект имеет восемь ручек, представляющих каждое направление, в котором он может быть уменьшен. Меньшее количество ручек может быть использовано, если объект может быть уменьшен только в определенных направлениях. Когда пользователь размеров объекта до тех пор, когда восемь ручек не будут интерактивными, тогда могут быть использованы четыре ручки. Размеры рук должны быть привязаны к оконной границе и метрикам края с функцией **GetSystemMetrics** API размером пропорционально разрешению дисплея.<br /><br /> ![Маркеры изменения размера](../../extensibility/ux-guidelines/media/0713-05_resizehandles.png "0713-05_ResizeHandles")|
|Повернуть выбранный объект|![Маркеры вращения](../../extensibility/ux-guidelines/media/0713-06_rotate.png "0713-06_Rotate")|

#### <a name="keyboard-interaction"></a>Взаимодействие с клавиатурой

|Входные данные|Результат|
|-----------|------------|
|Вкладка|Перемещает индикатор фокусировки среди логического порядка объектов в редакторе. Это может быть слева направо или сверху вниз в зависимости от стоимости свойства **TabIndex** (или эквивалент), порядка создания объекта и общей цели редактора. Shift-Tab меняет направление индикатора фокусировки.|
|Пробел|Активирует режим панорамирования при сохранении нажатия клавиши. Дополнительный вход мыши необходим для панорамирования положения порта представления.|
|Ctrl+ПРОБЕЛ|Активирует режим масштабирования при сохранении нажатия клавиш. Дополнительный ввод мыши необходим для увеличения и уменьшения фактора масштабирования.|
|Знак «Ктрл-Альт»Минус|Уменьшает коэффициент масштабирования на один уровень.|
|Знак Ctrl-Alt-Plus|Увеличивает коэффициент масштабирования на один уровень.|
|Сдвиг или Ctrl|Добавляет объект в группу выбора. Ctrl также позволяет удалять объекты индивидуально из группы выбора.|
|Введите:|Выполняет команду по умолчанию для объекта (обычно open или Edit).|
|F2|Активирует редактирование объекта на месте.|
|Клавиши со стрелками|Перемещает выбранный объект (ы) в направлении нажатия клавиши стрелки небольшими шагами (например, 1 пиксель за раз)|
|Ключи от «Ктрлстрелка»|Перемещает выбранный объект (ы) в направлении нажатия клавиши стрелки, в больших шагом (например, 10 пикселей одновременно)|
|Клавиши Shift-стрелки|Изображает выбранный объект (ы) в соответствующем направлении небольшими приращениями (например, 1 пиксель за раз)|
|Ключи от «Скворум»-Сдвига|Изображает выбранный объект (ы) в соответствующем направлении, более крупными приращениями (например, 10 пикселей одновременно)|

 При речировании элементов управления может быть целесообразно автоматически изменять размер объектов при вхотворе. Например, если пользователь отображает элемент управления меткой, то метка должна вырасти, чтобы отобразить текст, который пользователь только что набрал. Если это не сделано, пользователь должен изменить размер управления вручную после редактирования текста. Если пользователь имеет много элементов управления, это становится гнилой и непродуктивной задачей.

#### <a name="graphical-containers"></a>Графические контейнеры
 В некоторых случаях графические редакторы предоставляют контейнеры для других графических объектов, таких как управление панелью форм Windows или управление решеткой в HTML-дизайнере. Если редактор предоставляет контейнеры для других графических объектов, то следующая модель выбора должна использоваться только для контейнера (объекты в контейнере следуют стандартной модели, как описано выше):

|Входные данные|Результат|
|-----------|------------|
|Однокликна на контейнер|Выберите контейнерный объект без прямого выбора каких-либо из содержащихся объектов. Контейнер может быть перемещен и/или уменьшен со стандартным вводом мыши и клавиатуры (как описано выше). Содержащиеся объекты перемещаются по отношению к контейнеру, но содержащиеся объекты не перемещаются, если они также не выбраны непосредственно.|
|Нависает над пограничной областью контейнера|Превращает мышь в курсор перемещения, указывая, что контейнер может быть перемещен.|
|Перетащите границу контейнера|Изменяет мышь в курсор перемещения и перемещает контейнер (и содержащиеся объекты внутри). Контейнер не может быть перемещен без предварительного выбора одним щелчком мыши.|
|Однокликна на объект в контейнере|Выберите контейнер (если выбран) и выберите только нажатый объект.|
|Сдвиг/клик или ctrl-нажмите на содержащийся объект и /или контейнер|Добавляет нажатый объект в существующую группу выбора или выбора. Если нажатый объект уже является членом группы отбора, он удаляется из группы выбора.|

 Содержащиеся объекты должны соответствовать базовой модели выбора, описанной в предыдущем разделе. От тестирования удобства использования конструктора Windows Forms пользователи ожидали беспрепятственного доступа к содержащимся объектам без промежуточных шагов (навязанных объектом сдерживания).

#### <a name="disjoint-and-region-selections"></a>Разрозненные и региональные выборы
 Графические редакторы объектов должны поддерживать разрозненные выборы. Обратите внимание, что на этом рисунке не показан внешний вид управления для Visual Studio. Смотрите [внешний вид выбора графических объектов](../../extensibility/ux-guidelines/composite-patterns-for-visual-studio.md#BKMK_GraphicalObjectSelectionAppearance) для подробных визуальных спецификаций.

 ![Раздельные и областные селекторы](../../extensibility/ux-guidelines/media/0713-07_disjointregionselectors.png "0713-07_DisjointRegionSelectors")

 **Разрозненный отбор**

 Графические редакторы должны также предоставлять выбор региона с индикатором выбора типа шатер. Если графический редактор поддерживает другие типы объектов (например, текст), то выделение региона может быть невозможно в зависимости от ограничений этих других типов объектов.

 ![Область выделения](../../extensibility/ux-guidelines/media/0713-08_marqueeselection.png "0713-08_MarqueeSelection")

 **Область выделения**

#### <a name="primary-and-secondary-selections"></a>Первичный и вторичный выбор
 Некоторые графические редакторы объектов позволяют пользователю редактировать или выравнивать объекты в группах. В этом случае необходимо ввести понятие первичного и вторичного отбора. Основной выбор — это объект, на который все остальные объекты отвечают за групповые операции. Объект, выбранный пользователем, становится основным элементачом, а последующие выделения — вторичными выборами. Первичный отбор имеет четкое визуальное лечение из вторичного отбора (ы), чтобы указать, какой объект является первичным:

 ![Выбор основного и дополнительного выделенных объектов](../../extensibility/ux-guidelines/media/0713-09_primarysecondary.png "0713-09_PrimarySecondary")

 **Первичный отбор с двумя вторичными выборами**

#### <a name="graphical-object-selection-appearance"></a><a name="BKMK_GraphicalObjectSelectionAppearance"></a>Внешний вид выбора графических объектов
 Ручки выбора представляют собой квадраты, нарисованные прямоугольным узором вокруг ограничивающего ящика объекта. На приведенной ниже диаграмме приведены примеры различных состояний, которые графический объект может иметь с ручкой, размером и видом редактирования на месте. Размер декнокций должен быть привязан к оконной границе и метрикам края с помощью API **GetSystemMetrics.**

| Состояние | Вид | Визуальные детали |
|-------------------------|---------------| - |
| **Unselected** | Значение по умолчанию | ![Состояние кнопки по умолчанию](../../extensibility/ux-guidelines/media/0713-10_defaultstate.png "0713-10_DefaultState") |
| **Первичный отбор** | Изменение размера | ![Основной выделенный объект с маркерами изменения размера](../../extensibility/ux-guidelines/media/0713-11_primaryresize.png "0713-11_PrimaryResize") |
| **Первичный отбор** | Не изменяемые | ![Основной выделенный объект без маркеров изменения размера](../../extensibility/ux-guidelines/media/0713-13_primarynoresize.png "0713-13_PrimaryNoResize") |
| **Первичный отбор** | Заблокировано | ![Заблокированный основной выделенный объект](../../extensibility/ux-guidelines/media/0713-15_primarylocked.png "0713-15_PrimaryLocked") |
| **Вторичный отбор** | Изменение размера | ![Дополнительный выделенный объект с маркерами изменения размера](../../extensibility/ux-guidelines/media/0713-17_secondaryresize.png "0713-17_SecondaryResize") |
| **Вторичный отбор** | Не изменяемые | ![Дополнительный выделенный объект без маркеров изменения размера](../../extensibility/ux-guidelines/media/0713-19_secondarynoresize.png "0713-19_SecondaryNoResize") |
| **Вторичный отбор** | Заблокировано | ![Заблокированный дополнительный выделенный объект](../../extensibility/ux-guidelines/media/0713-21_secondarylocked.png "0713-21_SecondaryLocked") |
| **UI активный** | Значение по умолчанию | ![Активное состояние пользовательского интерфейса](../../extensibility/ux-guidelines/media/0713-23_uiactive.png "0713-23_UIActive") |

### <a name="view-selection-models"></a>Просмотр моделей выбора

#### <a name="tree-view"></a>Структура в виде дерева
 Выбор в представлении дерева отображается с помощью простой подсветки. Если пользователь нажимает на имя узла или значок узла, узла выбирается. Треугольные глифы слева от узла расширяют или сжимают управление деревом, но не влияют на выбор пользователя, за одним исключением: при падении родительского узла, когда выбор находится на ребенке этого узла, выбор перемещается к родителю.

 ![Типичное представление в виде дерева в Visual Studio](../../extensibility/ux-guidelines/media/0713-25_treeview.png "0713-25_TreeView")

 **Типичное представление в виде дерева в Visual Studio**

 Виды деревьев могут поддерживать смежные и разрозненные выделения, даже на нескольких уровнях дерева. Смежные или разрозненные несколько выделений должны быть сделаны на видимых узлах дерева. Если узла разрушается, разрозненный выбор теряется, и узла, который был разрушен, получает выбор. Таким образом, пользователь может видеть узлы, которые будут затронуты операцией. При обрушении узлов становится неясным, какие узлы могут быть затронуты.

 При выборе родительского узла операция должна применяться к родителю, хотя могут быть случаи, когда операция имеет смысл примениться к родителю и всем его детям. В этом случае предоставьте пользователю дополнительный пользовательский интерфейс во время операции, например, флажок или диалог подтверждения, чтобы сделать опцию "применить ко всем детям" явным.

##### <a name="renaming"></a>Переименование
 Если узлы в дереве поддерживают переименование, переименование должно быть сделано на месте. Операция на месте должна быть стандартом во всех элементах управления деревьями в Visual Studio. Предоставьте команду переименования, которая немедленно активирует режим редактирования на месте, с выбором текста, охватывающим все имя узла, готовым принимать пользовательский вход. Если узла представляет файл, имя файла должно содержать расширение. Выделение должно включать только тело имя файла, а не расширение.

|Входные данные|Результат|
|-----------|------------|
|ВВОД - клавиша|Совершает операцию переименования|
|Клавиша ESC|Отменяет операцию переименования|
|Нажатие за пределы области отсвачения места|Совершает операцию переименования|
|Отмена|Обеспечить легкое отменить операцию переименования|

#### <a name="selection-within-lists-and-grid-controls"></a>Выбор в списках и элементах управления сеткой
 Ключевая концепция выбора списка заключается в том, что он основан на строке, а это означает, что при выборе весь ряд выбирается как единое целое. В отличие от этого, сетки могут позволить выбрать определенные ячейки, не влияя на любой другой аспект строки. Сетки также могут содержать иерархию вложенных строк (например, в TreeGrid), которые позволяют выбрать и отобрать целые ветви иерархии, взаимодействуя с родительскими строками. Выбор в списках отображается простым цветом выделения на всем ряду данных. Фокус отображается однопиксельной пунктирной границей вокруг текущего редактируемого ряда или ячейки (строка, если все ячейки читаются только по чтению).

> [!NOTE]
> **Фокус** и **выбор** – это разные понятия. *Фокус* — это указание того, какой элемент uI предназначен для получения входных данных, прямо не направленных на другой объект, в то время как *выбор* относится к состоянию включения объекта в набор объектов, на которых могут происходить последующие операции.

 Выбор ы в списках может быть смежным, разрозненным или регионом. При допустимом выделении нескольких вариантов всегда следует поддерживать смежный и разрозненный выбор, в то время как поддержка выбора региона (коробки) не является обязательной. Выбор региона инициируется путем перетаскивания в белом пространстве тела списка.

| Объект | Выбор |
|--------|------------|
| Список | Смежных |
| Список | Непересекающиеся |
| Список | Регион |

 Нажатие один раз в списке выбирает строку, где произошел клик. Если пользователь нажимает на ячейку списка, поддерживающую редактирование на месте, ячейка также немедленно активируется для редактирования на месте. В противном случае, весь ряд немедленно выбран и показывает изюминку.

 Перетаскивание в теле списка делает одну из трех вещей:

- Инициирует выделение региона, если список поддерживает его, а мышь-вниз находится в белом пространстве

- Инициирует операцию перетаскивания/падения, если ячейка списка или строка поддерживает то, что источник перетаскивания

- Выберите текущую строку

##### <a name="in-place-editing"></a>Редактирование на месте
 Когда на месте редактирование разрешено, есть две основные модели: простой контроль редактирования и сборщик свойств. С помощью простого управления редактированием содержимое выделяется и готово к ввода пользователя, как только будет активировано редактирование на месте. В случае реализации набирателя свойств кнопка, которая вызывает сборщик айтера свойств, отображается после активации режима редактирования на месте, а текущий выбор не выделяется. Кнопка сборщика должна быть оправдана в ячейке. Примеры редактирования на месте смотрите в визуальной студии **окно свойств** и **список задач.**

##### <a name="keyboard-support"></a>Поддержка клавиатуры
 Поддержка клавиатуры для выбора в списках и сетках соответствует стандартным конвенциям Windows:

- Клавиши стрелки перемещаются по списку, выбирая каждую строку/ячейку при перемещении фокуса.

- Стрелка Shift и выполняет смежный отбор в направлении клавиш стрелки.

- Стрелка Ctrl, за которой следует Spacebar, переключается между добавлением и удалением элементов списка из выделения, создавая разрозненный выбор.

- Для сеток, содержащих вложенные иерархии, ключ Правой Стрелки расширяет родительский ряд, а ключ Левой стрелы разрушается один.

- Ключ вкладки перемещает фокус между ячейками в текущем ряду, если ячейки рефлективны.

- Ключ Enter выполняет команду по умолчанию в элементе в списке (часто **открытый).**

- Ключ F2 активирует редактирование на месте для выбранной в настоящее время ячейки.

## <a name="persistence-and-saving-settings"></a><a name="BKMK_PersistenceAndSavingSettings"></a>Настойчивые и сохраняющие настройки

### <a name="overview"></a>Обзор
 Хотя каждый компонент программного обеспечения в Visual Studio обычно отвечает за свое состояние и настойчивость, Visual Studio автоматически сохраняет настройки в некоторых случаях, например, с размерами окон и позициями. Приведенная ниже таблица представляет собой комбинацию параметров, сохраненных автоматически, и настроек, требующих явного пользователя или запрограммированных действий.

|Объект|Что сохранить|Когда экономить|Где сэкономить|
|------------|------------------|------------------|-------------------|
|Выбираемый объект (например, строка кода)|Точка разрыва на строке кода<br /><br /> Ярлык пользователя, связанный с строкой кода|При сохранении проекта|Файл **опций пользователя (.suo)** для проекта|
|Диалог|Расположение диалога, если бы оно было перемещено<br /><br /> Представление, которое пользователь в последний раз использовал в диалоге|Когда диалог закрывается<br /><br /> По окончании сеанса Visual Studio|В памяти<br /><br /> Регистрация в **HKEY_Current_User**|
|Окно|Размер и расположение окна|Когда окно закрывается<br /><br /> При изменении режима Visual Studio<br /><br /> По окончании сеанса Visual Studio|Файл **опций пользователя (.suo)** для проекта<br /><br /> Пользовательские параметры файла для настроек окна|
|Документ|Текущий выбор в документе<br /><br /> Представление документа<br /><br /> Последние несколько мест, которые посетил пользователь|При сохранении документа|Файл **опций пользователя (.suo)** для проекта|
|Проект|Ссылки на файлы<br /><br /> Ссылки на каталоги на диске<br /><br /> Ссылки на другое программное обеспечение<br /><br /> Компоненты<br /><br /> Государственная информация о самом проекте|При сохранении проекта|Файл проекта|
|Решение|Ссылки на проекты<br /><br /> Ссылки на файлы|При сохранении проекта или решения|Файл **решения (.sln)**|
|Настройки в **> опций инструментов**|Настройки клавиатуры<br /><br /> Настройки панели инструментов<br /><br /> Цветовые схемы|Когда диалог **«Инструменты > опции»** закрывается<br /><br /> По окончании сеанса Visual Studio|Регистрация в **HKEY_Current_User**|

 То, что пользователь делает, и когда он это делает, диктует ли параметр сохраняется в памяти (во время сеанса), сохраняется на диске (через сеансы в качестве настройки реестра), как часть самого файла проекта или решения, как часть **параметра решений (.suo)** файл, или как пользовательский файл параметров, о которых знает только этот компонент программного обеспечения. В таблице выше показаны несколько событий, при которых настройки могут быть сохранены. Однако, Есть другие времена, в которых вы можете сохранить состояние:

- Когда пользователь изменяет местоположение в диалоге или окне

- Когда пользователь передает фокус в другое окно

- Когда пользователь переключается с дизайна на режим отладки

- Когда пользователь регистрирует свою учетную запись

- Когда компьютер переходит в спячку или выключается

- Когда компьютер/жесткий диск вот-вот будет переформатирован и настроен снова

### <a name="window-configurations"></a>Конфигурации окон
 Конфигурация окна является основной презентацией среды разработки - это схема, состоящая из списка окон инструментов, присутствующих и способ, в котором они расположены. Для окон, управляемых IDE (окнаI IDE), информация о компоновке сохраняется на пользователя, поэтому, когда пользователь запускает IDE, макет окна отображается так же, как и при выходе из Visual Studio. Состояние и положение окон IDE сохраняется в пользовательском файле опций в формате XML. Окна инструментов, создаваемые пакетами, загруженными в IDE, сохраняют свою информацию о состоянии в реестре и могут быть или не быть на пользователя.

#### <a name="profile-specific-layouts"></a>Макеты для конкретных профилей
 Каждый профиль включает в себя макеты окнонов инструментов, организованные в порядке, знакомом конкретным деноминациям (разработчики Visual C' ожидают увидеть **Solution Explorer** на левой стороне IDE, в то время как разработчики C's ожидают увидеть **Solution Explorer** справа). Макеты окон, специфичные для профиля, загружаются после того, как пользователь выбирает профиль в запуске. Автор пакета должен определить макет окна, наиболее подходящий для работы клиента, зная, что изменения, внесенные пользователем в конфигурацию окна, будут сохраняться.

## <a name="touch-input"></a><a name="BKMK_TouchInput"></a>Сенсорный ввод
 Пользователи все чаще используют продукты разработки Майкрософт на сенсорных устройствах. Однако существуют барьеры, которые затрудняют использование средств разработки на сенсорных устройствах. Пользователи будут ожидать, что наши продукты обеспечат надежный и точный сенсорный опыт. Цель этих руководящих принципов заключается в информировании о решениях о том, какие сенсорные возможности для включения и поощрять последовательное сенсорное опыт через Visual Studio и связанных с ними продуктов.

### <a name="levels-of-experience"></a>Уровни опыта
 Следующие уровни опыта призваны служить в качестве руководства, чтобы помочь командам решить, какие возможности касания предложить на основе желаемого уровня инвестиционного интереса в контакте.

- **Основной опыт** для команд, которые хотят предоставить сенсорные возможности, чтобы не было тупиков на протяжении всей их работы.

- **Оптимизированный опыт** предназначен для команд, которые хотят предоставить наиболее распространенные сенсорные возможности (например, те, которые обычно доступны в приложениях для интернет-браузеров).

- **Повышенный опыт** предназначен для команд, которые хотят добавить такие возможности, как жесты или другие дополнительные возможности, которые могут сделать их приложение сенсорным.

||Базовый опыт|Оптимизированный опыт|Повышенный опыт|
|-|----------------------|--------------------------|-------------------------|
|Позволяет пользователям ...|Исправление кода и чтения на уровне решения/проекта без тупиков|Выполнение задач по техническому обслуживанию, рефактории и навигации|Работайте в последовательном, интуитивном и плавном опыте с уверенностью|
|Редактор|Сенсорный панорамирование и выбор<br /><br /> Прикосновение прокрутки, чтобы прыгать и нажимать|Пинч зум<br /><br /> Быстрый прокрутки<br /><br /> Выбор<br /><br /> Простое использование контекстного меню||
|Лучшие окна инструмента|Список панорамирования<br /><br /> Выбор элементов<br /><br /> Прикосновение прокрутки, чтобы прыгать и нажимать|Легкая прокрутка и выбор элементов||
|Оконное расширение||Окно размера размера<br /><br /> Быстрый доступ||
|Документ хорошо||Легкая навигация между открытыми файлами||
|Жесты||Обеспечить работу общих жестов по всему IDE|Действия, основанные на жестах<br /><br /> Поддержка перетаскивания и дизайнеров|
|Другие замечания|||Пользовательская экранная клавиатура|

#### <a name="gestures"></a>Жесты
 Жесты предоставляют пользователям ярлык для команд, которые в противном случае могут потребовать более сложного взаимодействия. Обратитесь к руководящим принципам Windows по [общим сенсорным жестам для настольных приложений](/windows/desktop/wintouch/windows-touch-gestures-overview)и следуйте этому руководству для большинства жестов, включая простые жесты, такие как панорамирование и масштабирование.
