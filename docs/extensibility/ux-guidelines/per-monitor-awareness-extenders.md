---
title: Для каждого монитора Awareness support для средств расширения Visual Studio
titleSuffix: ''
description: Дополнительные сведения о новой поддержки расширителя для каждого monitor-awareness доступны в Visual Studio 2019.
ms.date: 04/10/2019
helpviewer_keywords:
- Visual Studio, PMA, per-monitor-awareness, extenders, Windows Forms
- Per-Monitor Awareness support for extenders
ms.assetid: ''
author: rub8n
ms.author: rurios
manager: anthc
ms.prod: visual-studio-windows
monikerRange: vs-2019
ms.technology: vs-ide-general
ms.topic: reference
ms.workload:
- multiple
ms.openlocfilehash: 44938c5753491521702867398a514f770cf831fb
ms.sourcegitcommit: 94b3a052fb1229c7e7f8804b09c1d403385c7630
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62793647"
---
# <a name="per-monitor-awareness-support-for-visual-studio-extenders"></a>Для каждого монитора Awareness support для средств расширения Visual Studio
Версий, предшествующих Visual Studio 2019 было контексте awareness точек на ДЮЙМ, установить система поддерживает функции, а не учитывать точек на ДЮЙМ (PMA) для каждого монитора. Выполнение в системе awareness привело к снижению visual возможности (например нечетким шрифты или значков) каждый раз, когда Visual Studio пришлось визуализации на мониторах с отличающимися масштабами факторов или удаленный компьютер в машин с помощью разных конфигурациях например (различных Windows масштабирование).

Контексте awareness DPI 2019 г. Visual Studio будет задан PMA, когда среде поддерживает его, что позволяет Visual Studio для подготовки к просмотру в соответствии с конфигурацией области отображения, в котором она размещена, а не в одной системе заданной конфигурации. В конечном счете перевод на всегда четкое пользовательский Интерфейс для зон, которые поддерживают режим PMA.

Ссылаться на [высокий уровень разработки приложений рабочего стола DPI в Windows](https://docs.microsoft.com/windows/desktop/hidpi/high-dpi-desktop-application-development-on-windows) Дополнительные сведения об условиях и общий сценарий, рассматриваемые в данном документе.

## <a name="quickstart"></a>Краткое руководство
- Убедитесь, Visual Studio выполняется в режиме PMA (см. в разделе **Включение PMA**)

- Успешно проходят проверку вашего расширения работает через ряд распространенных сценариев (см. в разделе **тестирование расширений для проблемы PMA**)

- Если вы обнаружили проблемы, стратегии и рекомендации, описанные в этом документе можно использовать для диагностики и устранения этих проблем. Также необходимо добавить новый [Microsoft.VisualStudio.DpiAwareness](https://www.nuget.org/packages/Microsoft.VisualStudio.DpiAwareness/) проект для доступа к API требуется пакет NuGet.

## <a name="enabling-pma"></a>Включение PMA
Чтобы включить PMA в Visual Studio, следует соблюдать следующие требования:
1) Windows 10 апреля 2018 г. обновление (v1803 RS4) или более поздней версии
2) .NET framework 4.8 RTM или более поздней версии
3) Visual Studio 2019 с [«Оптимизация отрисовки для экранов с различным плотности»](https://docs.microsoft.com/visualstudio/ide/reference/general-environment-options-dialog-box?view=vs-2019) параметр включен

Если эти требования выполняются, Visual Studio автоматически включает режим PMA всех этапах процесса.

> [!NOTE]
> Содержимое Windows Forms в Visual STUDIO (например, браузер свойств) будет поддерживать PMA только в том случае, если у вас есть Visual Studio 2019 обновлением #1.

## <a name="testing-your-extensions-for-pma-issues"></a>Тестирование расширений для PMA проблемы

Visual Studio официально поддерживает платформы WPF, Windows Forms, Win32 и пользовательского интерфейса HTML/JS. Когда Visual Studio переключается в режим PMA, каждого пользовательского интерфейса стека работает по-разному. Таким образом независимо от платформы пользовательского интерфейса, рекомендуется, чтобы убедиться, что элементы пользовательского интерфейса совместим с режимом PMA выполняется тестового прохода.

Рекомендуется проверить следующие распространенные сценарии:

1. Изменение коэффициент масштабирования среды одного монитора, пока приложение находится выполнения *
    - Этот сценарий позволяет проверить, что пользовательского интерфейса отвечает на динамическое изменение точек на ДЮЙМ Windows

2. Стыковка и Отстыковка портативного компьютера, где присоединенного монитора установлен в основной и вложенные монитор имеет разные масштаб чем переносной компьютер во время работы приложения.
    - Этот сценарий позволяет проверить, что пользовательского интерфейса отвечает на экран изменения DPI, а также обработка отображает динамически добавления или удаления

3. Наличие несколько мониторов с отличающимися масштабами факторов и перемещение приложения между ними.
    - Этот сценарий позволяет проверить, что пользовательского интерфейса отвечает на изменения DPI отображения
    
4. Удаленное взаимодействие на компьютер при локальном и удаленном компьютерах у различных масштаба для основного монитора.
    - Этот сценарий позволяет проверить, что пользовательского интерфейса отвечает на динамическое изменение точек на ДЮЙМ Windows

Это удобно предварительные проверить ли пользовательский Интерфейс могут возникнуть проблемы является ли код использует *Microsoft.VisualStudio.Utilities.Dpi.DpiHelper*, *Microsoft.VisualStudio.PlatformUI.DpiHelper*, или *VsUI::CDpiHelper* классы. Эти старые DpiHelper классы поддерживают только системы поддержка dpi и не всегда правильно функционировать, когда процесс является PMA.

Типичное применение этих DpiHelpers выглядят следующим образом:

```cs
Point screenTopRight = logicalBounds.TopRight.LogicalToDeviceUnits();

POINT screenIntTopRight = new POINT
{
    x = (int)screenTopRIght.X,
    y = (int)screenTopRIght.Y
}

// Declared via P/Invoke
IntPtr monitor = MonitorFromPoint(screenIntTopRight, MONITOR_DEFAULTTONEARST);
```

В предыдущем примере прямоугольник, представляющий логические границы окна преобразуется в единицы устройства, таким образом, можно передать собственный метод MonitorFromPoint, ожидает, что координаты устройства для возвращения назад указатель точные монитора.

### <a name="classes-of-issues"></a>Классы проблем
При включении режима PMA для Visual Studio, пользовательский Интерфейс может реплицировать проблемы стандартными способами. Многие, если не все эти проблемы может произойти в любой из поддерживаемых платформ пользовательского интерфейса Visual Studio. Кроме того, эти проблемы также может произойти, если часть пользовательского интерфейса размещается в смешанном режиме разрешение DPI, сценарии (см. Windows [документации](https://docs.microsoft.com/windows/desktop/hidpi/high-dpi-desktop-application-development-on-windows) для получения дополнительных сведений). 

#### <a name="win32-window-creation"></a>Создание окна Win32
При создании windows с помощью CreateWindow() или CreateWindowEx(), распространенный подход заключается в том, чтобы создать окно с координатами (0,0) (левый верхний угол основного монитора), затем переместить его последняя позиция. Тем не менее это может привести к окна, чтобы активировать на ДЮЙМ изменить сообщение или событие, которое можно повторно активируйте другие сообщения пользовательского интерфейса или события и со временем привести к нежелательным поведением или подготовки отчетов.

#### <a name="wpf-element-placement"></a>Размещение элемента WPF
При перемещении элементов WPF, с помощью старого Microsoft.VisualStudio.Utilities.Dpi.DpiHelper, координаты верхнего левого может не быть вычислена правильно всякий раз, когда элементы находятся на неосновной точек на ДЮЙМ.

#### <a name="serialization-of-ui-element-sizes-or-positions"></a>Сериализация размерами элементов пользовательского интерфейса или позиции
При восстановлении в другом контексте точек на ДЮЙМ, чем он был сохранен в пользовательском Интерфейсе размера или положения (при сохранении в качестве единицы устройства) он будет расположен и размера неправильно. Это происходит, так как в единицах устройства имеют встроенные связь точек на ДЮЙМ.

#### <a name="incorrect-scaling"></a>Неправильное масштабирование
Элементы пользовательского интерфейса, созданные на основной точек на ДЮЙМ масштабируется правильно, однако при перемещении на дисплей с другим значением DPI, они не изменить масштаб, и таким образом, их содержимое в конечном итоге слишком велико или слишком мало.

#### <a name="incorrect-bounding"></a>Неправильный ограничивающего прямоугольника
Аналогичным образом для проблемы масштабирования, элементы пользовательского интерфейса вычислит их границы правильно на их основного контекста точек на ДЮЙМ, однако при перемещении на неосновной DPI, они не будут правильно вычислить новые границы. Таким образом окно содержимого оказывается слишком мало или слишком велико по сравнению с размещения пользовательского интерфейса, что приводит к пустого пространства или обрезки.

#### <a name="drag--drop"></a>Перетаскивание
Каждый раз, когда внутри сценариев DPI смешанного режима (например различные элементы пользовательского интерфейса Подготовка к просмотру в различных режимах awareness точек на ДЮЙМ) путем перетаскивания координаты может быть неверно вычисленных, полученный в результате позиции окончательный перетаскивания вверх неправильный.

#### <a name="out-of-process-ui"></a>Out-of-process пользовательского интерфейса
Пользовательский Интерфейс создается вне процесса и при создании внешнего процесса в другой режим awareness точек на ДЮЙМ, чем в Visual Studio, это может вызвать любой из предыдущих проблемы отрисовки.

#### <a name="windows-forms-controls-images-or-layouts-rendered-incorrectly"></a>Элементы управления Windows Forms, изображения или макеты, неправильной отрисовки
Не все содержимое Windows Forms поддерживают режим PMA. В результате может появиться отображением проблемы с макетами неправильные или масштабирование. Возможным решением в данном случае является явным образом отображать содержимое форм Windows в «System виду» DpiAwarenessContext (см. [перезагрузки элемента управления в определенных DpiAwarenessContext](#forcing-a-control-into-a-specific-dpiawarenesscontext)).

#### <a name="windows-forms-controls-or-windows-not-displaying"></a>Элементы управления Windows Forms или windows, которые не отображаются
Одной из причин этой проблемы является разработчиков, пытающихся изменение родительского объекта элемента управления или окно с одной DpiAwarenessContext в окно с разных DpiAwarenessContext.

На следующих рисунках показаны текущего **по умолчанию** ограничения операционной системы Windows в родительские связи windows:

![Снимок экрана поведение правильный родительские связи](../../extensibility/ux-guidelines/media/PMA-parenting-behavior.PNG)

> [!Note]
> Это поведение можно изменить, задав в среде размещения потока (см. [DpiHostinBehaviour](https://docs.microsoft.com/windows/desktop/api/windef/ne-windef-dpi_hosting_behavior)).

Таким образом Если родительско дочернее отношение между неподдерживаемые режимы, его не удастся, и элемент управления или окно может не отображаться должным образом.

### <a name="diagnosing-issues"></a>Диагностика проблем
Существует много факторов, которые следует учитывать при определении проблем, связанных с PMA: 

1. Выполняет пользовательский Интерфейс или API, которые ожидают логических или значения устройства.
    - Пользовательского интерфейса WPF и API-интерфейсы обычно используют логические значения (но не всегда)
    - Пользовательского интерфейса Win32 и API-интерфейсы обычно используют значения устройства

2. Откуда приходят значения?
    - При получении значений из другой пользовательский Интерфейс или API, это устройство передачи или логические значения.
    - При получении значений из нескольких источников, все используйте/ожидают, что же типы значений или преобразования требуется комбинировать и сопоставлять?

3. Такое константы пользовательского интерфейса используются и какие формы являются ли они в

4. Является потоком в правильном контексте DPI для значений получает?
    - Изменения для размещения смешанного DPI обычно следует помещать путей кода в правильном контексте, тем не менее, может выполнить работу за пределами потока событий или цикла основного сообщения из неправильного контекста точек на ДЮЙМ.

5. Значения выходить за границы контекста DPI?
    - Перетаскивание – это распространенная ситуация, где координаты может пересекать контекстов точек на ДЮЙМ. Окно пытается стать выполнено правильно, но в некоторых случаях пользовательского интерфейса ведущего приложения может потребоваться выполнить преобразование работу, чтобы обеспечить соответствующий границ контекста.

### <a name="pma-nuget-package"></a>Пакет PMA NuGet
Новые библиотеки DpiAwarness можно найти на [Microsoft.VisualStudio.DpiAwareness](https://www.nuget.org/packages/Microsoft.VisualStudio.DpiAwareness/) пакет NuGet.

### <a name="recommended-tools"></a>Рекомендованные средства
Следующие средства могут помочь при отладке проблем, связанных с PMA через ряд различных стеков пользовательского интерфейса, поддерживается в Visual Studio.

#### <a name="snoop"></a>Snoop
Snoop является средством отладки XAML, которое имеет некоторые дополнительные функциональные возможности, не имеет встроенные средства Visual Studio XAML. Кроме того Snoop не активно отладки Visual Studio, чтобы иметь возможность просмотреть и настроить его пользовательского интерфейса WPF. Двумя основными способами Snoop могут быть полезными для диагностики проблем PMA для проверки координат логическое расположение и размер границы, и для проверки пользовательского интерфейса имел правой точек на ДЮЙМ.
 
#### <a name="visual-studio-xaml-tools"></a>Инструменты Visual Studio XAML
Как и Snoop средства XAML в Visual Studio может помочь в выявлении проблем PMA. После нахождения скорее всего выяснилось, можно установить точки останова и использовать окна динамического визуального дерева, а также окнах отладки, для изучения границы пользовательского интерфейса и текущего точек на ДЮЙМ.

## <a name="strategies-for-fixing-pma-issues"></a>Стратегии устранения проблем PMA
### <a name="replacing-dpihelper-calls"></a>Замена вызовов DpiHelper
В большинстве случаев Устранение проблем пользовательского интерфейса в режиме PMA сводится к замена вызовов в управляемом коде старый *Microsoft.VisualStudio.Utilities.Dpi.DpiHelper* и *Microsoft.VisualStudio.PlatformUI.DpiHelper*классам с вызовов к новому *Microsoft.VisualStudio.Utilities.DpiAwareness* вспомогательный класс. 

```cs
// Remove this kind of use:
Point deviceTopLeft = new Point(window.Left, window.Top).LogicalToDeviceUnits();

// Replace with this use:
Point deviceTopLeft = window.LogicalToDevicePoint(new Point(window.Left, window.Top));
```

Для машинного кода, его придется заменив вызовы старого *VsUI::CDpiHelper* класс с вызовами к новому *VsUI::CDpiAwareness* класса. 

```cpp
// Remove this kind of use:
int cx = VsUI::DpiHelper::LogicalToDeviceUnitsX(m_cxS);
int cy = VsUI::DpiHelper::LogicalToDeviceUnitsY(m_cyS);

// Replace with this use:
int cx = m_cxS;
int cy = m_cyS;
VsUI::CDpiAwareness::LogicalToDeviceUnitsX(m_hwnd, &cx);
VsUI::CDpiAwareness::LogicalToDeviceUnitsY(m_hwnd, &cy);
```

Новые классы DpiAwareness и CDpiAwareness предлагают единиц вспомогательные функции преобразования как классы DpiHelper, но требуется дополнительный входной параметр: элемент пользовательского интерфейса для использования в качестве ссылки для операции преобразования. Важно отметить, что вспомогательные функции масштабирования изображения не существуют в новых вспомогательных функций DpiAwareness/CDpiAwareness и при необходимости [ImageService](https://docs.microsoft.com/visualstudio/extensibility/image-service-and-catalog?view=vs-2019) должны использоваться вместо нее.

Управляемый класс DpiAwareness предлагает вспомогательные функции WPF и визуальных элементов, элементы управления Windows Forms и дескрипторы Win32 HWND HMONITORs (как в виде IntPtrs), при собственного CDpiAwareness предложения HWND и HMONITOR вспомогательные классы.

### <a name="windows-forms-dialogs-windows-or-controls-displayed-in-the-wrong-dpiawarenesscontext"></a>Диалоговые окна Windows Forms, windows или элементами управления, отображаемыми в неправильный DpiAwarenessContext
Даже после успешного родительские связи Windows с разных DpiAwarenessContexts (из-за Windows по умолчанию), пользователи по-прежнему могут видеть масштабирования проблемы windows с отличающимися масштабами DpiAwarenessContexts по-разному. Таким образом пользователи могут см. в разделе нечеткого/выравнивание текста или изображений проблемы в пользовательском Интерфейсе.

Решение является установка области DpiAwarenessContext для всех окон и элементов управления в приложении.

### <a name="top-level-mixed-mode-tlmm-dialogs"></a>Диалоговые окна верхнего уровня смешанный режим (TLMM)
При создании окон верхнего уровня, такие как модальные диалоговые окна, очень важно, чтобы убедиться в том, что поток в нужном состоянии перед окна (и его дескриптор) создается. Поток могут быть помещены в awareness системы, используя вспомогательный метод CDpiScope в машинный код или управляемый вспомогательный модуль DpiAwareness.EnterDpiScope. (TLMM обычно можно использовать для диалоговых окон отличных от WPF или windows.)

### <a name="child-level-mixed-mode-clmm"></a>Дочерний уровень смешанный режим (CLMM)
По умолчанию дочерние окна получить текущий DPI awareness контекст потока Если создан без родительского элемента или родительского элемента DPI awareness контекст при создании с родительским. Чтобы создать дочерний элемент с DPI awareness контексте, отличном от родительского, поток может быть переведен в нужный контекст awareness точек на ДЮЙМ. Затем можно создать без родительского элемента и вручную изменен порядок наследования в родительское окно дочернего.

#### <a name="clmm-issues"></a>Проблемы CLMM
Большая часть операций вычисления пользовательского интерфейса, как часть главной обмена сообщениями цикла или событие цепочки должны работать в правильном контексте awareness точек на ДЮЙМ. Тем не менее если координаты или изменения размера вычисления выполняются за пределами этих основных рабочих процессов (например, во время выполнения задачи бездействия или вне потока пользовательского интерфейса, текущем контексте awareness точек на ДЮЙМ может быть неверный, что ведет к потери портативного компьютера пользовательского интерфейса или неверно изменения размера проблемы. Размещение потока в правильном состоянии для пользовательского интерфейса рабочего обычно решает проблему.
 
#### <a name="opting-out-of-clmm"></a>Отказ от CLMM
Если окно инструментов отличных от WPF переносится для полной поддержки PMA, его необходимо отказаться от CLMM. Чтобы сделать это, должен быть реализован новый интерфейс: IVsDpiAware.

C#:

```cs
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
public interface IVsDpiAeware
{
    [ComAliasName("Microsoft.VisualStudio.Shell.Interop.VSDPIMode")]
    uint Mode {get;}
}
```
 
C++:

```cpp
IVsDpiAware : public IUnknown
{
    public:
        HRRESULT STDMETHODCALLTYPE get_Mode(__RCP__out VSDPIMODE *dwMode);
};
```

Для управляемых языков — лучшее место для реализации этого интерфейса в том же классе, который является производным от *Microsoft.VisualStudio.Shell.ToolWindowPane*. Для C++, лучше всего для реализации этого интерфейса — в том же классе, который реализует *IVsWindowPane* из vsshell.h.

Значение, возвращенное свойство Mode в интерфейсе является __VSDPIMODE (и приведение к целое число без знака в управляемого):

```cs
enum __VSDPIMODE
{
    VSDM_Unaware    = 0x01,
    VSDM_System     = 0x02,
    VSDM_PerMonitor = 0x03,
}
```

- Означает, что окно инструментов должен обрабатывать 96 точек на ДЮЙМ, Windows будет обрабатывать, его масштабирования для всех других DPI. Полученный на содержимое, нечетко.
- Окно инструментов должен обрабатывать DPI для сервера-источника систем означает отображения точек на ДЮЙМ. Любой дисплей с помощью сопоставления точек на ДЮЙМ будет выглядеть четкое, но если DPI отличается или изменяется во время сеанса, Windows будет обрабатывать масштабирование, и оно станет нечетко.
- PerMonitor означает, что окно инструментов должен обрабатывать все DPI на все устройства отображения и при каждом изменении значения DPI.

> [!NOTE]
> Visual Studio поддерживает PerMonitorV2 awareness только в том случае, поэтому значение перечисления PerMonitor преобразуется в значение Windows DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2.

#### <a name="forcing-a-control-into-a-specific-dpiawarenesscontext"></a>Принудительная элемент управления в определенных DpiAwarenessContext
Устаревший пользовательский Интерфейс, который не обновляется для поддержки режима PMA, все равно могут потребоваться незначительных изменений для работы во время работы в режиме PMA Visual Studio. Одно исправление включает в себя убедившись, что в правом DpiAwarenessContext создается пользовательский Интерфейс. Можно принудительно пользовательского интерфейса в определенной DpiAwarenessContext, можно ввести область DPI следующим кодом:

C#:

```cs
using (DpiAwareness.EnterDpiScope(DpiAwarenessContext.SystemAware))
{
    Form form = new MyForm();
    form.ShowDialog();
}
```

C++:

```cpp
void MyClass::ShowDialog()
{
    VsUI::CDpiScope dpiScope(DPI_AWARENESS_CONTEXT_SYSTEM_AWARE);
    HWND hwnd = ::CreateWindow(...);
}
```

> [!NOTE]
> Принудительная DpiAwarenessContext работает только для интерфейса WPF и диалоговых окон верхнего уровня WPF. При создании пользовательского интерфейса WPF, для размещения окон инструментов и конструкторов, как только содержимое вставляется в дерево пользовательского интерфейса WPF, они преобразуются в текущем процессе DpiAwarenessContext.

## <a name="known-issues"></a>Известные проблемы
### <a name="windows-forms"></a>Windows Forms

Чтобы оптимизировать для новых сценариев смешанного режима, Windows Forms изменен способ создания элементов управления и окон всякий раз, когда родительского элемента не было задано явно. Ранее, элементы управления без явной родительского использовать внутренний «парковки окно» как временный родительский элемент для элемента управления или создания окна. 

Прежде чем .NET 4.8 произошла одного «парковки окна», получает его DpiAwarenessContext из текущего контекста awareness DPI потока во время создания окна. Любой элемент без родительского элемента управления наследует же DpiAwarenessContext окно парковки дескриптор элемента управления и может быть изменен порядок наследования родителю или ожидаемой final разработчиком приложения. Это приведет к сбоев на основе времени, если «Парковки окно» выше DpiAwarenessContext превышает ширину окна конечного родительского объекта.

Начиная с .NET 4.8 теперь есть «Парковки окно» для каждого DpiAwarenessContext были обнаружения. Основное отличие — что DpiAwarenessContext, используемый для элемента управления кэшируется, когда создается элемент управления, не в том случае, когда создается дескриптор. Это означает, что общее поведение конечных такой же, но можно включить, то, что раньше быть проблемы с временем в согласованное проблема. Она также предоставляет разработчику приложения дополнительные детерминированное поведение для написания кода пользовательского интерфейса и определение области правильно.
