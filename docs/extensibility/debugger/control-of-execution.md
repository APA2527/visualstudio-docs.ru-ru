---
title: Контроль исполнения (ru) Документы Майкрософт
ms.date: 11/04/2016
ms.topic: conceptual
helpviewer_keywords:
- debugging [Debugging SDK], control of execution
ms.assetid: 97071846-007e-450f-95a6-f072d0f5e61e
author: acangialosi
ms.author: anthc
manager: jillfra
ms.workload:
- vssdk
ms.openlocfilehash: e2d338c5470611a5eea0c6279404c4eaddebb2d0
ms.sourcegitcommit: 16a4a5da4a4fd795b46a0869ca2152f2d36e6db2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2020
ms.locfileid: "80739073"
---
# <a name="control-of-execution"></a>Контроль исполнения
Двигатель отладки (DE) обычно отправляет одно из следующих событий в качестве последнего события запуска:

- Событие точки входа, если он присоединен к недавно запущенной программе

- Полное событие нагрузки, если он прикрепляется к уже запущенной программе

  Оба эти события останавливают события, что означает, что DE ждет ответа от пользователя с помощью IDE. Для получения дополнительной [информации см.](../../extensibility/debugger/operational-modes.md)

## <a name="stopping-event"></a>Остановка события
 При отправке события остановки на сеанс отладки:

1. Программа и поток, содержащие текущий указатель инструкции, могут быть получены из интерфейса события.

2. IDE определяет текущий файл исходного кода и положение, которое отображается в виде выделения в редакторе.

3. Сеанс отладки обычно реагирует на это первое событие остановки, вызывая метод **продолжения** программы.

4. Затем программа выполняется до тех пор, пока не столкнется с условием остановки, например, в момент разрыва. В этом случае DE отправляет событие точки разрыва в сеанс отладки. Событие точки разрыва — это событие остановки, и DE снова ждет ответа пользователя.

5. Если пользователь выбирает шаг в, над, или из функции, IDE предлагает сеанс отладки для вызова метода `Step` программы. Затем IDE проходит блок шага (инструкция, инструкция или строка) и тип шага (будь то шаг в, над или вне функции). Когда шаг завершен, DE отправляет шаг полное событие на сеанс отладки, который является событием остановки.

    -или-

    Если пользователь выбирает продолжение выполнения из текущего указателя инструкции, IDE предлагает сеансу отладки вызвать метод **выполнения** программы. Программа возобновляет выполнение до тех пор, пока не столкнется со следующим условием остановки.

    -или-

    Если сеанс отладки игнорирует конкретное событие остановки, сеанс отладки вызывает метод **продолжения** программы. Если программа вступала в, более или из функции, когда она столкнулась с условием остановки, то она продолжает шаг.

   Программно, когда DE сталкивается с условием остановки, он отправляет такие события остановки, как [IDebugLoadCompleteEvent2](../../extensibility/debugger/reference/idebugloadcompleteevent2.md) или [IDebugEntryPointEvent2](../../extensibility/debugger/reference/idebugentrypointevent2.md) в диспетчер сессии отладки (SDM) с помощью интерфейса [IDebugEventCallback2.](../../extensibility/debugger/reference/idebugeventcallback2.md) DE проходит [интерфейсы IDebugProgram2](../../extensibility/debugger/reference/idebugprogram2.md) и [IDebugThread2,](../../extensibility/debugger/reference/idebugthread2.md) представляющие программу и поток, содержащий текущий указатель инструкций. SDM вызывает [IDebugThread2::EnumFrameInfo,](../../extensibility/debugger/reference/idebugthread2-enumframeinfo.md) чтобы получить верхнюю рамку стека и вызывает [IDebugStackFrame2::GetDocumentContext,](../../extensibility/debugger/reference/idebugstackframe2-getdocumentcontext.md) чтобы получить контекст документа, связанный с текущим указателем инструкции. Этот контекст документа обычно является именем файла исходного кода, строкой и номером столбца. IDE использует их для выделения исходного кода, содержащего текущий указатель инструкции.

   SDM обычно реагирует на это первое событие остановки, позвонив [iDebugProgram2::Продолжить](../../extensibility/debugger/reference/idebugprogram2-continue.md). Затем программа выполняется до тех пор, пока не столкнется с условием остановки, например, в момент разрыва, и в этом случае DE отправляет [интерфейс IDebugBreakpointEvent2](../../extensibility/debugger/reference/idebugbreakpointevent2.md) в SDM. Событие точки разрыва — это событие остановки, и DE снова ждет ответа пользователя.

   Если пользователь выбирает шаг в, над, или из функции, IDE предлагает SDM для вызова [IDebugProgram2::Шаг](../../extensibility/debugger/reference/idebugprogram2-step.md). Затем IDE передает [STEPUNIT](../../extensibility/debugger/reference/stepunit.md) (инструкция, заявление или строка) и [STEPKIND,](../../extensibility/debugger/reference/stepkind.md)то есть, следует ли вступать в, более или вне функции. Когда шаг завершен, DE отправляет интерфейс [IDebugStepCompleteEvent2](../../extensibility/debugger/reference/idebugstepcompleteevent2.md) в SDM, который является событием остановки.

   Если пользователь решит продолжить выполнение из текущего указателя инструкции, IDE просит SDM вызвать [IDebugProgram2::Execute](../../extensibility/debugger/reference/idebugprogram2-execute.md). Программа возобновляет выполнение до тех пор, пока не столкнется со следующим условием остановки.

   Если пакет отладки игнорирует конкретное событие остановки, пакет отладки вызывает SDM, который вызывает [IDebugProgram2::Продолжить](../../extensibility/debugger/reference/idebugprogram2-continue.md). Если программа вступала в, над или из функции, когда она столкнулась с условием остановки, она продолжает шаг. Это означает, что программа поддерживает состояние шага, так что она знает, как продолжать.

   Вызовы SDM делает, `Step` **выполнить,** и **продолжить** являются асинхронными, что означает, что SDM ожидает вызова вернуться быстро. Если DE отправляет SDM событие остановки на том `Step`же потоке до, **Выполните,** или **Продолжить** возвращается, SDM зависает.

## <a name="see-also"></a>См. также
- [Задачи дебуза](../../extensibility/debugger/debugging-tasks.md)
