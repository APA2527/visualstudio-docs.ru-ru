---
title: Практическое руководство. Диагностика производительности расширения | Документация Майкрософт
ms.date: 11/08/2016
ms.topic: conceptual
ms.assetid: 46b0a1e3-7e69-47c9-9d8d-a1815d6c3896
author: BertanAygun
ms.author: bertaygu
manager: jillfra
ms.workload:
- bertaygu
ms.openlocfilehash: 3d8fb5de23cbc4664ea322a9149653598956aed7
ms.sourcegitcommit: 94b3a052fb1229c7e7f8804b09c1d403385c7630
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62863335"
---
# <a name="measuring-extension-impact-in-startup"></a>Измерение влияния расширения в параметрах запуска

## <a name="focus-on-extension-performance-in-visual-studio-2017"></a>Сосредоточьтесь на производительность расширения в Visual Studio 2017

На основе отзывов клиентов, одной из области действия для выпуска Visual Studio 2017 была производительность загрузки для загрузки и решение. Группа платформы Visual Studio мы работаем над улучшением производительности загрузки для загрузки и решение. В общем случае наши измерения предложить установленных расширений также может иметь существенное влияние на этих сценариев.

Чтобы помочь пользователям понять влияние этой конфигурации, мы добавили новую функцию в Visual Studio для уведомления пользователей о медленных расширений. В некоторых случаях Visual Studio обнаруживает новый модуль, который замедляет работу загрузке решения или запуска. При обнаружении замедление, пользователи будут видеть уведомления в интегрированной среде разработки, им новое диалоговое окно «Управление производительностью Visual Studio». Это диалоговое окно также всегда может осуществляться с меню "Справка" для просмотра ранее обнаруженные расширения.

![Управление производительностью Visual Studio](media/manage-performance.png)

В этом документе имеет своей целью помочь разработчикам расширений с описания того, как вычисляется влияние расширения. В этом документе также описывается, как расширение влияние могут анализироваться локально. Локально анализ влияния расширение определит, если расширение может отображаться как производительности, влияющие на расширение.

> [!NOTE]
> Этот документ посвящен влияние расширения во время загрузки, запуска и решения. Расширения также повлиять на производительность Visual Studio, когда они вызывают зависание пользовательского интерфейса. Дополнительные сведения по этой теме, см. в разделе [как: Диагностика пользовательского интерфейса задержки, вызванные расширения](how-to-diagnose-ui-delays-caused-by-extensions.md).

## <a name="how-extensions-can-impact-startup"></a>Влияние запуска расширений

Одним из наиболее распространенных способов для расширения повлиять на производительность при запуске является, выбрав для автоматической загрузки на одном из контекстов пользовательского интерфейса известных запуска, например NoSolutionExists или ShellInitialized. Во время запуска, записываемое в следующих контекстах пользовательского интерфейса. Все пакеты, которые включают `ProvideAutoLoad` атрибут их определения с помощью этих контекстов будут загружаться и инициализирована в это время.

Когда мы измерить влияние расширения, мы в первую очередь сосредоточиться на время, проведенное тех расширений, которые решили нагрузки автоматически в контекстах выше. Измеряется время бы включать, но не ограничиваться:

* Загрузка сборок модуля для синхронного пакетов
* Время, затраченное в конструкторе класса пакета для синхронной пакетов
* Время, затраченное на метод Initialize (или SetSite) пакета для синхронной пакетов
* Для асинхронных пакетов выше операции выполняются в фоновом потоке.  Таким образом операции, исключаются из наблюдения.
* Время, затраченное на либо асинхронную работу, запланировано во время инициализации пакета на основной поток
* Время, затраченное на обработчики событий, специально оболочки инициализировать контекст активации или изменение состояния зомби оболочки
* Начиная с Visual Studio 2017 с обновлением 3, мы также запускает наблюдение за время, затраченное на на вызовов простоя перед инициализацией оболочки. Длительных операций в обработчиках простоя также вызвать не отвечать интегрированную среду разработки входят и воспринимаемое время запуска пользователем.

Мы добавили множество функций, начиная с Visual Studio 2015. Эти функции помогают с избавляет от пакетов для автоматической загрузки. Функции также отложить потребность пакетов для загрузки с более конкретными вариантами. К таким примерам относятся примеры, где пользователям было бы более определенные для использования расширения или снизить расширения при загрузке автоматически.

Дополнительные сведения об этих функциях можно найти в следующих документах:

[Контексты пользовательского интерфейса на основе правил](how-to-use-rule-based-ui-context-for-visual-studio-extensions.md): Более широкие ядра основе правил, построенная на основе контекстов пользовательского интерфейса позволяет создавать пользовательские контексты, на основе типов проектов, атрибуты и атрибуты. Чтобы загрузить пакет во время конкретных сценариях можно использовать настраиваемых контекстов. Эти сценарии включают в себя наличие проекта с конкретной функции вместо запуска. Также позволяют настраиваемые контексты [команды видимости должны быть привязаны к настраиваемый контекст](visibilityconstraints-element.md) на основе компоненты проекта или другие доступные условия. Эта возможность избавляет от необходимости загрузки пакета, чтобы зарегистрировать обработчик запроса состояния команды.

[Поддержка асинхронной пакета](how-to-use-asyncpackage-to-load-vspackages-in-the-background.md): Новый базовый класс AsyncPackage в Visual Studio 2015 позволяет пакетов Visual Studio необходимо загрузить в фоновом режиме асинхронно, была ли запрошена загрузку пакета с помощью атрибута нагрузки автоматически или запроса на асинхронную службу. Это фоновая загрузка позволяет реагировать в IDE. Интегрированной среды разработки быстро реагирующих, даже в том случае, если расширение инициализируется в фоновом режиме и не повлияет на важных сценариев, таких как загрузка запуска и решения.

[Асинхронные службы](how-to-provide-an-asynchronous-visual-studio-service.md): Благодаря поддержке асинхронных пакета мы также добавили поддержку для выполнения запросов службы асинхронно и не сможет зарегистрировать асинхронные службы. Что более важно, мы работаем над преобразование базовых служб Visual Studio для поддержки асинхронного запроса, что происходит основная работа в запросе async в фоновых потоках. Модели SComponentModel (Visual Studio MEF host) является одним из основных служб, которые теперь поддерживает асинхронный запрос, чтобы разрешить расширения для поддержки асинхронной загрузки полностью.

## <a name="reducing-impact-of-auto-loaded-extensions"></a>Снижения воздействия автоматической загрузки расширений

Если пакет по-прежнему должен быть автоматически загружен во время запуска, важно свести к минимуму работа, выполняемая во время инициализации пакета. Минимизация работы инициализации пакета снижает вероятность влияния на запуска расширения.

Ниже приведены некоторые примеры, которые могут привести к инициализации пакета потреблять много ресурсов.

### <a name="use-of-synchronous-package-load-instead-of-asynchronous-package-load"></a>Использование загрузку синхронной пакета вместо загрузку асинхронной пакета

Так как синхронный пакетов загружаются в основном потоке, по умолчанию, мы рекомендуем владельцев расширения, которые имеют пакеты автоматически загружен для использования базового класса асинхронном пакете вместо этого, как упоминалось ранее. Изменение загруженный пакет автоматически для обеспечения асинхронной загрузки также упростит для решения других проблем ниже.

### <a name="synchronous-filenetwork-io-requests"></a>Синхронных файл/сетевых запросов ввода-ВЫВОДА

В идеале следует избегать любой синхронный запрос ввода-ВЫВОДА файла или сети в основном потоке. Их влияние будет зависеть от состояния компьютера и можно заблокировать в течение длительных периодов времени, в некоторых случаях.

С помощью пакета асинхронной загрузки и асинхронные интерфейсы API ввода-ВЫВОДА убедитесь, что пакет инициализации не блокирует основной поток в таких случаях. Пользователи также получают возможность взаимодействовать с Visual Studio, а запросы ввода-вывода будет выполняться в фоновом режиме.

### <a name="early-initialization-of-services-components"></a>Раннее инициализации службы, компоненты

Один из распространенных шаблонов во время инициализации пакета состоит в инициализации службы используемые или предоставляемые этого пакета в пакете `constructor` или `initialize` метод. Хотя это гарантирует, что службы являются готов к использованию, его можно также добавить излишних затрат для упаковки, загрузки, если эти службы не используются непосредственно. Вместо этого такие службы должен быть инициализирован по запросу, чтобы свести к минимуму работа, выполняемая во время инициализации пакета.

Для глобальных служб, предоставляемую пакетом, можно использовать `AddService` методы, которые принимают функцию выполнять отложенную инициализацию службы только в том случае, когда он запрашивается с помощью компонента. Для служб, используемых в пакете, можно использовать Lazy\<T > или AsyncLazy\<T > Чтобы убедиться в том, что службы, инициализации и запрашивать при первом использовании.

## <a name="measuring-impact-of-auto-loaded-extensions-using-activity-log"></a>Измерение последствия автоматической загрузки расширений с помощью журнала действий

Начиная с Visual Studio 2017 с обновлением 3, журнал действий Visual Studio будет теперь содержать записи для влияние на производительность пакетов во время загрузки, запуска и решения. Чтобы просмотреть эти измерения, необходимо открыть Visual Studio с ключом/log и откройте *ActivityLog.xml* файла.

В журнале действий записи будет находиться в разделе «Управление производительностью Visual Studio» источник и будет выглядеть как в следующем примере:

```Component: 3cd7f5bf-6662-4ff0-ade8-97b5ff12f39c, Inclusive Cost: 2008.9381, Exclusive Cost: 2008.9381, Top Level Inclusive Cost: 2008.9381```

В этом примере показывает, что пакет с GUID «3cd7f5bf-6662-4ff0-ade8-97b5ff12f39c» на 2008 мс при запуске Visual Studio. Обратите внимание на то, что Visual Studio считает верхнего уровня затрат как основной номер, при вычислении влияние пакета, так как это экономия пользователи видят при их отключить расширение для этого пакета.

## <a name="measuring-impact-of-auto-loaded-extensions-using-perfview"></a>Измерение последствия автоматической загрузки расширения с использованием PerfView

Во время анализа кода может помочь определить пути кода, которые могут замедлить работу инициализации пакета, вы также можете использовать трассировку с помощью приложений, таких как PerfView, чтобы понять влияние загрузку пакета при запуске Visual Studio.

PerfView — это средство трассировки уровня системы. Это средство поможет понять критических путей в приложении из-за использования ЦП или блокирующих вызовов системы. Ниже приведен краткий пример на анализе пример расширения с помощью PerfView найти по адресу [центра загрузки Майкрософт](https://www.microsoft.com/en-us/download/details.aspx?id=28567).

**Пример кода:**

Этот пример основан на примере кода ниже код, который предназначен для отображения случае наиболее распространенные причины задержки:

```csharp
protected override void Initialize()
{
    // Initialize a class from another assembly as an example
    MakeVsSlowServiceImpl service = new MakeVsSlowServiceImpl();

    // Costly work in main thread involving file IO
    string systemPath = Environment.GetFolderPath(Environment.SpecialFolder.Windows);
    foreach (string file in Directory.GetFiles(systemPath))
    {
        DateTime creationDate = File.GetCreationTime(file);
    }

    // Costly work after shell is initialized. This callback executes on main thread
    KnownUIContexts.ShellInitializedContext.WhenActivated(() =>
    {
        DoMoreWork();
    });

    // Start async work on background thread
    DoAsyncWork().Forget();
}

private async Task DoAsyncWork()
{
    // Switch to background thread to do expensive work
    await TaskScheduler.Default;
    System.Threading.Thread.Sleep(500);
}

private void DoMoreWork()
{
    // Costly work
    System.Threading.Thread.Sleep(500);
    // Blocking call to an asynchronous work.
    ThreadHelper.JoinableTaskFactory.Run(async () => { await DoAsyncWork(); });
}
```

**Запись трассировки с PerfView:**

После настройки среды Visual Studio с расширением установки, можно записать трассировку запуска, открыв PerfView и открыв **собирать** диалогового окна из **собирать** меню.

![Сбор меню perfview](media/perfview-collect-menu.png)

Предоставляет параметры по умолчанию стеки вызовов для потребления ресурсов ЦП, но так как мы заинтересованы в тоже время блокировки, также следует включить **потоков время** стеков. После настройки все готово, можно щелкнуть **начать сбор** и затем откройте Visual Studio после запуска записи.

Перед этим необходимо остановить коллекцию, требуется убедитесь, что Visual Studio полностью инициализируется, главное окно приложения является полностью видимым и, если расширение содержит любого пользовательского интерфейса, которые показывают, автоматически, они доступны. Visual Studio полностью загружается и инициализируется расширение, можно остановить запись выполнить анализ трассировки.

**Анализ трассировки с PerfView.**

После завершения записи PerfView автоматически откройте трассировку и разверните параметры.

В целях в этом примере нас интересуют главным образом **стеки потоков времени** представления, который можно найти в разделе **Advanced Group**. В этом представлении отображается общее время, затраченное в потоке, с помощью метода, включая время ЦП и время блокировки, например операций ввода-ВЫВОДА или Ожидание дескрипторов.

 ![время стеки потоков](media/perfview-thread-time-stacks.png)

 При открытии **стеки потоков времени** просмотра следует выбрать **devenv** процесса для запуска анализа.

PerfView содержит подробные инструкции о том, как для чтения поток стеки времени под свои собственные меню "Справка" для более подробного анализа. Для целей этого примера мы хотим отфильтровать это представление, только в том числе стеков с нашего пакеты модуль имя и запуска потока.

1. Задайте **GroupPats** в пустой текст для удаления любое группирование, добавляется по умолчанию.
2. Задайте **IncPats** включать часть имени сборки и запуск потока в дополнение к существующий фильтр процесса. В этом случае следует **devenv; Поток запуска; MakeVsSlowExtension**.

Теперь в представлении будут отображаться только на издержки, связанные с использованием сборок, связанных с расширением. В этом представлении, в любое время списке **Inc (включительно стоимость)** столбец запуска потока, связанную с отфильтрованных расширения и будет влиять на запуска.

В примере выше некоторые интересные вызов стеки будет следующим:

1. Операции ввода-ВЫВОДА с помощью `System.IO` класса: Хотя включительно затраты на эти кадры могут быть слишком дорого в трассировке, они может возникнуть проблема, так как файл скорость ввода-ВЫВОДА будет зависеть от компьютера.

   ![кадры системы ввода-вывода](media/perfview-system-io-frames.png)

2. Блокировка вызовов, ожидающих на других асинхронных операций: В этом случае инклюзивное время представляет время, основной поток блокируется после завершения асинхронной работы.

   ![блокировки кадров вызова](media/perfview-blocking-call-frames.png)

Одним из других представлений в трассировки, которая будет полезна для определения влияния будет **стеки нагрузки изображений**. Можно применить те же фильтры применительно к **стеки потоков времени** просмотра и узнайте все сборки, загруженные из-за код, выполняемый в загруженный пакет автоматически.

Важно свести к минимуму количество загруженных сборках, внутри подпрограммы инициализации пакета как каждую дополнительную сборку потребует дополнительного дискового ввода-вывода, который может замедлить работу запуска значительно на медленных компьютерах.

## <a name="summary"></a>Сводка

При запуске Visual Studio была одной из областей, которые мы постоянно получайте отзывы об. Наша цель, как утверждалось ранее — все пользователи могли иметь согласованный запуска возникают независимо от того, компоненты и расширения, которые у них установлена. Мы бы хотели работать с владельцами расширения, чтобы помочь им помочь нам достичь этой цели. Вышеприведенное руководство могут помочь понять влияние расширения при запуске и либо избежать необходимости auto нагрузки или загрузить их асинхронно, чтобы свести к минимуму влияние на производительность работы пользователей.
