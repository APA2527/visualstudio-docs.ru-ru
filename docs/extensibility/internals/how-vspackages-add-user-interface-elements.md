---
title: Как добавить элементы пользовательского интерфейса в пакеты VSPackage | Документация Майкрософт
ms.date: 11/04/2016
ms.topic: conceptual
helpviewer_keywords:
- user interfaces, adding elements
- UI element design [Visual Studio SDK], VSPackages
- VSPackages, contributing UI elements
ms.assetid: abc5d9d9-b267-48a1-92ad-75fbf2f4c1b9
author: gregvanl
ms.author: gregvanl
manager: jillfra
ms.workload:
- vssdk
ms.openlocfilehash: b392c962a2ddbed57ca1af934c0ef9d8b5175595
ms.sourcegitcommit: 47eeeeadd84c879636e9d48747b615de69384356
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "63418398"
---
# <a name="how-vspackages-add-user-interface-elements"></a>Как добавить элементы пользовательского интерфейса в пакеты VSPackage
Пакет VSPackage можно добавить элементы пользовательского интерфейса (UI), например меню, панелей инструментов и инструментов для Visual Studio с помощью параметра *.vsct* файла.

 Вы найдете рекомендации по проектированию для элементов пользовательского интерфейса в [рекомендации по пользовательскому интерфейсу Visual Studio](../../extensibility/ux-guidelines/visual-studio-user-experience-guidelines.md).

## <a name="the-visual-studio-command-table-architecture"></a>Архитектура таблицы команд Visual Studio
 Как было отмечено, архитектура таблицы команда поддерживает описанные выше архитектурных принципов. Ниже приведены принципов абстракции, структуры данных и средства архитектуры таблицы команд.

- Существует три основных типа элементов: меню, команд и групп. Меню могут предоставляться в пользовательском Интерфейсе в виде меню, подменю, панели инструментов или окна инструментов. Команды, процедуры, которые пользователь может выполнять в интегрированной среде разработки, и они могут предоставляться в виде пунктов меню, кнопки, списки или других элементов управления. Группы — это контейнеры для меню и команд.

- Каждый элемент определяется определение, описывающее элемент, его приоритет относительно других элементов и флаги, определяющие его поведение.

- Каждый элемент имеет размещения, в котором описывается родительский элемент. Элемент может иметь несколько родительских элементов, так что он может присутствовать в нескольких местах в пользовательском Интерфейсе.

     Каждая команда должна быть группа с родительским, даже если он является единственным дочерним элементом в этой группе. Каждый стандартное меню также должен быть родительская группа. Панели инструментов и окон инструментов в качестве собственные родительские элементы. В группе может быть родительским главной строке меню Visual Studio или любой меню, панели инструментов или окна инструментов.

### <a name="how-items-are-defined"></a>Определение элементов
 Объект *.vsct* файл форматируется в формате XML. Он определяет элементы пользовательского интерфейса для пакета и определяет, где эти элементы отображаются в интегрированной среде разработки. Каждый меню, группы или команды в пакете впервые назначается идентификатор GUID и ID в `Symbols` разделе. В остальной части *.vsct* файла каждого меню, команды и группы идентифицируется комбинацией его GUID и идентификатор. В следующем примере показан типичный `Symbols` как созданный с помощью шаблона пакета Visual Studio при **команды меню** выбранных в шаблоне.

```xml
<Symbols>
  <!-- This is the package guid. -->
  <GuidSymbol name="guidMenuTextPkg" value="{b1253bc6-d266-402b-89e7-5e3d3b22c746}" />

  <!-- This is the guid used to group the menu commands together -->
  <GuidSymbol name="guidMenuTextCmdSet" value="{a633d4e4-6c65-4436-a138-1abeba7c9a69}">

    <IDSymbol name="MyMenuGroup" value="0x1020" />
    <IDSymbol name="cmdidMyCommand" value="0x0100" />
  </GuidSymbol>

  <GuidSymbol name="guidImages" value="{53323d9a-972d-4671-bb5b-9e418480922f}" >
    <IDSymbol name="bmpPic1" value="1" />
    <IDSymbol name="bmpPic2" value="2" />
    <IDSymbol name="bmpPicSearch" value="3" />
    <IDSymbol name="bmpPicX" value="4" />
    <IDSymbol name="bmpPicArrows" value="5" />
  </GuidSymbol>
</Symbols>
```

 Элемент верхнего уровня `Symbols` раздел [элемент GuidSymbol](../../extensibility/guidsymbol-element.md). `GuidSymbol` элементы сопоставляются имена идентификаторов GUID, используемых в интегрированной среде разработки для определения пакетов и их частей компонента.

> [!NOTE]
> Идентификаторы GUID создается автоматически с помощью шаблона пакета Visual Studio. Можно также создать уникальный идентификатор GUID, щелкнув **создать GUID** на **средства** меню.

 Первый `GuidSymbol` элемент, `guid<PackageName>Pkg`, — это GUID самого пакета. Это идентификатор GUID, который используется средой Visual Studio для загрузки пакета. Как правило он не имеет дочерних элементов.

 По соглашению, меню и команд, собраны в секунды `GuidSymbol` элемент, `guid<PackageName>CmdSet`, и точечные рисунки в разделе имеют третий `GuidSymbol` элемент, `guidImages`. У вас нет для соблюдения этого соглашения, но каждого меню, группы, команды и точечный рисунок должен быть дочерним элементом `GuidSymbol` элемент.

 Во втором `GuidSymbol` элемент, который представляет набор команд пакета, ряд `IDSymbol` элементов. Каждый [элемент IDSymbol](../../extensibility/idsymbol-element.md) сопоставляет имя с числовое значение и может представлять меню, группу или команду, которая является частью набора команд. `IDSymbol` Элементами в третьем `GuidSymbol` представляют элемент точечных рисунков, который может использоваться в качестве значков для команд. Так как пары GUID и идентификатора должно быть уникальным в приложении, а не два дочерних элемента, одной и той же `GuidSymbol` элемент может иметь то же значение.

### <a name="menus-groups-and-commands"></a>Меню, группы и команды
 Если меню, группы или команды содержит GUID и идентификатор, его можно добавить в интегрированную среду разработки. Каждый элемент пользовательского интерфейса должен иметь следующее:

- Объект `guid` атрибут, который совпадает с именем `GuidSymbol` , определенному в элемент пользовательского интерфейса.

- `id` Атрибут, который совпадает с именем связанного `IDSymbol` элемент.

     Вместе `guid` и `id` compose атрибуты *подпись* элемента пользовательского интерфейса.

- Объект `priority` атрибут, который определяет положение элемента пользовательского интерфейса в его родительском меню или группе.

- Объект [родительского элемента](../../extensibility/parent-element.md) с `guid` и `id` атрибуты, определяющие сигнатуры родительского меню или группы.

#### <a name="menus"></a>Меню
 Каждое меню определяется как [элемент меню](../../extensibility/menu-element.md) в `Menus` разделе. Меню должен иметь `guid`, `id`, и `priority` атрибуты и `Parent` элемента, а также следующие дополнительные атрибуты и дочерние элементы:

- Объект `type` атрибут, указывающий, следует ли отображать меню в интегрированной среде разработки в качестве своеобразного меню или панели инструментов.

- Объект [элемент Strings](../../extensibility/strings-element.md) , содержащий [элемент ButtonText](../../extensibility/buttontext-element.md), которая задает заголовок меню в интегрированной среде разработки и [элемент CommandName](../../extensibility/commandname-element.md), в виде имени, используется в **команда** окна для доступа к меню.

- Необязательные флаги. Объект [элемент CommandFlag](../../extensibility/command-flag-element.md) появляется в определении меню, чтобы изменить его внешний вид и поведение в интегрированной среде разработки.

  Каждый `Menu` элемент должен иметь группу как его родительский, если только это не фиксируемого элемента, например панель инструментов. Закрепляемое меню является его родительский элемент. Дополнительные сведения о меню и значения для `type` атрибут, см. в разделе [элемент меню](../../extensibility/menu-element.md) документации.

  В следующем примере показано меню, которое отображается в строке меню Visual Studio рядом **средства** меню.

```xml
<Menu guid="guidTopLevelMenuCmdSet"
id="TopLevelMenu" priority="0x700" type="Menu">
  <Parent guid="guidSHLMainMenu"
          id="IDG_VS_MM_TOOLSADDINS" />
  <Strings>
    <ButtonText>TestMenu</ButtonText>
    <CommandName>TestMenu</CommandName>
  </Strings>
</Menu>
```

#### <a name="groups"></a>Группы
 Группы — это элемент, который определен в `Groups` раздел *.vsct* файла. Группы — это просто контейнеры. Они не отображаются в интегрированной среде разработки, кроме как разделителя меню. Таким образом [элемент группы](../../extensibility/group-element.md) определяется только его сигнатура, приоритет и родительский.

 Группа может иметь меню, другую группу или сам как родительский элемент. Тем не менее обычно родительским является меню или панели инструментов. В меню в предыдущем примере является дочерним элементом `IDG_VS_MM_TOOLSADDINS` группы и группы является дочерним для элемента в строке меню Visual Studio. Группы в следующем примере является дочерним элементом меню, в предыдущем примере.

```xml
 <Group guid="guidTopLevelMenuCmdSet" id="MyMenuGroup"
priority="0x0600">
   <Parent guid="guidTopLevelMenuCmdSet" id="TopLevelMenu"/>
 </Group>
```

 Так как он является частью меню, эта группа обычно будет содержать команды. Тем не менее он может также содержать другие меню. Это определение подменю, как показано в следующем примере.

```xml
<Menu guid="guidTopLevelMenuCmdSet" id="SubMenu"
priority="0x0100" type="Menu">
  <Parent guid="guidTopLevelMenuCmdSet" id="MyMenuGroup"/>
  <Strings>
    <ButtonText>Sub Menu</ButtonText>
    <CommandName>Sub Menu</CommandName>
  </Strings>
</Menu>
```

#### <a name="commands"></a>Команды
 Команда, которая предоставляется в интегрированную среду разработки определен либо как [элемент Button](../../extensibility/button-element.md) или [элемент поля со списком](../../extensibility/combo-element.md). Для отображения в меню или панели инструментов, команда должна быть группа с родительским.

##### <a name="buttons"></a>Кнопки
 Кнопки определены в `Buttons` разделе. Кнопка считается любой элемент меню, кнопки или другого элемента, которую пользователь может щелкнуть для выполнения одной команды. Некоторые типы кнопок, также могут включать функции списка. Кнопки имеют одинаково необходимые и необязательные атрибуты, которые имеют меню, а также может иметь [элемент Icon](../../extensibility/icon-element.md) , который указывает идентификатор GUID и идентификатор растрового изображения, представляющего кнопку в интегрированной среде разработки. Дополнительные сведения о кнопках и их атрибутов см. в разделе [элемент Buttons](../../extensibility/buttons-element.md) документации.

 Кнопки в следующем примере является дочерним элементом группы, в предыдущем примере, а также отобразятся в интегрированной среде разработки, как элемент меню в меню родительского этой группы.

```xml
<Button guid="guidTopLevelMenuCmdSet" id="cmdidTestCommand" priority="0x0100" type="Button">
  <Parent guid="guidTopLevelMenuCmdSet" id="MyMenuGroup" />
  <Icon guid="guidImages" id="bmpPic1" />
  <Strings>
    <CommandName>cmdidTestCommand</CommandName>
    <ButtonText>Test Command</ButtonText>
  </Strings>
</Button>
```

##### <a name="combos"></a>Combos
 Комбинировать определяются в `Combos` разделе. Каждый `Combo` элемент представляет в поле с раскрывающимся списком в интегрированной среде разработки. Поле со списком может или не может быть доступным для записи, пользователями, в зависимости от значения `type` атрибут поля со списком. Комбинировать содержатся одинаковые элементы поведения, что кнопки имеют и также может иметь следующие дополнительные атрибуты:

- Объект `defaultWidth` атрибут, указывающий ширину в пикселях.

- `idCommandList` Атрибут, указывающий список, содержащий элементы, отображаемые в окне списка. Список команд должен быть объявлен в том же `GuidSymbol` узел, который содержит поля со списком.

  В следующем примере определяется элемент поля со списком.

```xml
<Combos>
  <Combo guid="guidFirstToolWinCmdSet"
         id="cmdidWindowsMediaFilename"
         priority="0x0100" type="DynamicCombo"
         idCommandList="cmdidWindowsMediaFilenameGetList"
         defaultWidth="130">
    <Parent guid="guidFirstToolWinCmdSet"
            id="ToolbarGroupID" />
    <CommandFlag>IconAndText</CommandFlag>
    <CommandFlag>CommandWellOnly</CommandFlag>
    <CommandFlag>StretchHorizontally</CommandFlag>
    <Strings>
      <CommandName>Filename</CommandName>
      <ButtonText>Enter a Filename</ButtonText>
    </Strings>
  </Combo>
</Combos>
```

##### <a name="bitmaps"></a>Растровые изображения
 Необходимо включить команды, которые отображаются вместе со значком с `Icon` элемент, который ссылается на точечный рисунок с помощью его идентификатора GUID и идентификатор. Каждый рисунок определяется как [точечный рисунок элемента](../../extensibility/bitmap-element.md) в `Bitmaps` разделе. Единственное обязательное атрибуты для `Bitmap` , определение `guid` и `href`, который указывает исходный файл. Если исходный файл представляет собой полосу ресурсов, **usedList** атрибут также является обязательным, чтобы получить список доступных образов в полосе. Дополнительные сведения см. в разделе [точечный рисунок элемента](../../extensibility/bitmap-element.md) документации.

### <a name="parenting"></a>Родительские связи
 Следующие правила определяют, как элемент можно вызвать другой элемент в качестве своего родительского элемента.

|Элемент|Заданные в этом разделе таблицы команд|Могут содержаться (родительской или размещения в `CommandPlacements` раздел или оба)|Может содержать (которые называют родителя)|
|-------------| - | - | - |
|Группа|[Элемент Groups](../../extensibility/groups-element.md), интегрированная среда разработки, других пакетов VSPackage|Меню, группы, сам элемент|Меню, группы и команды|
|Меню|[Элемент Menus](../../extensibility/menus-element.md), интегрированная среда разработки, других пакетов VSPackage|1, чтобы *n* групп|0, чтобы *n* групп|
|Toolbar|[Элемент Menus](../../extensibility/menus-element.md), интегрированная среда разработки, других пакетов VSPackage|Сам элемент|0, чтобы *n* групп|
|Menu Item|[Элемент Buttons](../../extensibility/buttons-element.md), интегрированная среда разработки, других пакетов VSPackage|1, чтобы *n* группы, сам элемент|-0, чтобы *n* групп|
|Кнопка|[Элемент Buttons](../../extensibility/buttons-element.md), интегрированная среда разработки, других пакетов VSPackage|1, чтобы *n* группы, сам элемент||
|Поле со списком|[Элемент combos](../../extensibility/combos-element.md), интегрированная среда разработки, других пакетов VSPackage|1, чтобы *n* группы, сам элемент||

### <a name="menu-command-and-group-placement"></a>Меню, команды и группы размещения
 Меню, группы или команды могут отображаться в нескольких местах в интегрированной среде разработки. Элемент должен появляться в нескольких местах, его необходимо добавить к `CommandPlacements` раздел как [элемент CommandPlacement](../../extensibility/commandplacement-element.md). Как размещения команд можно добавить любой меню, группы или команды. Тем не менее панели инструментов невозможно расположить таким образом, так как они не могут появляться в нескольких местах контекстно-зависимые.

 У команды размещения `guid`, `id`, и `priority` атрибуты. GUID и Идентификаторы должны совпадать, расположенного элемента. `priority` Атрибут управляет размещение элемента относительно других элементов. При интегрированной среды разработки объединяет два или более элементов, которые имеют одинаковый приоритет, их размещения не определено, так как интегрированная среда разработки не гарантирует, что ресурсы пакета считываются в порядке, каждый раз при сборке пакета.

 Если в меню или группу в нескольких местах, всех дочерних элементов данного меню или группы появляется в каждом экземпляре.

## <a name="command-visibility-and-context"></a>Команда видимость и контекстом
 При установке нескольких элементов VSPackage profusion меню, пункты меню и панелей инструментов может загромождать интегрированной среды разработки. Чтобы избежать этой проблемы, можно управлять видимостью отдельных элементов пользовательского интерфейса с помощью *ограничения видимости* и флаги команды.

### <a name="visibility-constraints"></a>Ограничения на видимость
 Ограничение видимости задается как [элемент VisibilityItem](../../extensibility/visibilityitem-element.md) в `VisibilityConstraints` разделе. Ограничение видимости определяет определенных контекстах пользовательского интерфейса, в которых целевой элемент видим. Меню или команду, которая включена в этом разделе отображается только в том случае, когда один из определенных контекстов активен. Если меню или команды не упоминается в этом разделе, это всегда отображается по умолчанию. В этом разделе не применяется к группам.

 `VisibilityItem` элементы должны иметь три атрибута, следующим образом: `guid` и `id` целевого элемента пользовательского интерфейса, и `context`. `context` Атрибут указывает, когда целевой элемент будут отображаться и принимает любой допустимый контекст пользовательского интерфейса, как его значение. Константы контекст пользовательского интерфейса для Visual Studio являются членами <xref:Microsoft.VisualStudio.VSConstants> класса. Каждый `VisibilityItem` элемент может содержать только один контекст значение. Чтобы применить второй контекст, создайте вторую `VisibilityItem` элемент, который указывает на один и тот же элемент, как показано в следующем примере.

```xml
<VisibilityConstraints>
  <VisibilityItem guid="guidSolutionToolbarCmdSet"
        id="cmdidTestCmd"
        context="UICONTEXT_SolutionHasSingleProject" />
  <VisibilityItem guid="guidSolutionToolbarCmdSet"
        id="cmdidTestCmd"
        context="UICONTEXT_SolutionHasMultipleProjects" />
</VisibilityConstraints>
```

### <a name="command-flags"></a>Флаги команд
 Далее перечислены флаги команды может повлиять на видимость меню и команды, которому они применяются.

 `AlwaysCreate` Меню создается, даже если он не имеет групп и кнопок.

 Допустимо для: `Menu`

 `CommandWellOnly` Примените этот флаг, если команда не отображается в меню верхнего уровня, и вы хотите сделать его доступным для настройки дополнительных оболочки, например, привязки его к ключу. После установки пакета VSPackage, пользователь может изменять эти команды, открыв **параметры** диалоговое окно, а затем изменив размещения команд в разделе **клавиатуры среды** категории. Не влияет на расположение на контекстных меню, панелей инструментов, контроллеры меню или подменю.

 Допустимым для: `Button`, `Combo`

 `DefaultDisabled` По умолчанию команда будет отключен, если не загружен VSPackage, который реализует команду или не был вызван метод QueryStatus.

 Допустимым для: `Button`, `Combo`

 `DefaultInvisible` По умолчанию команда невидим, если не загружен VSPackage, который реализует команду или не был вызван метод QueryStatus.

 Следует использовать в сочетании с `DynamicVisibility` флаг.

 Допустимым для: `Button`, `Combo`, `Menu`

 `DynamicVisibility` Видимость команды можно изменить с помощью `QueryStatus` метода или идентификатор GUID, включенный в контексте `VisibilityConstraints` раздел.

 Применяется к командам, которые отображаются в меню, а не на панели инструментов. Элементы верхнего уровня панели инструментов может быть отключена, но не скрыты, когда `OLECMDF_INVISIBLE` флаг возвращается из `QueryStatus` метод.

 В меню этот флаг также означает, что он должен автоматически скрываться после его члены скрыты. Этот флаг обычно назначается подменю, так как это поведение уже в меню верхнего уровня.

 Следует использовать в сочетании с `DefaultInvisible` флаг.

 Допустимым для: `Button`, `Combo`, `Menu`

 `NoShowOnMenuController` Если команду, которая содержит этот флаг находится на контроллере меню, команда не будут отображаться в раскрывающемся списке.

 Допустимо для: `Button`

 Дополнительные сведения о флаги команды, см. в разделе [элемент CommandFlag](../../extensibility/command-flag-element.md) документации.

#### <a name="general-requirements"></a>Общие требования
 Команде необходимо передать следующий ряд тестов, прежде чем его можно отобразить и включен:

- Команда расположено верно.

- `DefaultInvisible` Флаг не установлен.

- Виден родительского меню или панели инструментов.

- Команда не является невидимым из-за записи контекста на [элемент VisibilityConstraints](../../extensibility/visibilityconstraints-element.md) раздел.

- Код пакета VSPackage, который реализует <xref:Microsoft.VisualStudio.OLE.Interop.IOleCommandTarget> интерфейс отображает и позволяет вашей команды. Без кода интерфейса перехватить его и применить его.

- Когда пользователь щелкает команду, она подпадала под действие процедуры, описанные в [алгоритм маршрутизации](../../extensibility/internals/command-routing-algorithm.md).

## <a name="call-pre-defined-commands"></a>Вызов предварительно определенных команд
 [Элемент UsedCommands](../../extensibility/usedcommands-element.md) разрешает объектам VSPackage для доступа к командам, которые предоставляются с других пакетов VSPackage или IDE. Чтобы сделать это, создайте [элемент UsedCommand](../../extensibility/usedcommand-element.md) имеет идентификатор GUID и идентификатор команды для использования. Это гарантирует, что команда будет загружен средой Visual Studio, даже если он не является частью текущей конфигурации Visual Studio. Дополнительные сведения см. в разделе [элемент UsedCommand](../../extensibility/usedcommand-element.md).

## <a name="interface-element-appearance"></a>Внешний вид элемента интерфейса
 Ниже приведены рекомендации по выбору и размещение элементов команды.

- [!INCLUDE[vsprvs](../../code-quality/includes/vsprvs_md.md)] предлагает множество элементов пользовательского интерфейса, которые отображаются по-разному в зависимости от размещения.

- Элемент пользовательского интерфейса, который определен с помощью `DefaultInvisible` флаг не отображается в интегрированной среде разработки применяется в либо изображаемый свою реализацию VSPackage <xref:EnvDTE.IDTCommandTarget.QueryStatus%2A> метод, или связанные с конкретным контекстом пользовательского интерфейса в `VisibilityConstraints` разделе.

- Даже успешно позиционированные команды могут не отображаться. Это потому, что интегрированная среда разработки автоматически отображает или скрывает некоторые команды в зависимости от интерфейсов, которые VSPackage имеет (или не имеет) реализуется. Например реализацию VSPackage некоторых создавать интерфейсы пунктов меню, связанные с построением причины будет автоматически отображаться.

- Применение `CommandWellOnly` флаг в определении элемента пользовательского интерфейса означает, что команда может быть добавлено только благодаря настройке.

- Команды могут быть доступны только в определенных контекстах пользовательского интерфейса, к примеру, только в том случае, если диалоговое окно отображается в том случае, когда IDE в режиме конструктора.

- Чтобы определённые элементы пользовательского интерфейса для отображения в интегрированной среде разработки, необходимо реализовать один или несколько интерфейсов или написать код.

## <a name="see-also"></a>См. также
- [Расширение меню и команд](../../extensibility/extending-menus-and-commands.md)