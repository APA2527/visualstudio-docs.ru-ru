---
title: Как VSPackages добавить элементы пользовательского интерфейса (ru) Документы Майкрософт
ms.date: 11/04/2016
ms.topic: conceptual
helpviewer_keywords:
- user interfaces, adding elements
- UI element design [Visual Studio SDK], VSPackages
- VSPackages, contributing UI elements
ms.assetid: abc5d9d9-b267-48a1-92ad-75fbf2f4c1b9
author: acangialosi
ms.author: anthc
manager: jillfra
ms.workload:
- vssdk
ms.openlocfilehash: 1d9cc3184009dd98e743064db1b8eb2abe6059d1
ms.sourcegitcommit: ade07bd1cf69b8b494d171ae648cfdd54f7800d3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/21/2020
ms.locfileid: "81649601"
---
# <a name="how-vspackages-add-user-interface-elements"></a>Как VSPackages добавляют элементы пользовательского интерфейса
VSPackage может добавлять элементы пользовательского интерфейса (UI), например, меню, панели инструментов и окна инструментов, в Visual Studio с помощью файла *.vsct.*

Вы можете найти рекомендации по дизайну элементов пользовательского интерфейса в [руководствах visual Studio для пользователей](../../extensibility/ux-guidelines/visual-studio-user-experience-guidelines.md)Visual Studio.

## <a name="the-visual-studio-command-table-architecture"></a>Архитектура таблицы команд Visual Studio
Как уже отмечалось, архитектура таблицы команд поддерживает учёные архитектурные принципы. Принципы абстракций, структуры данных и инструменты архитектуры командной таблицы следующие:

- Есть три основных вида элементов: меню, команды и группы. Меню может быть выставлено в uI в виде меню, подменю, панели инструментов или окна инструментов. Команды — это процедуры, которые пользователь может выполнять в IDE, и они могут быть выставлены в виде элементов меню, кнопок, коробок списка или других элементов управления. Группы представляют контейнеры как для меню, так и для команд.

- Каждый элемент определяется определением, описывающее элемент, его приоритет по сравнению с другими элементами, и флаги, изменяющие его поведение.

- Каждый элемент имеет размещение, которое описывает родитель элемента. Элемент может иметь несколько родителей, так что он может отображаться в нескольких местах в uI.

Каждая команда должна иметь группу в качестве родительской группы, даже если она является единственным ребенком в этой группе. Каждое стандартное меню также должно иметь родительскую группу. Инструментарии и окна инструментов выступают в качестве своих родителей. Группа может иметь в качестве своего родителя главный бар меню Visual Studio или любое меню, панель инструментов или окно инструментов.

### <a name="how-items-are-defined"></a>Как определяются элементы
Файл *.vsct* отформатирован в XML. Он определяет элементы uI для пакета и определяет, где эти элементы отображаются в IDE. Каждое меню, группа или команда в пакете сначала присваиваются GUID и ID в `Symbols` разделе. На протяжении всего остального файла *.vsct* каждое меню, команда и группа идентифицируется по его комбинации GUID и ID. В следующем примере `Symbols` показан типичный раздел, созданный шаблоном пакета Visual Studio при выборе **команды меню** в шаблоне.

```xml
<Symbols>
  <!-- This is the package guid. -->
  <GuidSymbol name="guidMenuTextPkg" value="{b1253bc6-d266-402b-89e7-5e3d3b22c746}" />

  <!-- This is the guid used to group the menu commands together -->
  <GuidSymbol name="guidMenuTextCmdSet" value="{a633d4e4-6c65-4436-a138-1abeba7c9a69}">
    <IDSymbol name="MyMenuGroup" value="0x1020" />
    <IDSymbol name="cmdidMyCommand" value="0x0100" />
  </GuidSymbol>

  <GuidSymbol name="guidImages" value="{53323d9a-972d-4671-bb5b-9e418480922f}">
    <IDSymbol name="bmpPic1" value="1" />
    <IDSymbol name="bmpPic2" value="2" />
    <IDSymbol name="bmpPicSearch" value="3" />
    <IDSymbol name="bmpPicX" value="4" />
    <IDSymbol name="bmpPicArrows" value="5" />
  </GuidSymbol>
</Symbols>
```

Элемент верхнего уровня `Symbols` раздела — [элемент GuidSymbol.](../../extensibility/guidsymbol-element.md) `GuidSymbol`элементы отображают имена ГУИД, которые используются IDE для идентификации пакетов и их составных частей.

> [!NOTE]
> GUIDs генерируются автоматически шаблоном пакета Visual Studio. Вы также можете создать уникальный GUID, нажав **Создать GUID** в меню **Инструментов.**

Первый `GuidSymbol` элемент, `guid<PackageName>Pkg`является GUID самого пакета. Это GUID, который используется Visual Studio для загрузки пакета. Как правило, он не имеет элементов ребенка.

По конвенции, меню и команды `GuidSymbol` сгруппированы `guid<PackageName>CmdSet`под вторым элементом, `GuidSymbol` и `guidImages`bitmaps находятся под третьим элементом, . Вы не должны следовать этой конвенции, но каждое меню, группа, команда `GuidSymbol` и биткарта должны быть ребенком элемента.

Во втором `GuidSymbol` элементе, представляющем набор команд `IDSymbol` пакетов, находятся несколько элементов. Каждый [элемент IDSymbol](../../extensibility/idsymbol-element.md) отображает имя в числовое значение и может представлять меню, группу или команду, которая является частью набора команд. Элементы `IDSymbol` третьего `GuidSymbol` элемента представляют бит-карты, которые могут быть использованы в качестве значков для команд. Поскольку пары GUID/ID должны быть уникальными в приложении, ни один из двух детей одного `GuidSymbol` элемента не может иметь одинаковое значение.

### <a name="menus-groups-and-commands"></a>Меню, группы и команды
Когда меню, группа или команда имеют GUID и ID, его можно добавить в IDE. Каждый элемент uI должен иметь следующие вещи:

- Атрибут, `guid` сопозированный `GuidSymbol` с именем элемента, под которым определяется элемент uI.

- Атрибут, `id` сопозированный `IDSymbol` с именем связанного элемента.

Вместе и `guid` `id` атрибуты составляют *подпись* элемента uI.

- Атрибут, `priority` определяющий размещение элемента uI в родительском меню или группе.

- [Родительский элемент,](../../extensibility/parent-element.md) который имеет `guid` и `id` атрибуты, которые определяют подпись родительского меню или группы.

#### <a name="menus"></a>Меню
Каждое меню определяется как `Menus` элемент [меню](../../extensibility/menu-element.md) в разделе. Меню должно `guid`иметь `id`и `priority` атрибуты, `Parent` и элемент, а также следующие дополнительные атрибуты и дети:

- Атрибут, `type` который определяет, должно ли меню отображаться в IDE как своего рода меню или в качестве панели инструментов.

- [Элемент строки,](../../extensibility/strings-element.md) содержащий [элемент ButtonText,](../../extensibility/buttontext-element.md)который определяет название меню в IDE, и [элемент CommandName,](../../extensibility/commandname-element.md)который определяет имя, используемое в окне **команды** для доступа к меню.

- Дополнительные флаги. [Элемент CommandFlag](../../extensibility/command-flag-element.md) может отображаться в определении меню, чтобы изменить его внешний вид или поведение в IDE.

Каждый `Menu` элемент должен иметь группу в качестве родительского элемента, если только он не является доковым элементом, таким как панель инструментов. Док-меню является его собственным родителем. Для получения дополнительной информации о `type` меню и [Menu element](../../extensibility/menu-element.md) значениях для атрибута см.

В следующем примере показано меню, которое отображается в меню Visual Studio рядом с меню **Tools.**

```xml
<Menu guid="guidTopLevelMenuCmdSet" id="TopLevelMenu" priority="0x700" type="Menu">
  <Parent guid="guidSHLMainMenu" id="IDG_VS_MM_TOOLSADDINS" />
  <Strings>
    <ButtonText>TestMenu</ButtonText>
    <CommandName>TestMenu</CommandName>
  </Strings>
</Menu>
```

#### <a name="groups"></a>Группы
Группа — это элемент, определяемый в `Groups` разделе файла *.vsct.* Группы - это просто контейнеры. Они не отображаются в IDE, кроме как разделительная линия в меню. Таким образом, [элемент группы](../../extensibility/group-element.md) определяется только его подписью, приоритетом и родительским элементом.

Группа может иметь меню, другую группу или себя в качестве родителя. Тем не менее, родитель, как правило, меню или панели инструментов. Меню в предыдущем примере является `IDG_VS_MM_TOOLSADDINS` ребенком группы, и эта группа является ребенком панели меню Visual Studio. Группа в следующем примере является ребенком меню в предыдущем примере.

```xml
<Group guid="guidTopLevelMenuCmdSet" id="MyMenuGroup" priority="0x0600">
  <Parent guid="guidTopLevelMenuCmdSet" id="TopLevelMenu"/>
</Group>
```

Поскольку эта группа, как правило, содержит команды, поскольку она является частью меню. Тем не менее, он также может содержать другие меню. Так определяются подменю, как показано в следующем примере.

```xml
<Menu guid="guidTopLevelMenuCmdSet" id="SubMenu" priority="0x0100" type="Menu">
  <Parent guid="guidTopLevelMenuCmdSet" id="MyMenuGroup"/>
  <Strings>
    <ButtonText>Sub Menu</ButtonText>
    <CommandName>Sub Menu</CommandName>
  </Strings>
</Menu>
```

#### <a name="commands"></a>Команды
Команда, предоставляемая IDE, определяется как [элемент кнопки](../../extensibility/button-element.md) или [элемент Combo.](../../extensibility/combo-element.md) Чтобы появиться в меню или панели инструментов, команда должна иметь группу в качестве родительской группы.

##### <a name="buttons"></a>Кнопки
Кнопки определяются `Buttons` в разделе. Любой элемент меню, кнопка или другой элемент, который пользователь нажимает для выполнения одной команды, считается кнопкой. Некоторые типы кнопок также могут включать функциональность списка. Кнопки имеют те же требуемые и дополнительные атрибуты, что и меню, а также могут иметь [элемент значок,](../../extensibility/icon-element.md) который определяет GUID и идентификатор битовой карты, представляющей кнопку в IDE. Для получения дополнительной информации о кнопках [Buttons element](../../extensibility/buttons-element.md) и их атрибутах см.

Кнопка в следующем примере является ребенком группы в предыдущем примере и будет отображаться в IDE в качестве элемента меню в родительском меню этой группы.

```xml
<Button guid="guidTopLevelMenuCmdSet" id="cmdidTestCommand" priority="0x0100" type="Button">
  <Parent guid="guidTopLevelMenuCmdSet" id="MyMenuGroup" />
  <Icon guid="guidImages" id="bmpPic1" />
  <Strings>
    <CommandName>cmdidTestCommand</CommandName>
    <ButtonText>Test Command</ButtonText>
  </Strings>
</Button>
```

##### <a name="combos"></a>Комбо
Комбо определены `Combos` в разделе. Каждый `Combo` элемент представляет собой окно списка выпадающих в IDE. Коробка списка может или не может быть writable пользователями, `type` в зависимости от значения атрибута комбо. Комбо имеют те же элементы и поведение, что кнопки, а также может иметь следующие дополнительные атрибуты:

- Атрибут, `defaultWidth` опознававательный промедляет ширину пикселей.

- Атрибут, `idCommandList` опознавав список, содержащий элементы, отображаемые в поле списка. Список команд должен быть `GuidSymbol` объявлен в том же узло, который содержит комбо.

Следующий пример определяет комбо элемент.

```xml
<Combos>
  <Combo guid="guidFirstToolWinCmdSet"
         id="cmdidWindowsMediaFilename"
         priority="0x0100" type="DynamicCombo"
         idCommandList="cmdidWindowsMediaFilenameGetList"
         defaultWidth="130">
    <Parent guid="guidFirstToolWinCmdSet"
            id="ToolbarGroupID" />
    <CommandFlag>IconAndText</CommandFlag>
    <CommandFlag>CommandWellOnly</CommandFlag>
    <CommandFlag>StretchHorizontally</CommandFlag>
    <Strings>
      <CommandName>Filename</CommandName>
      <ButtonText>Enter a Filename</ButtonText>
    </Strings>
  </Combo>
</Combos>
```

##### <a name="bitmaps"></a>Битовые карты
Команды, которые будут отображаться вместе с `Icon` иконой, должны включать элемент, относящегося к биткарте, используя ее GUID и ID. Каждая бит-карта определяется как `Bitmaps` [элемент Bitmap](../../extensibility/bitmap-element.md) в разделе. Единственными необходимыми атрибутами `guid` для `href` `Bitmap` определения являются и, что указывает на исходный файл. Если исходный файл является полосой ресурсов, также требуется атрибут **usedList,** чтобы перечислить доступные изображения в полосе. Для получения дополнительной информации ознакомьтесь с документацией [элемента Bitmap.](../../extensibility/bitmap-element.md)

### <a name="parenting"></a>Воспитание
Следующие правила определяют, как элемент может называть другой элемент в качестве его родителя.

|Элемент|Определено в этом разделе таблицы командования|Может содержаться (как родитель, или `CommandPlacements` путем размещения в разделе, или оба)|Может содержать (называется как родитель)|
|-------------| - | - | - |
|Группа|[Элемент группы,](../../extensibility/groups-element.md)IDE, другие VSPackages|Меню, группа, сам элемент|Меню, группы и команды|
|Меню|[Элемент меню](../../extensibility/menus-element.md), IDE, другие VSPackages|1 до *n* групп|От 0 до *n* групп|
|Панель инструментов|[Элемент меню](../../extensibility/menus-element.md), IDE, другие VSPackages|Сам элемент|От 0 до *n* групп|
|Menu Item|[Элемент кнопки](../../extensibility/buttons-element.md), IDE, другие VSPackages|1 до *n* групп, сам элемент|-0 к *n* групп|
|Кнопка|[Элемент кнопки](../../extensibility/buttons-element.md), IDE, другие VSPackages|1 до *n* групп, сам элемент||
|Комбинированная|[Комбо элемент](../../extensibility/combos-element.md), IDE, другие VSPackages|1 до *n* групп, сам элемент||

### <a name="menu-command-and-group-placement"></a>Меню, команда и размещение групп
Меню, группа или команда могут отображаться в нескольких местах IDE. Для того чтобы элемент отображался в `CommandPlacements` нескольких местах, он должен быть добавлен в раздел в качестве [элемента CommandPlacement.](../../extensibility/commandplacement-element.md) Любое меню, группа или команда могут быть добавлены в качестве размещения команд. Однако панели инструментов не могут быть расположены таким образом, поскольку они не могут отображаться в нескольких чувствительных к контексту местах.

Размещение команд `guid`имеет `id`и `priority` атрибуты. GUID и идентификатор должны соответствовать элементу, который расположен. Атрибут `priority` регулирует размещение элемента по отношению к другим элементам. Когда IDE объединяет два или более элементов с одинаковым приоритетом, их размещение не определено, поскольку IDE не гарантирует, что ресурсы пакетов считываются в одном порядке каждый раз, когда пакет построен.

Если меню или группа отображаются в нескольких местах, все дети этого меню или группы будут отображаться в каждом экземпляре.

## <a name="command-visibility-and-context"></a>Видимость команды и контекст
При установке нескольких VSPackages изобилие меню, элементов меню и инструментов может загромождать IDE. Чтобы избежать этой проблемы, можно управлять видимостью отдельных элементов uI, используя *ограничения видимости* и флаги команд.

### <a name="visibility-constraints"></a>Ограничения видимости
Ограничение видимости устанавливается в виде `VisibilityConstraints` [элемента VisibilityItem](../../extensibility/visibilityitem-element.md) в разделе. Ограничение видимости определяет определенные контексты миноносного элемента, в которых виден целевой элемент. Меню или команда, включенные в этот раздел, видны только тогда, когда один из определенных контекстов активен. Если меню или команда не упоминаются в этом разделе, оно всегда отображается по умолчанию. Данный раздел не распространяется на группы.

`VisibilityItem`элементы должны иметь три атрибута, а именно: `guid` и `id` `context`элемент целевого элемента uI, и . Атрибут `context` определяет, когда целевой элемент будет виден, и использует любой допустимый контекст uI в качестве его значения. Константы контекста uI для <xref:Microsoft.VisualStudio.VSConstants> Visual Studio являются членами класса. Каждый `VisibilityItem` элемент может принимать только одно контекстное значение. Чтобы применить второй контекст, `VisibilityItem` создайте второй элемент, который указывает на тот же элемент, как показано в следующем примере.

```xml
<VisibilityConstraints>
  <VisibilityItem guid="guidSolutionToolbarCmdSet"
        id="cmdidTestCmd"
        context="UICONTEXT_SolutionHasSingleProject" />
  <VisibilityItem guid="guidSolutionToolbarCmdSet"
        id="cmdidTestCmd"
        context="UICONTEXT_SolutionHasMultipleProjects" />
</VisibilityConstraints>
```

### <a name="command-flags"></a>Флаги командования
Следующие флаги команд могут повлиять на видимость меню и команд, к которые они применяются.

`AlwaysCreate`Меню создается, даже если в нем нет групп или кнопок.

Действительно для:`Menu`

`CommandWellOnly`Примените этот флаг, если команда не отображается в меню верхнего уровня, и вы хотите сделать его доступным для дополнительной настройки оболочки, например, привязывая его к ключу. После установки VSPackage пользователь может настроить эти команды, открыв поле диалога **Options,** а затем отредактивая размещение команд в категории **"Среда клавиатуры".** Не влияет на размещение в меню ярлыка, панели инструментов, контроллеры меню или подменю.

Действительно для: `Button`,`Combo`

`DefaultDisabled`По умолчанию команда отключается, если VSPackage, который реализует команду, не загружен или метод queryStatus не был вызван.

Действительно для: `Button`,`Combo`

`DefaultInvisible`По умолчанию команда невидима, если VSPackage, который реализует команду, не загружен или метод queryStatus не был вызван.

Следует сочетать `DynamicVisibility` с флагом.

Действительно `Button`для: `Combo`, ,`Menu`

`DynamicVisibility`Видимость команды может быть изменена `QueryStatus` с помощью метода или контекста GUID, который включен в `VisibilityConstraints` раздел.

Применяется к командам, которые появляются в меню, а не на панели инструментов. Элементы панели инструментов верхнего уровня могут быть `OLECMDF_INVISIBLE` отключены, `QueryStatus` но не скрыты, когда флаг возвращается из метода.

В меню этот флаг также указывает на то, что он должен автоматически скрываться, когда его члены скрыты. Этот флаг обычно назначается подменю, поскольку меню верхнего уровня уже имеют такое поведение.

Следует сочетать `DefaultInvisible` с флагом.

Действительно `Button`для: `Combo`, ,`Menu`

`NoShowOnMenuController`Если команда с этим флагом позиционируется на контроллере меню, команда не отображается в списке выпадающих.

Действительно для:`Button`

Для получения дополнительной информации о флагах команд можно ознакомиться с документацией [элемента CommandFlag.](../../extensibility/command-flag-element.md)

#### <a name="general-requirements"></a>Общие требования
Ваша команда должна пройти следующие серии тестов, прежде чем она может быть отображана и включена:

- Команда позиционируется правильно.

- Флаг `DefaultInvisible` не установлен.

- Родительское меню или панель инструментов видна.

- Команда не невидима из-за ввода контекста в разделе [Элемент VisibilityConstraints.](../../extensibility/visibilityconstraints-element.md)

- VSPackage код, который <xref:Microsoft.VisualStudio.OLE.Interop.IOleCommandTarget> реализует интерфейс отображает и позволяет вашей команды. Ни один код интерфейса не перехватил его и не действовал на нем.

- Когда пользователь нажимает на вашу команду, она становится предметом процедуры, изложенной в [алгоритме routing.](../../extensibility/internals/command-routing-algorithm.md)

## <a name="call-pre-defined-commands"></a>Вызов заранее определенных команд
[Элемент UsedCommands](../../extensibility/usedcommands-element.md) позволяет VSPackages получать доступ к командам, предоставляемым другими VSPackages или IDE. Для этого создайте [элемент UsedCommand,](../../extensibility/usedcommand-element.md) который использует GUID и идентификатор команды. Это гарантирует, что команда будет загружена Visual Studio, даже если она не является частью текущей конфигурации Visual Studio. Для получения дополнительной [UsedCommand element](../../extensibility/usedcommand-element.md)информации см.

## <a name="interface-element-appearance"></a>Внешний вид элемента интерфейса
Рассмотрение вопроса о выборе и позиционировании элементов команды следующим образом:

- [!INCLUDE[vsprvs](../../code-quality/includes/vsprvs_md.md)]предлагает множество элементов uI, которые появляются по-разному в зависимости от размещения.

- Элемент uI, определяемый с помощью `DefaultInvisible` флага, не будет отображаться в IDE, если он не отображается в его реализации <xref:EnvDTE.IDTCommandTarget.QueryStatus%2A> метода VSPackage или связан с определенным контекстом uI в `VisibilityConstraints` разделе.

- Даже успешно расположенная команда может не отображаться. Это происходит потому, что IDE автоматически скрывает или отображает некоторые команды, в зависимости от интерфейсов, которые VSPackage имеет (или не реализовал). Например, реализация некоторых интерфейсов сборки VSPackage приводит к автоматическому отображанию элементов меню, связанных со сборкой.

- Применение флага `CommandWellOnly` в определении элемента пользовательского или айва означает, что команда может быть добавлена только путем настройки.

- Команды могут быть доступны только в определенных контекстах uI, например, только при отображении диалогового окна при представлении IDE.

- Чтобы вызвать отображение определенных элементов интерфейса в IDE, необходимо реализовать один или несколько интерфейсов или написать код.

## <a name="see-also"></a>См. также
- [Расширить меню и команды](../../extensibility/extending-menus-and-commands.md)
