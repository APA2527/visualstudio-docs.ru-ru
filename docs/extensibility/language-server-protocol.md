---
title: Обзор протокола языкового сервера (ru) Документы Майкрософт
ms.date: 11/14/2017
ms.topic: conceptual
ms.assetid: 6a7d93c2-31ea-4bae-8b29-6988a567ddf2
author: acangialosi
ms.author: anthc
manager: jillfra
ms.workload:
- vssdk
ms.openlocfilehash: c3bd5dce3cfb7022a8abb6397dc87b418144cbe1
ms.sourcegitcommit: 16a4a5da4a4fd795b46a0869ca2152f2d36e6db2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2020
ms.locfileid: "80703104"
---
# <a name="language-server-protocol"></a>Протокол языкового сервера

## <a name="what-is-the-language-server-protocol"></a>Что такое протокол языкового сервера?

Поддержка богатых функций редактирования, таких как автоматическое завершение исходного кода или **Перейти к определению** для языка программирования в редакторе или IDE, традиционно является очень сложной задачей и отнимает много времени. Обычно это требует написания модели домена (сканер, парсер, проверка типа, строитель и многое другое) на языке программирования редактора или IDE. Например, плагин Eclipse CDT, который обеспечивает поддержку C/C'в Java, написан на Java, так как сам Eclipse IDE написан на Java. Следуя этому подходу, это будет означать внедрение модели домена C/C' в TypeScript для Visual Studio Code и отдельной модели домена в C для Visual Studio.

Создание языковых моделей доменов также намного проще, если инструмент разработки может повторно использовать существующие библиотеки, специфичные для языка. Тем не менее, эти библиотеки, как правило, реализованы в самом языке программирования (например, хорошие модели доменов C/C'' реализованы в C/C). Интеграция библиотеки C/C е в редактор, написанный в TypeScript, технически возможна, но трудно сделать.

### <a name="language-servers"></a>Языковые серверы

Другой подход заключается в том, чтобы запустить библиотеку в своем собственном процессе и использовать межпроцессовую связь для общения с ней. Сообщения, отправленные туда и обратно, образуют протокол. Протокол языкового сервера (LSP) является продуктом стандартизации сообщений, обмениваемых между инструментом разработки и процессом языкового сервера. Использование языковых серверов или демонов не является новой или новой идеей. Редакторы, как Vim и Emacs делали это в течение некоторого времени, чтобы обеспечить семантические поддержки автозавершения. Цель LSP состояла в том, чтобы упростить такого рода интеграции и обеспечить полезную основу для раскрытия языковых функций для различных инструментов.

Наличие общего протокола позволяет интегрировать функции языка программирования в инструмент разработки с минимальной суетой, повторно используя существующую реализацию модели домена языка. Языковый сервер может быть написан в PHP, Python или Java, а LSP позволяет легко интегрировать его в различные инструменты. Протокол работает на общем уровне абстракции, так что инструмент может предложить богатые языковые услуги без необходимости в полной мере понимать нюансы, характерные для базовой модели домена.

## <a name="how-work-on-the-lsp-started"></a>Как началась работа над ЛСП

LSP развивалась с течением времени, и сегодня он находится на версии 3.0. Это началось, когда концепция языкового сервера была подхвачена OmniSharp, чтобы обеспечить богатые функции редактирования для C. Первоначально OmniSharp использовал протокол HTTP с полезной нагрузкой JSON и был интегрирован в несколько редакторов, включая [Visual Studio Code.](https://code.visualstudio.com)

Примерно в то же время, Microsoft начала работать на сервере языка TypeScript, с идеей поддержки TypeScript в редакторах, таких как Emacs и Sublime Text. В этой реализации редактор общается через stdin/stdout с процессом сервера TypeScript и использует полезную нагрузку JSON, вдохновленную протоколом v8 отладчика для запросов и ответов. Сервер TypeScript был интегрирован в плагин TypeScript Sublime и VS Code для богатого редактирования TypeScript.

После интеграции двух различных языковых серверов команда VS Code начала изучать общий языковой серверный протокол для редакторов и IDEs. Общий протокол позволяет поставщику языка создать единый языковой сервер, который может быть использован различными IDEs. Потребитель языкового сервера должен реализовать клиентскую сторону протокола только один раз. Это приводит к беспроигрышной ситуации как для поставщика языка, так и для потребителя языка.

Протокол языкового сервера начался с протокола, используемого сервером TypeScript, расширяя его с помощью большего количества языковых функций, вдохновленных API языка VS Code. Протокол поддерживается JSON-RPC для удаленного вызова из-за его простоты и существующих библиотек.

Команда VS Code прототипировала протокол, реализовав несколько серверов языка linter, которые отвечают на запросы на лисицу (сканирование) файла и возвращают набор обнаруженных предупреждений и ошибок. Цель состояла в том, чтобы свести файл к вовлекаемому в документ, что означает, что во время сеанса редактора будет много запросов. Имеет смысл поддерживать запуск сервера, чтобы для каждого пользователя не пришлось запускать новый процесс проверки. Было реализовано несколько linter-серверов, в ключая расширения VS Code ESLint и TSLint. Эти два сервера linter реализованы в TypeScript/JavaScript и работаются на Node.js. Они совместно разрадели библиотеку, которая реализует клиентскую и серверную часть протокола.

## <a name="how-the-lsp-works"></a>Как работает LSP

Языковой сервер работает в своем собственном процессе, и такие инструменты, как Visual Studio или VS Code, общаются с сервером, используя языковой протокол через JSON-RPC. Еще одним преимуществом языкового сервера, работающего в специальном процессе, является то, что избегаются проблемы с производительностью, связанные с одной моделью процесса. Фактическим транспортным каналом может быть stdio, розетки, названные трубы, или узла ipc, если клиент и сервер написаны в Node.js.

Ниже приведен пример того, как инструмент и языковой сервер общаются во время рутинной сессии редактирования:

![диаграмма потока lsp](media/lsp-flow-diagram.png)

* **Пользователь открывает файл (называемый документом) в инструменте:** Инструмент уведомляет языковой сервер об открытии документа ('textDocument/didOpen'). Отныне правда о содержимом документа больше не находится в файловой системе, а хранится инструментом в памяти.

* **Пользователь вносит изменения:** Инструмент уведомляет сервер об изменении документа ('textDocument/didChange') и семантическая информация программы обновляется языковым сервером. По мере этого языковой сервер анализирует эту информацию и уведомляет инструмент с обнаруженными ошибками и предупреждениями ('textDocument/publishDiagnostics').

* **Пользователь выполняет "Перейти к определению" на символ е-редакторе**: Инструмент отправляет запрос "textDocument/definition" с двумя параметрами: (1) документ URI и (2) текстовое положение, откуда запрос Go to Definition был инициирован на сервер. Сервер отвечает документом URI и положением определения символа внутри документа.

* **Пользователь закрывает документ (файл):** Из инструмента отправляется уведомление 'textDocument/didClose', информирующее языковой сервер о том, что документ больше не находится в памяти и что текущее содержимое теперь обновлено в файловой системе.

Этот пример иллюстрирует, как протокол общается с языковым сервером на уровне функций редактора, таких как "Перейти к определению", "Найти все ссылки". Типы данных, используемые протоколом, являются редактором или типами данных IDE, такими как открытый в настоящее время текстовый документ и положение курсора. Типы данных не находятся на уровне модели домена языка программирования, которая обычно предоставляет абстрактные деревья синтаксиса и символы компилятора (например, разрешенные типы, пространства имен,...). Это значительно упрощает протокол.

Теперь давайте рассмотрим запрос 'textDocument/definition' более подробно. Ниже приведены полезные нагрузки, которые идут между инструментом клиента и языковым сервером для запроса "Перейти к определению" в документе СЗ.

Это запрос:

```json
{
    "jsonrpc": "2.0",
    "id" : 1,
    "method": "textDocument/definition",
    "params": {
        "textDocument": {
            "uri": "file:///p%3A/mseng/VSCode/Playgrounds/cpp/use.cpp"
        },
        "position": {
            "line": 3,
            "character": 12
        }
    }
}
```

Это ответ:

```json
{
    "jsonrpc": "2.0",
    "id": "1",
    "result": {
        "uri": "file:///p%3A/mseng/VSCode/Playgrounds/cpp/provide.cpp",
        "range": {
            "start": {
                "line": 0,
                "character": 4
            },
            "end": {
                "line": 0,
                "character": 11
            }
        }
    }
}
```

Оглядываясь назад, описание типов данных на уровне редактора, а не на уровне модели языка программирования является одной из причин успеха протокола языкового сервера. Гораздо проще стандартизировать текстовый документ URI или положение курсора по сравнению с стандартизацией абстрактного дерева синтаксиса и символов компилятора на разных языках программирования.

Когда пользователь работает с разными языками, VS Code обычно запускает языковой сервер для каждого языка программирования. В приведенном ниже примере показан сеанс, в котором пользователь работает над файлами Java и SASS.

![Java и sass](media/lsp-java-and-sass.png)

### <a name="capabilities"></a>Возможности

Не каждый языковой сервер может поддерживать все функции, определенные протоколом. Таким образом, клиент и сервер объявляет о поддержке функции через "возможности". Например, сервер объявляет, что он может обрабатывать запрос 'textDocument/definition', но он может не обрабатывать запрос 'рабочее пространство/символ'. Аналогичным образом, клиенты могут объявить, что они могут предоставить уведомления «о сохранении» до сохранения документа, так что сервер может вычислить текстовые правки для автоматического форматирования отредактированного документа.

## <a name="integrating-a-language-server"></a>Интеграция языкового сервера

Фактическая интеграция языкового сервера в определенный инструмент не определяется протоколом языкового сервера и оставлена на усмотрение исполнителей инструмента. Некоторые инструменты интегрируют языковые серверы в общем плане, имея расширение, которое может начать и поговорить с любым видом языкового сервера. Другие, такие как VS Code, создают пользовательское расширение на языковом сервере, так что расширение по-прежнему может предоставить некоторые пользовательские функции языка.

Для упрощения реализации языковых серверов и клиентов существуют библиотеки или SDK для клиентских и серверных частей. Эти библиотеки предусмотрены для различных языков. Например, есть [модуль language client npm](https://www.npmjs.com/package/vscode-languageclient) для облегчения интеграции языкового сервера в расширение VS Code и другого [модуля language server npm](https://www.npmjs.com/package/vscode-languageserver) для написания языкового сервера с помощью Node.js. Это текущий [список](https://github.com/Microsoft/language-server-protocol/wiki/Protocol-Implementations) библиотек поддержки.

## <a name="using-the-language-server-protocol-in-visual-studio"></a>Использование протокола языкового сервера в Visual Studio

* [Добавление расширения протокола языкового сервера](adding-an-lsp-extension.md) - Узнайте об интеграции языкового сервера в Visual Studio.
