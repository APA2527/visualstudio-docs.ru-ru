---
title: Обзор протокола Server языка | Документация Майкрософт
ms.date: 11/14/2017
ms.topic: conceptual
ms.assetid: 6a7d93c2-31ea-4bae-8b29-6988a567ddf2
author: madskristensen
ms.author: madsk
manager: jillfra
ms.workload:
- vssdk
ms.openlocfilehash: 8f6f114d7165b85051092234ea33dfc7f73e1487
ms.sourcegitcommit: 40d612240dc5bea418cd27fdacdf85ea177e2df3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/29/2019
ms.locfileid: "66309625"
---
# <a name="language-server-protocol"></a>Протокол языкового сервера

## <a name="what-is-the-language-server-protocol"></a>Что такое протокол языкового сервера

Вспомогательные возможностей расширенного редактирования, такие как исходный код, автозавершения или **перейти к определению** для языка программирования, в редакторе или интегрированной среды разработки — обычно очень сложной и занимать много времени. Обычно требует написания модель предметной области (сканера, средство синтаксического анализа, проверки типа, конструктор и многое другое) на языке программирования редакторе или интегрированной среды разработки. Например подключаемый модуль Eclipse отчеты ЦЕНТРА, который обеспечивает поддержку для C/C++ в интегрированной среде разработки Eclipse создается на языке Java с момента самой интегрированной среды разработки Eclipse создается на языке Java. При таком подходе это означает, реализация модели домена C/C++ в TypeScript для Visual Studio Code и модель отдельный домен в C# для Visual Studio.

Создание моделей доменного языка также являются гораздо проще, если это средство разработки можно повторно использовать существующие библиотеки конкретного языка. Тем не менее эти библиотеки обычно реализуются в языке программирования (например, хорошим C/C++ домена модели реализуются в C/C++). Интеграция библиотеку C/C++ в редакторе на языке TypeScript технически возможно, но трудно сделать.

### <a name="language-servers"></a>Серверы языка

Другой подход заключается в том, для запуска библиотеки в отдельном процессе и позволяет обращаться к нему межпроцессного взаимодействия. Сообщения, отправленные и обратно форме протокол. Протокол языкового сервера (LSP) — это совокупность стандартизации сообщений, передаваемых между средство разработки и процессом сервера языка. С помощью языка серверов или программами не новые или novel идея. Редакторы, такие как Vim и Emacs: ведете это некоторое время для обеспечения поддержки семантического автоматического завершения. Цель LSP было упрощение подобных нарушений интеграции и формируют методологию, полезные для предоставления возможности языка для широкого спектра средств.

Общий протокол обеспечивает интеграцию возможностей языка программирования в средство разработки с минимальными усилиями, повторно используя существующую реализацию языка доменной модели. Язык сервера внутренний сервер может быть записан в PHP, Python или Java и использует LSP ее легко интегрировать в различные средства. Протокол работает на общего уровня абстракции, таким образом, это средство может предложить широкие возможности языковой службы без необходимости полностью понять особенности, относящиеся к базовой модели домена.

## <a name="how-work-on-the-lsp-started"></a>Как работают на LSP работы

LSP выявленная со временем, и сегодня он находится в версии 3.0. Он начинается, когда концепции языка сервера выбран в OmniSharp обеспечить широкие возможности редактирования для C#. Изначально OmniSharp используется протокол HTTP с полезными данными JSON и была интегрирована в несколько редакторов, в том числе [Visual Studio Code](https://code.visualstudio.com).

Примерно то же время корпорации Майкрософт начал работать на сервере языка TypeScript, поддержка TypeScript в редакторов Emacs и Sublime Text идея. В данном случае редактор обменивается данными через stdin и stdout с TypeScript серверный процесс и использует по протоколу отладчика V8 полезные данные JSON для запросов и ответов. Сервер TypeScript был интегрирован в TypeScript Sublime подключаемого модуля и VS Code для многофункциональное редактирование TypeScript.

После интегрированы два сервера на другой язык, команда VS Code начали работу с общего протокола server языка для редакторов и интегрированных сред разработки. Общий протокол позволяет поставщик языка для создания сервера для одного языка, который может использоваться в различных сред разработки. Потребитель языка сервера достаточно для реализации протокола на стороне клиента один раз. В результате наполнен ситуации для поставщика языка и языка потребитель.

Протокол языкового сервера к работе с протокол, используемый сервером TypeScript, развернув его с большим количеством возможностей языка по язык Visual STUDIO Code API. Протокол поддерживается с JSON-RPC для удаленного вызова благодаря простоте и существующие библиотеки.

VS файл кода team прототипом протокола путем реализации нескольких серверов анализатор кода языка, которых отвечать на запросы к lint (проверка) и возвращает набор обнаруженных предупреждений и ошибок. Мы хотели lint файл как пользовательские изменения в документе, это означает, что будет много запросов анализа кода во время сеанса редактора. Это было уместно, чтобы сохранить настройку и запуск сервера, чтобы новый процесс анализа кода не нужно запустить для каждого изменения пользователя. Несколько серверов анализатор кода были реализованы, включая Visual STUDIO Code расширения ESLint и TSLint. Эти два сервера анализатор кода, как реализовано в TypeScript и JavaScript и работают на Node.js. Они совместно используют библиотеку, которая реализует клиентские и серверные часть протокола.

## <a name="how-the-lsp-works"></a>Как работает LSP

Язык сервера выполняется в отдельном процессе и средств, таких как Visual Studio или VS Code взаимодействовать с сервером по протоколу языка через JSON-RPC. Еще одним преимуществом языка сервер, работающий в выделенном процессе является то, что устранение проблем производительности, связанные с моделью одного процесса. Фактический транспортный канал может быть stdio, сокеты, именованные каналы или ipc узел Если сервер и клиент написаны на Node.js.

Ниже приведен пример как средство и языка сервера взаимодействовать в ходе выполнения подпрограммы редактирует сеанса:

![Схема потока LSP](media/lsp-flow-diagram.png)

* **Пользователь открывает файл (называемого документом) в средстве**: Средство языка уведомляет сервер о том, что документ открыт («textDocument/didOpen»). Теперь правду о содержимом документа больше не находится в файловой системе, но сохраняются с помощью средства в памяти.

* **Пользователь вносит изменения**: Средство уведомляет сервер об изменении документа («textDocument/didChange») и семантической информации программы обновляется сервером языка. Как в этом случае сервер языка анализирует эту информацию и уведомляет средство с обнаруженные ошибки и предупреждения («textDocument/publishDiagnostics»).

* **Пользователь выполняет «Перейти к определению» символ в редакторе**: Отправляется запрос «textDocument и определение» с двумя параметрами: (1) документ URI и (2) положения текста которой было начато перейти к определению запроса на сервер. Сервер отвечает с URI документа и расположение определения символа внутри документа.

* **Пользователь закрывает документ (файл)** : Уведомление «textDocument/didClose» отправляется из средства, о том, язык сервера, он теперь больше не в памяти и что текущее содержимое теперь в актуальном состоянии в файловой системе.

В этом примере показано, как протокол взаимодействует с сервером языка на уровне функций редактора, таких как «Перейти к определению», «Найти все ссылки». Типы данных, используемого протоколом: редактора или интегрированной среды разработки «типы данных», как и в настоящее время открытый текстовый документ и положение курсора. Типы данных не на уровне модели домена языка программирования, которой обычно предоставляют дерева абстрактного синтаксиса и компилятора символы (например, разрешенных типов, пространства имен,...). Это значительно упрощает протокол.

Теперь давайте взглянем на запрос «textDocument или определения» более подробно. Ниже приведены полезные данные, которые проходят между средство клиента и сервера языка для запроса «Перейти к определению» в документе C++.

Это запрос:

```json
{
    "jsonrpc": "2.0",
    "id" : 1,
    "method": "textDocument/definition",
    "params": {
        "textDocument": {
            "uri": "file:///p%3A/mseng/VSCode/Playgrounds/cpp/use.cpp"
        },
        "position": {
            "line": 3,
            "character": 12
        }
    }
}
```

Это ответ:

```json
{
    "jsonrpc": "2.0",
    "id": "1",
    "result": {
        "uri": "file:///p%3A/mseng/VSCode/Playgrounds/cpp/provide.cpp",
        "range": {
            "start": {
                "line": 0,
                "character": 4
            },
            "end": {
                "line": 0,
                "character": 11
            }
        }
    }
}
```

По прошествии времени очевидно описывающие типы данных на уровне редактора, а не на уровне модели языка программирования — одна из причин успеха протоколом языкового сервера. Гораздо проще стандартизировать текстовый документ URI или положение курсора по сравнению с стандартизации символы дерева и компилятора абстрактного синтаксиса для разных языков программирования.

Когда пользователь работает с различными языками, VS Code обычно запускает сервер языка для каждого языка программирования. В приведенном ниже примере иллюстрирует сеанс, в которых пользователь работает с Java и SASS файлами.

![Java и sass](media/lsp-java-and-sass.png)

### <a name="capabilities"></a>Возможности

Не каждый язык сервер может поддерживать все функции, определенные протоколом. Таким образом клиент и сервер сообщает их набор поддерживаемых функций через «возможности». Например сервер объявляет о выпуске что он может обработать запрос «textDocument/определению», но он не может обработать запрос «рабочая область/symbol». Аналогичным образом, клиенты можно объявить, что они способны предоставить «готовится к сохранению» уведомления перед сохранением документа, таким образом, сервер может вычислить текстовые изменения автоматически форматировать отредактированный документ.

## <a name="integrating-a-language-server"></a>Интеграция языка сервера

Фактический интеграцию конкретного языка сервера не определяется протоколом языкового сервера и выполняется модулем реализаторов средство. Некоторые средства интеграции серверов языка для универсальной, благодаря наличию расширение, которое можно запустить и обратиться к любой язык сервера. Другим пользователям, как и VS Code, создавать пользовательского расширения на каждом сервере языка, таким образом, по-прежнему сможет предоставить некоторые особые языковые функции расширения.

Чтобы упростить реализацию языка серверы и клиенты, существуют библиотек или пакетов SDK для клиентских и серверных частей. Эти библиотеки предусмотрены для различных языков. Например, имеется [модуль npm клиента языка](https://www.npmjs.com/package/vscode-languageclient) , упрощают интеграцию сервера языка расширения VS Code, а другой [модуль npm server language](https://www.npmjs.com/package/vscode-languageserver) записываемый языка сервера, с помощью Node.js. Это связано с текущим [списка](https://github.com/Microsoft/language-server-protocol/wiki/Protocol-Implementations) библиотек поддержки.

## <a name="using-the-language-server-protocol-in-visual-studio"></a>С помощью протокола языкового сервера в Visual Studio

* [Добавление расширения протокола языкового сервера](adding-an-lsp-extension.md) -рассказывается об интеграции языка сервера в Visual Studio.
