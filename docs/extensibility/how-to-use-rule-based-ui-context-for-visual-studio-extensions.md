---
title: 'Как: Используйте контекст uI на основе правил для расширения визуальной студии (ru) Документы Майкрософт'
ms.date: 11/04/2016
ms.topic: conceptual
ms.assetid: 8dd2cd1d-d8ba-49b9-870a-45acf3a3259d
author: acangialosi
ms.author: anthc
ms.workload:
- vssdk
ms.openlocfilehash: de1a1e0a2022482433f81b0b2810b0d201ab7b8f
ms.sourcegitcommit: 16a4a5da4a4fd795b46a0869ca2152f2d36e6db2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2020
ms.locfileid: "80710593"
---
# <a name="how-to-use-rule-based-ui-context-for-visual-studio-extensions"></a>Как: Использование контекста uI на основе правил для расширений Visual Studio

Visual Studio позволяет загрузку VSPackages, <xref:Microsoft.VisualStudio.Shell.UIContext>когда некоторые известные s активируются. Тем не менее, эти контексты uI не являются мелкими зернистыми, что не оставляет авторам расширения выбора, кроме как выбрать доступный контекст uI, который активируется до точки, которую они действительно хотели, чтобы VSPackage загружался. Список известных контекстов uI см. <xref:Microsoft.VisualStudio.Shell.KnownUIContexts>

Загрузка пакетов может оказать влияние на производительность, и загрузка их раньше, чем это необходимо, не является наилучшей практикой. Visual Studio 2015 представила концепцию основанного на правилах контекстов UI, механизма, который позволяет авторам расширения определять точные условия, при которых активируется контекст UI и загружаются связанные с ними VSPackages.

## <a name="rule-based-ui-context"></a>Контекст uI, основанный на правилах

"Правило" состоит из нового контекста интерфейса (GUID) и выражения Boolean, которое ссылается на одно или несколько "Терминов" в сочетании с логическими операциями "и"или", "не" . "Сроки" динамически оцениваются во время выполнения, и выражение переоценивается всякий раз, когда любое из его терминов изменяется. Когда выражение оценивается как истинное, активация связанного контекста uI. В противном случае контекст uI отключается.

Контекст uI, основанный на правилах, может использоваться различными способами:

1. Укажите ограничения видимости для команд и окон инструментов. Окна команд/инструментов можно скрыть до тех пор, пока не будет выполнено правило контекста мига.

2. Как ограничения автоматической нагрузки: автозагрузка пакетов только при выполняется правило.

3. Как отсроченная задача: задержка загрузки до тех пор, пока не пройдет определенный интервал и правило не будет выполнено.

   Механизм может быть использован любым расширением Visual Studio.

## <a name="create-a-rule-based-ui-context"></a>Создание контекста uI, основанного на правилах
 Предположим, у вас есть расширение под названием TestPackage, которое предлагает команду меню, которая применяется только к файлам с *расширением .config.* Перед VS2015 лучшим вариантом была загрузка TestPackage при <xref:Microsoft.VisualStudio.Shell.KnownUIContexts.SolutionExistsAndFullyLoadedContext%2A> активации контекста uI. Загрузка TestPackage таким образом неэффективна, так как загруженное решение может даже не содержать файл *.config.* Эти шаги показывают, как контекст uI, основанный на правилах, может использоваться для активации контекста uI только при выборе файла с расширением *.config* и загрузке TestPackage при активации контекста uI.

1. Определите новый графический интерфейс UIContext <xref:Microsoft.VisualStudio.Shell.ProvideAutoLoadAttribute> и <xref:Microsoft.VisualStudio.Shell.ProvideUIContextRuleAttribute>добавьте в класс VSPackage и .

    Например, предположим, что будет добавлен новый UIContext "UIContextGuid". GUID создан (вы можете создать GUID, нажав на **инструменты** > **Создать GUID**) является "8B40D5E2-5626-42AE-99EF-3DD1EFF46E7B". Затем вы добавляете следующую декларацию в классе пакетов:

   ```csharp
   public const string UIContextGuid = "8B40D5E2-5626-42AE-99EF-3DD1EFF46E7B";
   ```

    Для атрибутов добавьте следующие значения: (Подробности этих атрибутов будут объяснены позже)

   ```csharp
   [ProvideAutoLoad(TestPackage.UIContextGuid)]
   [ProvideUIContextRule(TestPackage.UIContextGuid,
       name: "Test auto load",
       expression: "DotConfig",
       termNames: new[] { "DotConfig" },
       termValues: new[] { "HierSingleSelectionName:.config$" })]
   ```

    Эти метаданные определяют новый ГРАФИЧЕСКИй интерфейс UIContext (8B40D5E2-5626-42AE-99EF-3DD1EFF46E7B) и выражение, относящееся к одному термину "DotConfig". Термин "DotConfig" оценивается как верно всякий раз, когда текущий выбор в активной иерархии имеет имя, которое соответствует шаблону регулярного выражения ".config$"\\(заканчивается *.config).* Значение (Default) определяет дополнительное имя для правила, полезного для отладки.

    Значения атрибута добавляются в pkgdef, генерируемые во время сборки.

2. В файле VSCT для команд TestPackage добавьте флаг "Динамическаявидимость" в соответствующие команды:

   ```xml
   <CommandFlag>DynamicVisibility</CommandFlag>
   ```

3. В разделе Visibilities VSCT привяжите соответствующие команды к новому ГРАФИЧЕСКОМУ интерфейсу UIContext, определяемому в #1:

   ```xml
   <VisibilityConstraints>
       <VisibilityItem guid="guidTestPackageCmdSet" id="TestId"  context="UIContextGuid"/>
   </VisibilityConstraints>
   ```

4. В разделе Символы добавьте определение UIContext:

   ```xml
   <GuidSymbol name="UIContextGuid" value="{8B40D5E2-5626-42AE-99EF-3DD1EFF46E7B}" />
   ```

    Теперь команды контекстного * \** меню для файлов .config будут видны только тогда, когда выбранный элемент в исследователе решения является файлом *.config,* и пакет не будет загружен до тех пор, пока не будет выбрана одна из этих команд.

   Затем используйте отладчик, чтобы подтвердить, что пакет загружается только тогда, когда вы его ожидаете. Для отладки TestPackage:

5. Установите точку <xref:Microsoft.VisualStudio.Shell.Package.Initialize%2A> разрыва в методе.

6. Создайте TestPackage и начните отладку.

7. Создайте проект или откройте проект.

8. Выберите любой файл с расширением, кроме *.config.* Точка разрыва не должна быть поражена.

9. Выберите файл *App.Config.*

   TestPackage загружается и останавливается в точке разрыва.

## <a name="add-more-rules-for-ui-context"></a>Добавьте дополнительные правила для контекста uI
 Поскольку правила контекста uI являются выражениями Boolean, можно добавить более ограниченные правила для контекста uI. Например, в вышеуказанном контексте uI можно указать, что правило применяется только при загрузке решения с проектом. Таким образом, команды не отображаются, если вы откроете файл *.config* в качестве отдельного файла, а не как часть проекта.

```csharp
[ProvideAutoLoad(TestPackage.UIContextGuid)]
[ProvideUIContextRule(TestPackage.UIContextGuid,
    name: "Test auto load",
    expression: "(SingleProject | MultipleProjects) & DotConfig",
    termNames: new[] { "SingleProject", "MultipleProjects","DotConfig" },
    termValues: new[] { VSConstants.UICONTEXT_SolutionHasSingleProject_string , VSConstants.UICONTEXT_SolutionHasMultipleProjects_string , "HierSingleSelectionName:.config$" })]
```

 Теперь выражение ссылается на три термина. Первые два термина, "SingleProject" и "MultipleProjects", относятся к другим известным контекстам интерфейса (по их GUID). Третий термин, "DotConfig" является основанным на правилах контекстом uI, определенным ранее в этой статье.

## <a name="delayed-activation"></a>Задержка активации
 Правила могут иметь факультативную "Задержку". Задержка указана в миллисекундах. При наличии задержка приводит к тому, что активация или деактивация контекста uI правила задерживается на этот временной интервал. Если правило изменяется до интервала задержки, то ничего не происходит. Этот механизм может быть использован для "заселение" инициализации шагов - особенно одноразовая инициализация без учета таймеров или регистрации для простоя уведомлений.

 Например, можно указать правило тестовой нагрузки с задержкой 100 миллисекунд:

```csharp
[ProvideAutoLoad(TestPackage.UIContextGuid)]
[ProvideUIContextRule(TestPackage.UIContextGuid,
    name: "Test auto load",
    expression: "DotConfig",
    termNames: new[] { "DotConfig" },
    termValues: new[] { "HierSingleSelectionName:.config$" },
    delay: 100)]
```

## <a name="term-types"></a>Типы терминов

Вот различные типы терминов, которые поддерживаются:

|Термин|Описание|
|-|-|
|«nnnnnnnn-nnnn-nnnn-nnnnnnnnnnnnnnnnnnnn»|GUID относится к контексту uI. Этот термин будет верным всякий раз, когда контекст uI активен и ложно в противном случае.|
|HierSingleSelectionName:\<шаблон>|Этот термин будет верным всякий раз, когда выбор в активной иерархии является одним элементом, и название выбранного элемента совпадает с регулярным выражением .Net, приведенным "шаблоном".|
|UserSettingsStore'ry:\<запрос>|"запрос" представляет собой полный путь в хранилище настроек пользователя, который должен оценить ненулевое значение. Запрос делится на "собрание" и "propertyName" на последней слэше.|
|ConfigSettingsStore'ry:\<запрос>|"запрос" представляет собой полный путь в хранилище параметров конфигурации, который должен оцениваться по ненулевому значению. Запрос делится на "собрание" и "propertyName" на последней слэше.|
|ActiveProjectFlavor:\<проектTypeGuid>|Термин будет верным всякий раз, когда в настоящее время выбранный проект приправлен (агрегирован) и имеет вкус, соответствующий данному типу проекта GUID.|
|АктивныйEditorContentType:\<contentType>|Этот термин будет верным, когда выбранный документ является текстовым редактором с заданным типом содержимого. Примечание: при переименовании выбранного документа этот термин не обновляется до тех пор, пока файл не будет закрыт и вновь открыт.|
|ActiveProjectCapability:\<Экспрессия>|Этот термин соответствует действительности, когда активные возможности проекта соответствуют предоставленному выражению. Выражение может быть чем-то вроде VB &#124; CSharp.|
|РешениеHasProjectCapability:\<экспрессия>|Подобно тому, как выше, но термин верно, когда решение имеет любой загруженный проект, который соответствует выражению.|
|РешениеHasProjectFlavor:\<проектTypeGuid>|Термин будет верным всякий раз, когда решение имеет проект, который приправлен (агрегированный) и имеет вкус, соответствующий данному типу проекта GUID.|
|ProjectAddedItem:\<шаблон>| Этот термин верно при добавлении файла, соответствуя "шаблону", в открываемом растворе.|
|ActiveProjectOutputType:\<выходТип>|Этот термин верно, когда тип вывода для активного проекта точно совпадает.  ВыходТип может быть бесседотом или типом. <xref:Microsoft.VisualStudio.Shell.Interop.__VSPROJOUTPUTTYPE>|
|ActiveProjectBuildProperty:\<buildProperty\<>и> regex|Этот термин является верным, когда активный проект соответствует указанному свойству сборки и стоимости свойства, при условии фильтра regex. Для получения более подробной информации о свойствах сборки обратитесь к [упорствующим данным в файлах проекта MSBuild.](internals/persisting-data-in-the-msbuild-project-file.md)|
|РешениеHasProjectBuildProperty:\<buildProperty\<>и regex>|Этот термин соответствует, когда решение имеет загруженный проект с указанным свойством сборки и значением свойства, совпадающим с предоставленным фильтром regex.|

## <a name="compatibility-with-cross-version-extension"></a>Совместимость с расширением кросс-версии

Контексты uI, основанные на правилах, — это новая функция Visual Studio 2015, которая не будет портиться на более ранние версии. Не перенос на более ранние версии создает проблему с расширениями / пакетами, которые нацелены на несколько версий Visual Studio. Эти версии должны быть автоматически загружены в Visual Studio 2013 и ранее, но могут извлечь выгоду из основанных на правилах контекстов uI, чтобы предотвратить автоматическое загрузку в Visual Studio 2015.

Для поддержки таких пакетов, AutoLoadPackages записи в реестре теперь могут предоставить флаг в своем поле значения, чтобы указать, что запись должна быть пропущена в Visual Studio 2015 и выше. Это можно сделать, добавив <xref:Microsoft.VisualStudio.Shell.PackageAutoLoadFlags>опцию флагов. VSPackages теперь можно добавить **SkipWhenUIContextRulesActive** опцию к их <xref:Microsoft.VisualStudio.Shell.ProvideAutoLoadAttribute> атрибуту, чтобы указать запись должна быть проигнорирована в Visual Studio 2015 и выше.
## <a name="extensible-ui-context-rules"></a>Расширяемые правила контекста uI

Иногда пакеты не могут использовать статические правила контекста uI. Например, предположим, что у вас есть пакет, поддерживающий расширение, так что состояние команды основано на типах редакторов, которые поддерживаются импортированными поставщиками MEF. Команда включена при наличии расширения, поддерживающего текущий тип элемента .. В таких случаях пакет сам по себе не может использовать статическое правило контекста uI, так как условия изменятся в зависимости от того, какие расширения MEF доступны.

Для поддержки таких пакетов контексты совместного использования и утилиты uI contexts поддерживают жестко закодированное выражение «К», которое указывает на все термины, приведенные ниже, которые будут соединены с OR. Это позволяет мастер-пакету определить известный контекст uI, основанный на правилах, и связать его командное состояние с этим контекстом. После этого любое расширение MEF, предназначенное для основного пакета, может добавить свои термины для редакторов, которых он поддерживает, не влияя на другие термины или основное выражение.

Документация <xref:Microsoft.VisualStudio.Shell.ProvideExtensibleUIContextRuleAttribute.%23ctor%2A> конструктора показывает синтаксис для расширяемых правил контекста использования.
