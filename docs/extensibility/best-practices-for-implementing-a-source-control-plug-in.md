---
title: Лучшие практики для реализации подключаемого подключения к управлению исходным элементом (ru) Документы Майкрософт
ms.date: 11/04/2016
ms.topic: conceptual
helpviewer_keywords:
- source control plug-ins, best practices
- best practices, source control plug-ins
- source control [Visual Studio SDK], plug-ins
ms.assetid: 85e73b73-29dc-464f-8734-ed308742c435
author: acangialosi
ms.author: anthc
manager: jillfra
ms.workload:
- vssdk
ms.openlocfilehash: 68491f22d63ae3ebb664b7c22188a661dccbf39a
ms.sourcegitcommit: 16a4a5da4a4fd795b46a0869ca2152f2d36e6db2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2020
ms.locfileid: "80740050"
---
# <a name="best-practices-for-implementing-a-source-control-plug-in"></a>Рекомендации по внедрению плагина управления исходным управлением
Следующие технические детали могут помочь вам надежно реализовать плагин управления исходным [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)]управлением.

## <a name="memory-management-issues"></a>Вопросы управления памятью
 В большинстве случаев интегрированная среда разработки (IDE), которая является абонентом, высвобождает и распределяет память. Строки подвоза источника контролируются идругими элементами в буферах, выделенных абонентом. Исключения отмечаются в описаниях конкретных функций, где они происходят.

## <a name="arrays-of-file-names"></a>Массивы имен файлов
 Когда массив файлов передается, он не передается как смежный массив имен файлов. Он передается как массив указателей для файла имен. Например, в [SccGet](../extensibility/sccget-function.md)имена файлов передаются `lpFileNames` по `lpFileNames` параметру, где `char **`на самом деле указатель на . `lpFileNames`—указатель на имя, `lpFileNames`— указатель на второе имя и так далее.

## <a name="large-model"></a>Большая модель
 Все указатели 32 бита, даже на 16-битных операционных системах.

## <a name="fully-qualified-paths"></a>Полностью квалифицированные пути
 В тех случаях, когда имена файлов или каталоги указаны в качестве аргументов, они должны быть полностью квалифицированными путями или путями КООН, без окончания обратных сокращений. Плагин управления исходным управлением обязан перевести их на относительные пути, если это является требованием базовой системы управления исходным источником.

## <a name="specify-a-fully-qualified-path-for-the-registered-dll"></a>Укажите полностью квалифицированный путь для зарегистрированного DLL
 IDE больше не загружает DLLs с относительных путей (например, *. .*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Полный путь DLL должен быть указан (например, *C: »Провайдеры»NewProvider.dll*). Это требование укрепляет безопасность IDE, предотвращая загрузку несанкционированных или олицетворений dLL-контроля источников.

## <a name="check-for-an-existing-vssci-plug-in-when-you-install-your-source-control-plug-in"></a>Проверьте наличие подключаемого модуля VSSCI при установке плагина управления исходным элементом
 Пользователь, который планирует установить плагин управления исходным управлением, может уже иметь существующий плагин управления исходным управлением, установленный на компьютере. Программа установки (настройки) для создаваемого плагина должна определить, существуют ли существующие значения для соответствующих ключей реестра. Если эти ключи уже установлены, программа установки должна спросить пользователя, следует ли зарегистрировать плагин в качестве плагина управления исходным ключом по умолчанию и заменить уже установленный.

## <a name="error-result-codes-and-reporting"></a>Коды результатов ошибок и отчетность
 Код `SCC_OK` возврата функции управления исходным кодом указывает на то, что операция прошла успешно для всех файлов. Если операция выполняется неудачей, предполагается вернуть последний обнаруженный код ошибки.

 Правило для отчетности заключается в том, что если в IDE происходит ошибка, IDE несет ответственность за ее сообщение. Если в системе управления исходным кодом происходит ошибка, плагин управления исходным кодом отвечает за ее сообщение. Например, в настоящее время IDE не сообщает о том, что файлы не будут **отсеяны,** в то время как **этот файл уже проверен,** будет сообщен плагином.

## <a name="the-context-structure"></a>Структура контекста
 Во время вызова [в SccInitialize](../extensibility/sccinitialize-function.md)абонент `ppvContext` передает параметр, который является непрепременизированной ручкой, в пустоту. Плагин управления исходным элементом может игнорировать этот параметр или выделить структуру любого рода и поместить указатель на эту структуру в пройденое указатель. IDE не понимает эту структуру, но он передает указатель на эту структуру в каждый другой вызов в плагине. Это обеспечивает ценную информацию о кэше контекста для плагина, который он может использовать для поддержания глобальной информации о состоянии, которая сохраняется в вызовах функций без использования глобальных переменных. Плагин отвечает за освобождение структуры при вызове на [SccUninitialize.](../extensibility/sccuninitialize-function.md)

 Если плагин устанавливает `SCC_CAP_REENTRANT` бит в [SccInitialize](../extensibility/sccinitialize-function.md) (в `lpSccCaps` частности, в параметре), для отслеживания всех открытых проектов используются несколько структур контекста.

## <a name="bitflags-and-other-command-options"></a>Bitflags и другие варианты команд
 Для каждой команды, например [SccGet,](../extensibility/sccget-function.md)IDE может указать множество вариантов, которые меняют поведение команды.

 API поддерживает настройку определенных параметров IDE через `fOptions` параметр. Эти параметры описаны в [Bitflags, используемых определенными командами](../extensibility/bitflags-used-by-specific-commands.md) вместе с командами, которые они затрагивают. В общем, это варианты, для которых пользователь не будет предложено.

 Большинство настраиваемых пользователями параметров настройки не определены таким образом, потому что они сильно различаются между плагинами управления исходным управлением. Таким образом, рекомендуемый механизм является **кнопкой Advanced.** Например, в поле **Get** диалогов IDE отображает только информацию, которую он понимает, но он также отображает кнопку **Advanced,** если плагин имеет варианты для этой команды. Когда пользователь нажимает кнопку **Advanced,** IDE вызывает [SccGetCommandOptions,](../extensibility/sccgetcommandoptions-function.md) чтобы включить плагин управления исходным управлением, чтобы подсказать пользователю информацию, такую как bitflags или дата/время. Плагин возвращает эту информацию в структуру, `SccGet` которая передается обратно во время команды.

## <a name="see-also"></a>См. также
- [Плагины управления исходным элементом](../extensibility/source-control-plug-ins.md)
- [Создание плагина управления исходным элементом](../extensibility/internals/creating-a-source-control-plug-in.md)
