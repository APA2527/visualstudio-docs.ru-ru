---
title: Сохранение данных обратно в базу данных
ms.date: 11/04/2016
ms.topic: conceptual
helpviewer_keywords:
- datasets [Visual Basic], validating data
- data validation, datasets
- data [Visual Studio], saving
- row version
- updating datasets, constraints
- datasets [Visual Basic], about datasets
- datasets [Visual Basic], merging
- updates, constraints in datasets
- saving data, about saving data
- datasets [Visual Basic], constraints
- TableAdapters
ms.assetid: afe6cb8a-dc6a-428b-b07b-903ac02c890b
author: ghogen
ms.author: ghogen
manager: jillfra
ms.workload:
- data-storage
ms.openlocfilehash: 64d46d4d662b7226dd2be15e6281a17e5b87e577
ms.sourcegitcommit: d233ca00ad45e50cf62cca0d0b95dc69f0a87ad6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/01/2020
ms.locfileid: "75586293"
---
# <a name="save-data-back-to-the-database"></a>Сохранение данных обратно в базу данных

Набор данных — это копия данных в памяти. Если изменить эти данные, рекомендуется сохранить эти изменения обратно в базу данных. Это можно сделать одним из трех способов:

- Путем вызова одного из методов `Update` TableAdapter

- Путем вызова одного из методов `DBDirect` TableAdapter

- Вызывая метод `UpdateAll` в TableAdapterManager, который Visual Studio создает для вас, когда набор данных содержит таблицы, связанные с другими таблицами в наборе данных.

При связывании таблиц набора данных с элементами управления на странице Windows Forms или XAML архитектура привязки данных выполняет всю работу за вас.

Если вы знакомы с TableAdapter, вы можете перейти непосредственно к одному из следующих разделов:

|Раздел|Описание|
|-----------|-----------------|
|[Вставка новых записей в базу данных](../data-tools/insert-new-records-into-a-database.md)|Выполнение операций обновления и вставки с помощью адаптеров таблиц или объектов команд|
|[Обновление данных с помощью адаптера таблицы](../data-tools/update-data-by-using-a-tableadapter.md)|Как выполнять обновления с помощью адаптеров таблиц|
|[Иерархическое обновление](../data-tools/hierarchical-update.md)|Выполнение обновлений из набора данных с двумя или более связанными таблицами|
|[Обработка исключения параллельности](../data-tools/handle-a-concurrency-exception.md)|Как управлять исключениями, когда два пользователя пытаются одновременно изменить одни и те же данные в базе данных|
|[Практическое руководство. Сохранение данных с помощью транзакции](../data-tools/save-data-by-using-a-transaction.md)|Сохранение данных в транзакции с помощью системы. Пространство имен Transactions и объект TransactionScope|
|[Сохранение данных в транзакции](../data-tools/save-data-in-a-transaction.md)|Пошаговое руководство по созданию Windows Forms приложения для демонстрации сохранения данных в базе данных внутри транзакции|
|[Сохранение данных в базе данных (несколько таблиц)](../data-tools/save-data-to-a-database-multiple-tables.md)|Изменение записей и сохранение изменений в нескольких таблицах обратно в базу данных|
|[Сохранение данных из объекта в базе данных](../data-tools/save-data-from-an-object-to-a-database.md)|Передача данных из объекта, который не находится в наборе данных, в базу данных с помощью метода DbDirect адаптера таблицы|
|[Сохранение данных с помощью методов DBDirect адаптера таблицы](../data-tools/save-data-with-the-tableadapter-dbdirect-methods.md)|Как использовать TableAdapter для отправки запросов SQL непосредственно в базу данных|
|[Сохранение набора данных в формате XML](../data-tools/save-a-dataset-as-xml.md)|Сохранение набора данных в XML-документе|

## <a name="two-stage-updates"></a>Два этапа обновления

Обновление источника данных выполняется в два этапа. Первым шагом является обновление набора данных новыми записями, измененными записями или удаленными записями. Если приложение никогда не отправляет эти изменения обратно в источник данных, вы можете завершить обновление.

Если вы отправите изменения обратно в базу данных, необходимо выполнить второй шаг. Если элементы управления с привязкой к данным не используются, необходимо вручную вызвать метод `Update` того же TableAdapter (или адаптера данных), который использовался для заполнения набора данных. Однако можно также использовать различные адаптеры, например, для перемещения данных из одного источника данных в другой или для обновления нескольких источников данных. Если вы не используете привязку данных и сохраняете изменения для связанных таблиц, необходимо вручную создать экземпляр переменной автоматически созданного `TableAdapterManager` класса, а затем вызвать его метод `UpdateAll`.

![Концептуальная схема обновлений набора данных](../data-tools/media/vbdatasetupdates.gif)

Набор данных содержит коллекции таблиц, которые содержат коллекции строк. Если вы планируете обновить базовый источник данных позже, то при добавлении или удалении строк необходимо использовать методы в свойстве `DataTable.DataRowCollection`. Эти методы выполняют отслеживание изменений, необходимое для обновления источника данных. При вызове коллекции `RemoveAt` в свойстве Rows удаление не будет передаваться обратно в базу данных.

## <a name="merge-datasets"></a>Объединить наборы данных

Содержимое набора данных можно обновить, *объединив* его с другим набором данных. Это включает копирование содержимого *исходного* набора данных в вызывающий набор данных (называемый *целевым* набором данных). При слиянии наборов данных новые записи из исходного набора добавляются в целевой набор данных. Кроме того, дополнительные столбцы в исходном наборе данных добавляются в целевой набор данных. Объединение наборов данных полезно, если у вас есть локальный DataSet и вы получаете второй набор данных из другого приложения. Это также полезно при получении второго набора данных из компонента, например веб-службы XML, или при необходимости интегрировать данные из нескольких наборов данных.

При слиянии наборов данных можно передать логический аргумент (`preserveChanges`), который сообщает методу <xref:System.Data.DataSet.Merge%2A>, следует ли хранить существующие изменения в целевом наборе DataSet. Поскольку наборы данных поддерживают несколько версий записей, важно помнить, что объединяются более одной версии записей. В следующей таблице показано, как объединяются записи в двух наборах данных:

|Числен|Целевой набор данных|Исходный набор данных|
| - | - | - |
|До преобразования|Джеймс Уилсон (|Джеймс C. Уилсон (|
|Current|Джим Уилсон (|Джеймс C. Уилсон (|

Вызов метода <xref:System.Data.DataSet.Merge%2A> в предыдущей таблице с `preserveChanges=false targetDataset.Merge(sourceDataset)` приводит к следующим данным:

|Числен|Целевой набор данных|Исходный набор данных|
| - | - | - |
|До преобразования|Джеймс C. Уилсон (|Джеймс C. Уилсон (|
|Current|Джеймс C. Уилсон (|Джеймс C. Уилсон (|

Вызов метода <xref:System.Data.DataSet.Merge%2A> с `preserveChanges = true targetDataset.Merge(sourceDataset, true)` приводит к следующим данным:

|Числен|Целевой набор данных|Исходный набор данных|
| - | - | - |
|До преобразования|Джеймс C. Уилсон (|Джеймс C. Уилсон (|
|Current|Джим Уилсон (|Джеймс C. Уилсон (|

> [!CAUTION]
> В сценарии `preserveChanges = true`, если метод <xref:System.Data.DataSet.RejectChanges%2A> вызывается для записи в целевом наборе данных, то возвращается к исходным данным из *исходного* набора данных. Это означает, что при попытке обновить исходный источник данных с помощью целевого набора данных может оказаться невозможным найти исходную строку для обновления. Можно предотвратить нарушение параллелизма, заполняя другой набор данных обновленными записями из источника данных, а затем выполнив слияние, чтобы предотвратить нарушение параллелизма. (Нарушение параллелизма происходит, когда другой пользователь изменяет запись в источнике данных после заполнения набора данных.)

## <a name="update-constraints"></a>Ограничения обновления

Чтобы внести изменения в существующую строку данных, добавьте или обновите данные в отдельных столбцах. Если набор данных содержит ограничения (например, внешние ключи или ограничения, не допускающие значения NULL), то возможно, что запись может временно находиться в состоянии ошибки при ее обновлении. То есть он может находиться в состоянии ошибки после завершения обновления одного столбца, но до перехода к следующему.

Чтобы предотвратить преждевременные нарушения ограничений, можно временно приостановить ограничения обновления. Это служит двум целям:

- Он предотвращает возникновение ошибки после того, как вы закончите обновление одного столбца, но не начали обновлять другой.

- Он предотвращает возникновение некоторых событий обновления (событий, которые часто используются для проверки).

> [!NOTE]
> В Windows Forms архитектура привязки данных, встроенная в DataGrid, приостанавливает проверку ограничений до тех пор, пока фокус не будет перемещен из строки, и вам не нужно явно вызывать методы <xref:System.Data.DataRow.BeginEdit%2A>, <xref:System.Data.DataRow.EndEdit%2A>или <xref:System.Data.DataRow.CancelEdit%2A>.

Ограничения автоматически отключаются при вызове метода <xref:System.Data.DataSet.Merge%2A> в наборе данных. Когда слияние завершено, при наличии ограничений на набор данных, который не может быть включен, создается <xref:System.Data.ConstraintException>. В этом случае свойство <xref:System.Data.DataSet.EnforceConstraints%2A> имеет значение `false,` и все нарушения ограничений должны быть разрешены перед сбросом свойства <xref:System.Data.DataSet.EnforceConstraints%2A> в `true`.

После завершения обновления можно повторно включить проверку ограничений, которая также активирует события обновления и вызывает их.

Дополнительные сведения о приостановке событий см. [в разделе Отключение ограничений при заполнении набора данных](../data-tools/turn-off-constraints-while-filling-a-dataset.md).

## <a name="dataset-update-errors"></a>Ошибки обновления набора данных

При обновлении записи в наборе данных существует вероятность возникновения ошибки. Например, можно непреднамеренно записать данные неправильного типа в столбец или данные, которые имеют слишком большую длину, или данные с какой-либо другой проблемой целостности. Или могут возникнуть проверки, зависящие от приложения, которые могут вызывать пользовательские ошибки на любом этапе события обновления. Дополнительные сведения см. [в разделе Проверка данных в DataSets](../data-tools/validate-data-in-datasets.md).

## <a name="maintain-information-about-changes"></a>Ведение сведений об изменениях

Сведения об изменениях в наборе данных сохраняются двумя способами: путем пометки строк, указывающих, что они были изменены (<xref:System.Data.DataRow.RowState%2A>), и хранения нескольких копий записи (<xref:System.Data.DataRowVersion>). С помощью этих сведений процессы могут определить, что изменилось в наборе данных и могут отправить соответствующие обновления в источник данных.

### <a name="rowstate-property"></a>Свойство RowState

Свойство <xref:System.Data.DataRow.RowState%2A> объекта <xref:System.Data.DataRow> — это значение, которое предоставляет сведения о состоянии конкретной строки данных.

В следующей таблице приведены возможные значения перечисления <xref:System.Data.DataRowState>.

|Значение Датаровстате|Описание|
| - |-----------------|
|<xref:System.Data.DataRowState.Added>|Строка была добавлена в качестве элемента в <xref:System.Data.DataRowCollection>. (Строка в этом состоянии не имеет соответствующей исходной версии, так как она не существовала при вызове последнего метода <xref:System.Data.DataRow.AcceptChanges%2A>).|
|<xref:System.Data.DataRowState.Deleted>|Строка была удалена с помощью <xref:System.Data.DataRow.Delete%2A> объекта <xref:System.Data.DataRow>.|
|<xref:System.Data.DataRowState.Detached>|Строка была создана, но не является частью какой-либо <xref:System.Data.DataRowCollection>. Объект <xref:System.Data.DataRow> находится в этом состоянии сразу после его создания, перед добавлением в коллекцию и после его удаления из коллекции.|
|<xref:System.Data.DataRowState.Modified>|Значение столбца в строке изменилось каким-либо образом.|
|<xref:System.Data.DataRowState.Unchanged>|Строка не была изменена с момента последнего вызова <xref:System.Data.DataRow.AcceptChanges%2A>.|

### <a name="datarowversion-enumeration"></a>DataRowVersion - перечисление

Наборы данных поддерживают несколько версий записей. Поля <xref:System.Data.DataRowVersion> используются при получении значения, найденного в <xref:System.Data.DataRow> с помощью свойства <xref:System.Data.DataRow.Item%2A> или метода <xref:System.Data.DataRow.GetChildRows%2A> объекта <xref:System.Data.DataRow>.

В следующей таблице приведены возможные значения перечисления <xref:System.Data.DataRowVersion>.

|Значение DataRowVersion|Описание|
| - |-----------------|
|<xref:System.Data.DataRowVersion.Current>|Текущая версия записи содержит все изменения, выполненные с записью с момента последнего вызова <xref:System.Data.DataRow.AcceptChanges%2A>. Если строка была удалена, текущая версия отсутствует.|
|<xref:System.Data.DataRowVersion.Default>|Значение по умолчанию для записи, определяемое схемой набора данных или источником данных.|
|<xref:System.Data.DataRowVersion.Original>|Исходная версия записи — это копия записи, так как она была в последний раз зафиксирована в наборе данных. На практике это, как правило, версия записи, считанная из источника данных.|
|<xref:System.Data.DataRowVersion.Proposed>|Предлагаемая версия записи, которая временно доступна в середине обновления, то есть между моментом вызова метода <xref:System.Data.DataRow.BeginEdit%2A> и методом <xref:System.Data.DataRow.EndEdit%2A>. Как правило, доступ к предложенной версии записи осуществляется в обработчике для события, такого как <xref:System.Data.DataTable.RowChanging>. При вызове метода <xref:System.Data.DataRow.CancelEdit%2A> изменения отменяются и удаляется Предлагаемая версия строки данных.|

Исходная и текущая версии полезны при передаче сведений об обновлении в источник данных. Как правило, при отправке обновления в источник данных новые сведения для базы данных находятся в текущей версии записи. Сведения из исходной версии используются для нахождение обновляемой записи.

Например, в случае изменения первичного ключа записи необходим способ нахождение соответствующей записи в источнике данных для обновления изменений. Если исходная версия не существовала, запись, скорее всего, будет добавлена к источнику данных, что приведет не только к дополнительной нежелательной записи, но в одной записи, которая является неточной и устаревшей. Эти две версии также используются в управлении параллелизмом. Исходную версию можно сравнить с записью в источнике данных, чтобы определить, изменилась ли запись с момента ее загрузки в набор данных.

Предлагаемая версия полезна, если необходимо выполнить проверку перед фактическим фиксацией изменений в наборе данных.

Даже если записи были изменены, они не всегда являются исходными или текущими версиями этой строки. При вставке новой строки в таблицу нет исходной версии, а только текущей версии. Аналогичным образом, при удалении строки путем вызова метода `Delete` таблицы существует исходная версия, но отсутствует текущая версия.

Можно проверить, существует ли определенная версия записи, выполнив запрос к методу <xref:System.Data.DataRow.HasVersion%2A> строки данных. Доступ к любой версии записи можно получить, передав значение перечисления <xref:System.Data.DataRowVersion> в качестве необязательного аргумента при запросе значения столбца.

## <a name="get-changed-records"></a>Получить измененные записи

Распространенной практикой является не обновление каждой записи в наборе данных. Например, пользователь может работать с элементом управления Windows Forms <xref:System.Windows.Forms.DataGridView>, который отображает много записей. Однако пользователь может обновить только несколько записей, удалить один из них и вставить новый. Наборы данных и таблицы с данными предоставляют метод (`GetChanges`) для возврата только измененных строк.

Можно создавать подмножества измененных записей с помощью метода `GetChanges` таблицы данных (<xref:System.Data.DataTable.GetChanges%2A>) или самого набора данных (<xref:System.Data.DataSet.GetChanges%2A>). При вызове метода для таблицы данных возвращается копия таблицы только с измененными записями. Аналогично, при вызове метода для набора данных вы получаете новый набор данных, содержащий только измененные записи.

`GetChanges` сам по себе возвращает все измененные записи. Напротив, передача требуемого <xref:System.Data.DataRowState> в качестве параметра в метод `GetChanges` позволяет указать подмножество измененных записей: добавленные записи, записи, помеченные для удаления, отсоединенные записи или измененные записи.

Получение подмножества измененных записей полезно, если нужно отправить записи в другой компонент для обработки. Вместо отправки всего набора данных можно снизить издержки на взаимодействие с другим компонентом, получая только те записи, которые необходимы компоненту.

## <a name="commit-changes-in-the-dataset"></a>Фиксация изменений в наборе данных

По мере внесения изменений в набор данных задается свойство <xref:System.Data.DataRow.RowState%2A> измененных строк. Исходная и текущая версии записей устанавливаются, обслуживаются и становятся доступными для вас с помощью свойства <xref:System.Data.DataRowView.RowVersion%2A>. Метаданные, хранящиеся в свойствах этих измененных строк, необходимы для отправки правильных обновлений в источник данных.

Если изменения соответствуют текущему состоянию источника данных, вам больше не нужно поддерживать эти сведения. Обычно существует два раза, когда набор данных и его источник синхронизируются:

- Сразу же после загрузки информации в набор данных, например при чтении данных из источника.

- После отправки изменений из набора данных в источник данных (но не ранее, так как при этом теряются сведения об изменениях, необходимые для отправки изменений в базу данных).

Можно зафиксировать ожидающие изменения в наборе данных, вызвав метод <xref:System.Data.DataSet.AcceptChanges%2A>. Как правило, <xref:System.Data.DataSet.AcceptChanges%2A> вызывается в следующее время:

- После загрузки набора данных. При загрузке набора данных путем вызова метода `Fill` TableAdapter адаптер автоматически фиксирует изменения. Однако при загрузке набора данных путем объединения другого набора данных в него необходимо зафиксировать изменения вручную.

    > [!NOTE]
    > Можно запретить адаптеру автоматически фиксировать изменения при вызове метода `Fill`, задав для свойства `AcceptChangesDuringFill` адаптера значение `false`. Если задано значение `false`, <xref:System.Data.DataRow.RowState%2A> каждой строки, вставленной во время заполнения, задается <xref:System.Data.DataRowState.Added>.

- После отправки изменений набора данных в другой процесс, например в веб-службу XML.

    > [!CAUTION]
    > Применение изменений таким образом удаляет все сведения об изменениях. Не зафиксируйте изменения до тех пор, пока не завершите выполнение операций, требующих, чтобы приложение знало, какие изменения были сделаны в наборе данных.

Этот метод выполняет следующие задачи:

- Записывает <xref:System.Data.DataRowVersion.Current> версию записи в ее <xref:System.Data.DataRowVersion.Original>ную версию и перезаписывает исходную версию.

- Удаляет все строки, в которых свойство <xref:System.Data.DataRow.RowState%2A> имеет значение <xref:System.Data.DataRowState.Deleted>.

- Задает для свойства <xref:System.Data.DataRow.RowState%2A> записи значение <xref:System.Data.DataRowState.Unchanged>.

Метод <xref:System.Data.DataSet.AcceptChanges%2A> доступен на трех уровнях. Его можно вызвать для объекта <xref:System.Data.DataRow> для фиксации изменений только для этой строки. Его также можно вызвать для объекта <xref:System.Data.DataTable>, чтобы зафиксировать все строки в таблице. Наконец, можно вызвать его для объекта <xref:System.Data.DataSet>, чтобы зафиксировать все ожидающие изменения во всех записях всех таблиц набора данных.

В следующей таблице описаны изменения, которые фиксируются в зависимости от объекта, на котором вызывается метод.

|Метод|Результат|
|------------|------------|
|<xref:System.Data.DataRow.AcceptChanges%2A?displayProperty=fullName>|Изменения фиксируются только в указанной строке.|
|<xref:System.Data.DataTable.AcceptChanges%2A?displayProperty=fullName>|Изменения фиксируются во всех строках в указанной таблице.|
|<xref:System.Data.DataSet.AcceptChanges%2A?displayProperty=fullName>|Изменения фиксируются во всех строках во всех таблицах набора данных.|

> [!NOTE]
> При загрузке набора данных путем вызова метода `Fill` TableAdapter не нужно явно принимать изменения. По умолчанию метод `Fill` вызывает метод `AcceptChanges` после завершения заполнения таблицы данных.

Связанный метод, <xref:System.Data.DataSet.RejectChanges%2A>, отменяет результаты изменений, копируя <xref:System.Data.DataRowVersion.Original>ную версию обратно в <xref:System.Data.DataRowVersion.Current>ную версию записей. Он также задает <xref:System.Data.DataRow.RowState%2A> каждой записи обратно в <xref:System.Data.DataRowState.Unchanged>.

## <a name="data-validation"></a>Проверка данных

Чтобы убедиться, что данные в приложении соответствуют требованиям процессов, в которые оно передается, часто требуется добавить проверку. Это может потребовать проверки правильности записи пользователя в форме, проверки данных, отправляемых в приложение другим приложением, или даже проверки того, что данные, вычисляемые в компоненте, находятся в пределах ограничений источника данных. и требования к приложениям.

Проверить данные можно несколькими способами.

- На бизнес-уровне путем добавления кода в приложение для проверки данных. Этот набор данных можно использовать в одном месте. Набор данных предоставляет некоторые преимущества проверки серверной части, такие как возможность проверки изменений по мере изменения значений столбцов и строк. Дополнительные сведения см. [в разделе Проверка данных в DataSets](../data-tools/validate-data-in-datasets.md).

- На уровне представления, добавив проверку в формы. Дополнительные сведения см. [в разделе Проверка вводимых пользователем данных в Windows Forms](/dotnet/framework/winforms/user-input-validation-in-windows-forms).

- В серверной части данных, отправляя данные в источник данных, например базу данных, и позволяя ему принимать или отклонять данные. Если вы работаете с базой данных, которая обладает расширенными возможностями для проверки данных и предоставляет сведения об ошибках, это может быть практичным подходом, поскольку вы можете проверить данные независимо от того, откуда они приходят. Однако этот подход может не соответствовать требованиям к проверке для конкретного приложения. Кроме того, наличие проверки данных в источнике данных может привести к множеству циклических обращений к источнику данных в зависимости от того, как ваше приложение упрощает разрешение ошибок проверки, возникающих в серверной части.

   > [!IMPORTANT]
   > При использовании команд данных со свойством <xref:System.Data.SqlClient.SqlCommand.CommandType%2A>, для которого установлено значение <xref:System.Data.CommandType.Text>, внимательно проверяйте сведения, отправляемые с клиента, перед их передачей в базу данных. Злоумышленники могут попытаться отправить (внедрить) модифицированные или добавочные инструкции SQL и получить незаконный доступ к базе данных или повредить ее. Прежде чем передавать данные, введенные пользователем, в базу данных, всегда проверяйте, являются ли сведения допустимыми. Рекомендуется всегда использовать параметризованные запросы или хранимые процедуры, если это возможно.

## <a name="transmit-updates-to-the-data-source"></a>Передача обновлений в источник данных

После внесения изменений в наборе данных можно передать изменения в источник данных. Чаще всего это делается путем вызова метода `Update` TableAdapter (или адаптера данных). Этот метод выполняет цикл по каждой записи в таблице данных, определяет, какой тип обновления требуется (для обновления, вставки или удаления), если таковой имеется, а затем запускает соответствующую команду.

В качестве иллюстрации того, как выполняются обновления, предположим, что приложение использует набор данных, содержащий одну таблицу данных. Приложение выбирает две строки из базы данных. После извлечения таблица данных в памяти выглядит следующим образом:

```sql
(RowState)     CustomerID   Name             Status
(Unchanged)    c200         Robert Lyon      Good
(Unchanged)    c400         Nancy Buchanan    Pending
```

Приложение изменяет состояние Нэнси Батурин на "предпочтительно". В результате этого изменения значение свойства <xref:System.Data.DataRow.RowState%2A> для этой строки изменяется с <xref:System.Data.DataRowState.Unchanged> на <xref:System.Data.DataRowState.Modified>. Значение свойства <xref:System.Data.DataRow.RowState%2A> для первой строки остается <xref:System.Data.DataRowState.Unchanged>. Таблица данных теперь выглядит следующим образом:

```sql
(RowState)     CustomerID   Name             Status
(Unchanged)    c200         Robert Lyon      Good
(Modified)     c400         Nancy Buchanan    Preferred
```

Теперь приложение вызывает метод `Update` для передачи набора данных в базу данных. Метод проверяет каждую строку, в свою очередь. В первой строке метод не передает инструкцию SQL в базу данных, так как эта строка не изменилась с момента первоначальной выборки из базы данных.

Однако во второй строке метод `Update` автоматически вызывает правильную команду данных и передает ее в базу данных. Конкретный синтаксис инструкции SQL зависит от диалекта SQL, поддерживаемого базовым хранилищем данных. Однако следующие общие признаки передаваемой инструкции SQL являются значимыми:

- Передаваемая инструкция SQL является инструкцией UPDATE. Адаптер знает, что используется инструкция UPDATE, так как значение свойства <xref:System.Data.DataRow.RowState%2A> <xref:System.Data.DataRowState.Modified>.

- Переданная инструкция SQL содержит предложение WHERE, указывающее, что целевым объектом инструкции UPDATE является строка, в которой `CustomerID = 'c400'`. Эта часть инструкции SELECT отличает целевую строку от остальных, поскольку `CustomerID` является первичным ключом целевой таблицы. Информация для предложения WHERE является производной от исходной версии записи (`DataRowVersion.Original`) в случае, если значения, необходимые для обнаружения строки, изменились.

- Переданная инструкция SQL содержит предложение SET для установки новых значений измененных столбцов.

   > [!NOTE]
   > Если свойству `UpdateCommand` TableAdapter присвоено имя хранимой процедуры, адаптер не формирует инструкцию SQL. Вместо этого он вызывает хранимую процедуру с соответствующими передаваемыми параметрами.

## <a name="pass-parameters"></a>Передача параметров

Обычно параметры используются для передачи значений для записей, которые будут обновляться в базе данных. Когда метод `Update` TableAdapter выполняет инструкцию UPDATE, ему необходимо заполнить значения параметров. Он получает эти значения из коллекции `Parameters` для соответствующей команды данных, в данном случае `UpdateCommand` объекта в TableAdapter.

Если вы использовали инструменты Visual Studio для создания адаптера данных, то объект `UpdateCommand` содержит коллекцию параметров, соответствующих заполнительу параметра в инструкции.

Свойство <xref:System.Data.SqlClient.SqlParameter.SourceColumn%2A?displayProperty=fullName> каждого параметра указывает на столбец в таблице данных. Например, свойству `SourceColumn` для параметров `au_id` и `Original_au_id` присваивается любой столбец в таблице данных, содержащий идентификатор автора. При запуске метода `Update` адаптера он считывает столбец идентификатора автора из обновляемой записи и заполняет значения инструкцией.

В инструкции UPDATE необходимо указать оба новых значения (которые будут записаны в запись), а также старые значения (чтобы запись могла быть найдена в базе данных). Поэтому существуют два параметра для каждого значения: одно для предложения SET и другое для предложения WHERE. Оба параметра считывают данные из обновляемой записи, но получают разные версии значения столбца на основе свойства <xref:System.Data.SqlClient.SqlParameter.SourceVersion> параметра. Параметр для предложения SET получает текущую версию, а параметр для предложения WHERE получает исходную версию.

> [!NOTE]
> Можно также вручную задать значения в коллекции `Parameters` в коде, который обычно выполняется в обработчике событий для события <xref:System.Data.DataTable.RowChanging> адаптера данных.

## <a name="see-also"></a>См. также:

- [Инструменты для работы с наборами данных в Visual Studio](../data-tools/dataset-tools-in-visual-studio.md)
- [Создание и настройка адаптеров таблиц](create-and-configure-tableadapters.md)
- [Обновление данных с помощью адаптера таблицы](../data-tools/update-data-by-using-a-tableadapter.md)
- [Привязка элементов управления к данным в Visual Studio](../data-tools/bind-controls-to-data-in-visual-studio.md)
- [Проверка данных](validate-data-in-datasets.md)
- [Практическое руководство. Добавление, изменение и удаление сущностей (службы данных WCF)](/dotnet/framework/data/wcf/how-to-add-modify-and-delete-entities-wcf-data-services)
