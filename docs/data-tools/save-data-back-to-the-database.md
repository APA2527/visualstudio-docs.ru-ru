---
title: Сохранение данных обратно в базу данных
ms.date: 11/04/2016
ms.topic: how-to
helpviewer_keywords:
- datasets [Visual Basic], validating data
- data validation, datasets
- data [Visual Studio], saving
- row version
- updating datasets, constraints
- datasets [Visual Basic], about datasets
- datasets [Visual Basic], merging
- updates, constraints in datasets
- saving data, about saving data
- datasets [Visual Basic], constraints
- TableAdapters
ms.assetid: afe6cb8a-dc6a-428b-b07b-903ac02c890b
author: ghogen
ms.author: ghogen
manager: jillfra
ms.workload:
- data-storage
ms.openlocfilehash: 493637f81df15fadf65d6c7d90e980e322919b13
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/02/2020
ms.locfileid: "85281751"
---
# <a name="save-data-back-to-the-database"></a>Сохранение данных обратно в базу данных

Набор данных — это копия данных в памяти. Если изменить эти данные, рекомендуется сохранить эти изменения обратно в базу данных. Это можно сделать одним из трех способов:

- Путем вызова одного из `Update` методов адаптера таблицы

- Путем вызова одного из `DBDirect` методов адаптера таблицы

- Вызывая `UpdateAll` метод в TableAdapterManager, который Visual Studio создает для вас, когда набор данных содержит таблицы, связанные с другими таблицами в наборе данных.

При связывании таблиц набора данных с элементами управления на странице Windows Forms или XAML архитектура привязки данных выполняет всю работу за вас.

Если вы знакомы с TableAdapter, вы можете перейти непосредственно к одному из следующих разделов:

|Раздел|Описание|
|-----------|-----------------|
|[Вставка новых записей в базу данных](../data-tools/insert-new-records-into-a-database.md)|Выполнение операций обновления и вставки с помощью адаптеров таблиц или объектов команд|
|[Обновление данных с помощью адаптера таблицы](../data-tools/update-data-by-using-a-tableadapter.md)|Как выполнять обновления с помощью адаптеров таблиц|
|[Иерархическое обновление](../data-tools/hierarchical-update.md)|Выполнение обновлений из набора данных с двумя или более связанными таблицами|
|[Обработка исключения параллелизма](../data-tools/handle-a-concurrency-exception.md)|Как управлять исключениями, когда два пользователя пытаются одновременно изменить одни и те же данные в базе данных|
|[Инструкции. Сохранение данных с помощью транзакции](../data-tools/save-data-by-using-a-transaction.md)|Сохранение данных в транзакции с помощью системы. Пространство имен Transactions и объект TransactionScope|
|[Сохранение данных в транзакции](../data-tools/save-data-in-a-transaction.md)|Пошаговое руководство по созданию Windows Forms приложения для демонстрации сохранения данных в базе данных внутри транзакции|
|[Сохранение данных в базе данных (несколько таблиц)](../data-tools/save-data-to-a-database-multiple-tables.md)|Изменение записей и сохранение изменений в нескольких таблицах обратно в базу данных|
|[Сохранение данных из объекта в базе данных](../data-tools/save-data-from-an-object-to-a-database.md)|Передача данных из объекта, который не находится в наборе данных, в базу данных с помощью метода DbDirect адаптера таблицы|
|[Сохранение данных с помощью методов DBDirect адаптера таблицы](../data-tools/save-data-with-the-tableadapter-dbdirect-methods.md)|Как использовать TableAdapter для отправки запросов SQL непосредственно в базу данных|
|[Сохранение набора данных в формате XML](../data-tools/save-a-dataset-as-xml.md)|Сохранение набора данных в XML-документе|

## <a name="two-stage-updates"></a>Два этапа обновления

Обновление источника данных выполняется в два этапа. Первым шагом является обновление набора данных новыми записями, измененными записями или удаленными записями. Если приложение никогда не отправляет эти изменения обратно в источник данных, вы можете завершить обновление.

Если вы отправите изменения обратно в базу данных, необходимо выполнить второй шаг. Если элементы управления с привязкой к данным не используются, необходимо вручную вызвать `Update` метод того же TableAdapter (или адаптера данных), который использовался для заполнения набора данных. Однако можно также использовать различные адаптеры, например, для перемещения данных из одного источника данных в другой или для обновления нескольких источников данных. Если вы не используете привязку данных и сохраняете изменения для связанных таблиц, необходимо вручную создать экземпляр переменной автоматически созданного `TableAdapterManager` класса, а затем вызвать его `UpdateAll` метод.

![Концептуальная схема обновлений набора данных](../data-tools/media/vbdatasetupdates.gif)

Набор данных содержит коллекции таблиц, которые содержат коллекции строк. Если вы планируете обновить базовый источник данных позже, при `DataTable.DataRowCollection` добавлении или удалении строк необходимо использовать методы свойства. Эти методы выполняют отслеживание изменений, необходимое для обновления источника данных. При вызове `RemoveAt` коллекции в свойстве Rows удаление не будет передаваться обратно в базу данных.

## <a name="merge-datasets"></a>Объединить наборы данных

Содержимое набора данных можно обновить, *объединив* его с другим набором данных. Это включает копирование содержимого *исходного* набора данных в вызывающий набор данных (называемый *целевым* набором данных). При слиянии наборов данных новые записи из исходного набора добавляются в целевой набор данных. Кроме того, дополнительные столбцы в исходном наборе данных добавляются в целевой набор данных. Объединение наборов данных полезно, если у вас есть локальный DataSet и вы получаете второй набор данных из другого приложения. Это также полезно при получении второго набора данных из компонента, например веб-службы XML, или при необходимости интегрировать данные из нескольких наборов данных.

При слиянии наборов данных можно передать логический аргумент ( `preserveChanges` ), сообщающий <xref:System.Data.DataSet.Merge%2A> методу, следует ли хранить существующие изменения в целевом наборе DataSet. Поскольку наборы данных поддерживают несколько версий записей, важно помнить, что объединяются более одной версии записей. В следующей таблице показано, как объединяются записи в двух наборах данных:

|Числен|Целевой набор данных|Исходный набор данных|
| - | - | - |
|До преобразования|Джеймс Уилсон (|Джеймс C. Уилсон (|
|Текущий|Джим Уилсон (|Джеймс C. Уилсон (|

Вызов <xref:System.Data.DataSet.Merge%2A> метода в предыдущей таблице `preserveChanges=false targetDataset.Merge(sourceDataset)` приводит к получению следующих данных:

|Числен|Целевой набор данных|Исходный набор данных|
| - | - | - |
|До преобразования|Джеймс C. Уилсон (|Джеймс C. Уилсон (|
|Текущий|Джеймс C. Уилсон (|Джеймс C. Уилсон (|

Вызов <xref:System.Data.DataSet.Merge%2A> метода с `preserveChanges = true targetDataset.Merge(sourceDataset, true)` результатом приведет к следующим данным:

|Числен|Целевой набор данных|Исходный набор данных|
| - | - | - |
|До преобразования|Джеймс C. Уилсон (|Джеймс C. Уилсон (|
|Текущий|Джим Уилсон (|Джеймс C. Уилсон (|

> [!CAUTION]
> В `preserveChanges = true` сценарии, если <xref:System.Data.DataSet.RejectChanges%2A> метод вызывается для записи в целевом наборе данных, он возвращается к исходным данным из *исходного* набора данных. Это означает, что при попытке обновить исходный источник данных с помощью целевого набора данных может оказаться невозможным найти исходную строку для обновления. Можно предотвратить нарушение параллелизма, заполняя другой набор данных обновленными записями из источника данных, а затем выполнив слияние, чтобы предотвратить нарушение параллелизма. (Нарушение параллелизма происходит, когда другой пользователь изменяет запись в источнике данных после заполнения набора данных.)

## <a name="update-constraints"></a>Ограничения обновления

Чтобы внести изменения в существующую строку данных, добавьте или обновите данные в отдельных столбцах. Если набор данных содержит ограничения (например, внешние ключи или ограничения, не допускающие значения NULL), то возможно, что запись может временно находиться в состоянии ошибки при ее обновлении. То есть он может находиться в состоянии ошибки после завершения обновления одного столбца, но до перехода к следующему.

Чтобы предотвратить преждевременные нарушения ограничений, можно временно приостановить ограничения обновления. Это служит двум целям:

- Он предотвращает возникновение ошибки после того, как вы закончите обновление одного столбца, но не начали обновлять другой.

- Он предотвращает возникновение некоторых событий обновления (событий, которые часто используются для проверки).

> [!NOTE]
> В Windows Forms архитектура привязки данных, встроенная в DataGrid, приостанавливает проверку ограничений до тех пор, пока фокус не будет перемещен из строки, и вам не нужно явно вызывать <xref:System.Data.DataRow.BeginEdit%2A> методы, <xref:System.Data.DataRow.EndEdit%2A> или <xref:System.Data.DataRow.CancelEdit%2A> .

Ограничения автоматически отключаются при <xref:System.Data.DataSet.Merge%2A> вызове метода для набора данных. Когда слияние завершено, при наличии каких-либо ограничений на набор данных, который не может быть включен, <xref:System.Data.ConstraintException> создается исключение. В этом случае <xref:System.Data.DataSet.EnforceConstraints%2A> свойство имеет значение `false,` , а все нарушения ограничений должны быть разрешены перед сбросом <xref:System.Data.DataSet.EnforceConstraints%2A> свойства в `true` .

После завершения обновления можно повторно включить проверку ограничений, которая также активирует события обновления и вызывает их.

Дополнительные сведения о приостановке событий см. [в разделе Отключение ограничений при заполнении набора данных](../data-tools/turn-off-constraints-while-filling-a-dataset.md).

## <a name="dataset-update-errors"></a>Ошибки обновления набора данных

При обновлении записи в наборе данных существует вероятность возникновения ошибки. Например, можно непреднамеренно записать данные неправильного типа в столбец или данные, которые имеют слишком большую длину, или данные с какой-либо другой проблемой целостности. Или могут возникнуть проверки, зависящие от приложения, которые могут вызывать пользовательские ошибки на любом этапе события обновления. Дополнительные сведения см. [в разделе Проверка данных в DataSets](../data-tools/validate-data-in-datasets.md).

## <a name="maintain-information-about-changes"></a>Ведение сведений об изменениях

Сведения об изменениях в наборе данных сохраняются двумя способами: путем пометки строк, указывающих, что они были изменены ( <xref:System.Data.DataRow.RowState%2A> ), и хранения нескольких копий записи ( <xref:System.Data.DataRowVersion> ). С помощью этих сведений процессы могут определить, что изменилось в наборе данных и могут отправить соответствующие обновления в источник данных.

### <a name="rowstate-property"></a>Свойство RowState

<xref:System.Data.DataRow.RowState%2A>Свойство <xref:System.Data.DataRow> объекта — это значение, которое предоставляет сведения о состоянии конкретной строки данных.

В следующей таблице приведены возможные значения <xref:System.Data.DataRowState> перечисления.

|Значение Датаровстате|Описание:|
| - |-----------------|
|<xref:System.Data.DataRowState.Added>|Строка была добавлена в качестве элемента в <xref:System.Data.DataRowCollection> . (Строка в этом состоянии не имеет соответствующей исходной версии, так как она не существовала при <xref:System.Data.DataRow.AcceptChanges%2A> вызове последнего метода).|
|<xref:System.Data.DataRowState.Deleted>|Строка была удалена с помощью <xref:System.Data.DataRow.Delete%2A> <xref:System.Data.DataRow> объекта.|
|<xref:System.Data.DataRowState.Detached>|Строка была создана, но не является частью какой-либо <xref:System.Data.DataRowCollection>. <xref:System.Data.DataRow>Объект находится в этом состоянии сразу после его создания, перед добавлением в коллекцию и после его удаления из коллекции.|
|<xref:System.Data.DataRowState.Modified>|Значение столбца в строке изменилось каким-либо образом.|
|<xref:System.Data.DataRowState.Unchanged>|Строка не была изменена с момента последнего вызова <xref:System.Data.DataRow.AcceptChanges%2A>.|

### <a name="datarowversion-enumeration"></a>DataRowVersion - перечисление

Наборы данных поддерживают несколько версий записей. <xref:System.Data.DataRowVersion>Поля используются при получении значения, найденного в, <xref:System.Data.DataRow> с помощью <xref:System.Data.DataRow.Item%2A> свойства или <xref:System.Data.DataRow.GetChildRows%2A> метода <xref:System.Data.DataRow> объекта.

В следующей таблице приведены возможные значения <xref:System.Data.DataRowVersion> перечисления.

|Значение DataRowVersion|Описание:|
| - |-----------------|
|<xref:System.Data.DataRowVersion.Current>|Текущая версия записи содержит все изменения, выполненные с записью с момента последнего <xref:System.Data.DataRow.AcceptChanges%2A> вызова. Если строка была удалена, текущая версия отсутствует.|
|<xref:System.Data.DataRowVersion.Default>|Значение по умолчанию для записи, определяемое схемой набора данных или источником данных.|
|<xref:System.Data.DataRowVersion.Original>|Исходная версия записи — это копия записи, так как она была в последний раз зафиксирована в наборе данных. На практике это, как правило, версия записи, считанная из источника данных.|
|<xref:System.Data.DataRowVersion.Proposed>|Предлагаемая версия записи, которая временно доступна в середине обновления, то есть между моментом вызова <xref:System.Data.DataRow.BeginEdit%2A> метода и <xref:System.Data.DataRow.EndEdit%2A> методом. Как правило, доступ к предложенной версии записи осуществляется в обработчике для события, такого как <xref:System.Data.DataTable.RowChanging> . При вызове <xref:System.Data.DataRow.CancelEdit%2A> метода изменения меняются и удаляется Предлагаемая версия строки данных.|

Исходная и текущая версии полезны при передаче сведений об обновлении в источник данных. Как правило, при отправке обновления в источник данных новые сведения для базы данных находятся в текущей версии записи. Сведения из исходной версии используются для нахождение обновляемой записи.

Например, в случае изменения первичного ключа записи необходим способ нахождение соответствующей записи в источнике данных для обновления изменений. Если исходная версия не существовала, запись, скорее всего, будет добавлена к источнику данных, что приведет не только к дополнительной нежелательной записи, но в одной записи, которая является неточной и устаревшей. Эти две версии также используются в управлении параллелизмом. Исходную версию можно сравнить с записью в источнике данных, чтобы определить, изменилась ли запись с момента ее загрузки в набор данных.

Предлагаемая версия полезна, если необходимо выполнить проверку перед фактическим фиксацией изменений в наборе данных.

Даже если записи были изменены, они не всегда являются исходными или текущими версиями этой строки. При вставке новой строки в таблицу нет исходной версии, а только текущей версии. Аналогично, при удалении строки путем вызова `Delete` метода таблицы существует исходная версия, но отсутствует текущая версия.

Можно проверить, существует ли определенная версия записи, выполнив запрос к <xref:System.Data.DataRow.HasVersion%2A> методу строки данных. Доступ к любой версии записи можно получить, передав <xref:System.Data.DataRowVersion> значение перечисления в качестве необязательного аргумента при запросе значения столбца.

## <a name="get-changed-records"></a>Получить измененные записи

Распространенной практикой является не обновление каждой записи в наборе данных. Например, пользователь может работать с <xref:System.Windows.Forms.DataGridView> элементом управления Windows Forms, который отображает много записей. Однако пользователь может обновить только несколько записей, удалить один из них и вставить новый. Наборы данных и таблицы с данными предоставляют метод ( `GetChanges` ) для возвращения только измененных строк.

Можно создавать подмножества измененных записей с помощью `GetChanges` метода либо таблицы данных ( <xref:System.Data.DataTable.GetChanges%2A> ), либо самого набора данных ( <xref:System.Data.DataSet.GetChanges%2A> ). При вызове метода для таблицы данных возвращается копия таблицы только с измененными записями. Аналогично, при вызове метода для набора данных вы получаете новый набор данных, содержащий только измененные записи.

`GetChanges` сам по себе возвращает все измененные записи. Напротив, передача нужного в <xref:System.Data.DataRowState> качестве параметра в `GetChanges` метод позволяет указать подмножество измененных записей: добавленные записи, записи, помеченные для удаления, отсоединенные записи или измененные записи.

Получение подмножества измененных записей полезно, если нужно отправить записи в другой компонент для обработки. Вместо отправки всего набора данных можно снизить издержки на взаимодействие с другим компонентом, получая только те записи, которые необходимы компоненту.

## <a name="commit-changes-in-the-dataset"></a>Фиксация изменений в наборе данных

По мере внесения изменений в набор данных <xref:System.Data.DataRow.RowState%2A> задается свойство измененных строк. Исходная и текущая версии записей устанавливаются, обслуживаются и становятся доступными для вас <xref:System.Data.DataRowView.RowVersion%2A> свойством. Метаданные, хранящиеся в свойствах этих измененных строк, необходимы для отправки правильных обновлений в источник данных.

Если изменения соответствуют текущему состоянию источника данных, вам больше не нужно поддерживать эти сведения. Обычно существует два раза, когда набор данных и его источник синхронизируются:

- Сразу же после загрузки информации в набор данных, например при чтении данных из источника.

- После отправки изменений из набора данных в источник данных (но не ранее, так как при этом теряются сведения об изменениях, необходимые для отправки изменений в базу данных).

Можно зафиксировать ожидающие изменения в наборе данных, вызвав <xref:System.Data.DataSet.AcceptChanges%2A> метод. Обычно <xref:System.Data.DataSet.AcceptChanges%2A> вызывается в следующих случаях:

- После загрузки набора данных. При загрузке набора данных путем вызова `Fill` метода TableAdapter адаптер автоматически фиксирует изменения. Однако при загрузке набора данных путем объединения другого набора данных в него необходимо зафиксировать изменения вручную.

    > [!NOTE]
    > Можно запретить адаптеру автоматически фиксировать изменения при вызове `Fill` метода, задав `AcceptChangesDuringFill` для свойства адаптера значение `false` . Если задано значение `false` , то для <xref:System.Data.DataRow.RowState%2A> каждой строки, вставленной во время заполнения, задается значение <xref:System.Data.DataRowState.Added> .

- После отправки изменений набора данных в другой процесс, например в веб-службу XML.

    > [!CAUTION]
    > Применение изменений таким образом удаляет все сведения об изменениях. Не зафиксируйте изменения до тех пор, пока не завершите выполнение операций, требующих, чтобы приложение знало, какие изменения были сделаны в наборе данных.

Этот метод выполняет следующие задачи:

- Записывает <xref:System.Data.DataRowVersion.Current> версию записи в ее <xref:System.Data.DataRowVersion.Original> версию и перезаписывает исходную версию.

- Удаляет все строки, <xref:System.Data.DataRow.RowState%2A> в которых свойство имеет значение <xref:System.Data.DataRowState.Deleted> .

- Задает <xref:System.Data.DataRow.RowState%2A> для свойства записи значение <xref:System.Data.DataRowState.Unchanged> .

<xref:System.Data.DataSet.AcceptChanges%2A>Метод доступен на трех уровнях. Его можно вызвать для объекта, <xref:System.Data.DataRow> чтобы зафиксировать изменения только для этой строки. Его также можно вызвать для <xref:System.Data.DataTable> объекта, чтобы зафиксировать все строки в таблице. Наконец, можно вызвать его для <xref:System.Data.DataSet> объекта, чтобы зафиксировать все ожидающие изменения во всех записях всех таблиц набора данных.

В следующей таблице описаны изменения, которые фиксируются в зависимости от объекта, на котором вызывается метод.

|Метод|Результат|
|------------|------------|
|<xref:System.Data.DataRow.AcceptChanges%2A?displayProperty=fullName>|Изменения фиксируются только в указанной строке.|
|<xref:System.Data.DataTable.AcceptChanges%2A?displayProperty=fullName>|Изменения фиксируются во всех строках в указанной таблице.|
|<xref:System.Data.DataSet.AcceptChanges%2A?displayProperty=fullName>|Изменения фиксируются во всех строках во всех таблицах набора данных.|

> [!NOTE]
> При загрузке набора данных путем вызова метода TableAdapter не нужно `Fill` явно принимать изменения. По умолчанию `Fill` метод вызывает `AcceptChanges` метод после завершения заполнения таблицы данных.

Связанный метод, отменяет <xref:System.Data.DataSet.RejectChanges%2A> действие изменений путем копирования <xref:System.Data.DataRowVersion.Original> версии обратно в <xref:System.Data.DataRowVersion.Current> записи версии. Он также задает для <xref:System.Data.DataRow.RowState%2A> каждой записи обратно значение <xref:System.Data.DataRowState.Unchanged> .

## <a name="data-validation"></a>Проверка данных

Чтобы убедиться, что данные в приложении соответствуют требованиям процессов, в которые оно передается, часто требуется добавить проверку. Это может потребовать проверки правильности записи пользователя в форме, проверки данных, отправляемых в приложение другим приложением, или даже проверки того, что данные, вычисляемые в компоненте, находятся в пределах ограничений, предъявляемых к источникам данных и приложениям.

Проверить данные можно несколькими способами.

- На бизнес-уровне путем добавления кода в приложение для проверки данных. Этот набор данных можно использовать в одном месте. Набор данных предоставляет некоторые преимущества проверки серверной части, такие как возможность проверки изменений по мере изменения значений столбцов и строк. Дополнительные сведения см. [в разделе Проверка данных в DataSets](../data-tools/validate-data-in-datasets.md).

- На уровне представления, добавив проверку в формы. Дополнительные сведения см. [в разделе Проверка вводимых пользователем данных в Windows Forms](/dotnet/framework/winforms/user-input-validation-in-windows-forms).

- В серверной части данных, отправляя данные в источник данных, например базу данных, и позволяя ему принимать или отклонять данные. Если вы работаете с базой данных, которая обладает расширенными возможностями для проверки данных и предоставляет сведения об ошибках, это может быть практичным подходом, поскольку вы можете проверить данные независимо от того, откуда они приходят. Однако этот подход может не соответствовать требованиям к проверке для конкретного приложения. Кроме того, наличие проверки данных в источнике данных может привести к множеству циклических обращений к источнику данных в зависимости от того, как ваше приложение упрощает разрешение ошибок проверки, возникающих в серверной части.

   > [!IMPORTANT]
   > При использовании команд данных со <xref:System.Data.SqlClient.SqlCommand.CommandType%2A> свойством, для которого установлено значение <xref:System.Data.CommandType.Text> , внимательно проверяйте сведения, отправляемые с клиента, перед их передачей в базу данных. Злоумышленники могут попытаться отправить (внедрить) модифицированные или добавочные инструкции SQL и получить незаконный доступ к базе данных или повредить ее. Прежде чем передавать данные, введенные пользователем, в базу данных, всегда проверяйте, являются ли сведения допустимыми. Рекомендуется всегда использовать параметризованные запросы или хранимые процедуры, если это возможно.

## <a name="transmit-updates-to-the-data-source"></a>Передача обновлений в источник данных

После внесения изменений в наборе данных можно передать изменения в источник данных. Чаще всего это делается путем вызова `Update` метода TableAdapter (или адаптера данных). Этот метод выполняет цикл по каждой записи в таблице данных, определяет, какой тип обновления требуется (для обновления, вставки или удаления), если таковой имеется, а затем запускает соответствующую команду.

В качестве иллюстрации того, как выполняются обновления, предположим, что приложение использует набор данных, содержащий одну таблицу данных. Приложение выбирает две строки из базы данных. После извлечения таблица данных в памяти выглядит следующим образом:

```sql
(RowState)     CustomerID   Name             Status
(Unchanged)    c200         Robert Lyon      Good
(Unchanged)    c400         Nancy Buchanan    Pending
```

Приложение изменяет состояние Нэнси Батурин на "предпочтительно". В результате этого изменения значение <xref:System.Data.DataRow.RowState%2A> свойства для этой строки изменяется с <xref:System.Data.DataRowState.Unchanged> на <xref:System.Data.DataRowState.Modified> . Значение <xref:System.Data.DataRow.RowState%2A> свойства для первой строки остается равным <xref:System.Data.DataRowState.Unchanged> . Таблица данных теперь выглядит следующим образом:

```sql
(RowState)     CustomerID   Name             Status
(Unchanged)    c200         Robert Lyon      Good
(Modified)     c400         Nancy Buchanan    Preferred
```

Теперь приложение вызывает `Update` метод для передачи набора данных в базу данных. Метод проверяет каждую строку, в свою очередь. В первой строке метод не передает инструкцию SQL в базу данных, так как эта строка не изменилась с момента первоначальной выборки из базы данных.

Однако во второй строке `Update` метод автоматически вызывает правильную команду данных и передает ее в базу данных. Конкретный синтаксис инструкции SQL зависит от диалекта SQL, поддерживаемого базовым хранилищем данных. Однако следующие общие признаки передаваемой инструкции SQL являются значимыми:

- Передаваемая инструкция SQL является инструкцией UPDATE. Адаптер знает, что используется инструкция UPDATE, поскольку значение <xref:System.Data.DataRow.RowState%2A> свойства равно <xref:System.Data.DataRowState.Modified> .

- Переданная инструкция SQL содержит предложение WHERE, указывающее, что целевым объектом инструкции UPDATE является строка, где `CustomerID = 'c400'` . Эта часть инструкции SELECT отличает целевую строку от остальных, поскольку `CustomerID` является первичным ключом целевой таблицы. Информация для предложения WHERE является производной от исходной версии записи ( `DataRowVersion.Original` ), в случае, если значения, необходимые для обнаружения строки, изменились.

- Переданная инструкция SQL содержит предложение SET для установки новых значений измененных столбцов.

   > [!NOTE]
   > Если `UpdateCommand` свойству TableAdapter было присвоено имя хранимой процедуры, то адаптер не формирует инструкцию SQL. Вместо этого он вызывает хранимую процедуру с соответствующими передаваемыми параметрами.

## <a name="pass-parameters"></a>Передача параметров

Обычно параметры используются для передачи значений для записей, которые будут обновляться в базе данных. Когда `Update` метод TableAdapter выполняет инструкцию UPDATE, ему необходимо заполнить значения параметров. Он получает эти значения из `Parameters` коллекции для соответствующей команды данных, в данном случае `UpdateCommand` объекта в TableAdapter.

Если вы использовали инструменты Visual Studio для создания адаптера данных, `UpdateCommand` объект содержит коллекцию параметров, соответствующих каждому заполнительу параметра в инструкции.

<xref:System.Data.SqlClient.SqlParameter.SourceColumn%2A?displayProperty=fullName>Свойство каждого параметра указывает на столбец в таблице данных. Например, `SourceColumn` свойство для `au_id` `Original_au_id` параметров и устанавливается в любой столбец в таблице данных, содержащий идентификатор автора. При `Update` запуске метода адаптера он считывает столбец идентификатора автора из обновляемой записи и заполняет значения инструкцией.

В инструкции UPDATE необходимо указать оба новых значения (которые будут записаны в запись), а также старые значения (чтобы запись могла быть найдена в базе данных). Поэтому существуют два параметра для каждого значения: одно для предложения SET и другое для предложения WHERE. Оба параметра считывают данные из обновляемой записи, но получают разные версии значения столбца на основе <xref:System.Data.SqlClient.SqlParameter.SourceVersion> Свойства параметра. Параметр для предложения SET получает текущую версию, а параметр для предложения WHERE получает исходную версию.

> [!NOTE]
> Можно также задать значения в `Parameters` коллекции самостоятельно в коде, который обычно выполняется в обработчике событий для события адаптера данных <xref:System.Data.DataTable.RowChanging> .

## <a name="see-also"></a>См. также

- [Инструменты набора данных в Visual Studio](../data-tools/dataset-tools-in-visual-studio.md)
- [Создание и настройка адаптеров таблиц](create-and-configure-tableadapters.md)
- [Обновление данных с помощью адаптера таблицы](../data-tools/update-data-by-using-a-tableadapter.md)
- [Привязка элементов управления к данным в Visual Studio](../data-tools/bind-controls-to-data-in-visual-studio.md)
- [Проверка данных](validate-data-in-datasets.md)
- [Практическое руководство. Добавление, изменение и удаление сущностей (службы данных WCF)](/dotnet/framework/data/wcf/how-to-add-modify-and-delete-entities-wcf-data-services)
