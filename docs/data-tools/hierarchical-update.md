---
title: Иерархическое обновление
ms.date: 11/04/2016
ms.topic: conceptual
dev_langs:
- VB
- CSharp
helpviewer_keywords:
- saving data, changed data
- data [Visual Basic], hierarchical update
- saving updated data
- datasets [Visual Basic], hierarchical update
- hierarchical update
- saving data, hierarchical update
- modified data saving
- updated data saving
- related tables, saving
ms.assetid: 68bae3f6-ec9b-45ee-a33a-69395029f54c
author: jillre
ms.author: jillfra
manager: jillfra
ms.workload:
- data-storage
ms.openlocfilehash: 33ca9f91c9b1105af43af21a91f25be13e153aa9
ms.sourcegitcommit: a8e8f4bd5d508da34bbe9f2d4d9fa94da0539de0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/19/2019
ms.locfileid: "72648446"
---
# <a name="hierarchical-update"></a>Иерархическое обновление

*Иерархическое обновление* — это процесс сохранения обновленных данных (из набора данных с двумя или более связанными таблицами) обратно в базу данных с сохранением правил ссылочной целостности. *Ссылочная целостность* относится к правилам согласованности, предоставляемым ограничениями в базе данных, которые управляют поведением вставки, обновления и удаления связанных записей. Например, это ссылочная целостность, которая обеспечивает создание записи клиента перед тем, как разрешить создание заказов для этого клиента.  Дополнительные сведения о связях в наборах данных см. [в разделе связи в наборах данных](../data-tools/relationships-in-datasets.md).

Функция иерархического обновления использует `TableAdapterManager` для управления `TableAdapter`s в типизированном наборе данных. @No__t_0 компонент является классом, созданным Visual Studio, а не типом .NET. При перетаскивании таблицы из окна **Источники данных** на страницу Windows Forms или WPF Visual Studio добавляет переменную типа TableAdapterManager в форму или страницу, и она отображается в конструкторе в области компонентов. Подробные сведения о классе `TableAdapterManager` см. в разделе справки по TableAdapterManager [таблицы TableAdapter](../data-tools/create-and-configure-tableadapters.md).

По умолчанию набор данных рассматривает связанные таблицы как "только связи", что означает, что он не применяет ограничения внешнего ключа. Этот параметр можно изменить во время разработки с помощью **Конструктор наборов данных**. Выберите линию связи между двумя таблицами, чтобы открыть диалоговое окно **связь** . Изменения, вносимые здесь, определяют, как `TableAdapterManager` ведет себя при отправке изменений в связанных таблицах обратно в базу данных.

## <a name="enable-hierarchical-update-in-a-dataset"></a>Включение иерархического обновления в наборе данных

По умолчанию иерархическое обновление включено для всех новых наборов данных, которые добавляются или создаются в проекте. Включите или отключите иерархическое обновление, задав для свойства **иерархического обновления** типизированного набора данных в наборе данных **значение true** или **false**:

![Параметр иерархического обновления](../data-tools/media/hierarchical-update-setting.png)

## <a name="create-a-new-relation-between-tables"></a>Создание новой связи между таблицами

Чтобы создать новое отношение между двумя таблицами, в конструктор наборов данных выберите строку заголовка каждой таблицы, а затем щелкните правой кнопкой мыши и выберите команду **Добавить связь**.

![Меню иерархического обновления Добавление отношения](../data-tools/media/hierarchical-update-add-relation-menu.png)

## <a name="understand-foreign-key-constraints-cascading-updates-and-deletes"></a>Основные сведения об ограничениях внешнего ключа, каскадных обновлениях и удалениях

Важно понимать, как ограничения внешнего ключа и каскадное поведение в базе данных создаются в созданном коде набора данных.

По умолчанию таблицы данных в наборе данных создаются с помощью связей (<xref:System.Data.DataRelation>), соответствующих связям в базе данных. Однако связь в наборе данных не создается как ограничение внешнего ключа. @No__t_0 настроена как **связь только** без <xref:System.Data.ForeignKeyConstraint.UpdateRule%2A> или <xref:System.Data.ForeignKeyConstraint.DeleteRule%2A> в силе.

По умолчанию каскадные обновления и каскадные удаления отключены, даже если связь базы данных настроена с включенными каскадными обновлениями или каскадными удалениями. Например, создание нового клиента и нового заказа, а затем попытка сохранить данные может привести к конфликту с ограничениями внешнего ключа, определенными в базе данных. Дополнительные сведения см. в разделе [Отключение ограничений при заполнении набора данных](turn-off-constraints-while-filling-a-dataset.md).

## <a name="set-the-order-to-perform-updates"></a>Настройка порядка выполнения обновлений

Установка порядка выполнения обновлений задает порядок отдельных вставок, обновлений и удалений, необходимых для сохранения всех измененных данных во всех таблицах набора данных. Если включено иерархическое обновление, сначала выполняются вставки, затем обновления, а затем удаляются. @No__t_0 предоставляет свойство `UpdateOrder`, которое может быть настроено для выполнения обновлений сначала, затем вставляется, а затем удаляется.

> [!NOTE]
> Важно понимать, что порядок обновления является всем инклюзивным. То есть при выполнении обновлений операции вставки и удаления выполняются для всех таблиц в наборе данных.

Чтобы задать свойство `UpdateOrder`, после перетаскивания элементов из [окна Источники данных](add-new-data-sources.md#data-sources-window) на форму выберите `TableAdapterManager` в области компонентов, а затем задайте свойство `UpdateOrder` в окне **свойства** .

## <a name="create-a-backup-copy-of-a-dataset-before-performing-a-hierarchical-update"></a>Создание резервной копии набора данных перед выполнением иерархического обновления

При сохранении данных (путем вызова метода `TableAdapterManager.UpdateAll()`) `TableAdapterManager` пытается обновить данные для каждой таблицы в одной транзакции. Если какая-либо часть обновления для любой таблицы завершается ошибкой, выполняется откат всей транзакции. В большинстве случаев откат возвращает приложение в исходное состояние.

Однако иногда может потребоваться восстановить набор данных из резервной копии. Один из примеров этого может произойти при использовании значений автоприращения. Например, если операция сохранения не выполнена успешно, значения автоприращения не сбрасываются в наборе данных, а набор данных продолжит создавать значения с автоматическим приращением. Это оставляет разрыв в нумерации, который может быть неприемлемым для вашего приложения. В ситуациях, когда это является проблемой, `TableAdapterManager` предоставляет свойство `BackupDataSetBeforeUpdate`, которое заменяет существующий набор данных резервной копией в случае сбоя транзакции.

> [!NOTE]
> Резервная копия находится в памяти только во время выполнения метода `TableAdapterManager.UpdateAll`. Поэтому программный доступ к этому набору данных резервного копирования отсутствует, поскольку он либо заменяет исходный набор данных, либо выходит за пределы области действия сразу после завершения выполнения метода `TableAdapterManager.UpdateAll`.

## <a name="modify-the-generated-save-code-to-perform-the-hierarchical-update"></a>Изменение созданного кода сохранения для выполнения иерархического обновления

Сохраните изменения из связанных таблиц данных набора данных в базу данных, вызвав метод `TableAdapterManager.UpdateAll` и передав имя набора данных, содержащего связанные таблицы. Например, запустите метод `TableAdapterManager.UpdateAll(NorthwindDataset)` для отправки обновлений из всех таблиц в NorthwindDataset во внутреннюю базу данных.

После удаления элементов из окна **Источники данных** в событие `Form_Load` автоматически добавляется код для заполнения каждой таблицы (методы `TableAdapter.Fill`). Код также добавляется в событие нажатия кнопки **Сохранить** объекта <xref:System.Windows.Forms.BindingNavigator>, чтобы сохранить данные из набора данных обратно в базу данных (метод `TableAdapterManager.UpdateAll`).

Сформированный код сохранения также содержит строку, вызывающую метод `CustomersBindingSource.EndEdit`. В частности, он вызывает метод <xref:System.Windows.Forms.BindingSource.EndEdit%2A> первого <xref:System.Windows.Forms.BindingSource>that, добавленного в форму. Иными словами, этот код создается только для первой таблицы, которая перетаскивается из окна **Источники данных** на форму. Вызов <xref:System.Windows.Forms.BindingSource.EndEdit%2A> фиксирует все актуальные изменения для всех редактируемых в настоящее время элементов управления с привязкой к данным. Таким образом, если элемент управления с привязкой к данным все еще находится в фокусе и вы нажимаете кнопку **Сохранить**, все ожидающие правки в этом элементе управления фиксируются до фактического сохранения (метод `TableAdapterManager.UpdateAll`).

> [!NOTE]
> **Конструктор наборов данных** добавляет только код `BindingSource.EndEdit` для первой таблицы, которая переносится на форму. Таким образом, вам необходимо добавить строку кода, вызывающую метод `BindingSource.EndEdit` для каждой связанной таблицы на форме. В рамках данного пошагового руководства это означает, что вам нужно добавить вызов метода `OrdersBindingSource.EndEdit`.

### <a name="to-update-the-code-to-commit-changes-to-the-related-tables-before-saving"></a>Обновление кода для фиксации изменений в связанных таблицах перед сохранением

1. Дважды нажмите кнопку **Сохранить** на <xref:System.Windows.Forms.BindingNavigator>, чтобы открыть **Form1** в редакторе кода.

2. Добавьте строку кода для вызова метода `OrdersBindingSource.EndEdit` после строки, вызывающей метод `CustomersBindingSource.EndEdit`. Код в событии нажатия кнопки **Сохранить** должен выглядеть примерно следующим образом:

     [!code-vb[VSProDataOrcasHierarchicalUpdate#1](../data-tools/codesnippet/VisualBasic/hierarchical-update_1.vb)]
     [!code-csharp[VSProDataOrcasHierarchicalUpdate#1](../data-tools/codesnippet/CSharp/hierarchical-update_1.cs)]

Кроме фиксации изменений в связанной дочерней таблице перед сохранением данных в базе данных, вам также может понадобиться фиксировать недавно созданные родительские записи перед добавлением новых дочерних записей в базу данных. Иными словами, может потребоваться добавить новую родительскую запись (`Customer`) к набору данных до того, как ограничения внешнего ключа позволят добавить новые дочерние записи (`Orders`) в набор данных. Для этого можно использовать дочернее событие `BindingSource.AddingNew`.

> [!NOTE]
> Нужно ли зафиксировать новые родительские записи, зависит от типа элемента управления, который используется для привязки к источнику данных. В этом пошаговом руководстве для привязки к родительской таблице используются отдельные элементы управления. Для этого требуется дополнительный код для фиксации новой родительской записи. Если родительские записи отображались бы в сложном элементе управления привязки, таком как <xref:System.Windows.Forms.DataGridView>, то этот дополнительный <xref:System.Windows.Forms.BindingSource.EndEdit%2A>ный вызов для родительской записи не будет обязательным. Это вызвано тем, что базовая функциональность привязки к данным элемента управления обрабатывает фиксацию новых записей.

### <a name="to-add-code-to-commit-parent-records-in-the-dataset-before-adding-new-child-records"></a>Добавление кода для фиксации родительских записей в наборе данных перед добавлением новых дочерних записей

1. Создайте обработчик событий для события `OrdersBindingSource.AddingNew`.

    - Откройте **форму Form1** в режиме конструктора, выберите **OrdersBindingSource** в области компонентов, выберите **события** в окне **Свойства** , а затем дважды щелкните событие **AddingNew** .

2. Добавьте строку кода в обработчик событий, который вызывает метод `CustomersBindingSource.EndEdit`. Код в обработчике событий `OrdersBindingSource_AddingNew` должен выглядеть примерно следующим образом:

     [!code-vb[VSProDataOrcasHierarchicalUpdate#2](../data-tools/codesnippet/VisualBasic/hierarchical-update_2.vb)]
     [!code-csharp[VSProDataOrcasHierarchicalUpdate#2](../data-tools/codesnippet/CSharp/hierarchical-update_2.cs)]

## <a name="tableadaptermanager-reference"></a>Справочник по TableAdapterManager

По умолчанию класс `TableAdapterManager` создается при создании набора данных, содержащего связанные таблицы. Чтобы предотвратить создание класса, измените значение свойства `Hierarchical Update` набора данных на false. При перетаскивании таблицы, имеющей отношение, в область конструктора на странице Windows Form или WPF, Visual Studio объявляет переменную-член класса. Если не используется привязка данных, необходимо вручную объявить переменную.

Класс `TableAdapterManager` не является типом .NET. Поэтому вы не можете найти его в документации. Он создается во время разработки в рамках процесса создания набора данных.

Ниже приведены часто используемые методы и свойства класса `TableAdapterManager`.

|Член|Описание|
|------------|-----------------|
|Метод `UpdateAll`|Сохраняет все данные из всех таблиц данных.|
|Свойство`BackUpDataSetBeforeUpdate`|Определяет, следует ли создать резервную копию набора данных перед выполнением метода `TableAdapterManager.UpdateAll`. Логическая.|
|Свойство `TableAdapter` *TableName*|Представляет `TableAdapter`. Созданный `TableAdapterManager` содержит свойство для каждого `TableAdapter`, которыми он управляет. Например, набор данных с таблицей Customers и Orders создается с `TableAdapterManager`, содержащей свойства `CustomersTableAdapter` и `OrdersTableAdapter`.|
|Свойство`UpdateOrder`|Управляет порядком отдельных команд вставки, обновления и удаления. Присвойте этому параметру одно из значений перечисления `TableAdapterManager.UpdateOrderOption`.<br /><br /> По умолчанию для `UpdateOrder` задано значение **инсертупдатеделете**. Это означает, что операции вставки, обновления и удаления выполняются для всех таблиц в наборе данных.|

## <a name="see-also"></a>См. также

- [Сохранение данных обратно в базу данных](../data-tools/save-data-back-to-the-database.md)
