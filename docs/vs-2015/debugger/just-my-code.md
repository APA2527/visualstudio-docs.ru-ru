---
title: Только мой код | Документация Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-debug
ms.topic: conceptual
dev_langs:
- FSharp
- VB
- CSharp
- C++
ms.assetid: 0f0df097-bbaf-46ad-9ad1-ef5f40435079
caps.latest.revision: 14
author: MikeJo5000
ms.author: mikejo
manager: jillfra
ms.openlocfilehash: efcabf9c7dc201f95515cd24bf3a14727f7149fe
ms.sourcegitcommit: 75807551ea14c5a37aa07dd93a170b02fc67bc8c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/11/2019
ms.locfileid: "67823952"
---
# <a name="just-my-code"></a>Только мой код
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Разработчики, использующие языки платформы .NET Framework, знакомы с функцией отладчика "Только мой код", которая выполняет системные, платформенные и другие не относящиеся к пользователю вызовы и сворачивает эти вызовы в окнах стека вызовов. Режим "Только мой код" теперь предусмотрен для языков C++ и JavaScript. В этом разделе описаны особенности использования режима "Только мой код" в платформе .NET Framework и проектах, изначально основанных на C++ и JavaScript.  
  
## <a name="BKMK_Enable_or_disable_Just_My_Code"></a> Включение или отключение режима "Только мой код"  
 Чтобы включить или отключить только мой код, выберите **параметры и настройки** на **Отладка** меню. В **Отладка** / **Общие** узел, установите или снимите флажок **включить только мой код**.  
  
 ![Включить только мой код в диалоговом окне Параметры](../debugger/media/dbg-justmycode-options.png "DBG_JustMyCode_Options")  
  
> [!NOTE]
> **Включить только мой код** параметр — это глобальный параметр, который применяется ко всем проектам Visual Studio на всех языках.  
  
### <a name="BKMK_Override_call_stack_filtering"></a> Фильтрация стека вызовов переопределения  
 На экранах стека вызовов, таких как окна стека вызовов и задач, режим "Только мой код" сворачивает код, не написанный пользователем, в кадр с аннотациями и подписью `[External Code]`. Для просмотра свернутых кадров выберите **Показать внешний код** в контекстном меню стека вызова отображаться.  
  
> [!NOTE]
> **Показать внешний код** параметр сохраняется в профилировщик текущего пользователя. Он применяется ко всем проектам на всех языках, открываемых этим пользователем.  
  
## <a name="BKMK__NET_Framework_Just_My_Code"></a> Только мой код .NET framework  
  
### <a name="BKMK_NET_User_and_non_user_code"></a> Пользовательский код и не написанный пользователем код  
 Чтобы отличить пользовательский код от другого кода, Just My Code рассматривает файлов символов (.pdb) и программную оптимизацию. Отладчик считает код, не написанным пользователем, если двоичный файл оптимизируется или если pdb-файл недоступен.  
  
 Три атрибута также влияют на то, какой код отладчик считаем кодом пользователя:  
  
- <xref:System.Diagnostics.DebuggerNonUserCodeAttribute> сообщает отладчику, что код, к которому он применяется, не является пользовательским.  
  
- <xref:System.Diagnostics.DebuggerHiddenAttribute> скрывает код от отладчика, даже если режим "Только мой код" включен.  
  
- <xref:System.Diagnostics.DebuggerStepThroughAttribute> указывает отладчику выполнить в пошаговом режим код, к которому он применяется, а не осуществлять шаг с заходом в этот код.  
  
  Весь остальной код считается пользовательским.  
  
### <a name="BKMK_NET_Stepping_behavior"></a> Поведение пошагового выполнения  
 Когда вы **шаг с заходом** (сочетание клавиш: F11) другого кода, отладчик обходит код к следующему оператору пользователя. Когда вы **шаг с выходом** (клавиатуры: SHIFT + F11) отладчик переходит к следующей строке пользовательского кода. Если код пользователя не обнаруживается, выполнение продолжается до завершения работы приложения, достижения точки останова или возникновения исключения.  
  
### <a name="BKMK_NET_Breakpoint_behavior"></a> Поведение точек останова  
 При включении Just My Code, вы можете **прервать все** (клавиатуры: Ctrl + Alt + Break) и остановить выполнение в месте, где имеется пользовательский код для отображения. Когда это происходит, отображается окно "Нет исходного кода". Если затем выбирается команда "Шаг", отладчик переходит к следующей строке пользовательского кода.  
  
### <a name="BKMK_NET_Exception_behavior"></a> Поведение исключения  
 При возникновении необработанного исключения в коде, написанном не пользователем, отладчик прерывается на той строке в коде пользователя, где было создано исключение.  
  
 Если для этого исключения включена первичная обработка исключения, строка кода пользователя выделяется зеленым цветом. Стек вызовов отображает кадр с заметками с меткой **[внешний код]** .  
  
## <a name="BKMK_C___Just_My_Code"></a> "Только мой код" в C++  
  
### <a name="BKMK_CPP_User_and_non_user_code"></a> Пользовательский код и не написанный пользователем код  
 Функция "Только мой код" в C++ отличается от функции "Только мой код" для платформы .NET Framework и JavaScript, поскольку поведение пошагового выполнения не зависит от поведения стека вызовов.  
  
 **Стеки вызовов**  
  
 По умолчанию отладчик считает эти функции кодом, не написанным пользователем, в окнах стека вызовов.  
  
- Функции с открытой исходной информацией в файле символов.  
  
- Функции, в которых файлы символов указывают, что исходный файл, соответствующий кадру стека, отсутствует.  
  
- Функции, определенные в файлах `*.natjmc`, находящихся в папке `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers`.  
  
  **Шаг с заходом**  
  
  По умолчанию только функции, определенные в файлах `*.natstepfilter` (папка `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers`), считаются кодом, не написанным пользователем.  
  
  Для настройки пошагового выполнения и поведения окна стека вызовов в `%USERPROFILE%\My Documents\Visual Studio 2015\Visualizers` вы можете создавать собственные `.natstepfilter` и `.natjmc`.  
  
### <a name="BKMK_CPP_Stepping_behavior"></a> Поведение пошагового выполнения  
 Когда вы **шаг с заходом** (сочетание клавиш: F11) не написанный пользователем код из пользовательского кода, отладчик обходит код на следующую строку пользовательского кода. Когда вы **шаг с выходом** (клавиатуры: SHIFT + F11) отладчик переходит к следующей строке пользовательского кода. Если код пользователя не обнаруживается, выполнение продолжается до завершения работы приложения, достижения точки останова или возникновения исключения.  
  
 Если отладчик делает останов в коде, не написанном пользователем (например, если команда "Прервать все" останавливает в коде, не написанном пользователем), пошаговое выполнение продолжается в коде, не написанном пользователем.  
  
### <a name="BKMK_CPP_Exception_behavior"></a> Поведение исключения  
 Если отладчик обнаруживает исключение, он останавливается на исключении независимо от того, находится ли оно в коде пользователя. **Не обработанное пользовательским кодом** параметры в **исключения** диалоговое окно учитываются.  
  
### <a name="BKMK_CPP_Customize_stepping_behavior"></a> Настройка поведения пошагового выполнения  
 Вы можете определить функции, для которых будут выполняться шаги с обходом, внеся их в файлы `*.natstepfilter` как код, не написанный пользователем.  
  
- Чтобы указать встроенный код для всех пользователей компьютера с Visual Studio, добавьте файл .natstepfilter в `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers` папку.  
  
- Чтобы указать код, не написанный пользователем для отдельного пользователя, добавьте файл .natstepfilter в `%USERPROFILE%\My Documents\Visual Studio 2015\Visualizers` папку.  
  
  Файлы .natstepfilter представляют собой XML-файлы со следующим синтаксисом:  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<StepFilter xmlns="http://schemas.microsoft.com/vstudio/debugger/natstepfilter/2010">  
    <Function>  
        <Name>FunctionSpec</Name>  
        <Action>StepAction</Action>  
    </Function>  
    <Function>  
        <Name>FunctionSpec</Name>  
        <Module>ModuleSpec</Module>  
        <Action>StepAction</Action>  
    </Function>  
</StepFilter>  
  
```  
  
|Элемент|Описание|  
|-------------|-----------------|  
|Функция|Обязательный. Указывает одну или несколько функций как функцию, не написанную пользователем.|  
|`Name`|Обязательный. Регулярное выражение в формате ECMA-262, содержащее полное имя функции для сопоставления. Например:<br /><br /> `<Name>MyNS::MyClass.*</Name>`<br /><br /> сообщает отладчику, что все методы в `MyNS::MyClass`, должны считаться кодом, не написанным пользователем. Сопоставление учитывает регистр.|  
|`Module`|Необязательный параметр. Регулярное выражение в формате ECMA-262, указывающее полный путь к модулю, содержащему функцию. Сопоставление не учитывает регистр.|  
|`Action`|Обязательный. Одно из следующих чувствительных к регистру значений:<br /><br /> -   `NoStepInto`  — указывает отладчику выполнять шаги с обходом соответствующей функции.<br />-   `StepInto`  — указывает отладчику выполнять шаги с заходом в соответствующие функции, отменяя все остальные `NoStepInto` для соответствующих функций.|  
  
### <a name="BKMK_CPP_Customize_call_stack_behavior"></a> Настройка поведения стека вызовов  
 Вы можете указать модули, файлы исходного кода и функции, которые необходимо рассматривать как код, не написанный пользователем, в стеках вызовов, указав их в файлах `*.natjmc`.  
  
- Чтобы указать встроенный код для всех пользователей компьютера с Visual Studio, добавьте файл .natjmc в `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers` папку.  
  
- Чтобы указать код, не написанный пользователем для отдельного пользователя, добавьте файл .natjmc в `%USERPROFILE%\My Documents\Visual Studio 2015\Visualizers` папку.  
  
  Файлы .natjmc представляют собой XML-файлы со следующим синтаксисом:  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<NonUserCode xmlns="http://schemas.microsoft.com/vstudio/debugger/jmc/2015">  
  
  <!-- Modules -->  
  <Module Name="ModuleSpec" />  
  <Module Name="ModuleSpec" Company="CompanyName" />  
  
  <!-- Files -->  
  <File Name="FileSpec"/>  
  
  <!-- Functions -->  
  <Function Name="FunctionSpec" />  
  <Function Name="FunctionSpec" Module ="ModuleSpec" />  
  <Function Name="FunctionSpec" Module ="ModuleSpec" ExceptionImplementation="true" />  
  
</NonUserCode>  
  
```  
  
 **Атрибуты элементов модуля**  
  
|Атрибут|Описание|  
|---------------|-----------------|  
|`Name`|Обязательный. Полный путь к модулю или модулям. Вы можете использовать следующие подстановочные знаки Windows: `?` (ни одного или один символ) и `*` (ни одного или несколько символов). Например, примененная к объекту директива<br /><br /> `<Module Name=”?:\3rdParty\UtilLibs\*” />`<br /><br /> указывает отладчику, что необходимо рассматривать все модули в `\3rdParty\UtilLibs` на любом диске как внешний код.|  
|`Company`|Необязательный параметр. Название компании, публикующей модуль, внедренный в исполняемый файл. Этот атрибут можно использовать для устранения неоднозначности модулей.|  
  
 **Атрибуты элементов файла**  
  
|Атрибут|Описание|  
|---------------|-----------------|  
|`Name`|Обязательный. Полный путь к файлу или файлам исходного кода, который необходимо считать внешним кодом. При задании пути можно использовать следующие подстановочные знаки Windows: `?` и `*`.|  
  
 **Атрибуты элементов функций**  
  
|Атрибут|Описание|  
|---------------|-----------------|  
|`Name`|Обязательный. Полное имя функции, которую необходимо рассматривать как внешний код.|  
|`Module`|Необязательный параметр. Имя модуля или полный путь к модулю, содержащему эту функцию. Этот атрибут можно использовать для устранения неоднозначности функций с одинаковыми именами.|  
|`ExceptionImplementation`|Если задано значение `true`, стек вызовов отображает функцию, которая создала исключение, а не данную функцию.|  
  
## <a name="BKMK_JavaScript_Just_My_Code"></a> "Только мой код" в JavaScript  
  
### <a name="BKMK_JS_User_and_non_user_code"></a> Пользовательский код и не написанный пользователем код  
 **Классификации кода**  
  
 Режим "Только мой код" в JavaScript управляет пошаговым выполнением и отображением стека вызовов путем распределения кода по одной из следующих классификаций.  
  
|||  
|-|-|  
|**MyCode**|Код пользователя, которым вы распоряжаетесь и управляете.|  
|**LibraryCode**|Код, не написанный пользователем, полученный из библиотек, которыми вы пользуетесь регулярно и от которых зависит правильная работа приложения (например, WinJS или jQuery).|  
|**UnrelatedCode**|Непользовательский код, который может выполняться в приложении, но вы не являетесь и приложение не зависит напрямую ей функционировать правильно (например, рекламный SDK, отображающий объявления). В проектах Магазина Windows любой код, который загружается в приложение из URI HTTP или HTTPS, также считается UnrelatedCode.|  
  
 Отладчик JavaScript автоматически классифицирует эти типы кода:  
  
- Скрипт, который выполняется путем передачи строки предоставленной узлом `eval` функция классифицируется как **MyCode**.  
  
- Скрипт, который выполняется путем передачи строки `Function` конструктор классифицируется как **LibraryCode**.  
  
- Скрипт, содержащийся в ссылке платформы, например WinJS или Azure SDK, классифицируется как **LibraryCode**.  
  
- Скрипт, который выполняется путем передачи строки `setTimeout`, `setImmediate`, или `setInterval` функции классифицируется как **UnrelatedCode**.  
  
- С помощью `%VSInstallDirectory%\JavaScript\JustMyCode\mycode.default.wwa.json` во всех JavaScript-проектах Visual Studio определяется код, написанный другими пользователями, и код, не написанный пользователями.  
  
  Можно изменить классификации по умолчанию и классифицировать определенные файлы и url-адреса путем добавления файла .json с именем `mycode.json` в корневую папку проекта.  
  
  Весь остальной код классифицируется как **MyCode**.  
  
### <a name="BKMK_JS_Stepping_behavior"></a> Поведение пошагового выполнения  
  
- Если функция не является пользователем (**MyCode**) кода, **шаг с заходом** (сочетание клавиш: F11) ведет себя как **шаг с обходом** (клавиатуры: F10).  
  
- Если шаг начинается в непользовательском (**LibraryCode** или **UnrelatedCode**) кода, пошаговое выполнение временно осуществляется, как если бы только мой код не включен. Сразу после возвращения в код пользователя пошаговое выполнение в режиме "Только мой код" возобновляется.  
  
- Если шаг в коде пользователя приводит к выходу из текущего контекста выполнения (например, при выполнении шага в последней строке обработчика событий), отладчик останавливается на следующей выполняемой строке кода пользователя. Например, если обратный вызов выполняется в **LibraryCode** кода, отладчик продолжает, пока не будет выполнена следующая строка кода пользователя.  
  
- **Шаг с выходом** (клавиатуры: SHIFT + F11) останавливается на следующей строке пользовательского кода. Если код пользователя не обнаруживается, выполнение продолжается до завершения работы приложения, достижения точки останова или возникновения исключения.  
  
### <a name="BKMK_JS_Breakpoint_behavior"></a> Поведение точек останова  
  
- Точки останова, заданные в каком-либо коде, всегда соблюдаются независимо от классификации этого кода  
  
- Если ключевое слово `debugger` обнаруживается в:  
  
  - **LibraryCode** кода, отладчик всегда останавливается.  

  - **UnrelatedCode** кода, отладчик не останавливается.  
  
### <a name="BKMK_JS_Exception_behavior"></a> Поведение исключения  
 Если необработанное исключение возникает в:  
  
- **MyCode** или **LibraryCode** кода, отладчик всегда останавливается.  
  
- **UnrelatedCode** кода, и **MyCode** или **LibraryCode** код находится в стеке вызовов, отладчик достигнет точки останова.  
  
  Если исключения первого шанса включены для исключения в диалоговом окне исключения и исключение **LibraryCode** или **UnrelatedCode** кода:  
  
- Если исключение обрабатывается, отладчик не останавливается.  
  
- Если исключение не обрабатывается, отладчик останавливается.  
  
### <a name="BKMK_JS_Customize_Just_My_Code"></a> Настройка только мой код  
 Чтобы разделить код пользователя и код, не написанный пользователем, для отдельного проекта Visual Studio, добавьте файл .json с именем `mycode.json` в корневую папку проекта.  
  
 Классификации выполняются в следующем порядке:  
  
1. Классификации по умолчанию  
  
2. Классификации в файле `%VSInstallDirectory%\JavaScript\JustMyCode\mycode.default.wwa.json`  
  
3. Классификации в файле `mycode. json` текущего проекта.  
  
   Каждый шаг классификации переопределяет предыдущие шаги. JSON-файл должен отображать все пары ключ-значение и **MyCode**, **библиотеки**, и **Unrelated** значения могут быть пустыми массивами.  
  
   Файлы .json кода пользователя используют следующий синтаксис:  
  
```json  
{  
    "Eval" : "Classification",  
    "Function" : "Classification",  
    "ScriptBlock" : "Classification",  
    "MyCode" : [  
        "UrlOrFileSpec”,  
        . . .  
        "UrlOrFileSpec”  
    ],  
    "Libraries" : [  
        "UrlOrFileSpec”,  
        . .  
        "UrlOrFileSpec”  
    ],  
    "Unrelated" : [  
        "UrlOrFileSpec”,  
        . . .  
        "UrlOrFileSpec”  
    ]  
}  
  
```  
  
 **"Eval", "Function" и "ScriptBlock"**  
  
 **Eval**, **функция**, и **ScriptBlock** пар ключ-значение как динамически определить классифицируется сформированного кода.  
  
|||  
|-|-|  
|**Eval**|Скрипт, который выполняется путем передачи строки предоставленной хостом функции `eval`. По умолчанию скрипт Eval классифицируется как **MyCode**.|  
|**Function**|Скрипт, который выполняется путем передачи строки конструктору `Function`. По умолчанию скрипт Function классифицируется как **LibraryCode**.|  
|**ScriptBlock**|Скрипт, который выполняется путем передачи строки функциям `setTimeout`, `setImmediate` или `setInterval`. По умолчанию скрипт ScriptBlock классифицируется как **UnrelatedCode**.|  
  
 Можно изменить это значение на одно из следующих ключевых слов:  
  
- `MyCode` классифицирует скрипт как **MyCode**.  
  
- `Library` классифицирует скрипт как **LibraryCode**.  
  
- `Unrelated` классифицирует скрипт как **UnrelatedCode**.  
  
  **"MyCode", "Libraries" и "Unrelated"**  
  
  **MyCode**, **библиотеки**, и **Unrelated** пар ключ-значение укажите URL-адресов или файлы, которые вы хотите включить в классификацию:  
  
|||  
|-|-|  
|**MyCode**|Массив URL-адресов или файлы, которые классифицируются как **MyCode**.|  
|**Libraries**|Массив URL-адресов или файлы, которые классифицируются как **LibraryCode**.|  
|**Unrelated**|Массив URL-адресов или файлы, которые классифицируются как **UnrelatedCode**.|  
  
 Строка URL-адреса или файла может содержать один или несколько символов `*`, соответствующих любому количеству символов. `*` равноценен регулярному выражению `.*`.
