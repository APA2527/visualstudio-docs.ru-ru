---
title: Только мой код | Документация Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-debug
ms.topic: conceptual
dev_langs:
- FSharp
- VB
- CSharp
- C++
ms.assetid: 0f0df097-bbaf-46ad-9ad1-ef5f40435079
caps.latest.revision: 14
author: MikeJo5000
ms.author: mikejo
manager: jillfra
ms.openlocfilehash: 62da3a36a34a2111bb139765268fbb0bef9b500d
ms.sourcegitcommit: b885f26e015d03eafe7c885040644a52bb071fae
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/30/2020
ms.locfileid: "85531928"
---
# <a name="just-my-code"></a>Только мой код
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Разработчики, использующие языки платформы .NET Framework, знакомы с функцией отладчика "Только мой код", которая выполняет системные, платформенные и другие не относящиеся к пользователю вызовы и сворачивает эти вызовы в окнах стека вызовов. Режим "Только мой код" теперь предусмотрен для языков C++ и JavaScript. В этом разделе описаны особенности использования режима "Только мой код" в платформе .NET Framework и проектах, изначально основанных на C++ и JavaScript.  
  
## <a name="enable-or-disable-just-my-code"></a><a name="BKMK_Enable_or_disable_Just_My_Code"></a> Включение или отключение режима "Только мой код"  
 Чтобы включить или отключить Только мой код, выберите **Параметры и настройки** в меню **Отладка** . На узле **Отладка**  /  —**Общие** выберите или снимите флажок **включить только мой код**.  
  
 ![Флажок "Включить только мой код" в диалоговом окне "Параметры"](../debugger/media/dbg-justmycode-options.png "DBG_JustMyCode_Options")  
  
> [!NOTE]
> Параметр **включить только мой код** является глобальным параметром, который применяется ко всем проектам Visual Studio на всех языках.  
  
### <a name="override-call-stack-filtering"></a><a name="BKMK_Override_call_stack_filtering"></a>Переопределение фильтрации стека вызовов  
 На экранах стека вызовов, таких как окна стека вызовов и задач, режим "Только мой код" сворачивает код, не написанный пользователем, в кадр с аннотациями и подписью `[External Code]`. Чтобы просмотреть свернутые кадры, в контекстном меню отображения стека вызовов выберите **Показать внешний код** .  
  
> [!NOTE]
> Параметр **отобразить внешний код** сохраняется в профилировщике текущего пользователя. Он применяется ко всем проектам на всех языках, открываемых этим пользователем.  
  
## <a name="net-framework-just-my-code"></a><a name="BKMK__NET_Framework_Just_My_Code"></a>.NET Framework Только мой код  
  
### <a name="user-and-non-user-code"></a><a name="BKMK_NET_User_and_non_user_code"></a>Пользовательский и не пользовательский код  
 Чтобы отличать пользовательский код от кода, не относящегося к пользователю, Только мой код просматривает файлы символов (. pdb) и оптимизирует программы. Отладчик считает код, не написанным пользователем, если двоичный файл оптимизируется или если pdb-файл недоступен.  
  
 Три атрибута также влияют на то, какой код отладчик считаем кодом пользователя:  
  
- <xref:System.Diagnostics.DebuggerNonUserCodeAttribute> сообщает отладчику, что код, к которому он применяется, не является пользовательским.  
  
- <xref:System.Diagnostics.DebuggerHiddenAttribute> скрывает код от отладчика, даже если режим "Только мой код" включен.  
  
- <xref:System.Diagnostics.DebuggerStepThroughAttribute> указывает отладчику выполнить в пошаговом режим код, к которому он применяется, а не осуществлять шаг с заходом в этот код.  
  
  Весь остальной код считается пользовательским.  
  
### <a name="stepping-behavior"></a><a name="BKMK_NET_Stepping_behavior"></a>Пошаговое поведение  
 При **выполнении шага** (сочетание клавиш: F11) кода, отличного от пользователя, отладчик пошаговое выполнение кода до следующей инструкции User. При выполнении **шага** (сочетание клавиш: Shift + F11) отладчик выполняется на следующей строке пользовательского кода. Если код пользователя не обнаруживается, выполнение продолжается до завершения работы приложения, достижения точки останова или возникновения исключения.  
  
### <a name="breakpoint-behavior"></a><a name="BKMK_NET_Breakpoint_behavior"></a>Поведение точки останова  
 Если Только мой код включен, можно выбрать команду **прервать все** (сочетание клавиш: Ctrl + Alt + Break) и остановить выполнение в месте, где нет пользовательского кода для вывода. Когда это происходит, отображается окно "Нет исходного кода". Если затем выбирается команда "Шаг", отладчик переходит к следующей строке пользовательского кода.  
  
### <a name="exception-behavior"></a><a name="BKMK_NET_Exception_behavior"></a>Поведение исключения  
 При возникновении необработанного исключения в коде, написанном не пользователем, отладчик прерывается на той строке в коде пользователя, где было создано исключение.  
  
 Если для этого исключения включена первичная обработка исключения, строка кода пользователя выделяется зеленым цветом. В стеке вызовов отображается кадр с заметками **[внешний код]**.  
  
## <a name="c-just-my-code"></a><a name="BKMK_C___Just_My_Code"></a> "Только мой код" в C++  
  
### <a name="user-and-non-user-code"></a><a name="BKMK_CPP_User_and_non_user_code"></a>Пользовательский и не пользовательский код  
 Функция "Только мой код" в C++ отличается от функции "Только мой код" для платформы .NET Framework и JavaScript, поскольку поведение пошагового выполнения не зависит от поведения стека вызовов.  
  
 **Стеки вызовов**  
  
 По умолчанию отладчик считает эти функции кодом, не написанным пользователем, в окнах стека вызовов.  
  
- Функции с открытой исходной информацией в файле символов.  
  
- Функции, в которых файлы символов указывают, что исходный файл, соответствующий кадру стека, отсутствует.  
  
- Функции, определенные в файлах `*.natjmc`, находящихся в папке `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers`.  
  
  **Отладка по шагам**  
  
  По умолчанию только функции, определенные в файлах `*.natstepfilter` (папка `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers`), считаются кодом, не написанным пользователем.  
  
  Для настройки пошагового выполнения и поведения окна стека вызовов в `%USERPROFILE%\My Documents\Visual Studio 2015\Visualizers` вы можете создавать собственные `.natstepfilter` и `.natjmc`.  
  
### <a name="stepping-behavior"></a><a name="BKMK_CPP_Stepping_behavior"></a>Пошаговое поведение  
 При **выполнении шага** (сочетание клавиш: F11) кода, не являющегося пользовательским кодом, отладчик пошаговое выполнение кода до следующей строки пользовательского кода. При выполнении **шага** (сочетание клавиш: Shift + F11) отладчик выполняется на следующей строке пользовательского кода. Если код пользователя не обнаруживается, выполнение продолжается до завершения работы приложения, достижения точки останова или возникновения исключения.  
  
 Если отладчик делает останов в коде, не написанном пользователем (например, если команда "Прервать все" останавливает в коде, не написанном пользователем), пошаговое выполнение продолжается в коде, не написанном пользователем.  
  
### <a name="exception-behavior"></a><a name="BKMK_CPP_Exception_behavior"></a>Поведение исключения  
 Если отладчик обнаруживает исключение, он останавливается на исключении независимо от того, находится ли оно в коде пользователя. **Необработанные пользователем** параметры в диалоговом окне " **исключения** " игнорируются.  
  
### <a name="customize-stepping-behavior"></a><a name="BKMK_CPP_Customize_stepping_behavior"></a>Настройка пошагового поведения  
 Вы можете определить функции, для которых будут выполняться шаги с обходом, внеся их в файлы `*.natstepfilter` как код, не написанный пользователем.  
  
- Чтобы указать код, не являющийся пользователем, для всех пользователей компьютера Visual Studio, добавьте в папку файл. натстепфилтер `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers` .  
  
- Чтобы указать для отдельного пользователя код, не являющийся пользовательским, добавьте в папку файл. натстепфилтер `%USERPROFILE%\My Documents\Visual Studio 2015\Visualizers` .  
  
  Файлы .natstepfilter представляют собой XML-файлы со следующим синтаксисом:  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<StepFilter xmlns="http://schemas.microsoft.com/vstudio/debugger/natstepfilter/2010">  
    <Function>  
        <Name>FunctionSpec</Name>  
        <Action>StepAction</Action>  
    </Function>  
    <Function>  
        <Name>FunctionSpec</Name>  
        <Module>ModuleSpec</Module>  
        <Action>StepAction</Action>  
    </Function>  
</StepFilter>  
  
```  
  
|Элемент|Описание|  
|-------------|-----------------|  
|Компонент|Обязательный элемент. Указывает одну или несколько функций как функцию, не написанную пользователем.|  
|`Name`|Обязательный элемент. Регулярное выражение в формате ECMA-262, содержащее полное имя функции для сопоставления. Пример:<br /><br /> `<Name>MyNS::MyClass.*</Name>`<br /><br /> сообщает отладчику, что все методы в `MyNS::MyClass`, должны считаться кодом, не написанным пользователем. Сопоставление учитывает регистр.|  
|`Module`|Необязательный элемент. Регулярное выражение в формате ECMA-262, указывающее полный путь к модулю, содержащему функцию. Сопоставление не учитывает регистр.|  
|`Action`|Обязательный. Одно из следующих чувствительных к регистру значений:<br /><br /> -   `NoStepInto`— указывает отладчику выполнить проход по соответствующей функции.<br />-   `StepInto`— указывает отладчику выполнить шаг с заходом в соответствующие функции, переопределив все остальные `NoStepInto` для соответствующих функций.|  
  
### <a name="customize-call-stack-behavior"></a><a name="BKMK_CPP_Customize_call_stack_behavior"></a>Настройка поведения стека вызовов  
 Вы можете указать модули, файлы исходного кода и функции, которые необходимо рассматривать как код, не написанный пользователем, в стеках вызовов, указав их в файлах `*.natjmc`.  
  
- Чтобы указать код, не являющийся пользователем, для всех пользователей компьютера Visual Studio, добавьте в папку файл. натжмк `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers` .  
  
- Чтобы указать для отдельного пользователя код, не являющийся пользовательским, добавьте в папку файл. натжмк `%USERPROFILE%\My Documents\Visual Studio 2015\Visualizers` .  
  
  Файлы .natjmc представляют собой XML-файлы со следующим синтаксисом:  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<NonUserCode xmlns="http://schemas.microsoft.com/vstudio/debugger/jmc/2015">  
  
  <!-- Modules -->  
  <Module Name="ModuleSpec" />  
  <Module Name="ModuleSpec" Company="CompanyName" />  
  
  <!-- Files -->  
  <File Name="FileSpec"/>  
  
  <!-- Functions -->  
  <Function Name="FunctionSpec" />  
  <Function Name="FunctionSpec" Module ="ModuleSpec" />  
  <Function Name="FunctionSpec" Module ="ModuleSpec" ExceptionImplementation="true" />  
  
</NonUserCode>  
  
```  
  
 **Атрибуты элементов модуля**  
  
|Атрибут|Описание|  
|---------------|-----------------|  
|`Name`|Обязательный. Полный путь к модулю или модулям. Вы можете использовать следующие подстановочные знаки Windows: `?` (ни одного или один символ) и `*` (ни одного или несколько символов). Например,<br /><br /> `<Module Name=”?:\3rdParty\UtilLibs\*” />`<br /><br /> указывает отладчику, что необходимо рассматривать все модули в `\3rdParty\UtilLibs` на любом диске как внешний код.|  
|`Company`|Необязательный параметр. Название компании, публикующей модуль, внедренный в исполняемый файл. Этот атрибут можно использовать для устранения неоднозначности модулей.|  
  
 **Атрибуты элементов файла**  
  
|attribute|Описание|  
|---------------|-----------------|  
|`Name`|Обязательный элемент. Полный путь к файлу или файлам исходного кода, который необходимо считать внешним кодом. При задании пути можно использовать следующие подстановочные знаки Windows: `?` и `*`.|  
  
 **Атрибуты элементов функций**  
  
|Атрибут|Описание|  
|---------------|-----------------|  
|`Name`|Обязательный элемент. Полное имя функции, которую необходимо рассматривать как внешний код.|  
|`Module`|Необязательный параметр. Имя модуля или полный путь к модулю, содержащему эту функцию. Этот атрибут можно использовать для устранения неоднозначности функций с одинаковыми именами.|  
|`ExceptionImplementation`|Если задано значение `true`, стек вызовов отображает функцию, которая создала исключение, а не данную функцию.|  
  
## <a name="javascript-just-my-code"></a><a name="BKMK_JavaScript_Just_My_Code"></a> "Только мой код" в JavaScript  
  
### <a name="user-and-non-user-code"></a><a name="BKMK_JS_User_and_non_user_code"></a>Пользовательский и не пользовательский код  
 **Классификации кода**  
  
 Режим "Только мой код" в JavaScript управляет пошаговым выполнением и отображением стека вызовов путем распределения кода по одной из следующих классификаций.  
  
|Имя|Описание|
|-|-|  
|**MyCode**|Код пользователя, которым вы распоряжаетесь и управляете.|  
|**LibraryCode**|Код, не написанный пользователем, полученный из библиотек, которыми вы пользуетесь регулярно и от которых зависит правильная работа приложения (например, WinJS или jQuery).|  
|**UnrelatedCode**|Непользовательский код, который может быть выполнен в вашем приложении, но вы не владеете, и ваше приложение не полагается, чтобы оно правильно функционировало (например, с рекламным пакетом SDK, который отображает рекламу). В проектах Магазина Windows любой код, который загружается в приложение из URI HTTP или HTTPS, также считается UnrelatedCode.|  
  
 Отладчик JavaScript автоматически классифицирует эти типы кода:  
  
- Скрипт, который выполняется путем передачи строки в предоставляемую приложением `eval` функцию, классифицируется как **myCode**.  
  
- Скрипт, который выполняется путем передачи строки в конструктор, `Function` классифицируется как **LibraryCode**.  
  
- Скрипт, содержащийся в справочнике по платформе, например WinJS или Azure SDK, классифицируется как **LibraryCode**.  
  
- Скрипт, который выполняется путем передачи строки в `setTimeout` `setImmediate` функции, или, `setInterval` классифицируется как **UnrelatedCode**.  
  
- С помощью `%VSInstallDirectory%\JavaScript\JustMyCode\mycode.default.wwa.json` во всех JavaScript-проектах Visual Studio определяется код, написанный другими пользователями, и код, не написанный пользователями.  
  
  Можно изменить классификации по умолчанию и классифицировать определенные файлы и url-адреса путем добавления файла .json с именем `mycode.json` в корневую папку проекта.  
  
  Весь остальной код классифицируется как **MyCode**.  
  
### <a name="stepping-behavior"></a><a name="BKMK_JS_Stepping_behavior"></a>Пошаговое поведение  
  
- Если функция не является кодом пользователя (**myCode**), **шаг** с заходом (сочетание клавиш: F11) ведет себя как **Шаг с обходом** (клавиша F10).  
  
- Если шаг начинается в коде, не являющемся пользователем (**LibraryCode** или **UnrelatedCode**), пошаговое выполнение временно ведет себя так, как если бы только мой код не была включена. Сразу после возвращения в код пользователя пошаговое выполнение в режиме "Только мой код" возобновляется.  
  
- Если шаг в коде пользователя приводит к выходу из текущего контекста выполнения (например, при выполнении шага в последней строке обработчика событий), отладчик останавливается на следующей выполняемой строке кода пользователя. Например, если обратный вызов выполняется в коде **LibraryCode** , отладчик продолжит выполнение до следующей строки кода пользователя.  
  
- **Шаг с выходом** (сочетание клавиш: Shift + F11) останавливается на следующей строке пользовательского кода. Если код пользователя не обнаруживается, выполнение продолжается до завершения работы приложения, достижения точки останова или возникновения исключения.  
  
### <a name="breakpoint-behavior"></a><a name="BKMK_JS_Breakpoint_behavior"></a>Поведение точки останова  
  
- Точки останова, заданные в каком-либо коде, всегда соблюдаются независимо от классификации этого кода  
  
- Если ключевое слово `debugger` обнаруживается в:  
  
  - Код **LibraryCode** , отладчик всегда останавливается.  

  - Код **UnrelatedCode** , отладчик не останавливается.  
  
### <a name="exception-behavior"></a><a name="BKMK_JS_Exception_behavior"></a>Поведение исключения  
 Если необработанное исключение возникает в:  
  
- **MyCode** или **LibraryCode** код, отладчик всегда останавливается.  
  
- Код **UnrelatedCode** , а код **myCode** или **LibraryCode** — в стеке вызовов, отладчик прерывает работу.  
  
  Если для исключения в диалоговом окне исключения включены первые шансы исключения, а в коде **LibraryCode** или **UnrelatedCode** возникает исключение:  
  
- Если исключение обрабатывается, отладчик не останавливается.  
  
- Если исключение не обрабатывается, отладчик останавливается.  
  
### <a name="customize-just-my-code"></a><a name="BKMK_JS_Customize_Just_My_Code"></a>Настройка Только мой код  
 Чтобы разделить код пользователя и код, не написанный пользователем, для отдельного проекта Visual Studio, добавьте файл .json с именем `mycode.json` в корневую папку проекта.  
  
 Классификации выполняются в следующем порядке:  
  
1. Классификации по умолчанию  
  
2. Классификации в файле `%VSInstallDirectory%\JavaScript\JustMyCode\mycode.default.wwa.json`  
  
3. Классификации в файле `mycode. json` текущего проекта.  
  
   Каждый шаг классификации переопределяет предыдущие шаги. JSON-файлу не требуется выводить все пары "ключ-значение", а **myCode**, **библиотеки**и **несвязанные** значения могут быть пустыми массивами.  
  
   Файлы .json кода пользователя используют следующий синтаксис:  
  
```json  
{  
    "Eval" : "Classification",  
    "Function" : "Classification",  
    "ScriptBlock" : "Classification",  
    "MyCode" : [  
        "UrlOrFileSpec”,  
        . . .  
        "UrlOrFileSpec”  
    ],  
    "Libraries" : [  
        "UrlOrFileSpec”,  
        . .  
        "UrlOrFileSpec”  
    ],  
    "Unrelated" : [  
        "UrlOrFileSpec”,  
        . . .  
        "UrlOrFileSpec”  
    ]  
}  
  
```  
  
 **"Eval", "Function" и "ScriptBlock"**  
  
 Пары "ключ-значение" **eval**, **Function**и **ScriptBlock** определяют, как классифицированы динамически создаваемые коды.  
  
|Имя|Описание|
|-|-|  
|**Eval**|Скрипт, который выполняется путем передачи строки предоставленной хостом функции `eval`. По умолчанию скрипт Eval классифицируется как **MyCode**.|  
|**Function**|Скрипт, который выполняется путем передачи строки конструктору `Function`. По умолчанию скрипт Function классифицируется как **LibraryCode**.|  
|**ScriptBlock**|Скрипт, который выполняется путем передачи строки функциям `setTimeout`, `setImmediate` или `setInterval`. По умолчанию скрипт ScriptBlock классифицируется как **UnrelatedCode**.|  
  
 Можно изменить это значение на одно из следующих ключевых слов:  
  
- `MyCode`классифицирует скрипт как **myCode**.  
  
- `Library`классифицирует скрипт как **LibraryCode**.  
  
- `Unrelated`классифицирует скрипт как **UnrelatedCode**.  
  
  **"MyCode", "Libraries" и "Unrelated"**  
  
  Пары "ключ — **myCode**", " **библиотеки**" и " **несвязанные** значения" указывают URL-адреса или файлы, которые необходимо включить в классификацию.  
  
|Имя|Описание|
|-|-|  
|**MyCode**|Массив URL-адресов или файлов, которые классифицируются как **myCode**.|  
|**Библиотеки**|Массив URL-адресов или файлов, которые классифицируются как **LibraryCode**.|  
|**Unrelated**|Массив URL-адресов или файлов, которые классифицируются как **UnrelatedCode**.|  
  
 Строка URL-адреса или файла может содержать один или несколько символов `*`, соответствующих любому количеству символов. `*` равноценен регулярному выражению `.*`.
