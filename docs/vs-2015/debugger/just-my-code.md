---
title: Просто мой код Документы Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-debug
ms.topic: conceptual
dev_langs:
- FSharp
- VB
- CSharp
- C++
ms.assetid: 0f0df097-bbaf-46ad-9ad1-ef5f40435079
caps.latest.revision: 14
author: MikeJo5000
ms.author: mikejo
manager: jillfra
ms.openlocfilehash: efcabf9c7dc201f95515cd24bf3a14727f7149fe
ms.sourcegitcommit: 95f26af1da51d4c83ae78adcb7372b32364d8a2b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/13/2020
ms.locfileid: "79301395"
---
# <a name="just-my-code"></a>Только мой код
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Разработчики, использующие языки платформы .NET Framework, знакомы с функцией отладчика "Только мой код", которая выполняет системные, платформенные и другие не относящиеся к пользователю вызовы и сворачивает эти вызовы в окнах стека вызовов. Режим "Только мой код" теперь предусмотрен для языков C++ и JavaScript. В этом разделе описаны особенности использования режима "Только мой код" в платформе .NET Framework и проектах, изначально основанных на C++ и JavaScript.  
  
## <a name="enable-or-disable-just-my-code"></a><a name="BKMK_Enable_or_disable_Just_My_Code"></a> Включение или отключение режима "Только мой код"  
 Чтобы включить или отключить Just My Code, выберите **Параметры и Настройки** в меню **Debug.** В**общем** узло **Debugging** / выберите или очистите **Enable Just My Code.**  
  
 ![Флажок "Включить только мой код" в диалоговом окне "Параметры"](../debugger/media/dbg-justmycode-options.png "DBG_JustMyCode_Options")  
  
> [!NOTE]
> Настройка **Enable Just My Code** — это глобальная настройка, которая применяется ко всем проектам Visual Studio на всех языках.  
  
### <a name="override-call-stack-filtering"></a><a name="BKMK_Override_call_stack_filtering"></a>Переопределение фильтрации стека вызовов  
 На экранах стека вызовов, таких как окна стека вызовов и задач, режим "Только мой код" сворачивает код, не написанный пользователем, в кадр с аннотациями и подписью `[External Code]`. Для просмотра рухнувших кадров выберите **«Показать внешний код»** в контекстном меню отображения стеков вызовов.  
  
> [!NOTE]
> Настройка **внешнего кода Отображаемого** кода сохраняется для профиля текущего пользователя. Он применяется ко всем проектам на всех языках, открываемых этим пользователем.  
  
## <a name="net-framework-just-my-code"></a><a name="BKMK__NET_Framework_Just_My_Code"></a>.NET Framework Просто мой код  
  
### <a name="user-and-non-user-code"></a><a name="BKMK_NET_User_and_non_user_code"></a>Код пользователя и непользователя  
 Чтобы отличить пользовательский код от непользовательского, Just My Code рассматривает файлы символов (.pdb) и оптимизацию программ. Отладчик считает код, не написанным пользователем, если двоичный файл оптимизируется или если pdb-файл недоступен.  
  
 Три атрибута также влияют на то, какой код отладчик считаем кодом пользователя:  
  
- <xref:System.Diagnostics.DebuggerNonUserCodeAttribute> сообщает отладчику, что код, к которому он применяется, не является пользовательским.  
  
- <xref:System.Diagnostics.DebuggerHiddenAttribute> скрывает код от отладчика, даже если режим "Только мой код" включен.  
  
- <xref:System.Diagnostics.DebuggerStepThroughAttribute> указывает отладчику выполнить в пошаговом режим код, к которому он применяется, а не осуществлять шаг с заходом в этот код.  
  
  Весь остальной код считается пользовательским.  
  
### <a name="stepping-behavior"></a><a name="BKMK_NET_Stepping_behavior"></a>Шагая поведение  
 При **шаге в** (клавиатура ярлык: F11) не-пользователя код, отладчик шаги над кодом к следующему заявлению пользователя. Когда вы **выходите** (клавиатура: Shift и F11), отладчик переходит к следующей строке кода пользователя. Если код пользователя не обнаруживается, выполнение продолжается до завершения работы приложения, достижения точки останова или возникновения исключения.  
  
### <a name="breakpoint-behavior"></a><a name="BKMK_NET_Breakpoint_behavior"></a>Поведение точки разрыва  
 Когда просто мой код включен, вы можете выбрать **Break All** (клавиатура: Ctrl и Alt и Break) и остановить выполнение в месте, где нет кода пользователя для отображения. Когда это происходит, отображается окно "Нет исходного кода". Если затем выбирается команда "Шаг", отладчик переходит к следующей строке пользовательского кода.  
  
### <a name="exception-behavior"></a><a name="BKMK_NET_Exception_behavior"></a>Поведение исключений  
 При возникновении необработанного исключения в коде, написанном не пользователем, отладчик прерывается на той строке в коде пользователя, где было создано исключение.  
  
 Если для этого исключения включена первичная обработка исключения, строка кода пользователя выделяется зеленым цветом. В стеке вызовов отображается аннотированная рамка с надписью **«Внешний код».**  
  
## <a name="c-just-my-code"></a><a name="BKMK_C___Just_My_Code"></a> "Только мой код" в C++  
  
### <a name="user-and-non-user-code"></a><a name="BKMK_CPP_User_and_non_user_code"></a>Код пользователя и непользователя  
 Функция "Только мой код" в C++ отличается от функции "Только мой код" для платформы .NET Framework и JavaScript, поскольку поведение пошагового выполнения не зависит от поведения стека вызовов.  
  
 **Стеки вызовов**  
  
 По умолчанию отладчик считает эти функции кодом, не написанным пользователем, в окнах стека вызовов.  
  
- Функции с открытой исходной информацией в файле символов.  
  
- Функции, в которых файлы символов указывают, что исходный файл, соответствующий кадру стека, отсутствует.  
  
- Функции, определенные в файлах `*.natjmc`, находящихся в папке `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers`.  
  
  **Отладка по шагам**  
  
  По умолчанию только функции, определенные в файлах `*.natstepfilter` (папка `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers`), считаются кодом, не написанным пользователем.  
  
  Для настройки пошагового выполнения и поведения окна стека вызовов в `%USERPROFILE%\My Documents\Visual Studio 2015\Visualizers` вы можете создавать собственные `.natstepfilter` и `.natjmc`.  
  
### <a name="stepping-behavior"></a><a name="BKMK_CPP_Stepping_behavior"></a>Шагая поведение  
 Когда вы **шаг в** (клавиатура ярлык: F11) не-пользователя код из кода пользователя, отладчик шаги над кодом на следующую строку пользовательского кода. Когда вы **выходите** (клавиатура: Shift и F11), отладчик переходит к следующей строке кода пользователя. Если код пользователя не обнаруживается, выполнение продолжается до завершения работы приложения, достижения точки останова или возникновения исключения.  
  
 Если отладчик делает останов в коде, не написанном пользователем (например, если команда "Прервать все" останавливает в коде, не написанном пользователем), пошаговое выполнение продолжается в коде, не написанном пользователем.  
  
### <a name="exception-behavior"></a><a name="BKMK_CPP_Exception_behavior"></a>Поведение исключений  
 Если отладчик обнаруживает исключение, он останавливается на исключении независимо от того, находится ли оно в коде пользователя. **Необработанные** пользователями параметры в диалоговом поле **Исключений** игнорируются.  
  
### <a name="customize-stepping-behavior"></a><a name="BKMK_CPP_Customize_stepping_behavior"></a>Настройка ступенчатого поведения  
 Вы можете определить функции, для которых будут выполняться шаги с обходом, внеся их в файлы `*.natstepfilter` как код, не написанный пользователем.  
  
- Чтобы указать непользовательский код для всех пользователей машины Visual Studio, `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers` добавьте файл .natstepfilter в папку.  
  
- Чтобы указать непользовательский код для отдельного пользователя, добавьте файл .natstepfilter в `%USERPROFILE%\My Documents\Visual Studio 2015\Visualizers` папку.  
  
  Файлы .natstepfilter представляют собой XML-файлы со следующим синтаксисом:  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<StepFilter xmlns="http://schemas.microsoft.com/vstudio/debugger/natstepfilter/2010">  
    <Function>  
        <Name>FunctionSpec</Name>  
        <Action>StepAction</Action>  
    </Function>  
    <Function>  
        <Name>FunctionSpec</Name>  
        <Module>ModuleSpec</Module>  
        <Action>StepAction</Action>  
    </Function>  
</StepFilter>  
  
```  
  
|Элемент|Описание|  
|-------------|-----------------|  
|Компонент|Обязательный элемент. Указывает одну или несколько функций как функцию, не написанную пользователем.|  
|`Name`|Обязательный элемент. Регулярное выражение в формате ECMA-262, содержащее полное имя функции для сопоставления. Пример:<br /><br /> `<Name>MyNS::MyClass.*</Name>`<br /><br /> сообщает отладчику, что все методы в `MyNS::MyClass`, должны считаться кодом, не написанным пользователем. Сопоставление учитывает регистр.|  
|`Module`|Необязательный параметр. Регулярное выражение в формате ECMA-262, указывающее полный путь к модулю, содержащему функцию. Сопоставление не учитывает регистр.|  
|`Action`|Обязательный элемент. Одно из следующих чувствительных к регистру значений:<br /><br /> -   `NoStepInto`— говорит отладчику переступить через соответствующую функцию.<br />-   `StepInto`— говорит отладчику войти в соответствующие функции, переопределяя любые другие `NoStepInto` для соответствующих функций.|  
  
### <a name="customize-call-stack-behavior"></a><a name="BKMK_CPP_Customize_call_stack_behavior"></a>Настройка поведения стека вызовов  
 Вы можете указать модули, файлы исходного кода и функции, которые необходимо рассматривать как код, не написанный пользователем, в стеках вызовов, указав их в файлах `*.natjmc`.  
  
- Чтобы указать непользовательский код для всех пользователей машины Visual Studio, `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers` добавьте файл .natjmc в папку.  
  
- Чтобы указать непользовательский код для отдельного пользователя, добавьте файл .natjmc в `%USERPROFILE%\My Documents\Visual Studio 2015\Visualizers` папку.  
  
  Файлы .natjmc представляют собой XML-файлы со следующим синтаксисом:  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<NonUserCode xmlns="http://schemas.microsoft.com/vstudio/debugger/jmc/2015">  
  
  <!-- Modules -->  
  <Module Name="ModuleSpec" />  
  <Module Name="ModuleSpec" Company="CompanyName" />  
  
  <!-- Files -->  
  <File Name="FileSpec"/>  
  
  <!-- Functions -->  
  <Function Name="FunctionSpec" />  
  <Function Name="FunctionSpec" Module ="ModuleSpec" />  
  <Function Name="FunctionSpec" Module ="ModuleSpec" ExceptionImplementation="true" />  
  
</NonUserCode>  
  
```  
  
 **Атрибуты элементов модуля**  
  
|attribute|Описание|  
|---------------|-----------------|  
|`Name`|Обязательный элемент. Полный путь к модулю или модулям. Вы можете использовать следующие подстановочные знаки Windows: `?` (ни одного или один символ) и `*` (ни одного или несколько символов). Например,<br /><br /> `<Module Name=”?:\3rdParty\UtilLibs\*” />`<br /><br /> указывает отладчику, что необходимо рассматривать все модули в `\3rdParty\UtilLibs` на любом диске как внешний код.|  
|`Company`|Необязательный параметр. Название компании, публикующей модуль, внедренный в исполняемый файл. Этот атрибут можно использовать для устранения неоднозначности модулей.|  
  
 **Атрибуты элементов файла**  
  
|attribute|Описание|  
|---------------|-----------------|  
|`Name`|Обязательный элемент. Полный путь к файлу или файлам исходного кода, который необходимо считать внешним кодом. При задании пути можно использовать следующие подстановочные знаки Windows: `?` и `*`.|  
  
 **Атрибуты элементов функций**  
  
|attribute|Описание|  
|---------------|-----------------|  
|`Name`|Обязательный элемент. Полное имя функции, которую необходимо рассматривать как внешний код.|  
|`Module`|Необязательный параметр. Имя модуля или полный путь к модулю, содержащему эту функцию. Этот атрибут можно использовать для устранения неоднозначности функций с одинаковыми именами.|  
|`ExceptionImplementation`|Если задано значение `true`, стек вызовов отображает функцию, которая создала исключение, а не данную функцию.|  
  
## <a name="javascript-just-my-code"></a><a name="BKMK_JavaScript_Just_My_Code"></a> "Только мой код" в JavaScript  
  
### <a name="user-and-non-user-code"></a><a name="BKMK_JS_User_and_non_user_code"></a>Код пользователя и непользователя  
 **Классификации кода**  
  
 Режим "Только мой код" в JavaScript управляет пошаговым выполнением и отображением стека вызовов путем распределения кода по одной из следующих классификаций.  
  
|||  
|-|-|  
|**MyCode**|Код пользователя, которым вы распоряжаетесь и управляете.|  
|**LibraryCode**|Код, не написанный пользователем, полученный из библиотек, которыми вы пользуетесь регулярно и от которых зависит правильная работа приложения (например, WinJS или jQuery).|  
|**UnrelatedCode**|Непользовательский код, который может работать в приложении, но вы не владеете, и ваше приложение напрямую не полагается на него, чтобы функционировать правильно (например, рекламный SDK, который отображает рекламу). В проектах Магазина Windows любой код, который загружается в приложение из URI HTTP или HTTPS, также считается UnrelatedCode.|  
  
 Отладчик JavaScript автоматически классифицирует эти типы кода:  
  
- Сценарий, выполняемый путем передачи `eval` строки функции, предоставленной хостом, классифицируется как **MyCode.**  
  
- Сценарий, выполняемый путем `Function` передачи строки конструктору, классифицируется как **LibraryCode.**  
  
- Сценарий, содержащийся в рамочной ссылке, такой как WinJS или Azure SDK, классифицируется как **LibraryCode.**  
  
- Сценарий, который выполняется путем `setTimeout` `setImmediate`передачи `setInterval` строки в, или функции классифицируются как **UnrelatedCode.**  
  
- С помощью `%VSInstallDirectory%\JavaScript\JustMyCode\mycode.default.wwa.json` во всех JavaScript-проектах Visual Studio определяется код, написанный другими пользователями, и код, не написанный пользователями.  
  
  Можно изменить классификации по умолчанию и классифицировать определенные файлы и url-адреса путем добавления файла .json с именем `mycode.json` в корневую папку проекта.  
  
  Весь остальной код классифицируется как **MyCode**.  
  
### <a name="stepping-behavior"></a><a name="BKMK_JS_Stepping_behavior"></a>Шагая поведение  
  
- Если функция не является пользователем **(MyCode**) код, **Шаг в** (клавиатура ярлык: F11) ведет себя как **шаг за** (клавиатура: F10).  
  
- Если шаг начинается в коде непользователя **(LibraryCode** или **UnrelatedCode),** то шаг временно ведет себя так, как будто Just My Code не включен. Сразу после возвращения в код пользователя пошаговое выполнение в режиме "Только мой код" возобновляется.  
  
- Если шаг в коде пользователя приводит к выходу из текущего контекста выполнения (например, при выполнении шага в последней строке обработчика событий), отладчик останавливается на следующей выполняемой строке кода пользователя. Например, если обратный вызов выполняется в коде **Library,** отладчик продолжается до тех пор, пока не будет выполнена следующая строка пользовательского кода.  
  
- **Шаг из** (Клавиатура: Shift и F11) останавливается на следующей строке кода пользователя. Если код пользователя не обнаруживается, выполнение продолжается до завершения работы приложения, достижения точки останова или возникновения исключения.  
  
### <a name="breakpoint-behavior"></a><a name="BKMK_JS_Breakpoint_behavior"></a>Поведение точки разрыва  
  
- Точки останова, заданные в каком-либо коде, всегда соблюдаются независимо от классификации этого кода  
  
- Если ключевое слово `debugger` обнаруживается в:  
  
  - **Код Библиотечного кода,** отладчик всегда ломается.  

  - **Не связанный** код кода, отладчик не останавливается.  
  
### <a name="exception-behavior"></a><a name="BKMK_JS_Exception_behavior"></a>Поведение исключений  
 Если необработанное исключение возникает в:  
  
- **MyCode** или **код LibraryCode,** отладчик всегда ломается.  
  
- **Не связанный** код кода, а код **MyCode** или **Library Code** находится в стеке вызовов, отладчик ломается.  
  
  Если для исключения в диалоговом окне исключений включены исключения, и исключение выбрасывается в **Код -Код Библиотечного кода** или **несвязанный код:**  
  
- Если исключение обрабатывается, отладчик не останавливается.  
  
- Если исключение не обрабатывается, отладчик останавливается.  
  
### <a name="customize-just-my-code"></a><a name="BKMK_JS_Customize_Just_My_Code"></a>Настроить только мой код  
 Чтобы разделить код пользователя и код, не написанный пользователем, для отдельного проекта Visual Studio, добавьте файл .json с именем `mycode.json` в корневую папку проекта.  
  
 Классификации выполняются в следующем порядке:  
  
1. Классификации по умолчанию  
  
2. Классификации в файле `%VSInstallDirectory%\JavaScript\JustMyCode\mycode.default.wwa.json`  
  
3. Классификации в файле `mycode. json` текущего проекта.  
  
   Каждый шаг классификации переопределяет предыдущие шаги. Файлу .json не нужно перечислять все пары ключевых значений, а значения **MyCode,** **Библиотеки**и **несвязанные** значения могут быть пустыми массивами.  
  
   Файлы .json кода пользователя используют следующий синтаксис:  
  
```json  
{  
    "Eval" : "Classification",  
    "Function" : "Classification",  
    "ScriptBlock" : "Classification",  
    "MyCode" : [  
        "UrlOrFileSpec”,  
        . . .  
        "UrlOrFileSpec”  
    ],  
    "Libraries" : [  
        "UrlOrFileSpec”,  
        . .  
        "UrlOrFileSpec”  
    ],  
    "Unrelated" : [  
        "UrlOrFileSpec”,  
        . . .  
        "UrlOrFileSpec”  
    ]  
}  
  
```  
  
 **"Eval", "Function" и "ScriptBlock"**  
  
 Ключевые значения **Eval,** **Function**и **ScriptBlock** определяют, насколько динамично классифицирован код.  
  
|||  
|-|-|  
|**Eval**|Скрипт, который выполняется путем передачи строки предоставленной хостом функции `eval`. По умолчанию скрипт Eval классифицируется как **MyCode**.|  
|**Функция**|Скрипт, который выполняется путем передачи строки конструктору `Function`. По умолчанию скрипт Function классифицируется как **LibraryCode**.|  
|**ScriptBlock**|Скрипт, который выполняется путем передачи строки функциям `setTimeout`, `setImmediate` или `setInterval`. По умолчанию скрипт ScriptBlock классифицируется как **UnrelatedCode**.|  
  
 Можно изменить это значение на одно из следующих ключевых слов:  
  
- `MyCode`классифицирует скрипт как **MyCode**.  
  
- `Library`классифицирует скрипт как **LibraryCode**.  
  
- `Unrelated`классифицирует скрипт как **UnrelatedCode.**  
  
  **"MyCode", "Libraries" и "Unrelated"**  
  
  В парах **значений MyCode,** **Библиотеки**и **не связанные между ними** ключевых значений указываютurlые адреса или файлы, которые вы хотите включить в классификацию:  
  
|||  
|-|-|  
|**MyCode**|Массив URL-адресов или файлов, которые классифицируются как **MyCode**.|  
|**Библиотеки**|Массив URL-адресов или файлов, классифицируемых как **LibraryCode.**|  
|**Unrelated**|Массив URL-адресов или файлов, классифицируемых как **UnrelatedCode.**|  
  
 Строка URL-адреса или файла может содержать один или несколько символов `*`, соответствующих любому количеству символов. `*` равноценен регулярному выражению `.*`.
