---
title: Управление исключениями с помощью отладчика | Документация Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-debug
ms.topic: conceptual
f1_keywords:
- vs.debug.exceptions
- vs.debug.exceptions.find
dev_langs:
- FSharp
- VB
- CSharp
- C++
- JScript
helpviewer_keywords:
- run-time errors
- exception handling, during debugging
- errors [debugger]
- debugger, runtime errors
- On Error-style error handlers
- exceptions, Win32
- run-time errors, debugging
- Win32, exceptions
- run time, exceptions
- error handling
- debugging [Visual Studio], exception handling
- common language runtime, exceptions
- native run-time checks
- exceptions, debugging
ms.assetid: 43a77fa8-37d0-4c98-a334-0134dbca4ece
caps.latest.revision: 40
author: MikeJo5000
ms.author: mikejo
manager: jillfra
ms.openlocfilehash: be15b683a6e173d813ea13eaa0cc400a40e68206
ms.sourcegitcommit: 08fc78516f1107b83f46e2401888df4868bb1e40
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/15/2019
ms.locfileid: "65690510"
---
# <a name="managing-exceptions-with-the-debugger"></a>Управление исключениями с помощью отладчика
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Исключение указывает на состояние ошибки, возникающее при выполнении программы. Вы можете и должны предоставить обработчики, реагирующие на наиболее важные исключения. Важно знать, как настроить отладчик для останова исключений, которые требуется просмотреть.  
  
 При возникновении исключения отладчик записывает его сообщение в окно «Вывод». Он может прервать выполнение в следующих случаях:  
  
- если исключение возникает и не обрабатывается;  
  
- если отладчик настроен на прерывание выполнения сразу же после возникновения исключения, до вызова любого обработчика;  
  
- если задан параметр [Just My Code](../debugger/just-my-code.md)и отладчик настроен на прерывание по любому исключению, не обрабатываемому в коде пользователя.  
  
> [!NOTE]
> В ASP.NET существует обработчик исключений верхнего уровня, отображающий станицы ошибок в браузере. Он не прерывает выполнение до тех пор, пока не будет включен параметр **Только мой код** . Пример см. в разделе [Setting the debugger to continue on user-unhandled exceptions](../debugger/managing-exceptions-with-the-debugger.md#BKMK_UserUnhandled) ниже.  
  
> [!NOTE]
> В приложениях, написанных на Visual Basic, отладчик управляет всеми ошибками как исключениями, даже при использовании обработчиков ошибок типа On Error.  
  
## <a name="managing-exceptions-with-the-exception-settings-window"></a>Управление исключениями с помощью окна «Параметры исключений»  
 В окне **Параметры исключений** можно указать, какие исключения (или наборы исключений) приведут к прерыванию работы отладчика, и на этом этапе нужно сделать этот останов. Можно добавлять или удалять исключения или задавать исключения, при возникновении которых выполняется прерывание. Откройте это окно в открытом решении, последовательно выбрав **Отладка/Окна/Параметры исключений**.  
  
 Для поиска конкретных исключений можно воспользоваться окном **Поиск** на панели инструментов **Параметры исключений** или применить функцию поиска для фильтрации определенных пространств имен (например, **System.IO**).  
  
### <a name="setting-the-debugger-to-break-when-an-exception-is-thrown"></a>Настройка отладчика для прерывания выполнения при создании исключения  
 Отладчик может прервать выполнение приложения в точке возникновения исключения, предоставляя, таким образом, шанс проверки исключения еще до вызова обработчика.  
  
 В окне **Параметры исключений** разверните узел для категории исключений (например, **Исключения среды CLR**, то есть исключения .NET) и установите флажок для конкретного исключения в этой категории (например, **System.AccessViolationException**). Можно также выбрать всю категорию исключений.  
  
 ![Проверка AccessViolationException](../debugger/media/exceptionsettingscheckaccess.png "ExceptionSettingsCheckAccess")  
  
 При проверке данного исключения выполнение отладчика будет прерываться везде, где возникает это исключение независимо от того, обрабатывается оно или нет. На этом этапе исключение называется первым экземпляром исключения. Ниже приведено несколько примеров.  
  
1. В следующем консольном приложении C# метод Main создает исключение **AccessViolationException** внутри блока `try/catch` .  
  
   ```csharp  
   static void Main(string[] args)  
   {  
       try  
       {  
           throw new AccessViolationException();  
           Console.WriteLine("here");  
       }  
       catch (Exception e)  
       {  
           Console.WriteLine("caught exception");  
       }  
       Console.WriteLine("goodbye");  
   }  
   ```  
  
    Если исключение **AccessViolationException** отмечено в окне **Параметры исключений**, при выполнении этого кода в режиме отладчика произойдет останов на строке `throw` . После этого выполнение можно продолжить. В консоли должны отображаться обе строки.  
  
   ```  
   caught exception  
   goodbye  
   ```  
  
    Но в ней не отображается строка `here` .  
  
2. Консольное приложение C# ссылается на библиотеку классов с классом, который имеет два метода — метод, создающий исключение и обрабатывающий его, и второй метод, создающий то же исключение и не обрабатывающий его.  
  
   ```vb  
   public class Class1  
   {  
       public void ThrowHandledException()  
       {  
           try  
           {  
               throw new AccessViolationException();  
           }  
           catch (AccessViolationException ave)  
           {  
               Console.WriteLine("caught exception" + ave.Message);  
           }  
       }  
  
       public void ThrowUnhandledException()  
       {  
           throw new AccessViolationException();  
       }  
   }  
   ```  
  
    Далее приводится метод Main() консольного приложения.  
  
   ```csharp  
   static void Main(string[] args)  
   {  
       Class1 class1 = new Class1();  
       class1.ThrowHandledException();  
       class1.ThrowUnhandledException();  
   }  
   ```  
  
    Если исключение **AccessViolationException** отмечено в окне **Параметры исключений**, при выполнении этого кода в режиме отладчика произойдет останов на строке `throw` в методах **ThrowHandledException()** и **ThrowUnhandledException()**.  
  
   Чтобы восстановить заданные по умолчанию параметры исключений, нажмите кнопку **Восстановить** на панели инструментов.  
  
   ![Восстановить значения по умолчанию параметры исключения](../debugger/media/restoredefaultexceptions.png "RestoreDefaultExceptions")  
  
### <a name="BKMK_UserUnhandled"></a> Настройка отладчика для продолжения работы с исключениями не обработанное пользовательским кодом  
 При отладке кода .NET или JavaScript с параметром [Just My Code](../debugger/just-my-code.md)можно указать отладчику не прерывать выполнение при возникновении исключений, которые не обрабатываются в пользовательском коде, но обрабатываются в другом месте.  
  
1. В окне **Параметры исключений** откройте контекстное меню, щелкнув в окне правой кнопкой мыши, а затем затем выберите команду **Показать столбцы**. (Если параметр **Только мой код**отключен, данная команда не отображается.)  
  
2. Появится второй столбец с именем **Дополнительные действия**. В этом столбце отображается сообщение **Продолжать, если не обрабатывается в пользовательском коде** при конкретных исключениях. Это значит, что отладчик не прекращает выполнение, если исключение не обрабатывается в пользовательском коде, а обрабатывается во внешнем коде.  
  
3. Этот параметр можно изменить либо для конкретного исключения (выберите исключение, щелкните его правой кнопкой мыши и выберите или отмените выбор параметра **Продолжать, если не обрабатывается в пользовательском коде**), либо для всей категории исключений (например, все исключения CLR).  
  
   Например, веб-приложения ASP.NET обрабатывают исключения путем их преобразования в код состояния HTTP 500 ([Обработка исключений в API ASP.NET](http://www.asp.net/web-api/overview/error-handling/exception-handling)), что может затруднить определение источника исключения. В следующем примере пользовательский код вызывает метод `String.Format()` , который создает <xref:System.FormatException>. Выполнение прерывается следующим образом.  
  
   ![прерывается на пользователя&#45;создании не обработанного исключения](../debugger/media/exceptionunhandledbyuser.png "ExceptionUnhandledByUser")  
  
### <a name="adding-and-deleting-exceptions"></a>Добавление и удаление исключений  
 Исключения можно добавлять и удалять. Можно удалить любой тип исключения из любой категории. Для этого нужно выбрать исключение и нажать кнопку **Удалить** (знак «минус») на панели инструментов **Параметры исключений** либо щелкнуть исключение правой кнопкой мыши и в контекстном меню выбрать команду **Удалить** . Удаление исключения аналогично снятию флажка для исключения и заключается в том, что при возникновении исключения отладчик продолжит выполнение.  
  
 Чтобы добавить исключение, в окне **Параметры исключений** выберите одну из категории исключений (например, **Среда CLR**) и нажмите кнопку **Добавить** . Введите имя исключения (например, **System.UriTemplateMatchException**). Исключение будет добавлено в список (в алфавитном порядке) и будет автоматически выбрано.  
  
 Чтобы добавить исключение в категории «Исключения доступа к памяти GPU», «Исключения среды выполнения JavaScript» или «Исключения Win32», необходимо включить код ошибки, а также описание.  
  
> [!TIP]
> Проверьте правильность написания! В окне **Параметры исключений** не проверяется существование добавленного исключения. Поэтому при вводе **Sytem.UriTemplateMatchException**появится запись для этого исключения (а не для **System.UriTemplateMatchException**).  
  
 Параметры исключения сохраняются в файл SUO решения и, таким образом, применяются к конкретному решению. Параметры конкретного исключения нельзя повторно использовать в решениях. На этом этапе сохраняются только добавленные исключения. Удаленные исключения не сохраняются. Другими словами, можно добавить исключение, закрыть и повторно открыть решение — исключение будет находиться в нем по-прежнему. Однако при удалении исключения, закрытии и повторном открытии решения исключение появится снова.  
  
 В окне **Параметры исключений** поддерживаются универсальные типы исключений на C#, но не на Visual Basic. Чтобы делать останов при возникновении таких исключений, как `MyNamespace.GenericException<T>`, необходимо добавить исключение в виде **MyNamespace.GenericException'1**. То есть, если создано следующее исключение:  
  
```csharp  
public class GenericException<T> : Exception  
{  
    public GenericException() : base("This is a generic exception.")  
    {  
    }  
}  
```  
  
 Исключение можно добавить в окно **Параметры исключений** следующим образом.  
  
 ![Добавление общего исключения](../debugger/media/addgenericexception.png "AddGenericException")  
  
## <a name="see-also"></a>См. также  
 [Возобновление выполнения после исключения](../debugger/continuing-execution-after-an-exception.md)   
 [Практическое руководство. Анализ системного кода после исключения](../debugger/how-to-examine-system-code-after-an-exception.md)   
 [Практическое руководство. Настройка проверок во время выполнения машинного кода](../debugger/how-to-use-native-run-time-checks.md)   
 [Использование среды выполнения проверки без библиотеки времени выполнения C](../debugger/using-run-time-checks-without-the-c-run-time-library.md)   
 [Помощник по исключениям](https://msdn.microsoft.com/library/992892ac-9d52-44cc-bf09-b44bfc5befeb)   
 [Основы отладки](../debugger/debugger-basics.md)
