---
title: Использование ЦП | Документы Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-debug
ms.topic: conceptual
ms.assetid: 7501a20d-04a1-480f-a69c-201524aa709d
caps.latest.revision: 12
author: MikeJo5000
ms.author: mikejo
manager: jillfra
ms.openlocfilehash: 1a6160fb42ab3648eae9a7ea416e244b5cfabc99
ms.sourcegitcommit: 08fc78516f1107b83f46e2401888df4868bb1e40
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/15/2019
ms.locfileid: "65700927"
---
# <a name="cpu-usage"></a>Использование ЦП
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Если вам нужно проанализировать проблемы с производительностью в своем приложении, следует сначала понять, как оно использует ЦП. Средство **Использование ЦП** показывает, где ЦП тратит время при выполнении кода Visual C++, Visual C#/Visual Basic и JavaScript.  
  
 Начиная с версии Visual Studio 2015 с обновлением 1 можно просматривать разбивку загрузки ЦП по функциям, не выходя из отладчика. Во время отладки можно включать и выключать профилирование ЦП и просматривать результаты при остановке выполнения, например в точке останова. Дополнительные сведения см. в разделе [Профилирование ЦП в отладчике в Visual Studio 2015](http://blogs.msdn.com/b/visualstudioalm/archive/2015/10/29/profile-your-cpu-in-the-debugger-in-visual-studio-2015.aspx).  
  
 Пошаговое руководство, которое позволяет анализировать производительность приложения Магазина Windows, см. в разделе [Анализ использования ЦП в приложениях Магазина](https://msdn.microsoft.com/library/windows/apps/dn641982.aspx).  
  
 Концентратор производительности и диагностики предоставляет различные возможности по запуску сеансов диагностики и управления ими. Например, средство **Загрузка ЦП** можно запустить на локальном и удаленном компьютерах, в имитаторе или эмуляторе. Можно анализировать производительность открытого в Visual Studio проекта, присоединившись к выполняемому приложению, либо запустить приложение, которое устанавливается из Магазина Windows. Дополнительные сведения см. в разделе [запуск средств профилирования без отладки](https://msdn.microsoft.com/library/e97ce1a4-62d6-4b8e-a2f7-61576437ff01)  
  
## <a name="BKMK_Collect_CPU_usage_data"></a> Сбор данных о загрузке ЦП  
  
1. В Visual Studio установите для решения конфигурацию **Выпуск** и выберите цель развертывания.  
  
    ![Выбор выпуска и локального компьютера](../profiling/media/cpuuse-selectreleaselocalmachine.png "CPUUSE_SelectReleaseLocalMachine")  
  
   - Запуск приложения в режиме **Выпуск** обеспечивает более качественное представление фактической производительности приложения.  
  
   - Запуск приложения на локальном компьютере лучше отражает выполнение установленного приложения.  
  
   - При сборе данных из удаленного устройства запускайте приложение непосредственно на устройстве, не используя подключение к удаленному рабочему столу.  
  
   - Для приложений Windows Phone сбор данных непосредственно из **Устройства** позволяет получить наиболее точные данные.  
  
2. В меню **Отладка** выберите пункт **Профилировщик производительности...**  
  
3. Нажмите **Использование ЦП** и **Запуск**.  
  
    ![Выбор загрузки ЦП](../profiling/media/cpuuse-lib-choosecpuusage.png "CPUUSE_LIB_ChooseCpuUsage")  
  
4. После запуска приложения нажмите кнопку **Get Max Number**(Получить максимальное количество). После вывода результата подождите примерно одну секунду, а затем нажмите **Get Max Number Async**(Получить максимальное количество асинхронно). Перерыв между нажатиями кнопок облегчает нахождение в диагностическом отчете информации о подпрограммах обработки нажатия кнопок.  
  
5. После вывода второй строки выберите **Остановка сбора** в разделе "Производительность и диагностика".  
  
   ![Остановка сбора данных CpuUsage](../profiling/media/cpu-use-wt-stopcollection.png "CPU_USE_WT_StopCollection")  
  
   Инструмент "Использование ЦП" анализирует данные и отображает отчет.  
  
   ![Отчет CpuUsage](../profiling/media/cpu-use-wt-report.png "CPU_USE_WT_Report")  
  
## <a name="analyze-the-cpu-usage-report"></a>Анализ отчета об использовании ЦП  
  
### <a name="BKMK_The_CPU_Usage_call_tree"></a> Дерево вызовов средства "Использование ЦП"  
 Чтобы понять сведения в дереве вызовов, повторно выберите сегмент `GetMaxNumberButton_Click` и просмотрите дерево вызовов.  
  
#### <a name="BKMK_Call_tree_structure"></a> Структура дерева вызовов  
 ![Дерево вызовов GetMaxNumberButton_Click](../profiling/media/cpu-use-wt-getmaxnumbercalltree-annotated.png "CPU_USE_WT_GetMaxNumberCallTree_annotated")  
  
|||  
|-|-|  
|![Шаг 1](../profiling/media/procguid-1.png "ProcGuid_1")|Узел верхнего уровня в деревьях вызовов для использования ЦП представляет собой псевдоузел|  
|![Шаг 2](../profiling/media/procguid-2.png "ProcGuid_2")|В большинстве приложений при отключенном параметре **Показать внешний код** узлом второго уровня является узел **[Внешний код]** , который содержит код системы и инфраструктуры, запускающий и останавливающий приложение, отрисовывающий пользовательский интерфейс, управляющий планированием потоков и предоставляющий приложению другие низкоуровневые службы.|  
|![Шаг 3](../profiling/media/procguid-3.png "ProcGuid_3")|Дочерними элементами узла второго уровня являются методы пользовательского кода и асинхронные подпрограммы, которые вызываются или создаются кодом системы и инфраструктуры на втором уровне.|  
|![Шаг 4](../profiling/media/procguid-4.png "ProcGuid_4")|Дочерние узлы метода содержат данные только для вызова родительского метода. Если параметр **Показать внешний код** отключен, методы приложения также могут содержать узел **[Внешний код]** .|  
  
#### <a name="BKMK_External_Code"></a> Внешний код  
 Внешний код — это функции в компонентах системы и платформы, которые исполняются вашим кодом. Внешний код включает функции, которые запускают и останавливают приложение, отрисовывают пользовательский интерфейс, управляют потоками и предоставляют приложению другие низкоуровневые службы. В большинстве случаев внешний код вас интересовать не будет, поэтому дерево вызовов средства "Использование ЦП" собирает внешние функции пользовательского метода в один узел **[Внешний код]** .  
  
 Если вы захотите посмотреть пути к вызовам внешнего кода, выберите **Показать внешний код** в списке **Представление фильтра** и выберите **Применить**.  
  
 ![Выбор "Представление фильтра", а затем "Показать внешний код"](../profiling/media/cpu-use-wt-filterview.png "CPU_USE_WT_FilterView")  
  
 Помните о том, что многие цепочки вызовов имеют глубокий уровень вложенности, поэтому ширина столбца "Имя функции" может превышать ширину многих мониторов. В этом случае имена функций отображаются в виде **[…]**:  
  
 ![Вложенный внешний код в дереве вызовов](../profiling/media/cpu-use-wt-showexternalcodetoowide.png "CPU_USE_WT_ShowExternalCodeTooWide")  
  
 Используйте поле поиска, чтобы найти требуемый узел, а затем воспользуйтесь горизонтальной полосой прокрутки для отображения данных в представлении:  
  
 ![Поиск вложенного внешнего кода](../profiling/media/cpu-use-wt-showexternalcodetoowide-found.png "CPU_USE_WT_ShowExternalCodeTooWide_Found")  
  
### <a name="BKMK_Call_tree_data_columns"></a> Столбцы данных дерева вызовов  
  
|||  
|-|-|  
|**Общая активность ЦП (%)**|![Уравнение для данных процента общей активности](../profiling/media/cpu-use-wt-totalpercentequation.png "CPU_USE_WT_TotalPercentEquation")<br /><br /> Процент активности ЦП приложения за выбранный период времени, потраченной на вызовы функции и функций, которые вызывала данная функция. Обратите внимание, что это отличается от графика временной шкалы **Использование ЦП** , который сравнивает общую активность приложения за период времени с общей доступной емкостью ЦП.|  
|**Собственная активность ЦП (%)**|![Уравнение для процента собственной активности](../profiling/media/cpu-use-wt-selflpercentequation.png "CPU_USE_WT_SelflPercentEquation")<br /><br /> Процент активности ЦП приложения за выбранный период времени, потраченной на вызовы функции, исключая выполнение функций, которые вызывала данная функция.|  
|**Общее время ЦП (мс)**|Время в миллисекундах, затраченное на вызовы функции в выбранном временном интервале, и функций, которые были вызваны этой функцией.|  
|**Собственное время ЦП (мс)**|Время в миллисекундах, затраченное на вызовы функции в выбранном временном интервале, и функций, которые были вызваны этой функцией.|  
|**Модуль**|Имя модуля, содержащего функцию, или количество модулей, содержащих функции в узле [Внешний код].|  
  
### <a name="BKMK_Asynchronous_functions_in_the_CPU_Usage_call_tree"></a> Асинхронные функции в дереве вызовов средства "Использование ЦП"  
 Если компилятор обнаруживает асинхронный метод, он создает скрытый класс для контроля выполнения этого метода. По существу, класс представляет собой конечный автомат, содержащий список функций, созданных компилятором, которые асинхронно вызывают операции исходного метода. Также класс включает обратные вызовы, планировщик и итераторы, необходимые для его правильной работы. При вызове исходного метода родительским методом среда выполнения удаляет метод из контекста выполнения родительского метода и выполняет методы скрытого класса в контексте кода системы и инфраструктуры, который управляет выполнением приложения. Асинхронные методы часто, но не всегда выполняются в отдельном потоке (или в нескольких потоках). Этот код отображается в дереве вызовов средства "Использование ЦП" в виде дочерних элементов узла **[Внешний код]** сразу под верхним узлом дерева.  
  
 Чтобы увидеть его в нашем примере, снова выберите период `GetMaxNumberAsyncButton_Click` на временной шкале.  
  
 ![Выбор отчета GetMaxNumberAsyncButton_Click](../profiling/media/cpu-use-wt-getmaxnumberasync-selected.png "CPU_USE_WT_GetMaxNumberAsync_Selected")  
  
 Два первых узла в узле **[Внешний код]** представляют собой созданные компилятором методы класса конечного автомата. Третий узел является вызовом исходного метода. Развернув созданные методы, можно понять, как это работает.  
  
 ![Развернутое дерево вызовов GetMaxNumberAsyncButton_Click](../profiling/media/cpu-use-wt-getmaxnumberasync-expandedcalltree.png "CPU_USE_WT_GetMaxNumberAsync_ExpandedCallTree")  
  
- `MainPage::GetMaxNumberAsyncButton_Click` выполняет немного функций: управляет списком значений задач, вычисляет максимальное значение на основе результатов и отображает выходные данные.  
  
- `MainPage+<GetMaxNumberAsyncButton_Click>d__3::MoveNext` показывает время ЦП, затраченное на планирование и запуск 48 задач, которые являются оболочкой вызова `GetNumberAsync`.  
  
- `MainPage::<GetNumberAsync>b__b` показывает время ЦП, затраченное на выполнение задач, которые вызывают `GetNumber`.
