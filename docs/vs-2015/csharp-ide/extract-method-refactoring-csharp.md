---
title: Рефакторинг для извлечения метода (C#) | Документация Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-general
ms.topic: reference
f1_keywords:
- vs.csharp.refactoring.extractmethod
dev_langs:
- CSharp
helpviewer_keywords:
- refactoring [C#], Extract Method
- Extract Method refactoring operation [C#]
ms.assetid: eeba11df-a815-4bec-9c21-8a831891b783
caps.latest.revision: 29
author: jillre
ms.author: jillfra
manager: jillfra
ms.openlocfilehash: 6e6d5e7913a7433fd4b30da490f33dd614c3e2b2
ms.sourcegitcommit: a8e8f4bd5d508da34bbe9f2d4d9fa94da0539de0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/19/2019
ms.locfileid: "72667546"
---
# <a name="extract-method-refactoring-c"></a>Рефакторинг для извлечения метода (C#)
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

**Метод Extract** — это операция рефакторинга, которая предоставляет простой способ создания нового метода из фрагмента кода в существующем элементе.

 С помощью **метода Extract**можно создать новый метод, извлекая выделенный фрагмент кода из блока кода существующего элемента. Новый, извлеченный метод содержит выбранный код, а выбранный код в существующем элементе заменяется вызовом нового метода. Включение фрагмента кода в собственный метод позволяет быстро и точно реорганизовать код для более эффективного использования и удобочитаемости.

 **Метод Extract** имеет следующие преимущества:

- Способствует оптимальным методикам программирования, подчеркивая дискретные многократно используемые методы.

- Способствует созданию собственного кода с помощью хорошей организации.

     При использовании описательных имен методы высокого уровня могут читать больше, как ряд комментариев.

- Способствует созданию более детализированных методов для упрощения переопределения.

- Сокращает дублирование кода.

### <a name="to-use-extract-method"></a>Использование метода Extract

1. Создайте консольное приложение с именем `ExtractMethod`, а затем замените `Program` на следующий пример кода.

    ```csharp
    class A
    {
        const double PI = 3.141592;

        double CalculatePaintNeeded(double paintPerUnit, double radius)
        {
            // Select any of the following:
            // 1. The entire next line of code.
            // 2. The right-hand side of the next line of code.
            // 3. Just "PI *" of the right-hand side of the next line
            //    of code (to see the prompt for selection expansion).
            // 4.  All code within the method body.
            // ...Then invoke Extract Method.

            double area = PI * radius * radius;

            return area / paintPerUnit;
        }
    }
    ```

2. Выберите фрагмент кода, который необходимо извлечь:

    ```csharp
    double area = PI * radius * radius;
    ```

3. В меню **Рефакторинг** выберите пункт **извлечь метод**.

     Откроется диалоговое окно **Извлечение метода** .

     Кроме того, можно также ввести сочетание клавиш CTRL + R, M, чтобы открыть диалоговое окно **Извлечение метода** .

     Можно также щелкнуть выделенный код правой кнопкой мыши, наведите указатель на пункт **Рефакторинг**и выберите пункт **извлечь метод** , чтобы открыть диалоговое окно **Извлечение метода** .

4. Укажите имя нового метода, например `CircleArea`, в поле **имя нового метода** .

     Предварительный просмотр сигнатуры нового метода отображается в разделе **сигнатура метода предварительной версии**.

5. Нажмите кнопку **ОК**.

## <a name="remarks"></a>Заметки
 При использовании команды **извлечения метода** новый метод вставляется после исходного элемента в том же классе.

## <a name="partial-types"></a>Разделяемые типы
 Если класс является частичным типом, **метод Extract** создает новый метод сразу после исходного элемента. **Метод Extract** определяет сигнатуру нового метода, создавая статический метод, когда код в новом методе не ссылается на данные экземпляра.

## <a name="generic-type-parameters"></a>Параметры универсального типа
 При извлечении метода с неограниченным параметром универсального типа созданный код не будет добавлять модификатор `ref` к этому параметру, если ему не присвоено значение. Если извлеченный метод будет поддерживать ссылочные типы в качестве аргумента универсального типа, то следует вручную добавить модификатор `ref` к параметру в сигнатуре метода.

## <a name="anonymous-methods"></a>Анонимные методы
 При попытке извлечь часть анонимного метода, включающего ссылку на локальную переменную, которая объявлена или ссылается вне анонимного метода, Visual Studio выдаст предупреждение о возможных семантических изменениях.

 Если анонимный метод использует значение локальной переменной, значение получается в момент выполнения анонимного метода. При извлечении анонимного метода в другой метод значение локальной переменной получается в момент вызова извлеченного метода.

 В следующем примере демонстрируется это семантическое изменение. При выполнении этого кода на консоль будет выведено **11** . Если вы используете **метод Extract** для извлечения области кода, помеченной комментариями кода, в собственный метод, а затем выполняете код рефакторинга, то **10** будет выводиться на консоль.

```csharp
class Program
{
    delegate void D();
    D d;
    static void Main(string[] args)
    {
        Program p = new Program();
        int i = 10;
        /*begin extraction*/
            p.d = delegate { Console.WriteLine(i++); };
        /*end extraction*/
        i++;
        p.d();
    }
}
```

 Чтобы обойти эту ситуацию, необходимо сделать локальные переменные, используемые в полях анонимного метода класса.

## <a name="see-also"></a>См. также раздел
 [Рефакторинг (C#)](../csharp-ide/refactoring-csharp.md)