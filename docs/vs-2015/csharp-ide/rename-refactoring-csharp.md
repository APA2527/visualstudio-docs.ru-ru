---
title: Переименовать рефакторинг (C#) | Документация Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-general
ms.topic: reference
f1_keywords:
- vs.csharp.refactoring.rename
dev_langs:
- CSharp
helpviewer_keywords:
- refactoring [C#], Rename
- Rename refactoring [C#]
ms.assetid: 268942fc-b142-4dfa-8d90-bedd548c2e4f
caps.latest.revision: 45
author: gewarren
ms.author: gewarren
manager: jillfra
ms.openlocfilehash: 3f1c31d858fbe7a5183456bfc7fcc1e602d4e051
ms.sourcegitcommit: 08fc78516f1107b83f46e2401888df4868bb1e40
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/15/2019
ms.locfileid: "65686039"
---
# <a name="rename-refactoring-c"></a>Переименовать рефакторинг (C#)
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

**Переименовать** функция оптимизации в среде разработки Visual Studio (IDE), который предоставляет простой способ переименовывать идентификаторы для символов кода, таких как поля, локальные переменные, методы, пространства имен, свойств и типов. **Переименовать** может использоваться для изменения имен в комментариях и строках, так и для изменения объявлений и вызовов идентификаторов.  
  
> [!NOTE]
> При использовании системы управления версиями для Visual Studio, получите последнюю версию источников, прежде чем пытаться выполнить рефакторинг для переименования.  
  
 Рефакторинг для переименования можно найти следующие функции Visual Studio:  
  
|Функция|Поведение оптимизации в интегрированной среде разработки|  
|-------------|----------------------------------------|  
|Редактор кода|В редакторе кода, рефакторинг для переименования доступен при позиционирования курсора на символах кода определенного типа. Когда курсор находится в этой позиции, можно вызывать **Переименовать** команду, нажав сочетание клавиш (CTRL + R, CTRL + R), или выбрав **Переименовать** из смарт-тег, контекстное меню или  **Рефакторинг** меню.|  
|Представление классов|При выборе идентификатора в представлении классов рефакторинг для переименования доступна в контекстном меню и **рефакторинг** меню.|  
|Обозреватель объектов|При выборе идентификатора в обозревателе объектов, рефакторинг для переименования доступна только из **рефакторинг** меню.|  
|Сетки свойств в конструкторе Windows Forms|В **сетки свойств** части конструктора Windows Forms, изменение имени элемента управления будет инициировать операцию переименования для этого элемента управления. **Переименовать** диалоговое окно не будет отображаться.|  
|обозреватель решений|В **обозревателе решений**, **Переименовать** команда доступна в контекстном меню. Если выбранный исходный файл содержит класс, имя которого совпадает с именем файла, эта команда используется для одновременного переименуйте исходный файл и выполнить рефакторинг для переименования.<br /><br /> Например при создании приложения на базе Windows по умолчанию и затем переименуйте файл Form1.cs в TestForm.cs, имя исходного файла Form1.cs изменится на TestForm.cs и классу Form1, и все ссылки на что класс будет называться TestForm. **Примечание.**  **Отменить** команда (CTRL + Z) только отменить переименование рефакторинга в коде и будет не изменяется имя файла обратно в исходное имя. <br /><br /> Если выбранный исходный файл не содержит класса, имя которого совпадает с именем файла, **Переименовать** в команду **обозревателе решений** будет только переименуйте исходный файл и не будет выполняться переименования Рефакторинг.|  
  
## <a name="rename-operations"></a>Операции переименования  
 При выполнении **Переименовать**, подсистема оптимизации выполняет определенный операции переименования для каждого символа кода, как описано в следующей таблице.  
  
|Символ кода|Операции переименования|  
|-----------------|----------------------|  
|Поле|Изменяет объявление и случаи использования поля на новое имя.|  
|Локальная переменная|Изменяет объявления и использования переменной на новое имя.|  
|Метод|Изменяет имя метода и все ссылки на этот метод на новое имя. **Примечание.**  При переименовании метода расширения операция переименования распространяется на все экземпляры метода, которые находятся в области, независимо от того, используется ли метод расширения как статический метод или метод экземпляра. Дополнительные сведения см. в разделе [Методы расширения](https://msdn.microsoft.com/library/175ce3ff-9bbf-4e64-8421-faeb81a0bb51).|  
|Пространство имен|Изменяет имя пространства имен на новое имя в объявлении всех `using` инструкции и полные имена. **Примечание.**  При переименовании пространства имен, [!INCLUDE[vsprvs](../includes/vsprvs-md.md)] также обновляет **пространство имен по умолчанию** свойство **приложения** странице **конструктор проектов**. Это свойство невозможно сбросить, выбрав **отменить** из **изменить** меню. Чтобы сбросить **пространство имен по умолчанию** значение свойства, необходимо изменить свойство в **конструктор проектов**. Дополнительные сведения см. в разделе [страницы приложения](../ide/reference/application-page-project-designer-csharp.md).|  
|Свойство|Изменяет объявления и использования свойства на новое имя.|  
|Тип|Изменяет все объявления и все случаи использования типа на новое имя, включая конструкторы и деструкторы. Для разделяемых типов операция переименования распространяется на все части.|  
  
#### <a name="to-rename-an-identifier"></a>Чтобы переименовать идентификатор  
  
1. Создайте консольное приложение с именем `RenameIdentifier`, а затем замените `Program` на следующий пример кода.  
  
    ```csharp  
    class ProtoClassA  
    {  
        // Invoke on 'MethodB'.  
        public void MethodB(int i, bool b) { }  
    }  
  
    class ProtoClassC  
    {  
        void D()  
        {  
            ProtoClassA MyClassA = new ProtoClassA();  
  
            // Invoke on 'MethodB'.  
            MyClassA.MethodB(0, false);  
        }  
    }  
    ```  
  
2. Поместите курсор на `MethodB`, в объявлении метода или вызов метода.  
  
3. Из **рефакторинг** меню, выберите **Переименовать**. **Переименовать** откроется диалоговое окно.  
  
     Щелкните правой кнопкой мыши курсор, пункты **рефакторинг** контекстное меню, и затем **Переименовать** для отображения **Переименовать** диалоговое окно.  
  
4. В **новое имя** введите `MethodC`.  
  
5. Выберите **поиска в комментариях** "флажок".  
  
6. Нажмите кнопку **ОК**.  
  
7. В **Просмотр изменений** диалоговом окне щелкните **применить**.  
  
#### <a name="to-rename-an-identifier-using-smart-tags"></a>Чтобы переименовать идентификатор с помощью смарт-тегов  
  
1. Создайте консольное приложение с именем `RenameIdentifier`, а затем замените `Program` на следующий пример кода.  
  
    ```csharp  
    class ProtoClassA  
    {  
        // Invoke on 'MethodB'.  
        public void MethodB(int i, bool b) { }  
    }  
  
    class ProtoClassC  
    {  
        void D()  
        {  
            ProtoClassA MyClassA = new ProtoClassA();  
  
            // Invoke on 'MethodB'.  
            MyClassA.MethodB(0, false);  
        }  
    }  
    ```  
  
2. В объявлении `MethodB`введите или backspace идентификатор метода. Смарт-тег появится под идентификатором.  
  
    > [!NOTE]
    > Вызвать можно только с помощью смарт-тегов в объявлении идентификатора рефакторинг для переименования.  
  
3. Введите сочетание клавиш SHIFT + ALT + F10 и нажмите клавишу Стрелка вниз, чтобы открыть меню смарт-тега.  
  
     -или-  
  
     Наведите указатель мыши на строке смарт-тег для отображения смарт-тега. Затем наведите указатель мыши на смарт-тег и нажмите кнопку со стрелкой вниз, чтобы открыть меню смарт-тега.  
  
4. Выберите **переименовать "\<identifer1 >" для "\<идентификатор2 >"** пункт меню, чтобы вызвать переименованию без предварительного просмотра изменений в коде. Все ссылки на  **\<identifer1 >** будет автоматически обновлено до  **\<идентификатор2 >**.  
  
     -или-  
  
     Выберите **переименование с предварительной версией** пункт меню, чтобы вызвать операцию рефакторинга rename с предварительным просмотром изменений в коде. **Просмотр изменений** появится диалоговое окно.  
  
## <a name="remarks"></a>Примечания  
  
## <a name="renaming-implemented-or-overridden-members"></a>Переименование реализации или переопределенные члены  
 Когда вы **Переименовать** элемент, который реализует/переопределения или реализации/переопределяется членами других типов, [!INCLUDE[vsprvs](../includes/vsprvs-md.md)] отображает диалоговое окно, которое говорит, операции переименования приведет к каскадные обновления. Если щелкнуть **Продолжить**, рефакторинга рекурсивно ядра находит и переименование всех членов базового и производных типов, имеющих реализует/переопределений связи с членом, который требуется переименовать.  
  
 В следующем примере кода содержит члены со связями реализует/переопределений.  
  
 [!code-csharp[CsUsingCsIDERefactor#1](../snippets/csharp/VS_Snippets_VBCSharp/CsUsingCsIDERefactor/CS/Class1.cs#1)]  
  
 В предыдущем примере переименование `C.Method()` также переименовывает `Ibase.Method()` поскольку `C.Method()` реализует `Ibase.Method()`. Затем рекурсивно ядра refactor видит, что `Ibase.Method()` реализуется `Derived.Method()` и переименовывает `Derived.Method()`. Подсистема рефакторинга не приводит к переименованию `Base.Method()`, так как `Derived.Method()` не переопределяет `Base.Method()`. Подсистема оптимизации останавливается, если у вас есть **переименовать перегрузки** возврата **Переименовать** диалоговое окно.  
  
 Если **переименовать перегрузки** установлен, подсистема рефакторинга переименовывает `Derived.Method(int i)` так, как он перегружает `Derived.Method()`, `Base.Method(int i)` так, как он переопределяется атрибутом `Derived.Method(int i)`, и `Base.Method()` так как это перегрузка `Base.Method(int i)`.  
  
> [!NOTE]
> При переименовании членом, который был определен в связанной сборке, диалоговое окно объясняет, что переименование приведет к ошибкам построения.  
  
## <a name="renaming-properties-of-anonymous-types"></a>Переименование свойств анонимных типов  
 При изменении имени свойства в анонимные типы, операции переименования распространяется на свойства других анонимных типов, которые имеют одинаковые свойства. Следующие примеры иллюстрируют это поведение.  
  
```csharp  
var a = new { ID = 1};  
var b = new { ID = 2};  
```  
  
 В приведенном выше коде переименование `ID` приведет к изменению `ID` в обе инструкции так, как они имеют один и тот же анонимный тип.  
  
```csharp  
var companyIDs =  
    from c in companylist  
    select new { ID = c.ID, Name = c.Name};  
  
var orderIDs =  
    from o in orderlist  
    select new { ID = o.ID, Item = o.Name};  
```  
  
 В приведенном выше коде переименование `ID` переименовывает только один экземпляр `ID` поскольку `companyIDs` и `orderIDs` не имеют те же свойства.  
  
## <a name="see-also"></a>См. также  
 [Рефакторинг (C#)](../csharp-ide/refactoring-csharp.md)   
 [Анонимные типы](https://msdn.microsoft.com/library/59c9d7a4-3b0e-475e-b620-0ab86c088e9b)