---
title: Классы Visual C++ в конструкторе классов | Microsoft Docs
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-general
ms.topic: conceptual
f1_keywords:
- vs.classdesigner.inheritancelinelabel
helpviewer_keywords:
- Class Designer [Visual Studio], classes
ms.assetid: 75e56f8c-11ef-42a3-b7ec-3d2cf25c581b
caps.latest.revision: 23
author: jillre
ms.author: jillfra
manager: jillfra
ms.openlocfilehash: 4fc312736508a11d43cadf789b08aae77c528d35
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/02/2020
ms.locfileid: "72608679"
---
# <a name="visual-c-classes-in-class-designer"></a>Классы Visual C++ в конструкторе классов
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Конструктор классов поддерживает классы C++ и визуализирует собственные классы C++ так же, как фигуры классов Visual Basic и Visual C#. Отличие состоит в том, что классы C++ могут обладать отношениями множественного наследования. Фигуру класса можно развернуть, чтобы отобразить дополнительные поля и методы класса, а также свернуть в целях экономии места.

> [!NOTE]
> Конструктор классов не поддерживает объединения (это особый тип класса, в котором объем выделяемой памяти равен размеру самого большого элемента данных объединения).

## <a name="simple-inheritance"></a>Простое наследование
 Если перетащить на схему сразу несколько классов, между которыми есть отношение наследования, они будут соединены стрелкой. Стрелка указывает в направлении базового класса. Например, если на схеме классов отображаются следующие классы, они будут соединены стрелкой, которая будет указывать от класса B на класс A:

```
class A {};
class B : A {};
```

 Также можно перетащить на схему только класс B, щелкнуть правой кнопкой мыши его фигуру, а затем выбрать команду **Показать базовые классы**. В этом случае будет показан базовый класс A.

## <a name="multiple-inheritance"></a>Множественное наследование
 Конструктор классов поддерживает наглядное представление отношений множественного наследования. *Множественное наследование* используется, если у производного класса есть атрибуты более чем одного базового класса. Ниже приведен пример множественного наследования:

```
class Bird {};
class Swimmer {};
class Penguin : public Bird, public Swimmer {};
```

 Если перетащить на схему сразу несколько классов, между которыми есть отношение множественного наследования, они будут соединены стрелкой. Стрелка указывает в направлении базовых классов.

 Чтобы просмотреть классы, которые являются базовыми для выбранного, щелкните правой кнопкой мыши фигуру класса и выберите **Показать базовые классы**.

> [!NOTE]
> Команда **Показать производные классы** в коде C++ не поддерживается. Можно отобразить производные классы, перейдя в представление классов, развернув узел типа, развернув вложенную папку **производных типов** , а затем перетащив эти типы на схему классов.

 Дополнительные сведения о множественном наследовании классов см. в разделах [Множественное наследование (NOTINBUILD)](https://msdn.microsoft.com/3b74185e-2beb-4e29-8684-441e51d2a2ca) и [Несколько базовых классов](https://msdn.microsoft.com/library/a30c69fe-401c-4a87-96a0-e0da70c7c740).

## <a name="abstract-classes"></a>Абстрактные классы
 Конструктор классов поддерживает абстрактные классы (также называются "абстрактными базовыми классами"). Для этих классов не создаются экземпляры, но от них могут наследоваться другие классы. Используя пример из раздела "Множественное наследование" этого документа, вы можете создавать экземпляры класса `Bird` в виде отдельных объектов, как показано ниже:

```
int main()
{
   Bird sparrow;
   Bird crow;
   Bird eagle;
}
```

 Тем не менее вы не можете создавать экземпляры класса `Swimmer` в виде отдельных объектов. При этом вы можете создавать на его основе производные классы, например `Penguin`, `Whale` и `Fish`. В этом случае можно объявить `Swimmer` как абстрактный базовый класс.

 Чтобы объявить класс как абстрактный, используйте ключевое слово `abstract`. Элементы, помеченные как абстрактные или включенные в абстрактный класс, являются виртуальными и должны быть реализованы классами, производными от абстрактного класса.

```
class Swimmer abstract
{
   virtual void swim();
   void dive();
};
```

 Также можно объявить класс как абстрактный, включив по крайней мере одну чисто виртуальную функцию:

```
class Swimmer
{
   virtual void swim() = 0;
   void dive();
};
```

 При выводе этих объявлений на схеме классов имена класса `Swimmer` и его чисто виртуальной функции `swim` отображаются курсивом на фигуре абстрактного класса. Кроме того, будет показана надпись **Абстрактный класс**. Обратите внимание, что фигуры типа абстрактного класса аналогичны обычным классам, но их границы показаны пунктирной линией.

 В классе, производном от абстрактного базового класса, необходимо переопределить каждую чисто виртуальную функцию в базовом классе. В противном случае создать экземпляр производного класса нельзя. Например, если необходимо наследовать класс `Fish` от класса `Swimmer`, в классе `Fish` необходимо переопределить метод `swim`:

```
class Fish : public Swimmer
{
   void swim(int speed);
};

int main()
{
   Fish guppy;
}
```

 При отображении данного кода на схеме классов конструктор классов проводит линию наследования от класса `Fish` к классу `Swimmer`.

## <a name="anonymous-classes"></a>Анонимные классы
 Конструктор классов поддерживает анонимные классы. *Типы анонимных классов* объявляются без идентификатора. Они не могут иметь конструктор или деструктор, не могут передаваться в качестве аргументов в функции и не возвращаются в качестве значений из функций. Анонимный класс можно использовать для замены имени класса именем определения типа, как показано в следующем примере:

```
typedef struct
{
    unsigned x;
    unsigned y;
} POINT;
```

 Структуры также могут быть анонимными. Конструктор классов отображает анонимные классы и структуры таким же образом, как и соответствующие типы. Несмотря на то что можно объявить и отобразить анонимные классы и структуры, конструктор классов не будет использовать указанное имя тега. В этом случае будет использоваться имя, созданное в представлении классов. Класс или структура отображаются в представлении классов и конструкторе классов в виде элемента с именем **__unnamed**.

 Дополнительные сведения об анонимных классах см. в разделе [Типы анонимных классов](https://msdn.microsoft.com/library/9ba667b2-8c2a-4c29-82a6-fa120b9233c8).

## <a name="template-classes"></a>Классы шаблона
 Конструктор классов поддерживает визуализацию классов шаблона. Поддерживаются вложенные объявления. В следующей таблице показаны некоторые типичные объявления.

|Code, элемент|Представление конструктора классов|
|------------------|-------------------------|
|`template <class T>`<br /><br /> `class A {};`|`A<T>`<br /><br /> Класс шаблона|
|`template <class T, class U>`<br /><br /> `class A {};`|`A<T, U>`<br /><br /> Класс шаблона|
|`template <class T, int i>`<br /><br /> `class A {};`|`A<T, i>`<br /><br /> Класс шаблона|
|`template <class T, template <class K> class U>`<br /><br /> `class A {};`|`A<T, U>`<br /><br /> Класс шаблона|

 В следующей таблице показаны некоторые примеры частичной специализации.

|Code, элемент|Представление конструктора классов|
|------------------|-------------------------|
|`template<class T, class U>`<br /><br /> `class A {};`|`A<T, U>`<br /><br /> Класс шаблона|
|`template<class T>`<br /><br /> `class A<T, T> {};`|`A<T, T>`<br /><br /> Класс шаблона|
|`template <class T>`<br /><br /> `class A<T, int> {};`|`A<T, int>`<br /><br /> Класс шаблона|
|`template <class T1, class T2>`<br /><br /> `class A<T1*, T2*> {};`|`A<T1*, T2*>`<br /><br /> Класс шаблона|

 В следующей таблице показаны некоторые примеры наследования в частичной специализации.

|Code, элемент|Представление конструктора классов|
|------------------|-------------------------|
|`template <class T, class U>`<br /><br /> `class A {};`<br /><br /> `template <class TC>`<br /><br /> `class A<T, int> {};`<br /><br /> `class B : A<int, float>`<br /><br /> `{};`<br /><br /> `class C : A<int, int>`<br /><br /> `{};`|`A<T, U>`<br /><br /> Класс шаблона<br /><br /> `B`<br /><br /> Класс<br /><br /> (указывает на класс A)<br /><br /> `C`<br /><br /> Класс<br /><br /> (указывает на класс A)|

 В следующей таблице приведены некоторые примеры функций шаблона частичной специализации.

|Code, элемент|Представление конструктора классов|
|------------------|-------------------------|
|`class A`<br /><br /> `{`<br /><br /> `template <class T, class U>`<br /><br /> `void func(T a, U b);`<br /><br /> `template <class T>`<br /><br /> `void func(T a, int b);`<br /><br /> `};`|`A`<br /><br /> Func \<T, U> (+ 1 перегрузка)|
|`template <class T1>`<br /><br /> `class A {`<br /><br /> `template <class T2>`<br /><br /> `class B {};`<br /><br /> `};`<br /><br /> `template<> template<>`<br /><br /> `class A<type>::B<type> {};`|`A<T1>`<br /><br /> Класс шаблона<br /><br /> `B<T2>`<br /><br /> Класс шаблона<br /><br /> (Класс B содержится в классе A в разделе **Вложенные типы**)|
|`template <class T>`<br /><br /> `class C {};`<br /><br /> `class A : C<int> {};`|`A`<br /><br /> Класс<br /><br /> -> C\<int><br /><br /> `C<T>`<br /><br /> Класс шаблона|

 В следующей таблице показаны некоторые примеры наследования шаблонов.

|Code, элемент|Представление конструктора классов|
|------------------|-------------------------|
|`template <class T>`<br /><br /> `class C {};`<br /><br /> `template<>`<br /><br /> `class C<int> {`<br /><br /> `class B {};`<br /><br /> `}`<br /><br /> `class A : C<int>::B {};`|`A`<br /><br /> Класс<br /><br /> ->B<br /><br /> `C<int>`<br /><br /> Класс<br /><br /> (Класс B содержится в классе C в разделе **Вложенные типы**)<br /><br /> `C<T>`<br /><br /> Класс шаблона|

 В следующей таблице показаны некоторые примеры связей между классами в канонической специализации.

|Code, элемент|Представление конструктора классов|
|------------------|-------------------------|
|`template <class T>`<br /><br /> `class C {};`<br /><br /> `template<>`<br /><br /> `class C<int> {};`<br /><br /> `class A : C<int> {};`<br /><br /> `class D : C<float> {};`|`A`<br /><br /> Класс<br /><br /> ->C\<int><br /><br /> `C<int>`<br /><br /> Класс<br /><br /> `C<T>`<br /><br /> Класс шаблона<br /><br /> `D`<br /><br /> Класс<br /><br /> ->C\<float>|
|`class B {`<br /><br /> `template <class T>`<br /><br /> `T min (const T &a, const T &b);`<br /><br /> `};`|`B`<br /><br /> минимум \<T>|

## <a name="see-also"></a>См. также:
 [Работа с классами Visual C++ Code (конструктор классов)](../ide/working-with-visual-cpp-code-class-designer.md) [и структурами](https://msdn.microsoft.com/library/516dd496-13fb-4f17-845a-e9ca45437873) [типы анонимных классов](https://msdn.microsoft.com/library/9ba667b2-8c2a-4c29-82a6-fa120b9233c8) [(сборке) множественное наследование](https://msdn.microsoft.com/3b74185e-2beb-4e29-8684-441e51d2a2ca) [нескольких шаблонов базовых классов](https://msdn.microsoft.com/library/a30c69fe-401c-4a87-96a0-e0da70c7c740) [Templates](https://msdn.microsoft.com/library/90fcc14a-2092-47af-9d2e-dba26d25b872)
