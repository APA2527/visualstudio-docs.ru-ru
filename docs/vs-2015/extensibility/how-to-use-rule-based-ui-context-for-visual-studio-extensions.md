---
title: Как использовать контекст пользовательского интерфейса на основе правил для расширений | Документация Майкрософт
ms.date: 11/15/2016
ms.topic: conceptual
ms.assetid: 8dd2cd1d-d8ba-49b9-870a-45acf3a3259d
caps.latest.revision: 8
ms.author: gregvanl
ms.openlocfilehash: 26f66f635b2c248af01067d9dbd96fd997593593
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/02/2020
ms.locfileid: "85535568"
---
# <a name="how-to-use-rule-based-ui-context-for-visual-studio-extensions"></a>Практическое руководство. Использование контекста пользовательского интерфейса на основе правил для расширений Visual Studio
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Visual Studio позволяет загружать пакеты VSPackage, когда активированы определенные хорошо известные <xref:Microsoft.VisualStudio.Shell.UIContext> s. Тем не менее, эти контексты пользовательского интерфейса не очень детализированы, и у авторов расширений нет выбора, но для выбора доступного контекста пользовательского интерфейса, который активируется до того момента, когда ему действительно требуется загрузить VSPackage. Список хорошо известных контекстов пользовательского интерфейса см. в разделе <xref:Microsoft.VisualStudio.Shell.KnownUIContexts> .

 Загрузка пакетов может повлиять на производительность и загружать их раньше, чем требуется, но не является лучшим способом. В Visual Studio 2015 появилась концепция контекстов пользовательского интерфейса на основе правил, механизм, позволяющий авторам расширений определять точные условия, при которых контекст пользовательского интерфейса активируется и связанные пакеты VSPackage загружены.

## <a name="rule-based-ui-context"></a>Контекст пользовательского интерфейса на основе правил
 "Правило" состоит из нового контекста пользовательского интерфейса (GUID) и логического выражения, которое ссылается на один или несколько "терминов" в сочетании с логическими операциями "and", "or" и "not". "Условия" оцениваются динамически во время выполнения, и выражение повторно вычисляется каждый раз при изменении любого из его условий. Если выражение принимает значение true, активируется связанный контекст пользовательского интерфейса. В противном случае контекст пользовательского интерфейса отключается.

 Контекст пользовательского интерфейса на основе правил можно использовать различными способами.

1. Укажите ограничения видимости для команд и окон инструментов. Окна команд и средств можно скрыть до тех пор, пока не будет выполнено правило контекста пользовательского интерфейса.

2. В качестве ограничений автоматической загрузки: автоматическая загрузка пакетов только при соблюдении правила

3. Отложенная задача: отложенная загрузка до тех пор, пока не будет пройден указанный интервал, и правило все еще соблюдается.

   Этот механизм может использоваться любым расширением Visual Studio.

## <a name="create-a-rule-based-ui-context"></a>Создание контекста пользовательского интерфейса на основе правил
 Предположим, у вас есть расширение с именем Тестпаккаже, которое предоставляет команду меню, применимую только к файлам с расширением config. Перед VS2015 лучшим вариантом было Загрузка Тестпаккаже при <xref:Microsoft.VisualStudio.Shell.KnownUIContexts.SolutionExistsAndFullyLoadedContext%2A> активации контекста пользовательского интерфейса. Это неэффективно, так как загруженное решение может даже не содержать config-файл. Давайте посмотрим, как можно использовать контекст ПОЛЬЗОВАТЕЛЬСКОГО интерфейса на основе правил, чтобы активировать контекст пользовательского интерфейса, только если выбран файл с расширением config, и Load Тестпаккаже при активации этого контекста пользовательского интерфейса.

1. Определите новый GUID UIContext и добавьте его в класс VSPackage <xref:Microsoft.VisualStudio.Shell.ProvideAutoLoadAttribute> и <xref:Microsoft.VisualStudio.Shell.ProvideUIContextRuleAttribute> .

    Например, предположим, что будет добавлен новый UIContext "Уиконтекстгуид". Созданный GUID (GUID можно создать, щелкнув сервис-> Create GUID) — "8B40D5E2-5626-42AE-99EF-3DD1EFF46E7B". Затем добавьте в класс пакета следующее:

   ```csharp
   public const string UIContextGuid = "8B40D5E2-5626-42AE-99EF-3DD1EFF46E7B";
   ```

    Для атрибутов добавьте следующее: (подробные сведения об этих атрибутах будут объяснены далее).

   ```csharp
   [ProvideAutoLoad(TestPackage.UIContextGuid)]
   [ProvideUIContextRule(TestPackage.UIContextGuid,
       name: "Test auto load",
       expression: "DotConfig",
       termNames: new[] { "DotConfig" },
       termValues: new[] { "HierSingleSelectionName:.config$" })]
   ```

    Эти метаданные определяют новый UIContext GUID (8B40D5E2-5626-42AE-99EF-3DD1EFF46E7B) и выражение, ссылающееся на один термин "Дотконфиг". Термин "Дотконфиг" принимает значение true, когда текущее выделение в активной иерархии имеет имя, совпадающее с шаблоном регулярного выражения " \\ . config $" (заканчивается на ". config"). Значение (по умолчанию) определяет необязательное имя для правила, полезное для отладки.

    Значения атрибута добавляются к pkgdef, созданному во время сборки.

2. В файле VSCT для команд Тестпаккаже добавьте к соответствующим командам флаг "Динамиквисибилити":

   ```xml
   <CommandFlag>DynamicVisibility</CommandFlag>
   ```

3. В разделе видимости VSCT свяжите соответствующие команды с новым идентификатором GUID UIContext, определенным в #1:

   ```xml
   <VisibilityConstraints>
       <VisibilityItem guid="guidTestPackageCmdSet" id="TestId"  context="guidTestUIContext"/>
   </VisibilityConstraints>
   ```

4. В разделе символы добавьте определение UIContext:

   ```xml
   <GuidSymbol name="guidTestUIContext" value="{8B40D5E2-5626-42AE-99EF-3DD1EFF46E7B}" />
   ```

    Теперь команды контекстного меню для файлов *. config будут видны только в том случае, если выбранный элемент в обозревателе решений является файлом config, а пакет не будет загружен, пока не выбрана одна из этих команд.

   Теперь давайте воспользуемся отладчиком, чтобы убедиться, что пакет загружается только в том случае, если предполагается. Для отладки Тестпаккаже:

5. Установите точку останова в <xref:Microsoft.VisualStudio.Shell.Package.Initialize%2A> методе.

6. Создайте Тестпаккаже и начните отладку.

7. Создайте проект или откройте его.

8. Выберите любой файл с расширением, отличным от. config. Попадание в точку останова не должно.

9. Выберите файл App.Config.

   Тестпаккаже загружает и останавливается в точке останова.

## <a name="adding-more-rules-for-ui-context"></a>Добавление правил для контекста пользовательского интерфейса
 Поскольку правила контекста пользовательского интерфейса являются логическими выражениями, можно добавить более ограниченные правила для контекста пользовательского интерфейса. Например, в приведенном выше контексте пользовательского интерфейса можно указать, что правило применяется только при загрузке решения с проектом. Таким образом, команды не будут отображаться при открытии файла config в качестве отдельного файла, а не в составе проекта.

```csharp
[ProvideAutoLoad(TestPackage.UIContextGuid)]
[ProvideUIContextRule(TestPackage.UIContextGuid,
    name: "Test auto load",
    expression: "(SingleProject | MultipleProjects) & DotConfig",
    termNames: new[] { "SingleProject", "MultipleProjects","DotConfig" },
    termValues: new[] { VSConstants.UICONTEXT_SolutionHasSingleProject_string , VSConstants.UICONTEXT_SolutionHasMultipleProjects_string , "HierSingleSelectionName:.config$" })]
```

 Теперь выражение ссылается на три условия. Первые два термина "Синглепрожект" и "Мултиплепрожектс" ссылаются на другие хорошо известные контексты пользовательского интерфейса (по их идентификаторам GUID). Третий термин «Дотконфиг» — это контекст пользовательского интерфейса на основе правил, который мы определили ранее.

## <a name="delayed-activation"></a>Отложенная активация
 Правила могут иметь необязательные "задержки". Задержка указывается в миллисекундах. Если задано значение, задержка приводит к задержке активации или деактивации контекста пользовательского интерфейса правила на этот интервал времени. Если правило изменяется до интервала задержки, ничего не происходит. Этот механизм можно использовать для "пошагового" инициализации, особенно однократная инициализация без использования таймеров или регистрации уведомлений о неактивности.

 Например, можно указать в правиле тестовой нагрузки задержку в 100 миллисекунд:

```csharp
[ProvideAutoLoad(TestPackage.UIContextGuid)]
[ProvideUIContextRule(TestPackage.UIContextGuid,
    name: "Test auto load",
    expression: "DotConfig",
    termNames: new[] { "DotConfig" },
    termValues: new[] { "HierSingleSelectionName:.config$" },
    delay: 100)]
```

## <a name="term-types"></a>Типы терминов
 Ниже приведены различные типы поддерживаемых терминов.

|Тип термина|Описание|
|-|-|
|{nnnnnnnn-NNNN-NNNN-NNNN-нннннннннннн}|Идентификатор GUID ссылается на контекст пользовательского интерфейса. Термин будет иметь значение true, если активен контекст пользовательского интерфейса, и false в противном случае.|
|Хиерсинглеселектионнаме:\<pattern>|Термин будет иметь значение true, если выбор в активной иерархии является одним элементом, а имя выбранного элемента соответствует регулярному выражению .NET, заданному шаблоном.|
|Усерсеттингссторекуери:\<query>|"запрос" представляет полный путь к хранилищу пользовательских параметров, который должен иметь ненулевое значение. Запрос разбивается на "Collection" и "propertyName" по последней косой черте.|
|Конфигсеттингссторекуери:\<query>|"запрос" представляет полный путь к хранилищу параметров конфигурации, который должен иметь ненулевое значение. Запрос разбивается на "Collection" и "propertyName" по последней косой черте.|
|Активепрожектфлавор:\<projectTypeGuid>|Термин будет иметь значение true, если текущий выбранный проект является разновидностью (агрегированный) и имеет версию, совпадающую с заданным идентификатором GUID типа проекта.|
|Активидиторконтенттипе:\<contentType>|Этот термин будет иметь значение true, если выбранный документ является текстовым редактором с данным типом содержимого.|
|Активепрожекткапабилити:\<Expression>|Термин имеет значение true, если возможности активного проекта соответствуют указанному выражению. Выражение может представлять собой нечто вроде VB &#124; CSharp|
|Солутионхаспрожекткапабилити:\<Expression>|Аналогично выше, но термин имеет значение true, если в решении есть загруженный проект, соответствующий выражению.|
|Солутионхаспрожектфлавор:\<projectTypeGuid>|Термин будет иметь значение true, если в решении имеется проект с установленным флагом (агрегированный) и он имеет версию, совпадающую с идентификатором GUID данного типа проекта.|

## <a name="compatibility-with-cross-version-extension"></a>Совместимость с расширением для разных версий
 Контексты пользовательского интерфейса на основе правил — это новая функция Visual Studio 2015, которая не будет перенесена в более ранние версии. Это создает проблему с расширениями или пакетами, предназначенными для нескольких версий Visual Studio, которые должны быть загружены в Visual Studio 2013 и более ранних версиях, но могут воспользоваться преимуществами контекстов пользовательского интерфейса на основе правил, чтобы предотвратить автоматическую загрузку в Visual Studio 2015.

 Чтобы обеспечить поддержку таких пакетов, записи Аутолоадпаккажес в реестре теперь могут содержать флаг в поле "значение", чтобы указать, что запись должна быть пропущена в Visual Studio 2015 и более поздних версиях. Это можно сделать, добавив параметр flags в <xref:Microsoft.VisualStudio.Shell.PackageAutoLoadFlags> . Пакеты VSPackage теперь могут добавить параметр **скипвхенуиконтекструлесактиве** к своему <xref:Microsoft.VisualStudio.Shell.ProvideAutoLoadAttribute> атрибуту, чтобы указать, что запись должна игнорироваться в Visual Studio 2015 и более поздних версиях.

## <a name="extensible-ui-context-rules"></a>Расширяемые правила контекста пользовательского интерфейса
 Иногда пакеты не могут использовать статические правила контекста пользовательского интерфейса. Например, предположим, что имеется пакет, поддерживающий расширяемость, так что состояние команды основано на типах редакторов, поддерживаемых импортированными поставщиками MEF. Команда включена, если имеется расширение, поддерживающее текущий тип редактирования. В таких случаях пакет не может использовать статическое правило контекста пользовательского интерфейса, так как термины будут изменяться в зависимости от доступных расширений MEF.

 Для поддержки таких пакетов контексты пользовательского интерфейса на основе правил поддерживают жестко закодированное выражение "*", которое указывает на все приведенные ниже термины, которые будут соединены с или. Это позволяет основному пакету определять известный контекст пользовательского интерфейса на основе правила и привязывать его состояние команды к этому контексту. После этого любое расширение MEF, предназначенное для главного пакета, может добавлять свои термины для редакторов, которые он поддерживает, без влияния на другие термины или основное выражение.

 В <xref:Microsoft.VisualStudio.Shell.ProvideExtensibleUIContextRuleAttribute.%23ctor%2A> документации по конструктору показан синтаксис для расширенных правил контекста пользовательского интерфейса.
