---
title: Рослин Анализаторы и код-осведомленных библиотеки для ImmutableArrays (ru) Документы Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-sdk
ms.topic: conceptual
ms.assetid: 0b0afa22-3fca-4d59-908e-352464c1d903
caps.latest.revision: 6
ms.author: gregvanl
manager: jillfra
ms.openlocfilehash: 65849a3d9ad1cdd073551f96e61997fe5f91118a
ms.sourcegitcommit: 7b60e81414a82c6d34f6de1a1f56115c9cd26943
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2020
ms.locfileid: "81444899"
---
# <a name="roslyn-analyzers-and-code-aware-library-for-immutablearrays"></a>Анализаторы Roslyn и библиотека для ImmutableArrays с поддержкой кода
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

[Платформа компилятора .NET](https://github.com/dotnet/roslyn) («Рослин») помогает создавать библиотеки, осведомленные о коде. Библиотека, сознаюющая код, предоставляет функциональность, которая позволяет использовать и инструментарий (анализаторы Roslyn), чтобы наилучшим образом использовать библиотеку или избежать ошибок. Эта тема показывает, как построить реальный анализатор Roslyn, чтобы поймать распространенные ошибки при использовании [пакета NIB: Immutable Collections](https://msdn.microsoft.com/library/33f4449d-7078-450a-8d60-d9229f66bbca) NuGet. Пример также показывает, как предоставить исправление кода для проблемы кода, найденной анализатором. Пользователи видят исправления кода в пользовательном центре Visual Studio и могут автоматически применять исправление кода.

## <a name="getting-started"></a>Приступая к работе
Для создания этого примера необходимо следующее:

- Visual Studio 2015 (не Express Edition) или более поздняя версия. Вы можете использовать бесплатный [Visual Studio Community Edition](https://www.visualstudio.com/products/visual-studio-community-vs)

- [Визуальная студия SDK](../extensibility/visual-studio-sdk.md). Вы также можете, при установке Visual Studio, проверить Visual Studio Расширяемые инструменты под общие инструменты для установки SDK в то же время. Если вы уже установили Visual Studio, вы также можете установить этот SDK, перейдя в основное меню **Файл &#124; New &#124;Project ...,** выбрав C'в левом навигационном стекле, а затем выбрав Расширительность. Когда вы выбираете шаблон проекта **«Установка визуальной студии расширяемости»**— это подсказывает вам скачать и установить SDK.

- [.NET Компилятор Платформа ("Рослин") SDK](https://marketplace.visualstudio.com/items?itemName=VisualStudioProductTeam.NETCompilerPlatformSDK). Вы также можете установить этот SDK, перейдя в основное меню **Файл &#124; New &#124; Project ...,** выбирая **C's** в левом навигационном стекле, а затем выбирая **Расширяемость.** Когда вы выбираете шаблон проекта **.NET Compiler Platform SDK,** он подсказывает вам скачать и установить SDK. Этот SDK включает в себя [Roslyn Syntax Visualizer](https://github.com/dotnet/roslyn/wiki/Syntax%20Visualizer). Этот чрезвычайно полезный инструмент поможет вам выяснить, какие типы моделей кода следует искать в анализаторе. Инфраструктура анализатора вызывает ваш код для определенных типов моделей кода, поэтому ваш код выполняется только в случае необходимости и может сосредоточиться только на анализе соответствующего кода.

## <a name="whats-the-problem"></a>В чем проблема?
Представьте, что вы предоставляете библиотеку с <xref:System.Collections.Immutable.ImmutableArray%601?displayProperty=fullName>поддержкой ImmutableArray (например, ) Разработчики си-хау имеют большой опыт работы с массивами .NET. Однако из-за характера ImmutableArrays и методов оптимизации, используемых в реализации, интуиция разработчика СЗ заставит пользователей вашей библиотеки писать сломанный код, как описано ниже. Кроме того, пользователи не видят своих ошибок до времени выполнения, что не является качество множестстстстств, к которому они привыкли в Visual Studio с .NET.

Пользователи знакомы с написанием кода следующим образом:

```csharp
var a1 = new int[0];
Console.WriteLine("a1.Length = { 0}", a1.Length);
var a2 = new int[] { 1, 2, 3, 4, 5 };
Console.WriteLine("a2.Length = { 0}", a2.Length);

```

Создание пустых массивов для заполнения последующих строк кода и использование синтаксиса инициализаторов коллекции хорошо знакомы разработчикам с C.' Однако написание того же кода для ImmutableArray выходит из строя во время выполнения:

```csharp
var b1 = new ImmutableArray<int>();
Console.WriteLine("b1.Length = { 0}", b1.Length);
var b2 = new ImmutableArray<int> { 1, 2, 3, 4, 5 };
Console.WriteLine("b2.Length = { 0}", b2.Length);

```

Первая ошибка связана с использованием реализации ImmutableArray для обертывания базового хранилища данных. Structs должны иметь беспараметрыные `default(T)` конструкторы, чтобы выражения могли возвращать структуры со всеми нулевыми или нулевыми членами. При доступе `b1.Length`к коду происходит ошибка нулевой ссылки времени выполнения, поскольку в структуре ImmutableArray нет базового массива хранилища. Правильный способ создать пустой ImmutableArray . `ImmutableArray<int>.Empty`

 Ошибка с инициализаторами коллекции происходит потому, что метод ImmutableArray.Add возвращает новые экземпляры каждый раз, когда вы называете его. Поскольку ImmutableArrays никогда не изменяется при добавлении нового элемента, вы получаете новый объект ImmutableArray (который может совместно хранить по причинам производительности с ранее существовавшей ImmutableArray). Потому что `b2` указывает на первый `Add()` ImmutableArray, прежде чем звонить пять раз, `b2` является по умолчанию ImmutableArray. Длина вызова на нем также сбои с нулевой ошибкой dereference. Правильный способ инициализировать ImmutableArray без ручного вызова Добавить является использование. `ImmutableArray.CreateRange(new int[] {1, 2, 3, 4, 5})`

## <a name="finding-relevant-syntax-node-types-to-trigger-your-analyzer"></a>Поиск соответствующих типов узла Синтаксиса для запуска анализатора
Чтобы начать строить анализатор, сначала выясните, какой тип SyntaxNode вам нужно искать.   Запуск Syntax Visualizer из меню **Посмотреть &#124; Другие Windows &#124; Roslyn Syntax Visualizer**.

Поместите внимательность редактора на линию, которая декларирует `b1`. Вы увидите, что Syntax Visualizer `LocalDeclarationStatement` показывает, что вы находитесь в узеле дерева синтаксиса. Этот узло `VariableDeclaration`имеет , который, `VariableDeclarator`в свою очередь, имеет , который, в свою `EqualsValueClause`очередь, имеет , и, наконец, есть `ObjectCreationExpression`. При нажатии на дерево узлов Syntax Visualizer синтаксис в окне редактора выделяется, чтобы показать вам код, представленный этим узлом. Названия подтипов SyntaxNode совпадают с именами, используемыми в грамматике C.

## <a name="creating-the-analyzer-project"></a>Создание проекта анализатора
Из основного меню выберите **Файл &#124; Новый проект &#124; ...**. В диалоге **Нового проекта,** в рамках проектов **C'** в левой панели навигации, выберите Расширительность, а в правом стекле выбрать анализатор с шаблоном проекта **Code Fix.** Введите имя и подтвердите диалог.

Шаблон открывает DiagnosticAnalyzer.cs файл. Выберите буферную вкладку редактора. Этот файл имеет класс анализатора (сформированный из имени, `DiagnosticAnalyzer` которое вы дали проекту), который происходит от (тип API Roslyn). Ваш новый `DiagnosticAnalyzerAttribute` класс имеет объявление вашего анализатора имеет отношение к языку C, так что компилятор обнаруживает и загружает ваш анализатор.

```csharp
[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class ImmutableArrayAnalyzerAnalyzer : DiagnosticAnalyzer
{}
```

Можно реализовать анализатор с помощью Visual Basic, который нацелен на код C,, и наоборот. В DiagnosticAnalyzerAttribute важнее выбрать, нацелен ли анализатор на один язык или и то, и другое. Более сложные анализаторы, требующие детального моделирования языка, могут ориентироваться только на один язык. Если анализатор, например, проверяет только имена типов или имена публичных членов, возможно, можно использовать общую языковую модель, предлагает Roslyn через Visual Basic и C. Например, FxCop предупреждает, что <xref:System.Runtime.Serialization.ISerializable>класс реализует, но <xref:System.SerializableAttribute> у класса нет атрибута, независимого от языка и работая как для Visual Basic, так и для кода C.

## <a name="initalizing-the-analyzer"></a>Ирисовка анализатора
Прокрутите немного `DiagnosticAnalyzer` вниз в `Initialize` классе, чтобы увидеть метод. Компилятор вызывает этот метод при активации анализатора. Метод использует `AnalysisContext` объект, который позволяет анализатору получать информацию о контексте и регистрировать обратные вызовы для событий для видов кода, которые вы хотите проанализировать.

```csharp
public override void Initialize(AnalysisContext context) {}
```

Откройте новую строку в этом методе и введите "контекст". чтобы увидеть список завершения Intellisense. Вы можете видеть в списке `Register…` завершения Есть много методов для обработки различных видов событий. Например, первый, `RegisterCodeBlockAction`, перезванивает к коду для блока, который обычно код между фигурными скобками. Регистрация блока также вызывает обратный код для инициализатора поля, значения, присвоенного атрибуту, или значения дополнительного параметра.

В качестве `RegisterCompilationStartAction`другого примера, , перезванивает к коду в начале компиляции, что полезно, когда вам нужно собрать состояние во многих местах. Можно создать структуру данных, скажем, для сбора всех используемых символов, и каждый раз, когда анализатор вызывается обратно для синтаксиса или символа, вы можете сохранить информацию о каждом местоположении в вашей структуре данных. Когда вы перезванываете обратно из-за окончания компиляции, можно проанализировать все сохраненные места, например, чтобы сообщить, какие символы код использует из каждой `using` выписки.

Используя **Syntax Visualizer,** вы узнали, что вы хотите, чтобы вас называли, когда компилятор обрабатывает ObjectCreationExpression. Этот код используется для настройки обратного вызова:

```csharp

context.RegisterSyntaxNodeAction(c => AnalyzeObjectCreation(c),
                                 SyntaxKind.ObjectCreationExpression);
```

Вы регистрируетесь для узла синтаксиса и фильтруете только для узлов синтаксиса создания объектов. По конвенции, анализатор авторы используют лямбда при регистрации действий, что помогает сохранить анализаторы абонематией. Для создания метода `AnalyzeObjectCreation` можно использовать функцию Visual Studio Generate From **Use.** Это генерирует правильный тип параметра контекста для вас тоже.

## <a name="setting-properties-for-users-of-your-analyzer"></a>Установка свойств для пользователей вашего анализатора
Чтобы анализатор показался в ui Visual Studio соответствующим образом, ищите и изменяйте следующую строку кода для идентификации анализатора:

```csharp
internal const string Category = "Naming";
```

Измените `"Naming"` на `"API Guidance"`.

Следующая находка и откройте файл Resources.resx в проекте с помощью **Solution Explorer.** Вы можете поместить в описание для вашего анализатора, название и т.д. Вы можете изменить значение для `“Don’t use ImmutableArray<T> constructor”` всех из них на данный момент. Вы можете поместить строку форматирования{0}аргументы в строке {1}(, `Diagnostic.Create()`и т.д.), а затем, когда вы звоните, вы можете поставить парамс массив аргументов, которые будут переданы.

## <a name="analyzing-an-object-creation-expression"></a>Анализ выражения создания объекта
Метод `AnalyzeObjectCreation` использует другой тип контекста, поставляемого платформой анализа кода. Метод Initialize `AnalysisContext` позволяет регистрировать обратные вызовы действий для настройки анализатора. Например, `SyntaxNodeAnalysisContext`есть то, `CancellationToken` что вы можете пройти вокруг. Если пользователь начинает вводить в редакторе, Roslyn отменит анализаторы выполнения, чтобы сохранить работу и повысить производительность. В качестве другого примера этот контекст имеет свойство узла, которое возвращает синтаксисный узлы создания объекта.

Получите узел, который можно предположить, это тип, для которого вы отфильтровали действие синтаксисного узла:

```csharp
var objectCreation = (ObjectCreationExpressionSyntax)context.Node;
```

### <a name="launching-visual-studio-with-your-analyzer-the-first-time"></a>Запуск визуальной студии с вашим анализатором в первый раз
Запуск Visual Studio путем создания и выполнения вашего анализатора (нажмите **F5**). Поскольку проект запуска в **Solution Explorer** — это проект VSIX, запуск кода создает ваш код и VSIX, а затем запускает Visual Studio с установленной VSIX. При запуске Visual Studio таким образом, он запускает с отчетливым улей реестра, так что ваше основное использование Visual Studio не будет зависеть от ваших экземпляров тестирования при создании анализаторов. В первый раз, когда вы запускаете таким образом, Visual Studio делает несколько инициалинов, подобных тому, когда вы впервые запустили Visual Studio после ее установки.

 Создайте консольный проект, а затем введите код массива в основной метод консольных приложений:

```csharp
var b1 = new ImmutableArray<int>();
Console.WriteLine("b1.Length = {0}", b1.Length);
var b2 = new ImmutableArray<int> { 1, 2, 3, 4, 5 };
Console.WriteLine("b2.Length = {0}", b2.Length);

```

Строки кода `ImmutableArray` с имеют squiggles потому что вам нужно получить `using` неизменяемый пакет NuGet и добавить заявление к вашему коду. Нажмите кнопку указателя на узло проекта в **Solution Explorer** и выберите **пакеты Управления NuGet ...**. В менеджере NuGet введите "Immutable" в поле поиска и выберите элемент "System.Collections.Immutable" (не выбирайте "Microsoft.Bcl.Immutable") в левом стекле и нажмите кнопку "Установка в правом стекле". Установка пакета добавляет ссылку на ссылки на проект.

Вы все еще видите `ImmutableArray`красные squiggles под, так что поместите caret в том, что идентификатор и нажмите **CTRL.** (период) для составления предлагаемого меню и `using` добавления соответствующего оператора.

**Сохранить все и закрыть** второй экземпляр Visual Studio на данный момент, чтобы поставить вас в чистом состоянии, чтобы продолжить.

## <a name="finishing-the-analyzer-using-edit-and-continue"></a>Завершение анализатора с использованием и продолжения
В первом случае Visual Studio, установите точку `AnalyzeObjectCreation` разрыва в начале вашего метода, нажав **F9** с каретой на первой линии.

Запустите анализатор снова с **F5**, и во втором случае Visual Studio, вновь открыть консоль приложение, которое вы создали в прошлый раз.

Вы возвращаетесь к первой инстанции Visual Studio в точке разрыва, потому что компилятор Roslyn увидел выражение создания объекта и вызвал в ваш анализатор.

**Получите узла создания объекта.** Перейдите через линию, которая `objectCreation` устанавливает переменную, нажав **F10,** и в **немедленном окне** оценить выражение. `“objectCreation.ToString()”` Вы видите, что узла синтаксиса, на который указывает переменная, является кодом, `"new ImmutableArray<int>()"`только то, что вы ищете.

**Получить ImmutableArray\<T> Тип объекта.** Необходимо проверить, является ли создаваемый тип ImmutableArray. Во-первых, вы получаете объект, представляющий этот тип. Вы проверяете типы с помощью семантической модели, чтобы убедиться, что у вас есть именно правильный тип, и вы не сравниваете строку из ToString(). Введите следующую строку кода в конце функции:

```csharp

var immutableArrayOfTType =
    context.SemanticModel
           .Compilation
           .GetTypeByMetadataName("System.Collections.Immutable.ImmutableArray`1");

```

В метаданных вы определяете общие типы с бэк-киветами (') и числом общих параметров. Вот почему вы не видите "... ImmutableArray\<T>" в названии метаданных.

Семантической модели есть много полезных вещей на нем, которые позволяют задавать вопросы о символах, поток данных, переменной жизни и т.д. Рослин отделяет синтаксисные узлы от семантической модели по различным инженерным причинам (производительность, моделирование ошибочного кода и т.д.). Вы хотите, чтобы модель компиляции нанизала информацию, содержащуюся в ссылках для точного сравнения.

Можно перетащить желтую указатель исполнения на левую сторону окна редактора. Перетащите его до `objectCreation` линии, которая устанавливает переменную и перешагните через новую линию кода с помощью **F10.** Если вы наведите указатель `immutableArrayOfType`мыши над переменной, вы увидите, что мы нашли точный тип в семантической модели.

**Получите тип выражения создания объекта.** "Тип" используется в нескольких направлениях в этой статье, но это означает, что если у вас есть "новый Foo" выражение, вам нужно получить модель Foo. Необходимо получить тип выражения создания объекта, чтобы увидеть, является ли\<это типом ImmutableArray T>. Используйте семантические модели снова, чтобы получить информацию о символе для символа типа (ImmutableArray) в выражении создания объекта. Введите следующую строку кода в конце функции:

```csharp
var symbolInfo = context.SemanticModel.GetSymbolInfo(objectCreation.Type) as INamedTypeSymbol;

```

Поскольку анализатору необходимо обрабатывать неполный или неправильный код в `using` буферах редактора `symbolInfo` (например, есть недостающее заявление), следует проверить наличие. `null` Для завершения анализа необходимо получить тип имени (INamedTypeSymbol) от информационного объекта символа.

**Сравните типы.** Поскольку существует открытый общий тип T, который мы ищем, и тип в коде является конкретным общим типом, вы задавываете информацию о символах для того, из чего построен тип (открытый общий тип) и сравниваете этот результат с `immutableArrayOfTType`. Введите следующее в конце метода:

```csharp
if (symbolInfo != null &&
    symbolInfo.ConstructedFrom.Equals(immutableArrayOfTType))
{}
```

**Сообщите о диагностике.** Сообщение о диагностике довольно легко. В шаблоне проекта правило, созданное для вас, определяется перед методом Инициализации. Поскольку эта ситуация в коде является ошибкой, можно изменить `DiagnosticSeverity.Warning` строку, которая `DiagnosticSeverity.Error` инициализировала правило для замены (зеленый squiggle) с (красный squiggle). Остальная часть Правила инициализируется из ресурсов, которые вы редактировали в начале пошагового погони. Также необходимо сообщить о местоположении для squiggle, которое является расположением спецификации типа экспрессии создания объекта. Введите этот `if` код в блоке:

```csharp
context.ReportDiagnostic(Diagnostic.Create(Rule, objectCreation.Type.GetLocation()));
```

Ваша функция должна выглядеть следующим образом (возможно, отформатирована по-разному):

```csharp
private void AnalyzeObjectCreation(SyntaxNodeAnalysisContext context)
{
    var objectCreation = (ObjectCreationExpressionSyntax)context.Node;
    var immutableArrayOfTType =
        context.SemanticModel
               .Compilation
               .GetTypeByMetadataName(
                   "System.Collections.Immutable.ImmutableArray`1");
    var symbolInfo = context.SemanticModel.GetSymbolInfo(objectCreation.Type) as
        INamedTypeSymbol;
    if (symbolInfo != null &&
        symbolInfo.ConstructedFrom.Equals(immutableArrayOfTType))
    {
        context.ReportDiagnostic(
            Diagnostic.Create(Rule, objectCreation.Type.GetLocation()));
    }
}

```

Удалите точку разрыва, чтобы вы могли видеть работу анализатора (и перестаньте возвращаться в первую инстанцию Visual Studio). Перетащите указатель выполнения в начало метода и нажмите **F5,** чтобы продолжить выполнение. Когда вы переключитесь на второй экземпляр Visual Studio, компилятор снова начнет изучать код, и он будет вызываться в ваш анализатор. Вы можете увидеть squiggle под `ImmutableType<int>`.

## <a name="adding-a-code-fix-for-the-code-issue"></a>Добавление "Code Fix" для выпуска кода
Прежде чем начать, закройте второй экземпляр Visual Studio и прекратите отладку в первой инстанции Visual Studio (где вы разрабатываете анализатор).

**Добавьте новый класс.** Используйте меню ярлыка (кнопка указателя справа) на узле проекта в Solution Explorer и выберите добавить новый элемент. Добавить класс `BuildCodeFixProvider`под названием . Этот класс должен `CodeFixProvider`вытекать из, и вам нужно будет использовать **CTRL.** (период) для ввода исправления кода, которое добавляет правильное `using` утверждение. Этот класс также должен быть аннотирован с `ExportCodeFixProvider` атрибутом, `using` и вам `LanguageNames` нужно будет добавить заявление для решения enum. Вы должны иметь класс файл со следующим кодом в нем:

```csharp
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CodeFixes;

namespace ImmutableArrayAnalyzer
{
    [ExportCodeFixProvider(LanguageNames.CSharp)]
    class BuildCodeFixProvider : CodeFixProvider
    {}

```

**Заглушить производных членов.** Теперь поместите внимательность редактора в `CodeFixProvider` идентификатор и нажмите **CTRL.** (период), чтобы заглушить реализацию для этого абстрактного базового класса. Это создает свойство и метод для вас.

**Реализация свойства.** Заполните `FixableDiagnosticIds` `get` тело отеля следующим кодом:

```csharp
return ImmutableArray.Create(ImmutableArrayAnalyzerAnalyzer.DiagnosticId);
```

Roslyn объединяет диагностику и исправления, сопоставляя эти идентификаторы, которые являются всего лишь строками. Шаблон проекта создал для вас диагностический идентификатор, и вы можете изменить его. Код в свойстве просто возвращает идентификатор из класса анализатора.

**Метод RegisterCodeFixAsync имеет контекст.** Контекст важен, потому что исправление кода может применяться к нескольким диагностическим, или может быть несколько проблем на строке кода. При вводе "контекст". в теле метода список завершения Intellisense покажет вам несколько полезных членов. Есть участник CancellationToToken, который вы можете проверить, хочет ли что-то отменить исправление. Есть член документа, который имеет много полезных членов и позволяет перейти к объектам модели проекта и решения. Есть участник Span, который является началом и концом местоположения кода, указанного при сообщении о диагностике.

**Сделайте метод асин.** Первое, что вам нужно сделать, это `async` исправить заявление генерируемого метода, чтобы быть методом. Исправление кода для заглушения реализации абстрактного класса не включает `async` `Task`ключевое слово, даже если метод возвращает .

**Получите корень дерева синтаксиса.** Чтобы изменить код, необходимо создать новое дерево синтаксиса с изменениями, внесенными в исправление кода. Вам нужно `Document` из контекста, чтобы вызвать `GetSyntaxRootAsync`. Это метод асин, потому что есть неизвестная работа, чтобы получить дерево синтаксиса, возможно, включая получение файла с диска, его разбор и создание модели кода Roslyn для него. Визуальный разбивка должна быть отзывчивой в течение этого времени, что позволяет. `async` Замените строку кода в методе следующим:

```csharp
var root = await context.Document
                        .GetSyntaxRootAsync(context.CancellationToken);
```

**Найдите узла с проблемой.** Вы проходите в диапазоне контекста, но узел, который вы найдете, не может быть кодом, который вы должны изменить. Сообщаемые диагностики только при условии, промежуток для типа идентификатора (где `new` squiggle принадлежал), но вам нужно заменить все выражение создания объекта, в том числе keywoard в начале и скобки в конце. Добавьте следующий код в свой метод (и используйте **CTRL).** добавить `using` заявление `ObjectCreationExpressionSyntax`для):

```csharp

var objectCreation = root.FindNode(context.Span)
                         .FirstAncestorOrSelf<ObjectCreationExpressionSyntax>();
```

 **Зарегистрируйте код-фикс для ui-единомычня.** При регистрации кода, Roslyn подключается к утилите Visual Studio. Конечные пользователи увидят, что они могут использовать **CTRL.** (период), когда ваш анализатор завихряется плохое `ImmutableArray<T>` использование конструктора. Поскольку поставщик исправлений кода выполняет сядевидность только в том случае, если возникает проблема, можно предположить, что у вас есть выражение создания объекта, который вы искали. Из параметра контекста можно зарегистрировать новое исправление кода, `RegisterCodeFixAsync` добавив следующий код к концу метода:

```csharp

context.RegisterCodeFix(
            CodeAction.Create("Use ImmutableArray<T>.Empty",
                              c => ChangeToImmutableArrayEmpty(objectCreation,
                                                               context.Document,
                                                               c)),
            context.Diagnostics[0]);
```

Вам нужно поместить внимательность редактора в идентификатор, `CodeAction`затем используйте **CTRL.** (период), чтобы добавить соответствующее `using` заявление для этого типа.

Затем поместите внимательность редактора `ChangeToImmutableArrayEmpty` в идентификатор и используйте **CTRL.** снова, чтобы создать этот метод заглушки для вас.

Этот последний фрагмент кода, который вы добавили, регистрирует исправление кода, передавая `CodeAction` идентификатор диагностики для найденной проблемы. В этом примере есть только один диагностический идентификатор, для которого этот код предоставляет исправления, так что вы можете просто передать первый элемент массива диагностических идентификаторов. При `CodeAction`создании, вы передаете в тексте, что лампочка UI следует использовать в качестве описания кода исправить. Вы также проходите функцию, которая принимает CancellationToken и возвращает новый документ. Новый документ имеет новое дерево синтаксиса, `ImmutableArray.Empty`которое включает ваш исправленный код, который вызывает. В этом фрагменте кода используется лямбда, чтобы она сравнять сят-коннажт-объект и документ контекста.

**Постройте новое дерево синтаксиса.** В `ChangeToImmutableArrayEmpty` методе, заглушка которого вы создали `ImmutableArray<int>.Empty;`ранее, введите строку кода: . Если вы снова просмотрите окно инструмента Syntax Visualizer, то можно увидеть, что этот синтаксис является узелом SimpleMemberAccessExpression. Это то, что этот метод должен построить и вернуть в новом документе.

Первое изменение `ChangeToImmutableArrayEmpty` заключается `async` `Task<Document>` в добавлении раньше, потому что генераторы кода не могут предположить, что метод должен быть async.

Заполните тело следующим кодом, чтобы ваш метод был похож на следующее:

```csharp

private async Task<Document> ChangeToImmutableArrayEmpty(
    ObjectCreationExpressionSyntax objectCreation, Document document,
    CancellationToken c)
{
    var generator = SyntaxGenerator.GetGenerator(document);
    var memberAccess =
        generator.MemberAccessExpression(objectCreation.Type, "Empty");
    var oldRoot = await document.GetSyntaxRootAsync(c);
    var newRoot = oldRoot.ReplaceNode(objectCreation, memberAccess);
    return document.WithSyntaxRoot(newRoot);
}
```

Вам нужно будет поместить внимательность редактора `SyntaxGenerator` в идентификатор и использовать **CTRL.** (период), чтобы добавить соответствующее `using` заявление для этого типа.

Этот код `SyntaxGenerator`использует, который является очень полезным типом для построения нового кода. После получения генератора для документа, который `ChangeToImmutableArrayEmpty` имеет `MemberAccessExpression`проблему кода, звонки, прохождение типа, который имеет член мы хотим получить доступ и передачи имя члена в качестве строки.

Далее метод получает корень документа, и поскольку это может включать в себя произвольную работу в общем случае, код ждет этого вызова и передает маркер отмены. Модели кода Roslyn неизменяемы, например, работа со строкой .NET; при обновлении строки вы получаете новый объект строки взамен. Когда вы `ReplaceNode`звоните, вы получаете обратно новый корневой узла. Большая часть дерева синтаксиса является общим (потому что она неизменяема), но `objectCreation` узла заменяется `memberAccess` узлами, а также все родительские узлы до корня дерева синтаксиса.

## <a name="trying-your-code-fix"></a>Попытка исправить код
Теперь вы можете нажать **F5,** чтобы выполнить ваш анализатор во втором экземпляре Visual Studio. Откройте консольный проект, который вы использовали раньше. Теперь вы должны увидеть лампочку появляются, где ваш новый объект создания выражение для `ImmutableArray<int>`. Если вы нажмете **CTRL.** (период), то вы увидите ваш код исправить, и вы увидите автоматически генерируемых код разница предварительного просмотра в лампочка uI. Рослин создает это для тебя.

Pro Совет: Если вы запустите второй экземпляр Visual Studio, и вы не видите лампочки с кодом исправить, то вам может понадобиться, чтобы очистить компонент Visual Studio кэша. Очистка кэша заставляет Visual Studio пересмотреть компоненты, поэтому Visual Studio должна забрать ваш последний компонент. Во-первых, выключите второй экземпляр Visual Studio. Затем в Windows Explorer перейдите в каталог пользователей (c: «пользователи\\<userid)\>и найдите AppData-Местный(Microsoft)VisualStudio »14.0Roslyn\\. В этом каталоге удалите подкаталог ComponentModelCache. "14" меняет версию на версию с Visual Studio.

## <a name="talk-video-and-finish-code-project"></a>Обсуждение видео и закончить код проекта
Вы можете увидеть этот пример разработан и обсужден далее в [этом выступлении](https://channel9.msdn.com/events/Build/2015/3-725). Разговор демонстрирует рабочий анализатор и ведет вас через его строительство.

Вы можете увидеть все готового кода [здесь](https://github.com/DustinCampbell/CoreFxAnalyzers/tree/master/Source/CoreFxAnalyzers). Под папки DoNotUseImmutableArrayCollectionInitializer и DoNotUseImmutableArrayCtor каждый из них имеют файл C'е для поиска проблем и файл C, который реализует исправления кода, которые отображаются в visual Studio лампочка UI. Обратите внимание, что готовый код имеет немного больше абстракции, чтобы избежать извлечения объекта типа ImmutableArray\<T> снова и снова. Он использует вложенные зарегистрированные действия для сохранения объекта типа в контексте, который доступен всякий раз, когда выполняются действия подэлементного (анализ создания объектов и анализ инициализации собрания).

## <a name="see-also"></a>См. также:
[\\«Build 2015 говорить](https://channel9.msdn.com/events/Build/2015/3-725)
[Завершенный код на GitHub](https://github.com/DustinCampbell/CoreFxAnalyzers/tree/master/Source/CoreFxAnalyzers) 
[Несколько примеров на GitHub, сгруппированных в три вида анализаторов](https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Analyzer%20Samples.md) 
[Другие документы на сайте](https://github.com/dotnet/roslyn/tree/master/docs/analyzers) 
GitHub[OSS FxCop правила реализованы с Рослин анализаторов на GitHub](https://github.com/dotnet/roslyn/tree/master/src/Features/Core/Portable/Diagnostics/Analyzers)
