---
title: CA2006. Используйте SafeHandle для инкапсуляции машинных ресурсов | Документация Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-code-analysis
ms.topic: reference
f1_keywords:
- CA2006
- UseSafeHandleToEncapsulateNativeResources
helpviewer_keywords:
- UseSafeHandleToEncapsulateNativeResources
- CA2006
ms.assetid: a71950bd-bcc1-463d-b1f2-5233bc451456
caps.latest.revision: 19
author: gewarren
ms.author: gewarren
manager: wpickett
ms.openlocfilehash: dcf385263eba5a6012097f43b49e7a75166bad42
ms.sourcegitcommit: 94b3a052fb1229c7e7f8804b09c1d403385c7630
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "68154410"
---
# <a name="ca2006-use-safehandle-to-encapsulate-native-resources"></a>CA2006. Используйте SafeHandle для инкапсуляции собственных ресурсов
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

|||
|-|-|
|TypeName|UseSafeHandleToEncapsulateNativeResources|
|CheckId|CA2006|
|Категория|Microsoft.Reliability|
|Критическое изменение|Не критическое|

## <a name="cause"></a>Причина
 Управляемый код использует <xref:System.IntPtr> обратиться к собственным ресурсам.

## <a name="rule-description"></a>Описание правила
 Использование `IntPtr` в управляемом коде может свидетельствовать о потенциальных проблемах безопасности и надежности. Все случаи использования `IntPtr` необходимо изучить, чтобы определить ли использование <xref:System.Runtime.InteropServices.SafeHandle> , или аналогичную технологию, на его месте. Проблемы возникают в том случае, если `IntPtr` представляет некоторые машинный ресурс, например память, дескриптор файла или сокета, что управляемый код считается владельцем. Если управляемый код, которому принадлежит ресурс, он должен также освободить машинные ресурсы, связанные с ним, так как Невыполнение этого требования приведет утечки ресурсов.

 В таких случаях проблемы безопасности или надежности также будет существовать, если многопоточный доступ может быть `IntPtr` и способ освобождения ресурса, представленного `IntPtr` предоставляется. Эти проблемы связаны перезапуск с `IntPtr` значение освобождения ресурса во время одновременного использования ресурса выполняется в другом потоке. Это может привести к конкуренции, где один поток можно считывать или записывать данные, связанные с неправильный ресурс. Например, если дескриптор операционной системы, как хранение в типе `IntPtr` и позволяет пользователям следует вызвать оба **закрыть** и любой другой метод, использующий этот дескриптор одновременно и без какого-либо рода синхронизации, код содержит вторичное использование дескриптора проблема.

 Это проблема повторного использования дескриптора может привести к повреждению данных, а иногда и уязвимость системы безопасности. `SafeHandle` и его одноуровневый класс <xref:System.Runtime.InteropServices.CriticalHandle> предоставляют механизм для инкапсуляции собственный дескриптор для ресурса, так что можно избежать такой проблемы с потоками. Кроме того, можно использовать `SafeHandle` и того же уровня класса `CriticalHandle` для других проблем многопоточности, например, тщательно управление временем существования управляемых объектов, которые содержат копию собственный дескриптор через вызовы собственных методов. В этом случае его можно удалить вызовы `GC.KeepAlive`. Затратам на тайском языке производительности взимается при использовании `SafeHandle` и в меньшей степени `CriticalHandle`, часто можно сократить до тщательного проектирования.

## <a name="how-to-fix-violations"></a>Устранение нарушений
 Преобразовать `IntPtr` использования `SafeHandle` для безопасного управления неуправляемыми ресурсами. См. в разделе <xref:System.Runtime.InteropServices.SafeHandle> справочном разделе примеры.

## <a name="when-to-suppress-warnings"></a>Отключение предупреждений
 Не следует подавлять это предупреждение.

## <a name="see-also"></a>См. также
 <xref:System.IDisposable>
