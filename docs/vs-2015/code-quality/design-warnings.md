---
title: Создать предупреждения | Документация Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-code-analysis
ms.topic: conceptual
f1_keywords:
- vs.codeanalysis.designrules
helpviewer_keywords:
- design warnings
- managed code analysis warnings, design warnings
- warnings, design
ms.assetid: 34e65a18-560c-423f-814f-519089e318cf
caps.latest.revision: 27
author: jillre
ms.author: jillfra
manager: wpickett
ms.openlocfilehash: 16b44304dbfed49a72a19a15229f3e4754e0573e
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/02/2020
ms.locfileid: "72667664"
---
# <a name="design-warnings"></a>Предупреждения конструктора
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Предупреждения конструктора поддерживают соблюдение .NET Framework рекомендаций по проектированию.

## <a name="in-this-section"></a>в этом разделе

|Правило|Описание|
|----------|-----------------|
|[CA1000. Не объявляйте статические члены в универсальных типах](../code-quality/ca1000-do-not-declare-static-members-on-generic-types.md)|При вызове статического элемента универсального типа нужно указать аргумент этого типа. При вызове универсального экземпляра элемента, не поддерживающего вывод типа, для элемента нужно указать аргумент типа. В этих двух случаях синтаксис для определения аргумента типа различен, и его можно легко спутать.|
|[CA1001. Типы, которым принадлежат освобождаемые поля, должны быть освобождаемыми](../code-quality/ca1001-types-that-own-disposable-fields-should-be-disposable.md)|Класс объявляет и реализует поле экземпляра, которое является типом System. IDisposable, а класс не реализует IDisposable. Класс, в котором объявляется поле IDisposable, неявно владеет неуправляемым ресурсом и должен реализовывать интерфейс IDisposable.|
|[CA1002. Не предоставляйте универсальные списки](../code-quality/ca1002-do-not-expose-generic-lists.md)|System. Collections. Generic. List< (of \<(T> ) >) — это универсальная коллекция, предназначенная для повышения производительности, а не для наследования. Поэтому виртуальные элементы в списке отсутствуют. Вместо этого для наследования следует предоставить универсальную коллекцию.|
|[CA1003. Используйте экземпляры обработчика универсальных событий](../code-quality/ca1003-use-generic-event-handler-instances.md)|Тип содержит делегат, возвращающий значение void, сигнатура которого содержит два параметра (первый объект и второй тип, который может быть назначен EventArgs), и содержащий целевые объекты сборки [!INCLUDE[dnprdnlong](../includes/dnprdnlong-md.md)] .|
|[CA1004. Универсальные методы должны предоставлять параметр типа](../code-quality/ca1004-generic-methods-should-provide-type-parameter.md)|Вывод – это то, как аргумент типа универсального метода определяется по типу аргумента, переданного методу, а не по явному указанию аргумента типа. Чтобы задействовать вывод, сигнатура параметра универсального метода должна включать параметр, тип которого совпадает с параметром типа для метода. В этом случае аргумент типа указывать не обязательно. При использовании вывода для всех параметров типа синтаксис вызова универсальных и неуниверсальных методов экземпляра идентичен. Это упрощает удобство использования универсальных методов.|
|[CA1005. Не используйте слишком много параметров в универсальных типах](../code-quality/ca1005-avoid-excessive-parameters-on-generic-types.md)|Чем больше параметров типов содержит универсальный тип, тем сложнее знать и запоминать, что представляет каждый параметр типа. Обычно очевидно с одним параметром типа, как в списке \<T> , и в некоторых случаях с двумя параметрами типа, как в словаре \<TKey, TValue> . Если же используется более двух параметров типов, многие пользователи начинают испытывать большие трудности.|
|[CA1006. Не создавайте вложенные универсальные типы в сигнатурах членов](../code-quality/ca1006-do-not-nest-generic-types-in-member-signatures.md)|Аргумент вложенного типа также является аргументом универсального типа. Чтобы вызвать член, сигнатура которого содержит аргумент вложенного типа, пользователь должен создать экземпляр одного универсального типа и передать этот тип конструктору второго универсального типа. Это приводит к усложнению процедуры и синтаксиса, чего следует избегать.|
|[CA1007. По возможности используйте универсальные объекты](../code-quality/ca1007-use-generics-where-appropriate.md)|Видимый извне метод содержит ссылочный параметр типа System.Object. Использование универсального метода позволяет передавать в метод все типы без предварительного приведения к типу ссылочного параметра при условии выполнения некоторых ограничений.|
|[CA1008. Перечисляемые типы должны иметь нулевое значение](../code-quality/ca1008-enums-should-have-zero-value.md)|Значение по умолчанию неинициализированного перечисления, как и других типов значений, равно нулю. Перечисление без флагов должно определять член, используя нулевое значение, чтобы значение по умолчанию было допустимым значением перечисления. Если перечисление с примененным атрибутом FlagsAttribute определяет член с нулевым значением, для него должно быть задано имя None, свидетельствующее о том, что в перечислении не были заданы значения.|
|[CA1009. Правильно объявляйте обработчики событий](../code-quality/ca1009-declare-event-handlers-correctly.md)|Методы обработчиков событий принимают два параметра. Первый параметр принадлежит типу System.Object и называется "sender". Это объект, вызвавший событие. Второй параметр принадлежит типу System.EventArgs и называется "e". Это данные, связанные с событием. Методы обработки событий не должны возвращать значение; в языке программирования C# оно обозначается типом возвращаемого значения void.|
|[CA1010. Коллекции должны реализовать универсальный интерфейс](../code-quality/ca1010-collections-should-implement-generic-interface.md)|Чтобы расширить возможности использования коллекции, реализуйте один из универсальных интерфейсов коллекции. Затем данную коллекцию можно использовать для заполнения универсальных типов коллекции.|
|[CA1011. Попробуйте передать базовые типы в качестве параметров](../code-quality/ca1011-consider-passing-base-types-as-parameters.md)|Если в объявлении метода в качестве параметра указан базовый тип, любой тип, производный от базового, можно передать методу в качестве соответствующего аргумента. Если дополнительные функции, предоставляемые производным типом параметра, не требуются, то использование базового типа позволит более широко применять данный метод.|
|[CA1012. Абстрактные типы не должны иметь конструкторы](../code-quality/ca1012-abstract-types-should-not-have-constructors.md)|Конструкторы абстрактных типов могут быть вызваны только производными типами. Открытые конструкторы создают экземпляры типа. Невозможно создавать экземпляры абстрактного типа; абстрактный тип с открытым конструктором является недопустимым.|
|[CA1013. Перегружайте оператор равенства при перегрузке операторов сложения и вычитания](../code-quality/ca1013-overload-operator-equals-on-overloading-add-and-subtract.md)|Открытый или защищенный тип реализует операторы сложения или вычитания без реализации оператора равенства.|
|[CA1014. Пометьте сборки с помощью CLSCompliantAttribute](../code-quality/ca1014-mark-assemblies-with-clscompliantattribute.md)|Спецификация среды CLS определяет ограничения по именованию, типам данных и правилам, которым должны соответствовать сборки, предназначенные для использования в нескольких языках программирования. Хороший дизайн определяет, что все сборки явно указывают на совместимость с CLS с помощью CLSCompliantAttribute. Если этот атрибут у сборки отсутствует, сборка несовместима.|
|[CA1016. Пометьте сборки с помощью AssemblyVersionAttribute](../code-quality/ca1016-mark-assemblies-with-assemblyversionattribute.md)|.NET Framework использует номер версии для уникальной идентификации сборки и привязки к типам в сборках со строгими именами. Номер версии используется наряду с политикой версий и издателя. По умолчанию приложения выполняются только с версией сборки, которая использовалась для их построения.|
|[CA1017. Пометьте сборки с помощью ComVisibleAttribute](../code-quality/ca1017-mark-assemblies-with-comvisibleattribute.md)|Атрибут ComVisibleAttribute определяет порядок обращения клиентов COM к управляемому коду. Для правильной разработки сборки должны явным образом указывать видимость COM. Можно задать видимость COM для всей сборки, а затем переопределить ее для отдельных типов и элементов типов. Если атрибут отсутствует, содержимое сборки будет видимым клиентам COM.|
|[CA1018. Пометьте атрибуты с помощью AttributeUsageAttribute](../code-quality/ca1018-mark-attributes-with-attributeusageattribute.md)|При определении настраиваемого атрибута его нужно пометить атрибутом AttributeUsageAttribute, чтобы указать, где можно применять этот настраиваемый атрибут в исходном коде. Допустимое положение атрибута в коде зависит от значения атрибута и его применения.|
|[CA1019. Определите методы доступа для аргументов атрибута](../code-quality/ca1019-define-accessors-for-attribute-arguments.md)|Атрибуты могут определять обязательные аргументы, которые должны быть указаны при применении атрибута к целевому объекту. Они также известны как позиционные аргументы, поскольку предоставляются для конструкторов атрибутов в качестве позиционных параметров. Для каждого обязательного аргумента атрибут должен предоставлять соответствующее свойство, доступное только для чтения, чтобы извлечь значение аргумента во время выполнения. Кроме того, атрибуты могут определять дополнительные параметры, известные как именованные аргументы. Эти аргументы предоставляются для конструкторов атрибутов по имени и должны иметь соответствующее свойство чтения/записи.|
|[CA1020. Не используйте пространства имен с несколькими типами](../code-quality/ca1020-avoid-namespaces-with-few-types.md)|Убедитесь, что каждое из пространств имен имеет логическую организацию и что у вас есть допустимая причина для размещения типов в разреженном пространстве имен.|
|[CA1021. Не используйте параметры out](../code-quality/ca1021-avoid-out-parameters.md)|Для реализации передачи типов по ссылке (с помощью ключевого слова out или ref) от разработчика требуется опыт работы с указателями, понимание отличия между типами значения и ссылочными типами и умение работать с методами с несколькими возвращаемыми значениями. Кроме того, далеко не все понимают разницу между параметрами out и ref.|
|[CA1023. Индексы не должны быть многомерными](../code-quality/ca1023-indexers-should-not-be-multidimensional.md)|Для индексаторов (индексированных свойств) должен использоваться один индекс. Многомерные индексаторы могут крайне отрицательно сказаться на удобстве работы с библиотекой.|
|[CA1024. По возможности используйте свойства](../code-quality/ca1024-use-properties-where-appropriate.md)|Имя открытого или защищенного метода начинается с Get, он не принимает параметры и возвращает значение, не являющееся массивом. Возможно, этот метод лучше преобразовать в свойство.|
|[CA1025. Замените повторяющиеся аргументы массивом параметров](../code-quality/ca1025-replace-repetitive-arguments-with-params-array.md)|Если точное число аргументов неизвестно и эти аргументы принадлежат одному типу или могут быть переданы как аргументы одного типа, используйте вместо повторяющихся аргументов массив параметров.|
|[CA1026. Не следует использовать параметры по умолчанию](../code-quality/ca1026-default-parameters-should-not-be-used.md)|Методы, использующие параметры по умолчанию, разрешены по спецификации CLS; однако спецификация CLS разрешает компиляторам не учитывать значения, присвоенные этим параметрам. Для однородной работы с различными языками программирования следует заменять методы, использующие параметры по умолчанию, на перегрузки методов, предоставляющие параметры по умолчанию.|
|[CA1027. Пометьте перечисляемые типы с помощью FlagsAttribute](../code-quality/ca1027-mark-enums-with-flagsattribute.md)|Перечисление является типом значения, которое определяет набор связанных именованных констант. Атрибут FlagsAttribute применяется к перечислению, когда его именованные константы могут быть объединены осмысленным образом.|
|[CA1028. Хранилище перечисляемых типов должно относиться к типу Int32](../code-quality/ca1028-enum-storage-should-be-int32.md)|Перечисление является типом значения, которое определяет набор связанных именованных констант. По умолчанию для хранения значения константы используется тип данных System.Int32. Несмотря на то, что этот базовый тип можно изменить, он не является обязательным и не рекомендуется для большинства сценариев.|
|[CA1030. По возможности используйте события](../code-quality/ca1030-use-events-where-appropriate.md)|Данное правило отслеживает методы с именами, которые, как правило, используются для событий. Если метод вызывается в ответ на четко определенное изменение состояния, то этот вызов должен осуществляться с помощью обработчика событий. Объекты, вызывающие методы, должны создавать события, а не вызывать методы напрямую.|
|[CA1031. Не перехватывайте типы общих исключений](../code-quality/ca1031-do-not-catch-general-exception-types.md)|Общие исключения не должны перехватываться. Перехватите более конкретное исключение или повторно создайте общее исключение в качестве последней инструкции в блоке catch.|
|[CA1032. Реализуйте стандартные конструкторы исключений](../code-quality/ca1032-implement-standard-exception-constructors.md)|Для правильной обработки исключений необходимо предоставить полный набор конструкторов.|
|[CA1033. Методы интерфейса должны быть доступны для вызова дочерними типами](../code-quality/ca1033-interface-methods-should-be-callable-by-child-types.md)|Незапечатанный тип, доступный для внешнего кода, предоставляет явную реализацию метода открытого интерфейса и не предоставляет доступный для внешнего кода альтернативный метод с тем же именем.|
|[CA1034. Вложенные типы не должны быть видимыми](../code-quality/ca1034-nested-types-should-not-be-visible.md)|Вложенный тип — это тип, объявленный внутри области другого типа. Вложенные типы удобно использовать для инкапсуляции закрытых сведений о реализациях содержащего их типа. В силу этого вложенные типы не должны быть видимыми для внешнего кода.|
|[CA1035. В составе реализаций ICollection есть члены со строгим типом](../code-quality/ca1035-icollection-implementations-have-strongly-typed-members.md)|Это правило требует, чтобы реализации ICollection предоставляли строго типизированные элементы, поскольку тогда пользователям не придется приводить аргументы к типу Object при использовании функциональных возможностей интерфейса. В этом правиле предполагается, что тип, реализующий интерфейс ICollection, делает это для управления коллекцией экземпляров типа, более строгого, чем Object.|
|[CA1036. Переопределите методы в сопоставимых типах](../code-quality/ca1036-override-methods-on-comparable-types.md)|Открытый или защищенный тип реализует интерфейс System.IComparable. Он не переопределяет метод Object.Equals и не перегружает языковой оператор равенства, неравенства, "больше" или "меньше".|
|[CA1038. Перечислители должны иметь строгие типы](../code-quality/ca1038-enumerators-should-be-strongly-typed.md)|Это правило требует, чтобы реализации IEnumerator предоставляли строго типизированную версию свойства Current, поскольку тогда пользователям не придется приводить возвращаемое значение к строгому типу при использовании функциональных возможностей интерфейса.|
|[CA1039. Списки имеют строгие типы](../code-quality/ca1039-lists-are-strongly-typed.md)|Это правило требует, чтобы реализации IList предоставляли строго типизированные элементы, поскольку тогда пользователям не придется приводить аргументы к типу System.Object при использовании функциональных возможностей интерфейса.|
|[CA1040. Не используйте пустые интерфейсы](../code-quality/ca1040-avoid-empty-interfaces.md)|Интерфейсы определяют члены, предоставляющие поведение или соглашение об использовании. Функциональность, описанная интерфейсом, может быть использована любым типом вне зависимости от расположения типа в иерархии интерфейса. Тип реализует интерфейс путем предоставления реализаций для членов интерфейса. Пустой интерфейс не определяет никаких элементов, поэтому он не определяет контракт, который можно реализовать.|
|[CA1041. Укажите сообщение ObsoleteAttribute](../code-quality/ca1041-provide-obsoleteattribute-message.md)|Тип или элемент помечен атрибутом System.ObsoleteAttribute, для которого не указано свойство ObsoleteAttribute.Message. При компиляции типа или члена, помеченного с помощью атрибута ObsoleteAttribute, отображается свойство Message атрибута, которое предоставляет пользователю сведения об устаревшем типе или члене.|
|[CA1043. Используйте целый или строковый аргумент для индексаторов](../code-quality/ca1043-use-integral-or-string-argument-for-indexers.md)|Индексаторы (индексированные свойства) должны использовать для индекса целочисленные или строковые типы. Эти типы обычно используются для индексации структур данных и повышения удобства использования библиотеки. Тип Object следует использовать только в том случае, если во время разработки невозможно указать определенный целочисленный или строковый тип.|
|[CA1044. Свойства не должны быть доступными только для записи](../code-quality/ca1044-properties-should-not-be-write-only.md)|Несмотря на то, что допустимо, а часто и необходимо иметь свойство, доступное только на чтение, рекомендации по разработке запрещают использование свойств, доступных только на запись. Это связано с тем, что если позволить пользователю задать значение, а затем запретить ему просматривать это значение, то таким образом не будет обеспечиваться какая-либо безопасность. Кроме того, при отсутствии доступа на чтение нельзя просмотреть состояние общих объектов, что снижает их полезность.|
|[CA1045. Не передавайте типы по ссылке](../code-quality/ca1045-do-not-pass-types-by-reference.md)|Для реализации передачи типов по ссылке (с помощью ключевого слова out или ref) от разработчика требуется опыт работы с указателями, понимание отличия между типами значения и ссылочными типами и умение работать с методами с несколькими возвращаемыми значениями. Архитекторам, разрабатывающим библиотеки для широкого использования, не следует рассчитывать, что пользователи прекрасно разбираются в использовании параметров out и ref.|
|[CA1046. Не перегружайте оператор равенства для ссылочных типов](../code-quality/ca1046-do-not-overload-operator-equals-on-reference-types.md)|Реализация оператора равенства по умолчанию почти всегда правильно работает для ссылочных типов. По умолчанию две ссылки равны, если они указывают на один объект.|
|[CA1047. Не объявляйте защищенные члены в запечатанных типах](../code-quality/ca1047-do-not-declare-protected-members-in-sealed-types.md)|Типы объявляют защищенный члены таким образом, чтобы наследующие типы могли получить доступ к члену или переопределить его. По определению наследовать запечатанные типы нельзя; это означает, что вызов защищенных методов для запечатанных типов невозможен.|
|[CA1048. Не объявляйте виртуальные члены в запечатанных типах](../code-quality/ca1048-do-not-declare-virtual-members-in-sealed-types.md)|Типы объявляют методы как виртуальные, чтобы наследующие типы могли переопределять реализацию виртуального метода. По определению наследовать запечатанный тип нельзя. При этом виртуальный метод запечатанного типа теряет смысл.|
|[CA1049. Типы, которым принадлежат собственные ресурсы, должны быть освобождаемыми](../code-quality/ca1049-types-that-own-native-resources-should-be-disposable.md)|Типы, выделяющие неуправляемые ресурсы, должны реализовывать интерфейс IDisposable, чтобы вызывающие методы могли высвобождать эти ресурсы по требованию и сокращать время существования объектов, занимающих ресурсы.|
|[CA1050. Объявите типы в пространствах имен](../code-quality/ca1050-declare-types-in-namespaces.md)|Типы объявляются в пространствах имен во избежание конфликтов имен и с целью упорядочения связанных типов в иерархии объектов.|
|[CA1051. Не объявляйте видимые поля экземпляров](../code-quality/ca1051-do-not-declare-visible-instance-fields.md)|Поля главным образом следует использовать для данных реализации. Поля должны быть помечены как private или internal и должны быть представлены с помощью свойств.|
|[CA1052. Типы со статическими заполнителями должны быть запечатаны](../code-quality/ca1052-static-holder-types-should-be-sealed.md)|Открытый или защищенный тип содержит только статические члены и не объявляется с помощью модификатора sealed (C#) или NotInheritable (Visual Basic). Тип, для которого нельзя создавать унаследованные типы, должен быть помечен модификатором sealed, чтобы его нельзя было использовать как базовый тип.|
|[CA1053. Типы со статическими заполнителями не должны иметь конструкторы](../code-quality/ca1053-static-holder-types-should-not-have-constructors.md)|В открытом или вложенном открытом типе объявляются только статические элементы и имеется открытый или защищенный конструктор по умолчанию. Конструктор не нужен, поскольку при вызове статических членов не требуется экземпляр типа. Для обеспечения безопасности перегруженная строка должна вызывать перегрузку универсального кода ресурса (URI), используя строковый аргумент.|
|[CA1054. Параметры URI не должны быть строками](../code-quality/ca1054-uri-parameters-should-not-be-strings.md)|Если метод принимает строковое представление универсального кода ресурса (URI), необходимо предоставить соответствующую перегрузку, принимающую экземпляр класса URI, который предоставляет эти услуги безопасным образом.|
|[CA1055. Возвращаемые значения URI не должны быть строками](../code-quality/ca1055-uri-return-values-should-not-be-strings.md)|В этом правиле предполагается, что метод возвращает универсальный код ресурса (URI). В строковых представлениях кода URI часто встречаются ошибки синтаксического анализа и кодирования, которые могут привести к уязвимостям системы безопасности. Класс System.Uri предоставляет аналогичные услуги более надежным и безопасным способом.|
|[CA1056. Свойства URI не должны быть строками](../code-quality/ca1056-uri-properties-should-not-be-strings.md)|Это правило предполагает, что свойство представляет универсальный код ресурса (URI). В строковых представлениях кода URI часто встречаются ошибки синтаксического анализа и кодирования, которые могут привести к уязвимостям системы безопасности. Класс System.Uri предоставляет аналогичные услуги более надежным и безопасным способом.|
|[CA1057. Перегрузки строковых параметров URI вызывают перегрузки System.Uri](../code-quality/ca1057-string-uri-overloads-call-system-uri-overloads.md)|Тип объявляет перегрузки метода, которые отличаются только заменой строкового параметра на параметр System.Uri. Эта перегрузка, которая принимает строковый параметр, не вызывает перегрузку, которая принимает параметр URI.|
|[CA1058. Типы не должны расширять определенные базовые типы](../code-quality/ca1058-types-should-not-extend-certain-base-types.md)|Видимый извне тип расширяет некоторые базовые типы. Используйте только один вариант.|
|[CA1059. Члены не должны предоставлять определенные конкретные типы](../code-quality/ca1059-members-should-not-expose-certain-concrete-types.md)|Устойчивый тип – это тип, который имеет полную реализацию и экземпляр которого можно создать. Чтобы иметь возможность широкого использования этого элемента, замените конкретный тип предложенным интерфейсом.|
|[CA1060: перемещение P/Invoke в класс NativeMethods](../code-quality/ca1060-move-p-invokes-to-nativemethods-class.md)|Методы вызова платформы, такие как помечаются <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> методами или, определенными с помощью ключевого слова Declare в [!INCLUDE[vbprvb](../includes/vbprvb-md.md)] , обращаются к неуправляемому коду. Эти методы должны относиться к классу NativeMethods, SafeNativeMethods или UnsafeNativeMethods.|
|[CA1061. Не скрывайте методы базовых классов](../code-quality/ca1061-do-not-hide-base-class-methods.md)|Метод в базовом типе скрыт методом с таким же именем в производном типе. Сигнатура параметра производного метода отличается только типами, которые являются более слабыми, чем соответствующие типы в сигнатуре параметра базового метода.|
|[CA1062. Проверьте аргументы или открытые методы](../code-quality/ca1062-validate-arguments-of-public-methods.md)|Все ссылочные аргументы, передаваемые в видимые для внешнего кода методы, должны проверяться на равенство значению NULL.|
|[CA1063. Правильно реализуйте IDisposable](../code-quality/ca1063-implement-idisposable-correctly.md)|Все типы IDisposable должны правильно реализовывать шаблон "Dispose".|
|[CA1064. Исключения должны быть общими](../code-quality/ca1064-exceptions-should-be-public.md)|Внутреннее исключение видно только внутри своей внутренней области. После выхода исключения за пределы внутренней области для перехвата исключения можно использовать только базовое исключение. Если внутреннее исключение наследуется от <xref:System.Exception?displayProperty=fullName> , <xref:System.SystemException?displayProperty=fullName> или <xref:System.ApplicationException?displayProperty=fullName> , внешний код не будет иметь достаточных сведений, чтобы узнать, что делать с этим исключением.|
|[CA1065. Не вызывайте исключения в непредвиденных местах](../code-quality/ca1065-do-not-raise-exceptions-in-unexpected-locations.md)|Метод вызывает исключение, хотя не должен этого делать.|
|[CA2210. Сборки должны иметь допустимые строгие имена](../code-quality/ca2210-assemblies-should-have-valid-strong-names.md)|Строгое имя защищает клиентов от случайной загрузки сборки, которая была подменена. Сборки без строгих имен следует развертывать лишь в крайне небольшом числе случаев. При обмене или распространении сборок без правильной подписи сборки могут быть подменены, среда CLR может не загрузить сборку или пользователь может быть вынужден отключить проверку на своем компьютере.|
