---
title: 'CA1021: Избегайте вывода параметров | Документация Майкрософт'
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-code-analysis
ms.topic: reference
f1_keywords:
- CA1021
- AvoidOutParameters
helpviewer_keywords:
- AvoidOutParameters
- CA1021
ms.assetid: 970f2304-842c-4fb7-9734-f3871da8d479
caps.latest.revision: 21
author: jillre
ms.author: jillfra
manager: wpickett
ms.openlocfilehash: ea5d943212122672b84376b9b3ddf5e72bb0e81f
ms.sourcegitcommit: a8e8f4bd5d508da34bbe9f2d4d9fa94da0539de0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/19/2019
ms.locfileid: "72662003"
---
# <a name="ca1021-avoid-out-parameters"></a>CA1021: не используйте параметры out
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

|||
|-|-|
|TypeName|AvoidOutParameters|
|CheckId|CA1021|
|Категория|Microsoft. Design|
|Критическое изменение|Критическое|

## <a name="cause"></a>Причина
 Открытый или защищенный метод в открытом типе имеет параметр `out`.

## <a name="rule-description"></a>Описание правила
 Передача типов по ссылке (с использованием `out` или `ref`) требует взаимодействия с указателями, понимание того, как типы значений и ссылочные типы различаются, а также обработка методов с несколькими возвращаемыми значениями. Кроме того, различие между параметрами `out` и `ref` не является широко понятным.

 Когда ссылочный тип передается по ссылке, метод намеревается использовать параметр для возврата другого экземпляра объекта. Передача ссылочного типа по ссылке также называется использованием двойного указателя, указателя на указатель или двойного косвенного обращения. Используя соглашение о вызовах по умолчанию, которое передает "по значению", параметр, который принимает ссылочный тип, уже получает указатель на объект. Указатель, а не объект, на который он указывает, передается по значению. Передача по значению означает, что метод не может изменить указатель, чтобы он указывал на новый экземпляр ссылочного типа. Однако он может изменить содержимое объекта, на который он указывает. Для большинства приложений это достаточно и дает желаемое поведение.

 Если метод должен возвращать другой экземпляр, используйте для этого возвращаемое значение метода. См. класс <xref:System.String?displayProperty=fullName> для различных методов, которые работают с строками и возвращают новый экземпляр строки. При использовании этой модели вызывающий объект должен решить, сохраняется ли исходный объект.

 Хотя возвращаемые значения являются наиболее распространенными и часто используются, правильное применение `out` и `ref` параметров требует промежуточных навыков проектирования и программирования. Архитекторы библиотек, которые разрабатывает общую аудиторию, не должны ждать, чтобы пользователи работали с параметрами `out` или `ref`.

## <a name="how-to-fix-violations"></a>Устранение нарушений
 Чтобы устранить нарушение этого правила, вызванное типом значения, метод должен вернуть объект в качестве возвращаемого значения. Если метод должен возвращать несколько значений, перепроектирование его для возврата одного экземпляра объекта, содержащего значения.

 Чтобы устранить нарушение этого правила, вызванное ссылочным типом, убедитесь, что нужно вернуть новый экземпляр ссылки. Если это так, метод должен использовать его возвращаемое значение для этого.

## <a name="when-to-suppress-warnings"></a>Отключение предупреждений
 В этом правиле можно отключить вывод предупреждений. Однако такая схема может вызвать проблемы с удобством использования.

## <a name="example"></a>Пример
 В следующей библиотеке показаны две реализации класса, которые создают ответы на отзыв пользователя. Первая реализация (`BadRefAndOut`) заставляет пользователя библиотеки управлять тремя возвращаемыми значениями. Вторая реализация (`RedesignedRefAndOut`) упрощает взаимодействие с пользователем, возвращая экземпляр класса контейнера (`ReplyData`), который управляет данными как единым блоком.

 [!code-csharp[FxCop.Design.NoRefOrOut#1](../snippets/csharp/VS_Snippets_CodeAnalysis/FxCop.Design.NoRefOrOut/cs/FxCop.Design.NoRefOrOut.cs#1)]

## <a name="example"></a>Пример
 В следующем приложении показана работа пользователя. Вызов переработанной библиотеки (метод `UseTheSimplifiedClass`) более прост, и сведения, возвращаемые методом, легко управляются. Выходные данные двух методов идентичны.

 [!code-csharp[FxCop.Design.TestNoRefOrOut#1](../snippets/csharp/VS_Snippets_CodeAnalysis/FxCop.Design.TestNoRefOrOut/cs/FxCop.Design.TestNoRefOrOut.cs#1)]

## <a name="example"></a>Пример
 В следующем примере библиотеки показано, как используются параметры `ref` для ссылочных типов, и демонстрируется лучший способ реализации этой функции.

 [!code-csharp[FxCop.Design.RefByRefNo#1](../snippets/csharp/VS_Snippets_CodeAnalysis/FxCop.Design.RefByRefNo/cs/FxCop.Design.RefByRefNo.cs#1)]

## <a name="example"></a>Пример
 Следующее приложение вызывает каждый метод в библиотеке, чтобы продемонстрировать поведение.

 [!code-csharp[FxCop.Design.TestRefByRefNo#1](../snippets/csharp/VS_Snippets_CodeAnalysis/FxCop.Design.TestRefByRefNo/cs/FxCop.Design.TestRefByRefNo.cs#1)]

 В этом примере формируются следующие данные:

 **Изменение указателя, передаваемого по значению:** 
**12345** 
**12345** 
**изменение указателя, передаваемого по ссылке:** 
**12345** 
**12345 ABCD** 1**передачи по возвращаемому значению: **3**12345 ABCD**
## <a name="try-pattern-methods"></a>Методы шаблона try

### <a name="description"></a>Описание
 Методы, реализующие шаблон **Try \<Something >** , например <xref:System.Int32.TryParse%2A?displayProperty=fullName>, не вызывают это нарушение. В следующем примере показана структура (тип значения), реализующая метод <xref:System.Int32.TryParse%2A?displayProperty=fullName>.

### <a name="code"></a>Код
 [!code-csharp[FxCop.Design.TryPattern#1](../snippets/csharp/VS_Snippets_CodeAnalysis/FxCop.Design.TryPattern/cs/FxCop.Design.TryPattern.cs#1)]

## <a name="related-rules"></a>Связанные правила
 [CA1045: не передавайте типы по ссылке](../code-quality/ca1045-do-not-pass-types-by-reference.md)
