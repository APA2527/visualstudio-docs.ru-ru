---
title: Аннотирование режима блокировки | Документация Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-code-analysis
ms.topic: conceptual
f1_keywords:
- _Releases_nonreentrant_lock_
- _Lock_kind_mutex_
- _Lock_kind_critical_section_
- _Acquires_lock_
- _Releases_lock_
- _Has_lock_kind_
- _Releases_exclusive_lock_
- _Post_same_lock_
- _Requires_exclusive_lock_held_
- _Requires_shared_lock_held_
- _Lock_kind_semaphore_
- _Requires_lock_held_
- _Acquires_exclusive_lock_
- _Create_lock_level_
- _Acquires_nonreentrant_lock_
- _Releases_shared_lock_
- _Has_lock_level_
- _Lock_kind_spin_lock_
- _Requires_lock_not_held_
- _Acquires_shared_lock_
- _Requires_no_locks_held_
- _Lock_level_order_
- _Lock_kind_event_
ms.assetid: 07769c25-9b97-4ab7-b175-d1c450308d7a
caps.latest.revision: 11
author: corob-msft
ms.author: corob
manager: jillfra
ms.openlocfilehash: 00d3c90ce7e21ab4e9852ed937481103c351609b
ms.sourcegitcommit: 68f893f6e472df46f323db34a13a7034dccad25a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/15/2020
ms.locfileid: "77271587"
---
# <a name="annotating-locking-behavior"></a>Аннотация поведения блокировки
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Во избежание ошибок параллелизма в многопоточных программах, всегда выполняйте соответствующую дисциплину блокировок и используйте заметки SAL.  
  
 Ошибки параллелизма, как известно, трудно воспроизвести, распознать и отладить в силу случайного характера их проявления. Рассуждение о последовательности потоков в лучшем случае представляется трудным и становится непрактичным при разработке основной части кода с более чем несколькими потоками. Поэтому рекомендуется следовать дисциплине блокировки в многопоточных программах. Например, проработка порядка блокировки при множественном захвате блокировок помогает избежать взаимоблокировок, а приобретение защитной блокировки до получения доступа к общему ресурсу помогает избежать состояния гонок.  
  
 К сожалению, простым на первый взгляд правилам блокировки удивительно сложно следовать на практике. Фундаментальным ограничением в современных языках программирования и компиляторами является то, что они не поддерживают спецификацию и анализ требований параллелизма напрямую. Программисты должны полагаться на неофициальные комментарии к коду для выражения своих намерений о том, как они используют блокировки.  
  
 Заметки SAL параллелизма предназначены для помощи в определении побочных эффектов блокировки, ответственности за блокировку, владения данными, иерархии порядка блокировки и другого ожидаемого поведения блокировки. Выполняя неявные правила явно, заметки SAL параллелизма предоставляют последовательный способ для документирования того, как код использует правила блокировки. Заметки параллелизма также расширяют возможности средств анализа кода для поиска условий гонки, взаимоблокировки, несоответствующих операций синхронизации и других неявных ошибок параллелизма.  
  
## <a name="general-guidelines"></a>Общие рекомендации  
 Используя аннотации, вы можете формулировать договоры, которые неявно выражены определениями функций, между реализациями (вызываемыми объектами) и клиентами (вызывающими объектами), а также задавать инварианты и другие свойства программы, которые впоследствии могут повысить эффективность анализа.  
  
 SAL поддерживает множество различных типов примитивов блокирования, таких как критические секции, мьютексы, спин-блокировки и другие объекты ресурсов. Многие аннотации параллелизма принимают в качестве параметра выражение блокировки. По соглашению блокировка обозначается выражением пути базового объекта блокировки.  
  
 Некоторые правила учета владения потоком, которые следует помнить постоянно:  
  
- Спин-блокировки являются несчитающими блокировками, у которых есть определенный поток-владелец.  
  
- Мьютексы и критические секции являются считающими блокировками, у которых есть определенный поток-владелец.  
  
- Семафоры и события являются считающими блокировками, не имеющими определенного потока-владельца.  
  
## <a name="locking-annotations"></a>Блокировка заметок  
 В следующей таблице перечислены заметки о блокировке.  
  
|Заметка|Description|  
|----------------|-----------------|  
|`_Acquires_exclusive_lock_(expr)`|Добавляет заметки к функции и указывает, что функция после вызова увеличивает на единицу число монопольных блокировок объекта блокировок с именем `expr`.|  
|`_Acquires_lock_(expr)`|Аннотирует функцию и указывает, что функция после вызова увеличивает на единицу число блокировок объекта блокировок с именем `expr`.|  
|`_Acquires_nonreentrant_lock_(expr)`|Блокировка с именем `expr` получена.  Возникает ошибка, если блокировка уже захвачена.|  
|`_Acquires_shared_lock_(expr)`|Аннотирует функцию и указывает, что функция после вызова увеличивает на единицу число общих блокировок объекта блокировок с именем `expr`.|  
|`_Create_lock_level_(name)`|Оператор, который объявляет символ `name` символом уровня блокировки, благодаря чему он может быть использован в аннотациях `_Has_Lock_level_` и `_Lock_level_order_`.|  
|`_Has_lock_kind_(kind)`|Закомментировать любой объект, чтобы уточнить сведения о типе объекта ресурса. Иногда для различных типов ресурсов используется общий тип, а перегруженный тип недостаточно для различения семантических требований между различными ресурсами. Ниже представлен список предварительно определенных параметров `kind`:<br /><br /> `_Lock_kind_mutex_`<br /> Идентификатор типа блокировки для мьютексов.<br /><br /> `_Lock_kind_event_`<br /> Идентификатор типа блокировки для событий.<br /><br /> `_Lock_kind_semaphore_`<br /> Идентификатор типа блокировки для семафоров.<br /><br /> `_Lock_kind_spin_lock_`<br /> Идентификатор типа блокировки для спин блокировок.<br /><br /> `_Lock_kind_critical_section_`<br /> Идентификатор типа блокировки для критических секций.|  
|`_Has_lock_level_(name)`|Аннотирует объект блокировки и присваивает ему уровень блокировки `name`.|  
|`_Lock_level_order_(name1, name2)`|Инструкция, которая обеспечивает порядок блокировки между `name1` и `name2`.|  
|`_Post_same_lock_(expr1, expr2)`|Аннотирует функцию и указывает, что в состоянии выполнения две блокировки, `expr1` и `expr2`, рассматриваются таким образом, как если бы они были одним и тем же объектом блокировки.|  
|`_Releases_exclusive_lock_(expr)`|Добавляет заметки к функции и указывает, что функция после вызова уменьшает на единицу число монопольных блокировок объекта блокировок с именем `expr`.|  
|`_Releases_lock_(expr)`|Аннотирует функцию и указывает, что функция после вызова уменьшает на единицу число блокировок объекта блокировок с именем `expr`.|  
|`_Releases_nonreentrant_lock_(expr)`|Блокировка с именем `expr` снята. Возникает ошибка, если блокировка на данный момент не захвачена.|  
|`_Releases_shared_lock_(expr)`|Аннотирует функцию и указывает, что функция после вызова уменьшает на единицу число общих блокировок объекта блокировок с именем `expr`.|  
|`_Requires_lock_held_(expr)`|Аннотирует функцию и указывает, что перед вызовом функции количество блокировок объекта с именем `expr` не менее единицы.|  
|`_Requires_lock_not_held_(expr)`|Добавляет заметки к функции и указывает, что перед вызовом функции количество блокировок объекта с именем `expr` равно нулю.|  
|`_Requires_no_locks_held_`|Аннотирует функцию и указывает, что количество блокировок на всех объектах блокировки равно нулю.|  
|`_Requires_shared_lock_held_(expr)`|Аннотирует функцию и указывает, что перед вызовом функции количество общих блокировок объекта с именем `expr` не менее единицы.|  
|`_Requires_exclusive_lock_held_(expr)`|Добавляет заметки к функции и указывает, что перед вызовом функции количество монопольных блокировок объекта с именем `expr` не менее единицы.|  
  
## <a name="sal-intrinsics-for-unexposed-locking-objects"></a>Встроенные SAL для непредоставленных явно объектов блокировки  
 Некоторые объекты блокировки не предоставляются реализацией связанных функций блокировки.  В следующей таблице перечислены встроенные переменные SAL, которые содержат заметки для функций, действующих на эти защищенные объекты блокировки.  
  
|Заметка|Description|  
|----------------|-----------------|  
|`_Global_cancel_spin_lock_`|Описывает отмену спин-блокировки.|  
|`_Global_critical_region_`|Описывает критическую область.|  
|`_Global_interlock_`|Описывает блокируемые операции.|  
|`_Global_priority_region_`|Описывает область приоритета.|  
  
## <a name="shared-data-access-annotations"></a>Общие заметки о доступе к данным  
 В следующей таблице перечисляются аннотации для доступа к разделяемым данным.  
  
|Заметка|Description|  
|----------------|-----------------|  
|`_Guarded_by_(expr)`|Добавляет заметки к переменной и указывает на то, что при доступе к данной переменной количество блокировок объекта с именем `expr` не менее единицы.|  
|`_Interlocked_`|Добавляет заметки к переменной и эквивалентен `_Guarded_by_(_Global_interlock_)`.|  
|`_Interlocked_operand_`|Параметр функции с заметками является целевым операндом одной из различных взаимоблокированных функций.  Эти операнды должны иметь определенные дополнительные свойства.|  
|`_Write_guarded_by_(expr)`|Добавляет заметки к переменной и указывает на то, что при изменении данной переменной количество блокировок объекта с именем `expr` не менее единицы.|  
  
## <a name="see-also"></a>См. также:  
 [Использование аннотаций SAL для сокращения дефектов C/C++ Code](../code-quality/using-sal-annotations-to-reduce-c-cpp-code-defects.md)   
 [Основные сведения о SAL](../code-quality/understanding-sal.md)   
 [Добавление заметок к параметрам и возвращаемым значениям функций](../code-quality/annotating-function-parameters-and-return-values.md)   
 [Аннотирование поведения функций](../code-quality/annotating-function-behavior.md)   
 [Добавление заметок к структурам и классам](../code-quality/annotating-structs-and-classes.md)   
 [Указание времени и места применения заметки](../code-quality/specifying-when-and-where-an-annotation-applies.md)   
 [Встроенные функции](../code-quality/intrinsic-functions.md)   
 Рекомендации [и примеры](../code-quality/best-practices-and-examples-sal.md)   
 [Блог команды разработчиков анализа кода](https://blogs.msdn.com/b/codeanalysis/)
