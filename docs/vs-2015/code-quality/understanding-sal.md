---
title: Основные сведения о SAL | Документация Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-code-analysis
ms.topic: conceptual
ms.assetid: a94d6907-55f2-4874-9571-51d52d6edcfd
caps.latest.revision: 20
author: mikeblome
ms.author: mblome
manager: jillfra
ms.openlocfilehash: 0a898096c282a22201d60995693144cc0e187812
ms.sourcegitcommit: 47eeeeadd84c879636e9d48747b615de69384356
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "63435403"
---
# <a name="understanding-sal"></a>Основные сведения о языке SAL
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Языка заметок исходного кода (SAL) для Microsoft предоставляет набор заметок, которые можно использовать для описания того, как функция использует свои параметры, какие предположения о них она делает и гарантии предоставляет при завершении. Примечания определены в файле заголовка `<sal.h>`. Для изменения анализа функций анализа кода Visual Studio для C++ использует примечания SAL. Дополнительные сведения о SAL 2.0 для разработки драйверов Windows, см. в разделе [заметок SAL 2.0 для Windows драйверы](http://go.microsoft.com/fwlink/?LinkId=250979).  
  
 В собственном коде C и C++ обеспечивают только ограниченной для разработчиков постоянно выразить намерение и неизменность. С помощью заметки SAL, можно описать функций более подробно, что разработчикам, использующим их можно лучше понять их использование.  
  
## <a name="what-is-sal-and-why-should-you-use-it"></a>Что такое SAL и почему ее следует использовать?  
 Проще говоря, SAL — это недорогое позвольте компилятору проверки кода.  
  
### <a name="sal-makes-code-more-valuable"></a>SAL делает код более ценным  
 SAL может помочь сделать проект код более понятным, как для пользователей, так и для средств анализа кода. Рассмотрим следующий пример, показывающий функция времени выполнения C `memcpy`:  
  
```cpp  
  
void * memcpy(  
   void *dest,   
   const void *src,   
   size_t count  
);  
  
```  
  
 Узнать, что делает эту функцию? Когда функция реализации, или вызывается, чтобы обеспечить правильность программы должны поддерживаться некоторые свойства. Лишь взглянув на объявление, подобное показанному в примере, вы не знаете, что это такое. Без заметки SAL пришлось бы полагаться на документацию или комментарии к коду. Вот какие в документации MSDN для `memcpy` говорит:  
  
> «Копирует количество байтов src в указанное место. Если источника и назначения перекрываются, поведение memcpy не определено. Используйте memmove для обработки перекрывающихся областей.   
> **Примечание о безопасности.** Убедитесь в том, что буфер назначения равен или превосходит по размеру исходный буфер. Дополнительные сведения см. в разделе как избежать переполнения буфера.»  
  
 Документация содержит несколько битов сведений, которые предполагают, что код должен поддерживать определенные свойства, чтобы обеспечить правильность программы:  
  
- `memcpy` Копирует `count` байтов из исходного буфера в буфер назначения.  
  
- Буфер назначения должен быть по крайней мере в исходный буфер.  
  
  Однако компилятору не удается прочитать в документации или неофициальные комментарии. Он не знает, что имеется отношение между 2 буферами и `count`, и его также невозможно подобрать эффективно об отношении. SAL может большей наглядностью о свойствах и реализации функции, как показано ниже:  
  
```cpp  
  
void * memcpy(  
   _Out_writes_bytes_all_(count) void *dest,   
   _In_reads_bytes_(count) const void *src,   
   size_t count  
);  
```  
  
 Обратите внимание на то, что эти заметки напоминают сведения в документации MSDN, но они являются более краткими, и они следуют семантической модели. Когда вы читаете этот код, может быстро подобрать свойств этой функции и как избежать проблем безопасности переполнение буфера. Более того семантических шаблонов, предоставляемых SAL может повысить эффективность средств анализа кода автоматических в раннее обнаружение потенциальных ошибок. Представьте, что кто-то записывает ошибками реализация `wmemcpy`:  
  
```cpp  
  
wchar_t * wmemcpy(  
   _Out_writes_all_(count) wchar_t *dest,   
   _In_reads_(count) const wchar_t *src,   
   size_t count)  
{  
   size_t i;  
   for (i = 0; i <= count; i++) { // BUG: off-by-one error  
      dest[i] = src[i];  
   }  
   return dest;  
}  
  
```  
  
 Эта реализация содержит распространенной ошибкой из за другой. К счастью, автор кода включает размер буфера SAL-аннотации — это средство анализа кода может обработать ошибку путем анализа только этой функции.  
  
### <a name="sal-basics"></a>Основные сведения о SAL  
 SAL определяет четыре основные типа параметров, классифицированные по шаблону использования.  
  
|Категория|Аннотация параметра|Описание|  
|--------------|--------------------------|-----------------|  
|**Входные данные для вызова функции**|`_In_`|Данные вызываемой функции передается и обрабатывается как доступный только для чтения.|  
|**Входные данные для вызвал функцию и вывода вызывающего объекта**|`_Inout_`|Полезные данные, передается в функцию, а потенциально изменяется.|  
|**Выходные данные для вызывающего объекта**|`_Out_`|Вызывающий объект предоставляет только пространство для вызываемой функции для записи. Вызываемая функция записывает данные в этой области.|  
|**Указатель на вызывающий объект выходные данные**|`_Outptr_`|Как и **выходные данные вызывающему**. Значение, которое возвращается вызываемая функция является указателем.|  
  
 Эти четыре основные заметки явными могут стать более различными способами. По умолчанию с заметками указатель предполагается, что параметры обязательным — они должны иметь значение NULL для успешного выполнения функции. Наиболее часто используемые разновидность основные заметки указывает, что необязательный параметр-указатель, если он имеет значение NULL, функция по-прежнему добиться успеха в его работу.  
  
 В этой таблице показано, как различать обязательные и необязательные параметры:  
  
||Параметры являются обязательными|Параметры являются необязательными|  
|-|-----------------------------|-----------------------------|  
|**Входные данные для вызова функции**|`_In_`|`_In_opt_`|  
|**Входные данные для вызвал функцию и вывода вызывающего объекта**|`_Inout_`|`_Inout_opt_`|  
|**Выходные данные для вызывающего объекта**|`_Out_`|`_Out_opt_`|  
|**Указатель на вызывающий объект выходные данные**|`_Outptr_`|`_Outptr_opt_`|  
  
 Эти заметки для выявления возможных значений неинициализированный и недопустимый указатель null использует формальные и точным способом. Передача NULL для обязательного параметра может привести к сбою или может вызвать с кодом ошибки «сбой», должны быть возвращены. В любом случае функция не может успешно выполнять свою работу.  
  
## <a name="sal-examples"></a>Примеры SAL  
 В этом разделе показаны примеры кода для основных заметки SAL.  
  
### <a name="using-the-visual-studio-code-analysis-tool-to-find-defects"></a>С помощью средства анализа кода в Visual Studio для поиска дефектов  
 В примерах средство анализа кода Visual Studio используется вместе с аннотаций SAL для поиска дефектов кода. Вот как это сделать.  
  
##### <a name="to-use-visual-studio-code-analysis-tools-and-sal"></a>Использование средств анализа кода Visual Studio и SAL  
  
1. В Visual Studio откройте проект C++, который содержит примечания SAL.  
  
2. В строке меню выберите **построения**, **выполнить анализ кода в решении**.  
  
    Рассмотрите возможность \_в\_ пример в этом разделе. Это предупреждение отображается, если для выполнения анализа кода для:  
  
   > **C6387 Недопустимое значение**   
   > «выберите команду» может быть "0": это не соответствует спецификации функции «InCallee».  
  
### <a name="example-the-in-annotation"></a>Пример \_В\_ заметки  
 `_In_` Заметка указывает, что:  
  
- Параметр должен быть допустимым и не будет изменен.  
  
- Функция считает только из одного элемента буфера.  
  
- Вызывающий должен предоставить буфер и инициализировать его.  
  
- `_In_` Указывает «только для чтения». Распространенной ошибкой является применение `_In_` к параметру, который должен иметь `_Inout_` заметки вместо этого.  
  
- `_In_` допускается, но игнорируется анализатора в скалярных величин не являющихся указателями.  
  
```cpp  
void InCallee(_In_ int *pInt)  
{  
   int i = *pInt;  
}  
  
void GoodInCaller()  
{  
   int *pInt = new int;  
   *pInt = 5;  
  
   InCallee(pInt);  
   delete pInt;     
}  
  
void BadInCaller()  
{  
   int *pInt = NULL;  
   InCallee(pInt); // pInt should not be NULL  
}  
  
```  
  
 При использовании анализа кода Visual Studio в этом примере выполняется проверка, что вызывающие объекты передать указатель ненулевой инициализированный буфер для `pInt`. В этом случае `pInt` указатель не может иметь значение NULL.  
  
### <a name="example-the-inopt-annotation"></a>Пример \_In_opt\_ заметки  
 `_In_opt_` совпадает со значением `_In_`, за исключением того, что входной параметр может быть NULL, и, таким образом, функцию следует проверить это.  
  
```cpp  
  
void GoodInOptCallee(_In_opt_ int *pInt)  
{  
   if(pInt != NULL) {  
      int i = *pInt;  
   }  
}  
  
void BadInOptCallee(_In_opt_ int *pInt)  
{  
   int i = *pInt; // Dereferencing NULL pointer ‘pInt’  
}  
  
void InOptCaller()  
{  
   int *pInt = NULL;  
   GoodInOptCallee(pInt);  
   BadInOptCallee(pInt);  
}  
  
```  
  
 Анализа кода Visual Studio проверяет, что функция проверяет наличие NULL перед обращением к буфера.  
  
### <a name="example-the-out-annotation"></a>Пример \_Out\_ заметки  
 `_Out_` поддерживает распространенный сценарий, в котором указатель отличное от NULL, который указывает на элемент буфер передается в, а функция инициализирует элемент. У вызывающего объекта отсутствует инициализации буфера перед вызовом; вызываемая функция обещает инициализируйте его, прежде чем вернуть.  
  
```cpp  
  
void GoodOutCallee(_Out_ int *pInt)  
{  
   *pInt = 5;  
}  
  
void BadOutCallee(_Out_ int *pInt)  
{  
   // Did not initialize pInt buffer before returning!  
}  
  
void OutCaller()  
{  
   int *pInt = new int;  
   GoodOutCallee(pInt);  
   BadOutCallee(pInt);  
   delete pInt;  
}  
  
```  
  
 Средство анализа кода Visual Studio проверяет, что вызывающий объект передает НЕНУЛЕВОЙ указатель на буфер для `pInt` и что до возвращения функцией инициализируется буфер.  
  
### <a name="example-the-outopt-annotation"></a>Пример \_Out_opt\_ заметки  
 `_Out_opt_` совпадает со значением `_Out_`, за исключением того, что параметр может иметь значение NULL, и, таким образом, функцию следует проверить это.  
  
```cpp  
  
void GoodOutOptCallee(_Out_opt_ int *pInt)  
{  
   if (pInt != NULL) {  
      *pInt = 5;  
   }  
}  
  
void BadOutOptCallee(_Out_opt_ int *pInt)  
{  
   *pInt = 5; // Dereferencing NULL pointer ‘pInt’  
}  
  
void OutOptCaller()  
{  
   int *pInt = NULL;  
   GoodOutOptCallee(pInt);  
   BadOutOptCallee(pInt);  
}  
  
```  
  
 Анализа кода Visual Studio проверяет, что эта функция проверяет наличие NULL перед `pInt` разыменовано и если `pInt` не равно NULL, что буфер инициализируется с помощью функции перед возвратом.  
  
### <a name="example-the-inout-annotation"></a>Пример \_Inout\_ заметки  
 `_Inout_` используется для добавления заметок к параметр-указатель, который может быть изменен с помощью функции. Указатель должен указывать на допустимый инициализированные данные перед вызовом, и даже, если он изменяется, по-прежнему должен иметь допустимое значение при возвращении. Заметка указывает, что функция может свободно чтение и запись в буфер одного элемента. Вызывающий должен предоставить буфер и инициализировать его.  
  
> [!NOTE]
> Как и `_Out_`, `_Inout_` необходимо применить к изменяемое значение.  
  
```cpp  
  
void InOutCallee(_Inout_ int *pInt)  
{  
   int i = *pInt;  
   *pInt = 6;  
}  
  
void InOutCaller()  
{  
   int *pInt = new int;  
   *pInt = 5;  
   InOutCallee(pInt);  
   delete pInt;  
}  
  
void BadInOutCaller()  
{  
   int *pInt = NULL;  
   InOutCallee(pInt); // ‘pInt’ should not be NULL  
}  
  
```  
  
 Анализа кода Visual Studio проверяет, что вызывающие объекты передать указатель отличное от NULL, инициализированный буфер для `pInt`и, прежде чем возвращении `pInt` по-прежнему отлично от NULL и инициализируется буфер.  
  
### <a name="example-the-inoutopt-annotation"></a>Пример \_Inout_opt\_ заметки  
 `_Inout_opt_` совпадает со значением `_Inout_`, за исключением того, что входной параметр может быть NULL, и, таким образом, функцию следует проверить это.  
  
```cpp  
  
void GoodInOutOptCallee(_Inout_opt_ int *pInt)  
{  
   if(pInt != NULL) {  
      int i = *pInt;  
      *pInt = 6;  
   }  
}  
  
void BadInOutOptCallee(_Inout_opt_ int *pInt)  
{  
   int i = *pInt; // Dereferencing NULL pointer ‘pInt’  
   *pInt = 6;  
}  
  
void InOutOptCaller()  
{  
   int *pInt = NULL;  
   GoodInOutOptCallee(pInt);  
   BadInOutOptCallee(pInt);  
}  
  
```  
  
 Анализа кода Visual Studio проверяет, что эта функция проверяет наличие NULL перед обращением к буфера и в том случае, если `pInt` не равно NULL, что буфер инициализируется с помощью функции перед возвратом.  
  
### <a name="example-the-outptr-annotation"></a>Пример \_Outptr\_ заметки  
 `_Outptr_` используется для добавления заметок к параметру, который предназначен для возврата указателя.  Сам параметр не должен иметь значение NULL и вызываемая функция возвращает указатель отличное от NULL, в нем, и этот указатель указывает на инициализированные данные.  
  
```cpp  
  
void GoodOutPtrCallee(_Outptr_ int **pInt)  
{  
   int *pInt2 = new int;  
   *pInt2 = 5;  
  
   *pInt = pInt2;  
}  
  
void BadOutPtrCallee(_Outptr_ int **pInt)  
{  
   int *pInt2 = new int;  
   // Did not initialize pInt buffer before returning!  
   *pInt = pInt2;  
}  
  
void OutPtrCaller()  
{  
   int *pInt = NULL;  
   GoodOutPtrCallee(&pInt);  
   BadOutPtrCallee(&pInt);  
}  
  
```  
  
 Анализа кода Visual Studio проверяет, что вызывающий объект передает указатель отличное от NULL `*pInt`, и что до возвращения функцией инициализируется буфер.  
  
### <a name="example-the-outptropt-annotation"></a>Пример \_Outptr_opt\_ заметки  
 `_Outptr_opt_` совпадает со значением `_Outptr_`, за исключением того, что параметр является необязательным, вызывающий объект может передавать указатель NULL для параметра.  
  
```cpp  
  
void GoodOutPtrOptCallee(_Outptr_opt_ int **pInt)  
{  
   int *pInt2 = new int;  
   *pInt2 = 6;  
  
   if(pInt != NULL) {  
      *pInt = pInt2;  
   }  
}  
  
void BadOutPtrOptCallee(_Outptr_opt_ int **pInt)  
{  
   int *pInt2 = new int;  
   *pInt2 = 6;  
   *pInt = pInt2; // Dereferencing NULL pointer ‘pInt’  
}  
  
void OutPtrOptCaller()  
{  
   int **ppInt = NULL;  
   GoodOutPtrOptCallee(ppInt);  
   BadOutPtrOptCallee(ppInt);  
}  
  
```  
  
 Анализа кода Visual Studio проверяет, что эта функция проверяет наличие NULL перед `*pInt` разыменовано, и что до возвращения функцией инициализируется буфер.  
  
### <a name="example-the-success-annotation-in-combination-with-out"></a>Пример \_Успех\_ заметки в сочетании с \_Out\_  
 Заметки могут применяться для большинства объектов.  В частности можно добавить заметку всей функции.  Одной из наиболее очевидных характеристик функции является, что ее выполнение или сбой. Но как ассоциации между буфера и его размером, не может представлять C/C++, функция успех или неудачу. С помощью `_Success_` заметки, можно сказать, для функции цель.  Параметр `_Success_` заметки — это просто, если он имеет значение true указывает успешное функция выражение. Выражение может быть все, что средство синтаксического анализа заметки можно обрабатывать. Последствия заметки после возвращения функции применяются только в случае, если функция выполняется успешно. В этом примере показано, как `_Success_` взаимодействует с `_Out_` делать правильно. Можно использовать ключевое слово `return` для представления возвращаемое значение.  
  
```cpp  
  
_Success_(return != false) // Can also be stated as _Success_(return)  
bool GetValue(_Out_ int *pInt, bool flag)  
{  
   if(flag) {  
      *pInt = 5;  
      return true;  
   } else {  
      return false;  
   }  
}  
  
```  
  
 `_Out_` Заметки вызывает анализа кода Visual Studio для проверки, что вызывающий объект передает НЕНУЛЕВОЙ указатель на буфер для `pInt`, и что до возвращения функцией инициализируется буфер.  
  
## <a name="sal-best-practice"></a>Рекомендуется SAL  
  
### <a name="adding-annotations-to-existing-code"></a>Добавление заметок для существующего кода  
 SAL — это мощная технология, которая может помочь повысить безопасность и надежность кода. Когда вы узнаете SAL, можно применить новый навык для повседневной работы. В новом коде можно использовать на базе SAL спецификации, во всех; в старом коде можно постепенно добавлять заметки и тем самым повысить преимущества, каждый раз при обновлении.  
  
 Microsoft, которые уже отмечены общих заголовках. Таким образом мы рекомендуем, что в проектах сначала аннотировании конечный узел функций и функций, которые вызывают API-интерфейсов Win32 для получения оптимальных результатов.  
  
### <a name="when-do-i-annotate"></a>Когда заметки?  
 Ниже приведены некоторые рекомендации.  
  
- Добавление заметок все параметры-указатели.  
  
- Таким образом, чтобы анализ кода можно обеспечить безопасность буфера и указатель на добавление заметок диапазон значений заметок.  
  
- Заметки к правилам блокировки и побочных эффектов. Дополнительные сведения см. в разделе [Аннотация поведения блокировки](../code-quality/annotating-locking-behavior.md).  
  
- Заметки к свойствам драйвера и других свойств конкретного домена.  
  
  Или можно добавить заметку все параметры, чтобы сделать ваши намерения clear на протяжении всего и упростить процесс проверить, что было сделано заметок.  
  
## <a name="related-resources"></a>Связанные ресурсы  
 [Блог команды анализа кода](http://go.microsoft.com/fwlink/p/?LinkId=251197)  
  
## <a name="see-also"></a>См. также  
 [Использование аннотаций SAL для сокращения количества дефектов в коде C/C++](../code-quality/using-sal-annotations-to-reduce-c-cpp-code-defects.md)   
 [Создание примечаний к функции параметров и возвращаемых значений](../code-quality/annotating-function-parameters-and-return-values.md)   
 [Аннотация поведения функций](../code-quality/annotating-function-behavior.md)   
 [Аннотация структур и классов](../code-quality/annotating-structs-and-classes.md)   
 [Аннотация поведения блокировки](../code-quality/annotating-locking-behavior.md)   
 [Указание времени и места применения примечания](../code-quality/specifying-when-and-where-an-annotation-applies.md)   
 [Рекомендации и примеры](../code-quality/best-practices-and-examples-sal.md)
