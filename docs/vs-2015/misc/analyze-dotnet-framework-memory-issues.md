---
title: Анализ проблем с памятью .NET Framework | Документация Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: devlang-csharp
ms.topic: conceptual
f1_keywords:
- vs.diagnostics.managedmemoryanalysis
ms.assetid: 43341928-9930-48cf-a57f-ddcc3984b787
caps.latest.revision: 9
ms.author: mikejo
manager: jillfra
ms.openlocfilehash: e78cefa9778e2889130f865e4c61cc8a97014db7
ms.sourcegitcommit: 47eeeeadd84c879636e9d48747b615de69384356
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "63444666"
---
# <a name="analyze-net-framework-memory-issues"></a>Анализ проблем с памятью .NET Framework
С помощью анализатора управляемой памяти Visual Studio вы можете найти утечки памяти и определить неэффективное использование памяти в коде .NET Framework. Минимальная версия .NET Framework целевого кода — .NET Framework 4.5.  
  
 Средство анализа памяти обрабатывает сведения в *файлы с данными кучи дампа* , копии объектов в памяти приложения. Вы можете собрать файлы дампа (DMP) в среде Visual Studio или с помощью других системных средств.  
  
- Можно проанализировать один мгновенный снимок, чтобы понять относительное влияние типов объектов на использование памяти и найти код в приложении, который использует память неэффективно.  
  
- Вы также можете сравнить (*diff*) два мгновенных снимка приложения, чтобы найти области в коде, вызывающие память использовать рост.  
  
  Пошаговое руководство, анализатора управляемой памяти, см. в разделе [с помощью Visual Studio 2013 для диагностики проблем памяти .NET в рабочей среде](http://blogs.msdn.com/b/visualstudioalm/archive/2013/06/20/using-visual-studio-2013-to-diagnose-net-memory-issues-in-production.aspx) на Visual Studio ALM и блог Team Foundation Server.  
  
## <a name="BKMK_Contents"></a> Описание  
 [Использование памяти в приложениях .NET Framework](#BKMK_Memory_use_in__NET_Framework_apps)  
  
 [Определение проблемы с памятью в приложении](#BKMK_Identify_a_memory_issue_in_an_app)  
  
 [Сбор снимков памяти](#BKMK_Collect_memory_snapshots)  
  
 [Анализ использования памяти](#BKMK_Analyze_memory_use)  
  
## <a name="BKMK_Memory_use_in__NET_Framework_apps"></a> Использование памяти в приложениях .NET Framework  
 .NET Framework — это среда выполнения со сборкой мусора, поэтому в большинстве приложений использование памяти не вызывает проблем. Но в долго работающих приложениях, таких как веб-службы и приложения, и на устройствах с ограниченным объемом памяти, накопление объектов в памяти может снизить производительность приложения и устройства. Избыточное использование памяти может привести к дефициту ресурсов, если сборщик мусора будет запускаться слишком часто или операционной системе приходится часто перемещать данные между ОЗУ и диском. В худшем случае приложение может завершить работу с исключением "Недостаточно памяти".  
  
 .NET *управляемой кучи* — это область виртуальной памяти, где хранятся ссылаться на объекты, созданные приложением. Жизненный цикл объектов контролирует сборщик мусора (GC). Сборщик мусора использует ссылки для отслеживания объектов, занимающих блоки памяти. Ссылка создается, когда объект создается и назначается переменной. У одного объекта может быть несколько ссылок. Например, дополнительные ссылки на объект можно создать, добавив его в класс, коллекцию или другую структуру данных или назначив объект второй переменной. Менее очевидный способ создания ссылки — добавление обработчика в событие другого объекта. В этом случае второй объект содержит ссылку на первый объект, пока не будет явно удален обработчик или второй объект.  
  
 Для каждого приложения сборщик мусора хранит три ссылки, отслеживающие объекты, на которые ссылается приложение. *Дерево ссылок* имеет набор корней, включая глобальные и статические объекты, а также связанные стеки потоков и динамически инициализируемые объекты. Объект становится корневым, если у него есть по крайней мере один родительский объект с ссылкой на него. Сборщик мусора может освободить память, занимаемую объектом, только если другие объекты или переменные в приложении не ссылаются на него.  
  
 ![К началу](../debugger/media/pcs-backtotop.png "PCS_BackToTop") [Содержание](#BKMK_Contents)  
  
## <a name="BKMK_Identify_a_memory_issue_in_an_app"></a> Определение проблемы с памятью в приложении  
 Самым очевидным признаком проблем с памятью служит производительность приложения, особенно ее падение с течением времени. Ухудшение производительности других приложений во время работы вашего приложения также может указывать на проблему с памятью. Если возможно возникновение проблем с памятью, использовать диспетчером задач или [системный монитор Windows](http://technet.microsoft.com/library/cc749249.aspx) для ее дальнейшего изучения. Например, посмотрите, существуют ли случаи увеличения общего объема памяти, которые вы не можете объяснить — возможно, это источник утечки памяти:  
  
 ![Постоянный рост емкости памяти в мониторе ресурсов](../misc/media/mngdmem-resourcemanagerconsistentgrowth.png "MNGDMEM_ResourceManagerConsistentGrowth")  
  
 Вы также можете заметить пиковые объемы используемой памяти, которые превышают предполагаемый объем — это может указывать на неэффективное использование памяти в процедуре:  
  
 ![Пиковые объемы используемой памяти в диспетчере ресурсов](../misc/media/mngdmem-resourcemanagerspikes.png "MNGDMEM_ResourceManagerSpikes")  
  
## <a name="BKMK_Collect_memory_snapshots"></a> Сбор снимков памяти  
 Средство анализа памяти обрабатывает сведения в *файлы дампа* , содержащие сведения о куче. Можно создать файлы дампов в Visual Studio, или можно использовать такой инструмент, как [ProcDump](http://technet.microsoft.com/sysinternals/dd996900.aspx) из [Windows Sysinternals](http://technet.microsoft.com/sysinternals). См. в разделе [что такое дамп и как его создать?](http://blogs.msdn.com/b/debugger/archive/2009/12/30/what-is-a-dump-and-how-do-i-create-one.aspx) в блоге Visual Studio Debugger Team.  
  
> [!NOTE]
> Большинство средств могут собирать данные дампа с полными данными памяти кучи или без них. Анализатору памяти Visual Studio требуются полные сведения о куче.  
  
 **Получение дампа из Visual Studio**  
  
1. Вы можете создать файл дампа для процесса, запущенного из проекта Visual Studio, или можете присоединить отладчик к запущенному процессу. См. в разделе [присоединение к выполняемым процессам](../debugger/attach-to-running-processes-with-the-visual-studio-debugger.md).  
  
2. Остановите выполнение. Отладчик останавливается при выборе **прервать все** на **Отладка** меню, или исключение, или в точке останова  
  
3. На **Отладка** меню, выберите **Сохранение дампа**. В **Сохранение дампа** диалогового окна поле, укажите расположение и убедитесь, что **малый дамп с кучей** (по умолчанию) выбран в **тип** списка.  
  
   **Для сравнения двух снимков памяти**  
  
   Для анализа роста объема используемой приложением памяти получите два файла дампа из одного экземпляра приложения.  
  
   ![К началу](../debugger/media/pcs-backtotop.png "PCS_BackToTop") [Содержание](#BKMK_Contents)  
  
## <a name="BKMK_Analyze_memory_use"></a> Анализ использования памяти  
 [Фильтрация списка объектов](#BKMK_Filter_the_list_of_objects) **&#124;** [анализ данных памяти одного снимка](#BKMK_Analyze_memory_data_in_from_a_single_snapshot) **&#124;** [сравнения двух памяти моментальные снимки](#BKMK_Compare_two_memory_snapshots)  
  
 Чтобы проанализировать файл дампа на наличие проблем с памятью:  
  
1. В Visual Studio, выберите **файл**, **откройте** и выберите файл дампа.  
  
2. На **Сводка файла минидампа** выберите **отладка управляемой памяти**.  
  
    ![Страница сводки файла дампа](../misc/media/mngdmem-dumpfilesummary.png "MNGDMEM_DumpFileSummary")  
  
   Анализатор памяти начнет сеанс отладки для анализа файла, а результаты появятся на странице "Представление кучи":  
  
   ![К началу](../debugger/media/pcs-backtotop.png "PCS_BackToTop") [Содержание](#BKMK_Contents)  
  
### <a name="BKMK_Filter_the_list_of_objects"></a> Фильтрация списка объектов  
 По умолчанию анализатор памяти фильтрует список объектов в снимке памяти, отображая только типы и экземпляры, относящиеся к коду пользователя, и показывая только те типы, общий инклюзивный размер которых превышает процентный порог от общего размера кучи. Можно изменить эти параметры в **параметры представления** списка:  
  
|||  
|-|-|  
|**Включение функции "Только мой код"**|В режиме "Только мой код" основные системные объекты скрыты, поэтому в списке отображаются только типы, созданные вами.<br /><br /> Можно также задать параметр Just My Code в Visual Studio **параметры** диалоговое окно. В меню **Отладка** выберите **Параметры и настройки**. В **Отладка**/**Общие** вкладке, установите или снимите флажок **Just My Code**.|  
|**Свернуть маленькие объекты**|**Свернуть маленькие объекты** скрывает все типы, общий инклюзивный размер которых будет меньше 0,5 процента от общего размера кучи.|  
  
 Также можно фильтровать список типов, введя строку в **поиска** поле. В списке будут показаны только типы, имена которых содержат введенную строку.  
  
 ![К началу](../debugger/media/pcs-backtotop.png "PCS_BackToTop") [Содержание](#BKMK_Contents)  
  
### <a name="BKMK_Analyze_memory_data_in_from_a_single_snapshot"></a> Анализ данных памяти одного снимка  
 Visual Studio начнет новый сеанс отладки для анализа файла, а результаты появятся в окне "Представление кучи".  
  
 ![Список типов объектов](../misc/media/dbg-mma-objecttypelist.png "DBG_MMA_ObjectTypeList")  
  
 ![К началу](../debugger/media/pcs-backtotop.png "PCS_BackToTop") [Содержание](#BKMK_Contents)  
  
#### <a name="object-type-table"></a>Таблица "Тип объекта"  
 В верхней таблице перечислены типы объектов, которые хранятся в памяти.  
  
- **Число** показано число экземпляров типа в моментальном снимке.  
  
- **Размер (байт)** — это размер всех экземпляров типа, без учета размера объектов, которые он ссылается. Классу  
  
- **Инклюзивный размер (байт)** содержит размеры объектов, на которую указывает ссылка.  
  
  Вы можете выбрать значок экземпляров (![значок экземпляра в столбце типа объекта](../misc/media/dbg-mma-instancesicon.png "DBG_MMA_InstancesIcon")) в **тип объекта** столбец для просмотра списка экземпляров тип.  
  
#### <a name="instance-table"></a>Таблица экземпляров  
 ![Таблица экземпляров](../misc/media/dbg-mma-instancestable.png "DBG_MMA_InstancesTable")  
  
- **Экземпляр** — это область памяти объекта, который служит в качестве объекта идентификатора объекта  
  
- **Значение** показывает фактическое значение типов значений. Можно навести указатель мыши на имя ссылочного типа, чтобы просмотреть его значения в подсказке.  
  
   ![Экземпляр значения в подсказке по данным](../misc/media/dbg-mma-instancevaluesindatatip.png "DBG_MMA_InstanceValuesInDataTip")  
  
- **Размер (байт)** — это размер объекта, без учета размера объектов, которые он ссылается. Классу  
  
- **Инклюзивный размер (байт)** содержит размеры объектов, на которую указывает ссылка.  
  
  По умолчанию типы и экземпляры сортируются по **Инклюзивный размер (байт)**. Выберите заголовок столбца в списке, чтобы изменить порядок сортировки.  
  
#### <a name="paths-to-root"></a>Пути к корню  
  
- Для типа, выбранного в **тип объекта** таблицы, **пути к корню** таблице показаны уникальные иерархии типов, которые ведут к корневым объектам для всех объектов данного типа, а также число ссылок на тип, который находится над ним в иерархии.  
  
- Для объекта, выбранного в списке экземпляров типа **пути к корню** отображает граф фактических объектов, содержащих ссылку на экземпляр. Можно навести указатель мыши на имя объекта, чтобы просмотреть его значения в подсказке.  
  
#### <a name="referenced-types--referenced-objects"></a>Ссылочные типы и объекты  
  
- Для типа, выбранного в **тип объекта** таблицы, **ссылочные типы** вкладке отображается размер и число ссылочных типов, удерживаемых всеми объектами выбранного типа.  
  
- Для выбранного экземпляра типа **ссылки на объекты** показывает объекты, которые хранятся в выбранном экземпляре. Можно навести указатель мыши на имя, чтобы просмотреть значения в подсказке.  
  
  **Циклические ссылки**  
  
  Объект может ссылаться на второй объект, который напрямую или косвенно содержит ссылку на первый объект. Когда анализатор памяти обнаруживает такую ситуацию, он прекращает расширение ссылочного пути и добавляет **[обнаружен цикл]** заметки в описание первого объекта и останавливается.  
  
  **Корневые типы**  
  
  Анализатор памяти добавляет к корневым объектам комментарии с описанием ссылки, которые содержатся в объектах:  
  
|Комментарий|Описание|  
|----------------|-----------------|  
|**Статическая переменная** `VariableName`|Статическая переменная. `VariableName` — имя переменной.|  
|**Дескриптор завершения**|Ссылка из очереди метода завершения|  
|**Локальная переменная**|Локальная переменная.|  
|**Строгий дескриптор**|Дескриптор строгой ссылки из таблицы дескрипторов объектов.|  
|**Async. Закрепленный дескриптор**|Асинхронный закрепленный объект из таблицы дескрипторов объектов.|  
|**Зависимый дескриптор**|Зависимый объект из таблицы дескрипторов объектов.|  
|**Закрепленный дескриптор**|Закрепленная строгая ссылка из таблицы дескрипторов объектов.|  
|**Дескриптор RefCount**|Объект с подсчетом ссылок из таблицы дескрипторов объектов.|  
|**Дескриптор Sizedref**|Строгая ссылка, хранящая приблизительный размер общего закрытия всех объектов и корневых объектов во время сборки мусора.|  
|**Закрепленная локальная переменная**|Закрепленная локальная переменная.|  
  
### <a name="BKMK_Compare_two_memory_snapshots"></a> Сравнение двух снимков памяти  
 Вы можете сравнить два файла дампа процесса, чтобы найти объекты, которые могут вызывать утечку памяти. Интервал между сбором первого (более раннего) и второго (более позднего) файла должен быть достаточно большим, чтобы увеличение числа потерянных объектов было очевидным. Сравнение двух файлов  
  
1. Откройте второй файл дампа, а затем выберите **отладка управляемой памяти** на **Сводка файла минидампа** страницы.  
  
2. На странице отчета анализа памяти откройте **выберите шаблон базовой конфигурации** , а затем выберите **Обзор** для указания первого файла дампа.  
  
   Анализатор добавляет столбцы в верхнюю область отчета, который разницу между **число**, **размер**, и **Инклюзивный размер** типов, соответствующих значений в более раннего моментального снимка.  
  
   ![Столбцы Diff в списке типов](../misc/media/mngdmem-diffcolumns.png "MNGDMEM_DiffColumns")  
  
   Объект **разница числа ссылок** также добавляется столбец **пути к корню** таблицы.  
  
   ![К началу](../debugger/media/pcs-backtotop.png "PCS_BackToTop") [Содержание](#BKMK_Contents)  
  
## <a name="see-also"></a>См. также  
 [Блог VS ALM TFS: С помощью Visual Studio 2013 для диагностики проблем с памятью .NET в рабочей среде](http://blogs.msdn.com/b/visualstudioalm/archive/2013/06/20/using-visual-studio-2013-to-diagnose-net-memory-issues-in-production.aspx)   
 [Channel 9 &#124; Visual Studio TV &#124; анализ управляемой памяти](http://channel9.msdn.com/Series/Visual-Studio-2012-Premium-and-Ultimate-Overview/Managed-Memory-Analysis)   
 [Channel 9 &#124; элементов Visual Studio &#124; анализ управляемой памяти в Visual Studio 2013](http://channel9.msdn.com/Shows/Visual-Studio-Toolbox/Managed-Memory-Analysis-in-Visual-Studio-2013)