---
title: Анализ проблем с памятью .NET Framework | Документация Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: devlang-csharp
ms.topic: conceptual
f1_keywords:
- vs.diagnostics.managedmemoryanalysis
ms.assetid: 43341928-9930-48cf-a57f-ddcc3984b787
caps.latest.revision: 9
ms.author: mikejo
manager: jillfra
ms.openlocfilehash: e89b3f04a3e0e1dcd0cc29e57e09b1c71fbc2279
ms.sourcegitcommit: b885f26e015d03eafe7c885040644a52bb071fae
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/30/2020
ms.locfileid: "85545552"
---
# <a name="analyze-net-framework-memory-issues"></a>Анализ проблем с памятью .NET Framework
С помощью анализатора управляемой памяти Visual Studio вы можете найти утечки памяти и определить неэффективное использование памяти в коде .NET Framework. Минимальная версия .NET Framework целевого кода — .NET Framework 4.5.  
  
 Средство анализа памяти анализирует сведения в *файлах дампа с данными кучи* , которые являются копией объектов в памяти приложения. Вы можете собрать файлы дампа (DMP) в среде Visual Studio или с помощью других системных средств.  
  
- Можно проанализировать один мгновенный снимок, чтобы понять относительное влияние типов объектов на использование памяти и найти код в приложении, который использует память неэффективно.  
  
- Вы также можете сравнить (*diff*) два моментальных снимка приложения, чтобы найти области в коде, которые приводят к увеличению использования памяти с течением времени.  
  
  Пошаговое руководство по анализатору управляемой памяти см. в разделе [использование Visual Studio 2013 для диагностики проблем с памятью .NET в рабочей](https://devblogs.microsoft.com/devops/using-visual-studio-2013-to-diagnose-net-memory-issues-in-production/) области Visual Studio ALM + Team Foundation Server.  
  
## <a name="contents"></a><a name="BKMK_Contents"></a> Описание  
 [Использование памяти в приложениях .NET Framework](#BKMK_Memory_use_in__NET_Framework_apps)  
  
 [Определение проблемы с памятью в приложении](#BKMK_Identify_a_memory_issue_in_an_app)  
  
 [Сбор снимков памяти](#BKMK_Collect_memory_snapshots)  
  
 [Анализ использования памяти](#BKMK_Analyze_memory_use)  
  
## <a name="memory-use-in-net-framework-apps"></a><a name="BKMK_Memory_use_in__NET_Framework_apps"></a>Использование памяти в .NET Framework приложениях  
 .NET Framework — это среда выполнения со сборкой мусора, поэтому в большинстве приложений использование памяти не вызывает проблем. Но в долго работающих приложениях, таких как веб-службы и приложения, и на устройствах с ограниченным объемом памяти, накопление объектов в памяти может снизить производительность приложения и устройства. Избыточное использование памяти может привести к дефициту ресурсов, если сборщик мусора будет запускаться слишком часто или операционной системе приходится часто перемещать данные между ОЗУ и диском. В худшем случае приложение может завершить работу с исключением "Недостаточно памяти".  
  
 *Управляемая куча* .NET — это область виртуальной памяти, в которой хранятся ссылочные объекты, созданные приложением. Жизненный цикл объектов контролирует сборщик мусора (GC). Сборщик мусора использует ссылки для отслеживания объектов, занимающих блоки памяти. Ссылка создается, когда объект создается и назначается переменной. У одного объекта может быть несколько ссылок. Например, дополнительные ссылки на объект можно создать, добавив его в класс, коллекцию или другую структуру данных или назначив объект второй переменной. Менее очевидный способ создания ссылки — добавление обработчика в событие другого объекта. В этом случае второй объект содержит ссылку на первый объект, пока не будет явно удален обработчик или второй объект.  
  
 Для каждого приложения сборщик мусора хранит три ссылки, отслеживающие объекты, на которые ссылается приложение. *Дерево ссылок* содержит набор корней, включая глобальные и статические объекты, а также связанные стеки потоков и динамически создаваемые объекты. Объект становится корневым, если у него есть по крайней мере один родительский объект с ссылкой на него. Сборщик мусора может освободить память, занимаемую объектом, только если другие объекты или переменные в приложении не ссылаются на него.  
  
 ![В начало](../debugger/media/pcs-backtotop.png "PCS_BackToTop") [Содержимое](#BKMK_Contents)  
  
## <a name="identify-a-memory-issue-in-an-app"></a><a name="BKMK_Identify_a_memory_issue_in_an_app"></a>Выявление проблемы с памятью в приложении  
 Самым очевидным признаком проблем с памятью служит производительность приложения, особенно ее падение с течением времени. Ухудшение производительности других приложений во время работы вашего приложения также может указывать на проблему с памятью. Если вы подозреваете проблему с памятью, воспользуйтесь для дальнейшего изучения средством, например диспетчером задач или [монитором производительности Windows](https://technet.microsoft.com/library/cc749249.aspx) . Например, посмотрите, существуют ли случаи увеличения общего объема памяти, которые вы не можете объяснить — возможно, это источник утечки памяти:  
  
 ![Постоянный рост емкости памяти в мониторе ресурсов](../misc/media/mngdmem-resourcemanagerconsistentgrowth.png "MNGDMEM_ResourceManagerConsistentGrowth")  
  
 Вы также можете заметить пиковые объемы используемой памяти, которые превышают предполагаемый объем — это может указывать на неэффективное использование памяти в процедуре:  
  
 ![Резкие изменения емкости памяти в диспетчере ресурсов](../misc/media/mngdmem-resourcemanagerspikes.png "MNGDMEM_ResourceManagerSpikes")  
  
## <a name="collect-memory-snapshots"></a><a name="BKMK_Collect_memory_snapshots"></a>Получение моментальных снимков памяти  
 Средство анализа памяти анализирует данные в *файлах дампа* , содержащих сведения о куче. Вы можете создавать файлы дампа в Visual Studio, а также использовать такие средства, как [ProcDump](https://technet.microsoft.com/sysinternals/dd996900.aspx) , из [Windows Sysinternals](https://technet.microsoft.com/sysinternals). См. раздел [что такое дамп и как создать его?](https://blogs.msdn.microsoft.com/debugger/2009/12/30/what-is-a-dump-and-how-do-i-create-one/) в блоге группы отладчика Visual Studio.  
  
> [!NOTE]
> Большинство средств могут собирать данные дампа с полными данными памяти кучи или без них. Анализатору памяти Visual Studio требуются полные сведения о куче.  
  
 **Получение дампа в Visual Studio**  
  
1. Вы можете создать файл дампа для процесса, запущенного из проекта Visual Studio, или можете присоединить отладчик к запущенному процессу. См. раздел [Присоединение к запущенным процессам](../debugger/attach-to-running-processes-with-the-visual-studio-debugger.md).  
  
2. Остановите выполнение. Отладчик останавливается, если выбрать пункт **прервать все** в меню **Отладка** , либо в случае исключения или в точке останова  
  
3. В меню **Отладка** выберите команду **сохранить дамп как**. В диалоговом окне **сохранить дамп как** укажите расположение и убедитесь, что в списке **Тип файла** выбрано мини- **дамп с кучей** (по умолчанию).  
  
   **Сравнение двух снимков памяти**  
  
   Для анализа роста объема используемой приложением памяти получите два файла дампа из одного экземпляра приложения.  
  
   ![В начало](../debugger/media/pcs-backtotop.png "PCS_BackToTop") [Содержимое](#BKMK_Contents)  
  
## <a name="analyze-memory-use"></a><a name="BKMK_Analyze_memory_use"></a>Анализ использования памяти  
 [Фильтрация списка объектов](#BKMK_Filter_the_list_of_objects) **&#124;** [анализ данных памяти в одном моментальном снимке](#BKMK_Analyze_memory_data_in_from_a_single_snapshot) **&#124;** [Сравнение двух моментальных снимков памяти](#BKMK_Compare_two_memory_snapshots)  
  
 Чтобы проанализировать файл дампа на наличие проблем с памятью:  
  
1. В Visual Studio выберите **файл**, **откройте** и укажите файл дампа.  
  
2. На странице **Сводка по файлу минидампа** выберите **Отладка управляемой памяти**.  
  
    ![Страница сводки файла дампа](../misc/media/mngdmem-dumpfilesummary.png "MNGDMEM_DumpFileSummary")  
  
   Анализатор памяти начнет сеанс отладки для анализа файла, а результаты появятся на странице "Представление кучи":  
  
   ![В начало](../debugger/media/pcs-backtotop.png "PCS_BackToTop") [Содержимое](#BKMK_Contents)  
  
### <a name="filter-the-list-of-objects"></a><a name="BKMK_Filter_the_list_of_objects"></a>Фильтрация списка объектов  
 По умолчанию анализатор памяти фильтрует список объектов в снимке памяти, отображая только типы и экземпляры, относящиеся к коду пользователя, и показывая только те типы, общий инклюзивный размер которых превышает процентный порог от общего размера кучи. Эти параметры можно изменить в списке **Просмотреть параметры** .  
  
|Имя|Описание|  
|-|-|  
|**Включение режима "Только мой код"**|В режиме "Только мой код" основные системные объекты скрыты, поэтому в списке отображаются только типы, созданные вами.<br /><br /> Можно также задать параметр Только мой код в диалоговом окне **Параметры** Visual Studio. В меню **Отладка** выберите **Параметры и настройки**. На вкладке Общие в области **Отладка** / **General** выберите или снимите флажок **только мой код**.|  
|**Свернуть небольшие объекты**|**Свернуть небольшие объекты** скрывает все типы, общий инклюзивный размер которых меньше 0,5% от общего размера кучи.|  
  
 Можно также отфильтровать список типов, введя строку в поле **поиска** . В списке будут показаны только типы, имена которых содержат введенную строку.  
  
 ![В начало](../debugger/media/pcs-backtotop.png "PCS_BackToTop") [Содержимое](#BKMK_Contents)  
  
### <a name="analyze-memory-data-in-from-a-single-snapshot"></a><a name="BKMK_Analyze_memory_data_in_from_a_single_snapshot"></a>Анализ данных памяти в одном снимке  
 Visual Studio начнет новый сеанс отладки для анализа файла, а результаты появятся в окне "Представление кучи".  
  
 ![Список типов объектов](../misc/media/dbg-mma-objecttypelist.png "DBG_MMA_ObjectTypeList")  
  
 ![В начало](../debugger/media/pcs-backtotop.png "PCS_BackToTop") [Содержимое](#BKMK_Contents)  
  
#### <a name="object-type-table"></a>Таблица "Тип объекта"  
 В верхней таблице перечислены типы объектов, которые хранятся в памяти.  
  
- **Количество** показывает количество экземпляров типа в моментальном снимке.  
  
- **Размер (в байтах)** — это размер всех экземпляров типа, исключая размер объектов, на которые он ссылается. Классу  
  
- **Инклюзивный размер (в байтах)** включает размеры объектов, на которые имеются ссылки.  
  
  Чтобы просмотреть список экземпляров типа, можно выбрать значок экземпляры (![значок экземпляра в столбце Тип объекта](../misc/media/dbg-mma-instancesicon.png "DBG_MMA_InstancesIcon")) в столбце **тип объекта** .  
  
#### <a name="instance-table"></a>Таблица экземпляров  
 ![Экземпляры таблицы](../misc/media/dbg-mma-instancestable.png "DBG_MMA_InstancesTable")  
  
- **Instance** — это расположение памяти объекта, который служит в качестве идентификатора объекта объекта.  
  
- **Значение** показывает фактическое значение типов значений. Можно навести указатель мыши на имя ссылочного типа, чтобы просмотреть его значения в подсказке.  
  
   ![Значения экземпляров в подсказке по данным](../misc/media/dbg-mma-instancevaluesindatatip.png "DBG_MMA_InstanceValuesInDataTip")  
  
- **Размер (в байтах)** — это размер объекта, исключая размер объектов, на которые он ссылается. Классу  
  
- **Инклюзивный размер (в байтах)** включает размеры объектов, на которые имеются ссылки.  
  
  По умолчанию типы и экземпляры сортируются по **инклюзивному размеру (в байтах)**. Выберите заголовок столбца в списке, чтобы изменить порядок сортировки.  
  
#### <a name="paths-to-root"></a>Пути к корню  
  
- Для типа, выбранного из таблицы **тип объекта** , **пути к корневой** таблице показывают уникальные иерархии типов, ведущие к корневым объектам для всех объектов данного типа, а также число ссылок на тип, расположенный над ним в иерархии.  
  
- Для объекта, выбранного из экземпляра типа, **пути к корню** показывают графы фактических объектов, которые содержат ссылку на экземпляр. Можно навести указатель мыши на имя объекта, чтобы просмотреть его значения в подсказке.  
  
#### <a name="referenced-types--referenced-objects"></a>Ссылочные типы и объекты  
  
- Для типа, выбранного из таблицы **тип объекта** , на вкладке **Ссылочные типы** отображается размер и количество ссылочных типов, удерживаемых всеми объектами выбранного типа.  
  
- Для выбранного экземпляра типа объекты, на которые **указывают ссылки** , показывают объекты, удерживаемые выбранным экземпляром. Можно навести указатель мыши на имя, чтобы просмотреть значения в подсказке.  
  
  **Циклические ссылки**  
  
  Объект может ссылаться на второй объект, который напрямую или косвенно содержит ссылку на первый объект. Когда анализатор памяти встречает эту ситуацию, он прекращает расширение пути ссылки и добавляет заметку **[Cycled]** в список первого объекта и останавливается.  
  
  **Корневые типы**  
  
  Анализатор памяти добавляет к корневым объектам комментарии с описанием ссылки, которые содержатся в объектах:  
  
|Заметка|Описание|  
|----------------|-----------------|  
|**Статическая переменная** `VariableName`|Статическая переменная. `VariableName` — имя переменной.|  
|**Дескриптор завершения**|Ссылка из очереди метода завершения|  
|**Локальная переменная**|Локальная переменная.|  
|**Строгий дескриптор**|Дескриптор строгой ссылки из таблицы дескрипторов объектов.|  
|**Async. Закрепленный маркер**|Асинхронный закрепленный объект из таблицы дескрипторов объектов.|  
|**Зависимый дескриптор**|Зависимый объект из таблицы дескрипторов объектов.|  
|**Закрепленный дескриптор**|Закрепленная строгая ссылка из таблицы дескрипторов объектов.|  
|**Дескриптор RefCount**|Объект с подсчетом ссылок из таблицы дескрипторов объектов.|  
|**Дескриптор SizedRef**|Строгая ссылка, хранящая приблизительный размер общего закрытия всех объектов и корневых объектов во время сборки мусора.|  
|**Закрепленная локальная переменная**|Закрепленная локальная переменная.|  
  
### <a name="compare-two-memory-snapshots"></a><a name="BKMK_Compare_two_memory_snapshots"></a>Сравнение двух моментальных снимков памяти  
 Вы можете сравнить два файла дампа процесса, чтобы найти объекты, которые могут вызывать утечку памяти. Интервал между сбором первого (более раннего) и второго (более позднего) файла должен быть достаточно большим, чтобы увеличение числа потерянных объектов было очевидным. Сравнение двух файлов  
  
1. Откройте второй файл дампа и выберите **Отладка управляемой памяти** на странице **Сводка файла минидампа** .  
  
2. На странице Отчет об анализе памяти Откройте список **Выбор базовых показателей** и нажмите кнопку **Обзор** , чтобы указать первый файл дампа.  
  
   Анализатор добавляет столбцы в верхнюю область отчета, которая показывает разницу между **числом**, **размером**и **инклюзивным размером** типов с этими значениями в более раннем снимке.  
  
   ![Столбцы различий в списке типов](../misc/media/mngdmem-diffcolumns.png "MNGDMEM_DiffColumns")  
  
   В **пути к корневой** таблице также добавляется столбец **разницы по числу ссылок** .  
  
   ![В начало](../debugger/media/pcs-backtotop.png "PCS_BackToTop") [Содержимое](#BKMK_Contents)  
  
## <a name="see-also"></a>См. также  
 [Блог по VS ALM TFS. Использование Visual Studio 2013 для диагностики проблем с памятью .NET в рабочей среде](https://devblogs.microsoft.com/devops/using-visual-studio-2013-to-diagnose-net-memory-issues-in-production/)   
 [Канал 9 &#124; анализ управляемой памяти в Visual Studio TV &#124;](https://channel9.msdn.com/Series/Visual-Studio-2012-Premium-and-Ultimate-Overview/Managed-Memory-Analysis)   
 [Канал 9 &#124; панели элементов Visual Studio &#124; анализ управляемой памяти в Visual Studio 2013](https://channel9.msdn.com/Shows/Visual-Studio-Toolbox/Managed-Memory-Analysis-in-Visual-Studio-2013)