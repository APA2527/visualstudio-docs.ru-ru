---
title: Определение политики блокировки для создания сегментов только для чтения | Документация Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-modeling
ms.topic: conceptual
ms.assetid: fa549c71-2bf6-4b08-b7b2-7756dd6f1dc8
caps.latest.revision: 14
author: jillre
ms.author: jillfra
manager: jillfra
ms.openlocfilehash: 85573309e594fab49db75115a48b5a4e98e44de3
ms.sourcegitcommit: 939407118f978162a590379997cb33076c57a707
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/13/2020
ms.locfileid: "75918846"
---
# <a name="defining-a-locking-policy-to-create-read-only-segments"></a>Определение политики блокировки для создания сегментов, доступных только для чтения
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

API неизменности [!INCLUDE[vsprvs](../includes/vsprvs-md.md)] SDK визуализации и моделирования позволяет программе заблокировать часть или всю модель доменного языка (DSL), чтобы ее можно было читать, но не изменять. Этот параметр доступен только для чтения, например, чтобы пользователь мог попросить коллег закомментировать и проверить модель DSL, но может запретить им изменять исходное значение.

 Кроме того, в качестве автора DSL можно определить *политику блокировки.* Политика блокировки определяет, какие блокировки разрешены, не разрешены или являются обязательными. Например, при публикации DSL можно рекомендовать сторонним разработчикам расширять его с помощью новых команд. Но можно также использовать политику блокировки, чтобы предотвратить изменение состояния только для чтения указанных частей модели.

> [!NOTE]
> Политику блокировки можно обойти с помощью отражения. Она предоставляет четкие границы для сторонних разработчиков, но не обеспечивает надежную защиту.

 Дополнительные сведения можно найти на веб-сайте [SDK для визуализации и моделирования](https://www.microsoft.com/download/details.aspx?id=48148) [!INCLUDE[vsprvs](../includes/vsprvs-md.md)].

## <a name="setting-and-getting-locks"></a>Установка и получение блокировок
 Можно установить блокировки для хранилища, для секции или для отдельного элемента. Например, эта инструкция предотвращает удаление элемента модели и также предотвратит изменение его свойств:

```
using Microsoft.VisualStudio.Modeling.Immutability; ...
element.SetLocks(Locks.Delete | Locks.Property);
```

 Другие значения блокировки можно использовать для предотвращения изменений связей, создания элементов, перемещения между секциями и повторного упорядочения ссылок в роли.

 Блокировки применяются как к действиям пользователя, так и к программному коду. Если программный код пытается внести изменение, будет выдано исключение `InvalidOperationException`. Блокировки игнорируются при выполнении операции отмены или повтора.

 Можно определить, имеет ли элемент блокировку в заданном наборе с помощью `IsLocked(Locks)`, а также получить текущий набор блокировок для элемента с помощью `GetLocks()`.

 Вы можете установить блокировку без использования транзакции. База данных блокировки не является частью хранилища. Если установить блокировку в ответ на изменение значения в магазине, например в Онвалуечанжед, следует разрешить изменения, которые являются частью операции отмены.

 Эти методы являются методами расширения, определенными в пространстве имен <xref:Microsoft.VisualStudio.Modeling.Immutability>.

### <a name="locks-on-partitions-and-stores"></a>Блокировки на секции и хранилища
 Блокировки также можно применять к секциям и магазину. Блокировка, заданная для секции, применяется ко всем элементам в секции. Поэтому, например, следующая инструкция предотвратит удаление всех элементов в секции независимо от состояний собственных блокировок. Тем не менее другие блокировки, такие как `Locks.Property`, могут быть установлены для отдельных элементов:

```
partition.SetLocks(Locks.Delete);
```

 Блокировка, заданная для хранилища, применяется ко всем его элементам независимо от параметров этой блокировки в секциях и элементах.

### <a name="using-locks"></a>Использование блоков
 Можно использовать блокировки для реализации схем, таких как следующие примеры:

- Запретить изменения для всех элементов и связей, кроме тех, которые представляют комментарии. Это позволяет пользователям закомментировать модель, не изменяя ее.

- Запретить изменения в разделе по умолчанию, но разрешить изменения в секции диаграммы. Пользователь может перестроить диаграмму, но не может изменить базовую модель.

- Запретить изменения в магазине, кроме группы пользователей, зарегистрированных в отдельной базе данных. Для других пользователей схема и модель доступны только для чтения.

- Запретить изменения в модели, если логическое свойство схемы имеет значение true. Укажите команду меню, чтобы изменить это свойство. Это гарантирует, что пользователи не будут случайно вносить изменения.

- Запретить добавление и удаление элементов и связей конкретных классов, но разрешить изменение свойств. Это дает пользователям фиксированную форму, в которой они могут заполнять свойства.

## <a name="lock-values"></a>Заблокировать значения
 Блокировки можно задать для хранилища, секции или отдельных ModelElement. Блокировки — это перечисление `Flags`. его значения можно комбинировать с&#124;помощью "".

- Блокировки ModelElement всегда включают блокировки своего раздела.

- Блокировки секции всегда содержат блокировки хранилища.

  Нельзя установить блокировку для секции или хранилища и одновременно отключить блокировку для отдельного элемента.

|{2&gt;Value&lt;2}|Значение, если `IsLocked(Value)` имеет значение true|
|-----------|------------------------------------------|
|Нет|Без ограничений.|
|Идентификаторы|Свойства домена элементов не могут быть изменены. Это не относится к свойствам, создаваемым ролью доменного класса в связи.|
|Add|Новые элементы и ссылки не могут быть созданы в разделе или хранилище.<br /><br /> Неприменимо к `ModelElement`.|
|Перемещение|Элемент нельзя перемещать между секциями, если `element.IsLocked(Move)` имеет значение true или если `targetPartition.IsLocked(Move)` имеет значение true.|
|Удалить|Элемент не может быть удален, если эта блокировка задана для самого элемента или для любого элемента, к которому будет распространяться удаление, например внедренные элементы и фигуры.<br /><br /> Можно использовать `element.CanDelete()`, чтобы определить, можно ли удалить элемент.|
|Переупорядочить|Невозможно изменить порядок ссылок в RolePlayer.|
|RolePlayer|Набор ссылок, источником которых является этот элемент, изменить нельзя. Например, новые элементы не могут быть внедрены в этот элемент. Это не влияет на связи, для которых этот элемент является целевым.<br /><br /> Если этот элемент является ссылкой, то его источник и целевой объект не затрагиваются.|
|Все .|Побитовое или для других значений.|

## <a name="locking-policies"></a>Политики блокировки
 Как автор DSL вы можете определить *политику блокировки*. Политика блокировки является средним действием Сетлоккс (), что позволяет предотвращать установку конкретных блокировок или задавать необходимость установки конкретных блокировок. Как правило, политика блокировки используется для того, чтобы запретить пользователям или разработчикам случайно контравенинг предполагаемое использование DSL, точно так же, как можно объявить переменную `private`.

 Можно также использовать политику блокировки для установки блокировок всех элементов, зависящих от типа элемента. Это связано с тем, что `SetLocks(Locks.None)` всегда вызывается при первом создании или десериализации элемента из файла.

 Однако нельзя использовать политику для изменения блокировок элемента в течение его жизненного цикла. Для достижения этого результата следует использовать вызовы `SetLocks()`.

 Чтобы определить политику блокировки, необходимо выполнить следующие действия.

- Создайте класс, реализующий <xref:Microsoft.VisualStudio.Modeling.Immutability.ILockingPolicy>.

- Добавьте этот класс в службы, доступные через DocData вашего DSL.

### <a name="to-define-a-locking-policy"></a>Определение политики блокировки
 <xref:Microsoft.VisualStudio.Modeling.Immutability.ILockingPolicy> имеет следующее определение:

```
public interface ILockingPolicy
{
  Locks RefineLocks(ModelElement element, Locks proposedLocks);
  Locks RefineLocks(Partition partition, Locks proposedLocks);
  Locks RefineLocks(Store store, Locks proposedLocks);
}
```

 Эти методы вызываются, когда выполняется вызов `SetLocks()` в хранилище, секции или ModelElement. В каждом методе предоставляется предложенный набор блокировок. Вы можете вернуть предложенный набор или добавить и вычесть блокировки.

 Например:

```
using Microsoft.VisualStudio.Modeling;
using Microsoft.VisualStudio.Modeling.Immutability;
namespace Company.YourDsl.DslPackage // Change
{
  public class MyLockingPolicy : ILockingPolicy
  {
    /// <summary>
    /// Moderate SetLocks(this ModelElement target, Locks locks)
    /// </summary>
    /// <param name="element">target</param>
    /// <param name="proposedLocks">locks</param>
    /// <returns></returns>
    public Locks RefineLocks(ModelElement element, Locks proposedLocks)
    {
      // In my policy, users can never delete an element,
      // and other developers cannot easily change that:
      return proposedLocks | Locks.Delete);
    }
    public Locks RefineLocks(Store store, Locks proposedLocks)
    {
      // Only one user can change this model:
      return Environment.UserName == "aUser"
           ? proposedLocks : Locks.All;
    }

```

 Чтобы гарантировать, что пользователи всегда могут удалять элементы, даже если другие вызовы кода `SetLocks(Lock.Delete):`

 `return proposedLocks & (Locks.All ^ Locks.Delete);`

 Чтобы запретить изменение во всех свойствах каждого элемента MyClass:

 `return element is MyClass ? (proposedLocks | Locks.Property) : proposedLocks;`

### <a name="to-make-your-policy-available-as-a-service"></a>Предоставление доступа к политике в качестве службы
 В проекте `DslPackage` добавьте новый файл, содержащий код, который напоминает следующий пример:

```
using Microsoft.VisualStudio.Modeling;
using Microsoft.VisualStudio.Modeling.Immutability;
namespace Company.YourDsl.DslPackage // Change
{
  // Override the DocData GetService() for this DSL.
  internal partial class YourDslDocData // Change
  {
    /// <summary>
    /// Custom locking policy cache.
    /// </summary>
    private ILockingPolicy myLockingPolicy = null;

    /// <summary>
    /// Called when a service is requested.
    /// </summary>
    /// <param name="serviceType">Service requested</param>
    /// <returns>Service implementation</returns>
    public override object GetService(System.Type serviceType)
    {
      if (serviceType == typeof(SLockingPolicy)
       || serviceType == typeof(ILockingPolicy))
      {
        if (myLockingPolicy == null)
        {
          myLockingPolicy = new MyLockingPolicy();
        }
        return myLockingPolicy;
      }
      // Request is for some other service.
      return base.GetService(serviceType);
    }
}
```
