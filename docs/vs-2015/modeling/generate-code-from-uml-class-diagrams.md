---
title: Создание кода на основе схем классов UML | Документация Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-modeling
ms.topic: conceptual
f1_keywords:
- vs.teamarch.logicalclassdiagram.shapes.properties.Templates
- vs.teamarch.logicalclassdiagram.shapes.properties.Templates.TextTransformationDataCollectionEditor
helpviewer_keywords:
- code generation, UML class diagrams
- class diagrams - UML, generating code
- UML diagrams, generating code
ms.assetid: 2790e64d-7728-4c2e-a4dd-4131e795f730
caps.latest.revision: 53
author: jillre
ms.author: jillfra
manager: jillfra
ms.openlocfilehash: 75120b2f09c2eba3254a1b94e78875d8130c5225
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/02/2020
ms.locfileid: "72666134"
---
# <a name="generate-code-from-uml-class-diagrams"></a>Создание кода на основе схем классов UML
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Чтобы создать код Visual C# .NET на основе схем классов UML в Visual Studio, используйте команду **сформировать код** . По умолчанию команда создает тип C# для каждого выбранного типа UML. Это поведение можно изменить и расширить, изменив или скопировав текстовые шаблоны для создания кода. Можно задать другое поведение для типов, которые содержатся в разных пакетах модели.

 Команда **сформировать код** особенно подходит для создания кода из выбранных пользователем элементов и создания одного файла для каждого класса UML или другого элемента. Например, на снимке экрана показаны два файла C#, созданные из двух UML-классов.

 В качестве альтернативы, если требуется создать код, в котором создаваемые файлы не имеют связи 1:1 с элементами UML, можно рассмотреть возможность написания текстовых шаблонов, которые вызываются с помощью команды **преобразовать все шаблоны** . Дополнительные сведения об этом методе см. в разделе [Создание файлов из модели UML](../modeling/generate-files-from-a-uml-model.md).

 ![Схема классов UML и созданные файлы классов C&#35;.](../modeling/media/oob-gencode1.png "oob_GenCode1")

 Подробнее о схемах классов UML в Visual Studio читайте в следующих разделах:

- [UML-схемы классов: справочные материалы](../modeling/uml-class-diagrams-reference.md)

- [UML-схемы классов: правила работы](../modeling/uml-class-diagrams-guidelines.md)

  Сведения о том, какие версии Visual Studio поддерживают UML-схемы классов, см. в разделе [Поддержка версий для инструментов архитектуры и моделирования](../modeling/what-s-new-for-design-in-visual-studio.md#VersionSupport).

## <a name="using-the-generate-code-command"></a>Использование команды создания кода
 Следующая процедура описывает поведение по умолчанию для команды **сформировать код** :

#### <a name="to-generate-a-separate-file-for-each-element"></a>Создание отдельного файла для каждого элемента

1. Создайте UML-модель, содержащую классы. Возможно, потребуется применить к элементам модели стереотипы.

    Дополнительные сведения см. в разделе [преобразования создания кода по умолчанию](#default).

2. На схеме классов или в **обозревателе моделей UML**выберите элементы, из которых нужно создать код. Можно выбрать один из следующих вариантов:

   - Конкретный набор элементов.

   - Пакет или модель для создания кода из содержимого пакета или модели.

   - Схема, на которой можно выбрать все элементы.

3. Откройте контекстное меню для выбранного элемента и выберите команду **создать код**.

    При первом использовании **создания кода** в конкретной модели появляется диалоговое окно. Это диалоговое окно позволяет изменять параметры создания кода модели.

    Нажмите кнопку **ОК** , если не уверены, что вы хотите изменить эти параметры.

    Чтобы вернуться к этому диалоговому окну позже, откройте **Обозреватель моделей UML**. Откройте контекстное меню проекта моделирования и выберите пункт **Настройка создания кода**. Дополнительные сведения см. [в разделе Настройка команды создания кода](#custom).

   Создаются файлы, содержащие код C#. В сценарии по умолчанию для каждого типа создается отдельный файл. Такие файлы создаются в проекте библиотеки классов C#. Однако можно выполнить пользовательскую настройку такого поведения. Дополнительные сведения см. [в разделе Настройка команды создания кода](#custom).

   С моделью выполняются некоторые проверочные тесты, позволяющие убедиться, что модель можно преобразовать в C#. Если модель не проходит тесты, отображается сообщение об ошибке, создание кода не выполняется. Если была создана команда меню проверки, код создается только для элементов, успешно прошедших такую проверку. Дополнительные сведения см. в разделе [Определение ограничений проверки для моделей UML](../modeling/define-validation-constraints-for-uml-models.md).

## <a name="default-code-generation-transforms"></a><a name="default"></a> Преобразования создания кода по умолчанию
 В этом разделе обобщены результаты, созданные командой **создать код** , если не настроить команду. Дополнительные сведения см. [в разделе Настройка команды создания кода](#custom).

- Для каждого выбранного в UML-модели типа создается один тип C#. Каждый тип размещается в отдельном файле кода в папке **GeneratedCode**

- Если UML-тип содержится в пакете, созданный тип C# помещается в пространство имен, а файл создается в папке, имя которой совпадает с именем пространства имен.

- Свойство C# создается для каждого атрибута `Attribute` UML-класса.

- Метод C# создается для каждой операции `Operation` UML-типа.

- Поле C# создается для каждой ассоциации с возможностью перехода, в которой участвует класс.

  Добавление стереотипов в каждый UML-тип позволяет контролировать больше свойств созданного типа C#.

|**Создание типа C#**|**Использование UML-типа**|**Применение стереотипа**|
|---------------------------------|----------------------------|-------------------------------|
|Класс|Класс|\<none> или<br /><br /> класс C#|
|Интерфейс|Интерфейс|\<none> или<br /><br /> интерфейс C#|
|Перечисление|Перечисление|\<none> или<br /><br /> C# enum|
|Делегат|Класс|делегат C#|
|Структура|Класс|C# struct|

#### <a name="to-set-a-stereotype-on-a-type-or-other-element"></a>Задание стереотипа в типе или другом элементе

1. Откройте контекстное меню элемента на схеме или в **обозревателе моделей UML**и выберите пункт **свойства**.

2. В окне **Свойства** выберите стрелку раскрывающегося списка в свойстве **стереотипы** и установите флажок для стереотипа, который необходимо применить.

   > [!TIP]
   > Если стереотипы C# не отображаются, включите профиль C# для модели или пакета, содержащего нужные элементы модели. Выберите пакет или корень модели в **обозревателе моделей UML**. Затем в окне **Свойства** выберите **профиль**, а затем включите профиль C#.

3. Разверните свойство **стереотипы** , чтобы просмотреть дополнительные свойства, которые можно задать.

   Свойства **описания** типов, атрибутов, операций и ассоциаций записываются в `<summary>` комментарии в созданном коде. Элементы комментариев, связанные с типами, записываются в комментарии `<remarks>`.

## <a name="varying-the-generated-code"></a>Варьирование созданного кода
 Созданный код варьируется в зависимости от свойств каждого типа, атрибута или операции. Например, если задать для **абстрактного** свойства класса значение true, то в `abstract` созданном классе будет отображаться ключевое слово. Если установить **кратность** атрибута в **0. \* .**, то созданное свойство будет иметь `IEnumerable<>` тип.

 Кроме того, каждый стереотип предоставляет несколько дополнительных свойств, которые можно задать. Эти значения преобразуются в соответствующие ключевые слова в коде C#. Например, если задать значения для свойства `Is Static` в классе, класс C# будет `static`.

 Чтобы задать эти дополнительные свойства, выберите класс или другой элемент на схеме. В окно свойств разверните элемент **стереотипы**, а затем разверните стереотип c#, например **класс c#**.  Для классов такие дополнительные свойства включают:

- CLR-атрибуты

- Является разделенным

- Является статическим

- Является небезопасным

- Видимость пакета

  Каждый атрибут и операция имеет свойства стереотипа, которые можно задать. Если вы не видите свойства для нового атрибута, выполните команду **создать код**.

## <a name="customizing-the-generate-code-command"></a><a name="custom"></a> Настройка команды «сформировать код»
 Команда **создания кода** работает путем преобразования элементов модели с помощью набора текстовых шаблонов. Дополнительные сведения о текстовых шаблонах см. в разделе [Создание кода и текстовые шаблоны T4](../modeling/code-generation-and-t4-text-templates.md).

 Шаблоны задаются в наборе *привязок текстовых шаблонов*. Привязка к текстовому шаблону указывает, какой шаблон следует применить, где должны быть помещены создаваемые выходные данные, и другие параметры команды **сформировать код** .

 При первом запуске команды **сформировать код** для конкретной модели она присоединяет набор привязок шаблона по умолчанию к корню модели. Эти привязки применимы ко всем элементам модели.

 Однако набор этих привязок по умолчанию можно переопределить и расширить, прикрепив пользовательские привязки к пакетам, классам или другим элементам. Привязка применима ко всем элементам, которые содержатся внутри элемента, к которому прикреплена привязка. Например, если требуется преобразовать все типы внутри определенного пакета с использованием другого набора шаблонов или сохранить выходные данные в другой папке, можно прикрепить к пакету привязки шаблонов.

 Чтобы проверить привязки шаблонов, присоединенные к элементу модели, нажмите кнопку с многоточием **[...]** в свойстве **привязки текстовых шаблонов** в окно свойств.

 Команда **сформировать код** применяет шаблоны к каждому выбранному элементу модели. Применяемым набором шаблонов для каждого элемента является совокупный набор шаблонов, прикрепленный к контейнерам элемента, вплоть до корня модели и включая его.

 Если две привязки шаблонов в этом наборе имеют одно и то же имя, привязка в более мелком контейнере переопределяет привязку в более крупном. Например, корневой элемент модели имеет привязку с **шаблоном Class**Name. Чтобы применить к содержимому определенного пакета собственный шаблон, определите собственную привязку шаблона, имеющую **шаблон Class**Name.

 К элементу модели можно применить несколько шаблонов. Из каждого элемента модели можно создать несколько файлов.

> [!NOTE]
> Привязки, прикрепленные к корню модели, выполняют функции привязок по умолчанию для всех элементов модели. Чтобы просмотреть эти привязки по умолчанию, откройте **Обозреватель моделей UML**. Откройте контекстное меню проекта моделирования и выберите пункт **Настройка создания кода**. Кроме того, можно выбрать корень модели в обозревателе моделей UML. В окно свойств выберите **[...]** в свойстве **привязки текстовых шаблонов** . Привязки не будут отображаться, пока не будет использована команда **сформировать код** хотя бы один раз. Привязки шаблонов невозможно прикрепить к схеме.

#### <a name="to-attach-text-template-bindings-to-a-package-or-other-model-element"></a>Прикрепление привязок текстовых шаблонов к пакету или другому элементу модели

1. В **обозревателе моделей UML**откройте контекстное меню элемента модели и выберите пункт **свойства**. Как правило, привязки текстовых шаблонов прикрепляются к пакету или к корню модели.

2. В окне **Свойства** нажмите кнопку с многоточием (**[...]**) в свойстве **привязки текстовых шаблонов** .

    Откроется диалоговое окно **привязки текстовых шаблонов** .

3. Нажмите кнопку **Добавить** , чтобы создать новую привязку текстового шаблона.

    \- или -

    Выберите существующую привязку, чтобы изменить ее.

    Каждая привязка шаблонов определяет способ применения заданного шаблона к выбранному элементу модели и другим элементам модели, которые в нем содержатся.

4. В диалоговом окне задайте свойства привязки текстовых шаблонов.

   |    **Свойство**    |                                                                                                                                                                                                                                                                                                                    **Описание**                                                                                                                                                                                                                                                                                                                    |
   |--------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
   |        Имя        |                                                                                                                                                                                                                                                  Имя данной привязки. Чтобы переопределить привязку, наследованную от содержащего элементы пакета или модели, используйте имя, совпадающее с именем привязки, которую требуется переопределить.                                                                                                                                                                                                                                                  |
   |     Overwrite      |                                                                                                                                                                                                                                                                                                      Если это свойство имеет значение true, существующий код перезаписывается.                                                                                                                                                                                                                                                                                                       |
   |    Имя цели     | Имя создаваемого файла.<br /><br /> В эту строку можно вставлять выражения, такие как `{Name}` или `{Owner.Name}` . Например, можно написать: `{Owner.Name}_{Name}` . Выражение оценивается в элементе модели. Оно может использовать свойства элементов, но не его методы. Чтобы узнать, какие свойства можно использовать, просмотрите свойства типов в **Microsoft. VisualStudio. UML. \* **. \*\*Важно. \* \* `{Name}` или `{Owner.Name}` может использоваться только в свойстве **target name** .   Чтобы изменить имя созданного класса, необходимо изменить шаблон. Дополнительные сведения см. [в разделе Написание текстового шаблона](#writing). |
   |    Путь проекта    |                                                                      Задает путь к проекту [!INCLUDE[vsprvs](../includes/vsprvs-md.md)], в котором будут содержаться выходные файлы преобразования. Для создания нового проекта используйте типизированные значения. Нажмите кнопку с многоточием (**[...]**), чтобы выбрать существующий проект.<br /><br /> Если проекта не существует, будет создан новый проект. Это будет проект библиотеки классов C#.<br /><br /> Для этого необходимо указать проект напрямую. Можно включить макрос переменной среды, такой как %ProgramFiles% или %LocalAppData%.                                                                       |
   |  Целевой каталог  |                                                                                          Папка, в которой создается целевой файл. Путь является относительным по отношению к папке проекта.<br /><br /> Можно воспользоваться выражением `{PackageStructure}`, чтобы вставить путь, соответствующий именам содержащих элементы пакетов. Значение по умолчанию — `\GeneratedCode\{PackageStructure}`. Кроме того, можно включить переменные среды, например %TEMP% или %HomePath%. **Важно.** `{PackageStructure}` может использоваться только в свойстве **целевого каталога** .                                                                                            |
   | Путь к файлу шаблона |                                                                                                                                                           Шаблон, который будет выполнять преобразование.<br /><br /> Можно использовать предоставленные шаблоны или создать свой собственный. Предоставленные шаблоны можно найти в следующем расположении:<br /><br /> …\Program Files\Microsoft Visual Studio 12.0\Common7\IDE\Extensions\Microsoft\Architecture Tools\Extensibility\Templates\Text\                                                                                                                                                           |

5. К элементу можно прикрепить любое количество привязок.

## <a name="writing-a-text-template"></a><a name="writing"></a> Написание текстового шаблона
 Можно создать собственные текстовые шаблоны. Текстовые шаблоны позволяют создавать программный код или текстовые файлы любого другого вида.

 Рекомендуется начать с изменения копий стандартных шаблонов. Можно копировать шаблоны из следующих местоположений:

 …\Program Files\Microsoft Visual Studio 12.0\Common7\IDE\Extensions\Microsoft\Architecture Tools\Extensibility\Templates\Text\

 Сведения о текстовых шаблонах см. в следующих разделах.

- Текстовый шаблон — это прототип получаемого файла, который содержит текст и программный код, выполняющий считывание модели. Дополнительные сведения см. в разделе [Создание кода и текстовые шаблоны T4](../modeling/code-generation-and-t4-text-templates.md).

- Для осуществления перехода по UML-модели в программном коде необходимо использовать API-интерфейс UML. Дополнительные сведения см. [в разделе Навигация по модели UML](../modeling/navigate-the-uml-model.md) и [Справочник по API для расширяемости моделирования UML](../modeling/api-reference-for-uml-modeling-extensibility.md).

  Чтобы использовать шаблоны с командой **сформировать код** , необходимо включить директиву моделирования. Пример:

  `<#@ Modeling ElementType="Microsoft.VisualStudio.Uml.Classes.IClass" Processor="ModelingProcessor" #>`

  Атрибут `ElementType` определяет тип UML-элемента, к которому применим данный шаблон.

  В этом шаблоне `this` принадлежит временному классу со следующими свойствами:

- `Element` = [IELEMENT](/previous-versions/dd516035(v=vs.140)) UML, к которому применяется шаблон.

- `Errors`: <xref:System.CodeDom.Compiler.CompilerErrorCollection>

- `Host`: [Итексттемплатинженгинехост](/previous-versions/visualstudio/visual-studio-2012/bb126505(v=vs.110))

- `ModelBus`: [ModelBus](/previous-versions/ee904639(v=vs.140)). Дополнительные сведения см. [в разделе Интеграция моделей UML с другими моделями и инструментами](../modeling/integrate-uml-models-with-other-models-and-tools.md).

- `ProfileName` = "C#Profile"

- `ServiceProvider`: <xref:System.IServiceProvider>

- `Session`: <xref:Microsoft.VisualStudio.TextTemplating.TextTemplatingSession>.

- `Store`: <xref:Microsoft.VisualStudio.Modeling.Store>. Это хранилище пакета Visualization and Modeling SDK, к которому применяется хранилище UML ModelStore. Чтобы получить [ИМОДЕЛСТОРЕ](/previous-versions/ee789385(v=vs.140))UML, используйте `this.Element.GetModelStore()` .

  Следующие советы могут оказаться полезными при создании текстового шаблона. Эти сведения подробно описаны в разделе [Создание кода и текстовые шаблоны T4](../modeling/code-generation-and-t4-text-templates.md).

- Задать расширение имени получаемого файла можно в директиве `Output`. Каждому текстовому шаблону требуется отдельная директива `Output`.

- Шаблон автоматически ссылается на некоторые сборки. Эти сборки включают, к примеру, System.dll и Microsoft.VisualStudio.Uml.Interfaces.dll.

   Для использования других сборок в создаваемом программном коде необходимо использовать директиву `Assembly`. Пример:

   `<#@ Assembly Name="%ProgramFiles%\Microsoft Visual Studio 12.0\Common7\IDE\PublicAssemblies\Microsoft.VisualStudio.ArchitectureTools.Extensibility.dll" #>`

- Некоторые пространства имен, такие как `System`, автоматически импортируются в программный код. Для других пространств имен можно использовать директиву `Import` так же, как использовалась бы инструкция `using`. Пример:

   `<#@ Import Namespace="Microsoft.VisualStudio.Uml.Classes" #>`

   `<#@ Import Namespace="Microsoft.VisualStudio.ArchitectureTools.Extensibility.Uml" #>`

- Используйте директиву `Include`, чтобы создать ссылку на текст другого файла.

- Части шаблона, заключенные в скобки, `<# ... #>` выполняются командой **сформировать код** . Части шаблона за пределами этих скобок копируются в получаемый файл. Важно различать генерирующий код и генерируемый текст. Текст может генерироваться на любом языке.

- `<#= Expressions #>` оцениваются и преобразуются в строки.

## <a name="see-also"></a>См. также:
 [UML-схемы классов. ссылки на](../modeling/uml-class-diagrams-reference.md) [UML-схемы классов: рекомендации по](../modeling/uml-class-diagrams-guidelines.md) [ФОРМИРОВАНИю файлов из модели UML](../modeling/generate-files-from-a-uml-model.md)
