---
title: Создание файлов из модели UML | Документация Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-modeling
ms.topic: conceptual
helpviewer_keywords:
- UML model, generating files
ms.assetid: 4e28b0e6-ce8f-45ee-9e3a-e4d600a0ad81
caps.latest.revision: 21
author: jillre
ms.author: jillfra
manager: jillfra
ms.openlocfilehash: 832dc3f7fea959ff4d2834aba921cd16f1117b5c
ms.sourcegitcommit: a8e8f4bd5d508da34bbe9f2d4d9fa94da0539de0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/19/2019
ms.locfileid: "72666148"
---
# <a name="generate-files-from-a-uml-model"></a>Создание файлов на основе модели UML
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

На основе модели UML можно создавать программный код, схемы, документы, ресурсы и другие артефакты. Одним из удобных способов создания текстовых файлов из модели UML является использование [текстовых шаблонов](../modeling/code-generation-and-t4-text-templates.md). В этом случае можно вставлять программный код в текст, который необходимо создать.

 Существует три возможных сценария.

- [Создание файлов из команды меню](#Command) или жеста. Для этого нужно определить команду [!INCLUDE[vsprvs](../includes/vsprvs-md.md)], доступную в моделях UML.

- [Создание файлов из приложения](#Application). Нужно создать приложение, читающее модели UML и создающее файлы.

- [Создание во время разработки](#Design). Модель используется для определения некоторых функциональных возможностей приложения, создания кода. ресурсов и т. д. в решении [!INCLUDE[vsprvs](../includes/vsprvs-md.md)].

  В этом разделе заканчивается обсуждение того, [как использовать создание текста](#What). Дополнительные сведения см. в разделе [Создание кода и текстовые шаблоны T4](../modeling/code-generation-and-t4-text-templates.md).

## <a name="Command"></a>Создание файлов из команды меню
 В команде меню UML можно использовать предварительно обработанные шаблоны текста. В коде шаблона текста или в отдельном разделяемом классе можно прочитать модель, отображаемую на схеме.

 Подробнее об этих возможностях читайте в следующих разделах:

- [Определение команды меню на схеме моделирования](../modeling/define-a-menu-command-on-a-modeling-diagram.md)

- [Создание текста во время выполнения с помощью текстовых шаблонов T4](../modeling/run-time-text-generation-with-t4-text-templates.md)

- [Навигация по модели UML](../modeling/navigate-the-uml-model.md)

  Подход, продемонстрированный в примере ниже, подходит для создания текста на основе одной модели, когда операция инициируется из одной из схем модели. Чтобы обработать модель в отдельном контексте, рассмотрите возможность использования [Visual Studio ModelBus](../modeling/integrate-uml-models-with-other-models-and-tools.md) для доступа к модели и ее элементам.

### <a name="example"></a>Пример
 Для выполнения этого примера создайте проект расширения [!INCLUDE[vsprvs](../includes/vsprvs-md.md)] (VSIX). Имя проекта, используемое в этом примере, — `VdmGenerator`. В файле **source. extension. vsixmanifest** щелкните **Добавить содержимое** и задайте для поля Тип значение **компонент MEF** и исходный путь, ссылающийся на текущий проект. Дополнительные сведения о настройке этого типа проекта см. в разделе [Определение команды меню на схеме моделирования](../modeling/define-a-menu-command-on-a-modeling-diagram.md).

 Добавьте в проект файл C#, содержащий приведенный ниже код. Этот класс определяет команду меню, которая отобразится на схеме классов UML.

```
using System;
using System.ComponentModel.Composition;
using Microsoft.VisualStudio.ArchitectureTools.Extensibility.Uml;
using Microsoft.VisualStudio.ArchitectureTools.Extensibility.Presentation;
using Microsoft.VisualStudio.Modeling.ExtensionEnablement;

namespace VdmGenerator
{
  [Export(typeof(ICommandExtension))]
  [ClassDesignerExtension]
  public class GenerateVdmFromClasses : ICommandExtension
  {
    [Import] public IDiagramContext DiagramContext { get; set; }
    public void Execute(IMenuCommand command)
    {
      // Initialize the template with the Model Store.
      VdmGen generator = new VdmGen(
             DiagramContext.CurrentDiagram.ModelStore);
      // Generate the text and write it.
      System.IO.File.WriteAllText
        (System.IO.Path.Combine(
            Environment.GetFolderPath(
                Environment.SpecialFolder.Desktop),
            "Generated.txt")
         , generator.TransformText());
    }
    public void QueryStatus(IMenuCommand command)
    {
      command.Enabled = command.Visible = true;
    }
    public string Text
    { get { return "Generate VDM"; } }
  }
}
```

 Приведенный ниже файл представляет собой текстовый шаблон. Он создает строку текста для каждого класса UML в модели, а также для каждого атрибута этих классов. Код для чтения модели вставлен в текст и разделен `<# ... #>`.

 Чтобы создать этот файл, щелкните правой кнопкой мыши проект в обозреватель решений, наведите указатель на пункт **Добавить**и выберите пункт **новый элемент**. Выберите **предварительно обработанный текстовый шаблон**. Имя файла для этого примера должно быть **VdmGen.TT**. Свойство **пользовательского инструмента** для файла должно быть **тексттемплатингфилепрепроцессор**. Дополнительные сведения о предварительно обработанных текстовых шаблонах см. [в статье Создание текста во время выполнения с помощью текстовых шаблонов T4](../modeling/run-time-text-generation-with-t4-text-templates.md).

```
<#@ import namespace="Microsoft.VisualStudio.Uml.Classes" #>
<#
   foreach (IClass classElement in store.AllInstances<IClass>())   {
#>
Type <#= classElement.Name #> ::
<#
     foreach (IProperty attribute in classElement.OwnedAttributes)     {
#>
       <#= attribute.Name #> : <#=
           attribute.Type == null ? ""
                                  : attribute.Type.Name #>
<#
     }   }
#>
```

 Текстовый шаблон создает разделяемый класс C#, который становится частью проекта [!INCLUDE[vsprvs](../includes/vsprvs-md.md)]. В отдельном файле нужно добавить другое частичное объявление того же класса. Этот код предоставляет шаблон с возможностью доступа к хранилищу моделей UML.

```
using Microsoft.VisualStudio.ArchitectureTools.Extensibility.Uml;
namespace VdmGenerator
{
    public partial class VdmGen
    {
        private IModelStore store;
        public VdmGen(IModelStore s)
        { store = s; }
    }
}
```

 Чтобы протестировать проект, нажмите клавишу **F5**. Будет запущен новый экземпляр [!INCLUDE[vsprvs](../includes/vsprvs-md.md)]. В этом экземпляре откройте или создайте модель UML, содержащую схему классов. Добавьте на схему несколько классов, а в каждый класс — несколько атрибутов. Щелкните правой кнопкой мыши диаграмму и выберите команду пример `Generate VDM`. Команда создает файл `C:\Generated.txt`. Проверьте этот файл. Его содержимое должно напоминать приведенный ниже текст, но с перечислением ваших собственных классов и атрибутов.

```
Type Class1 ::
          Attribute1 : int
          Attribute2 : string
Type Class2 ::
          Attribute3 : string
```

## <a name="Application"></a>Создание файлов из приложения
 Файлы можно создать из приложения, которое читает модель UML. Для этой цели наиболее гибкий и надежный способ доступа к модели и ее элементам — [Visual Studio ModelBus](../modeling/integrate-uml-models-with-other-models-and-tools.md).

 Кроме того, для загрузки модели и ее передачи в текстовые шаблоны с помощью приемов, описанных в предыдущем подразделе, можно использовать базовый API-интерфейс. Дополнительные сведения о загрузке модели см. в разделе [Чтение модели UML в программном коде](../modeling/read-a-uml-model-in-program-code.md).

## <a name="Design"></a>Создание файлов во время разработки
 Если стандартным методом интерпретации UML в проекте является код, можно создать текстовые шаблоны, позволяющие создавать код на основе модели UML внутри проекта. Как правило, имеется решение, которое содержит проект модели UML и один или несколько проектов для кода приложения. Каждый проект кода может содержать несколько шаблонов, создающих программный код, ресурсы и файлы конфигурации на основе содержимого модели. Разработчик может запустить все шаблоны, щелкнув элемент **преобразовать все шаблоны** на панели инструментов Обозреватель решений. Программный код, как правило, создается в форме разделяемых классов, так как это облегчает интеграцию созданных вручную частей.

 Проект [!INCLUDE[vsprvs](../includes/vsprvs-md.md)] такого вида можно распространять в форме шаблона, чтобы каждый участник команды мог создавать проекты, генерирующие код на основе модели аналогичным образом. Как правило, шаблон — это часть пакета расширения, включающая ограничения проверки модели, чтобы гарантировать соблюдение предусловий кода создания.

### <a name="outline-procedure-for-generating-files"></a>Общая процедура создания файлов

- Чтобы добавить шаблон в проект, выберите **текстовый шаблон** в диалоговом окне Добавление нового файла. Шаблон можно добавить в проект практически любого типа, за исключением проектов моделирования.

- Свойство Custom Tools файла шаблона должно быть **тексттемплатингфилеженератор**, а расширение имени файла должно быть. tt.

- Шаблон должен иметь по меньшей мере директиву output.

     `<#@ output extension=".cs" #>`

     Задайте в поле расширения значение, соответствующее языку проекта.

- Чтобы разрешить коду создания в шаблоне доступ к модели, создайте для всех сборок, необходимых для прочтения модели UML, директивы `<#@ assembly #>`. Для открытия модели используйте `ModelingProject.LoadReadOnly()`. Дополнительные сведения см. [в разделе Чтение модели UML в программном коде](../modeling/read-a-uml-model-in-program-code.md).

- Шаблон выполняется при сохранении и нажатии кнопки **преобразовать все шаблоны** на панели инструментов Обозреватель решений.

- Дополнительные сведения об этом типе шаблонов см. в разделе [Создание кода во время разработки с помощью текстовых шаблонов T4](../modeling/design-time-code-generation-by-using-t4-text-templates.md).

- В стандартном проекте имеется несколько шаблонов, позволяющих создавать на основе одной модели разные файлы. Первая часть всех шаблонов одинаковая. Во избежание дублирования переместите совпадающие части в отдельный текстовый файл и вызывайте его по мере надобности в каждом шаблоне с помощью директивы `<#@include file="common.txt"#>`.

- Кроме того, можно определить специализированный процессор директив, позволяющий предоставлять параметры в процессе создания текста. Дополнительные сведения см. в разделе [Настройка преобразования текста T4](../modeling/customizing-t4-text-transformation.md).

### <a name="example"></a>Пример
 В этом примере показано создание класса C# для каждого класса UML в исходной модели.

##### <a name="to-set-up-a-visual-studio-solution-for-this-example"></a>Настройка решения Visual Studio для этого примера

1. Создайте схему классов UML в проекте моделирования нового решения.

   1. В меню **архитектура** выберите пункт **создать диаграмму**.

   2. Выберите **UML-схему классов**.

   3. Следуйте инструкциям на экране, чтобы создать решение и проект моделирования.

   4. Добавьте на схему несколько классов, перетащив инструмент "Класс UML" с панели элементов.

   5. Сохраните файл.

2. Создайте проект C# или Visual Basic в том же решении.

   - В обозреватель решений щелкните решение правой кнопкой мыши, наведите указатель на пункт **Добавить**и выберите пункт **Новый проект**. В разделе **Установленные шаблоны**щелкните **Visual Basic** или **визуальный C#элемент,** а затем выберите тип проекта, например **консольное приложение**.

3. Добавьте в проект C# или Visual Basic обычный текстовый файл. Этот файл содержит код, который можно использовать для создания нескольких текстовых шаблонов.

   - В обозреватель решений щелкните правой кнопкой мыши проект, наведите указатель на пункт **Добавить**и выберите пункт **новый элемент**. Выберите **текстовый файл**.

     Вставьте текст, показанный в следующем подразделе.

4. Добавьте в проект C# или Visual Basic файл текстового шаблона.

   - В обозреватель решений щелкните правой кнопкой мыши проект, наведите указатель на пункт **Добавить**и выберите пункт **новый элемент**. Выберите **текстовый шаблон**.

     Вставьте приведенный ниже код в файл текстового шаблона.

5. Сохраните файл текстового шаблона.

6. Проверьте код в дочернем файле. Он должен содержать класс для каждого класса UML в модели.

   1. В Visual Basic проекте щелкните **Показывать все файлы** на панели инструментов Обозреватель решений.

   2. Разверните узел файла шаблона в обозревателе решений.

#### <a name="content-of-the-shared-text-file"></a>Содержимое общего текстового файла
 В этом примере этот файл называется SharedTemplateCode.txt и находится в той же папке, что и текстовые шаблоны.

```
<# /* Common material for inclusion in my model templates */ #>
<# /* hostspecific allows access to the Visual Studio API */ #>
<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="Microsoft.VisualStudio.Uml.Interfaces.dll"#>
<#@ assembly name="Microsoft.VisualStudio.ArchitectureTools.Extensibility.dll"#>
<#@ assembly name="EnvDTE" #>
<#@ import namespace="Microsoft.VisualStudio.Uml.Classes" #>
<#@ import namespace="Microsoft.VisualStudio.ArchitectureTools.Extensibility" #>
<#@ import namespace="Microsoft.VisualStudio.ArchitectureTools.Extensibility.Uml" #>
<#+  // Note this is a Class Feature Block
///<summary>
/// Text templates are run in a common AppDomain, so
/// we can cache the model store that we find.
///</summary>
private IModelStore StoreCache
{
  get { return AppDomain.CurrentDomain.GetData("ModelStore") as IModelStore; }
  set { AppDomain.CurrentDomain.SetData("ModelStore", value); }
}
private bool CacheIsOld()
{
    DateTime? dt = AppDomain.CurrentDomain
           .GetData("latestAccessTime") as DateTime?;
    DateTime t = dt.HasValue ? dt.Value : new DateTime();
    DateTime now = DateTime.Now;
    AppDomain.CurrentDomain.SetData("latestAccessTime", now);
    return now.Subtract(t).Seconds > 3;
}

///<summary>
/// Find the UML modeling project in this solution,
/// and load the model.
///</summary>
private IModelStore ModelStore
{
  get
  {
    // Avoid loading the model for every template:
    if (StoreCache == null || CacheIsOld())
    {
      // Use Visual Studio API to find modeling project:
      EnvDTE.DTE dte = (EnvDTE.DTE) ((IServiceProvider) this.Host)
                       .GetService(typeof(EnvDTE.DTE));
      EnvDTE.Project project = null;
      foreach (EnvDTE.Project p in dte.Solution.Projects)
      {
        if (p.FullName.EndsWith(".modelproj"))
        {
          project = p;
          break;
        }
      }
      if (project == null) return null;

      // Load UML model into this AppDomain
      // and access model store:
      IModelingProjectReader reader =
           ModelingProject.LoadReadOnly(project.FullName);
      StoreCache = reader.Store;
    }
    return StoreCache;
  }
}
#>
```

#### <a name="content-of-the-text-template-file"></a>Содержимое файла текстового шаблона
 Следующий текст помещается в **TT** -файл. В этом примере в файле C# классы создаются из классов UML модели. Вы можете, однако, создавать файлы любого типа. Язык созданного файла не связан с языком, на котором написан код текстового шаблона.

```
<#@include file="SharedTemplateCode.txt"#>
<#@ output extension=".cs" #>
namespace Test{
<#
      foreach (IClass c in ModelStore.AllInstances<IClass>())
      {
#>
   public partial class <#=c.Name#>
   {   }
<#
      }
#>
}
```

## <a name="What"></a>Использование создания текста
 Преимущества моделирования раскрываются полнее всего, если модели используются для конструирования на уровне требований или архитектуры. Текстовые шаблоны можно использовать для выполнения некоторых задач по преобразованию высокоуровневых идей в код. Очень часто это не порождает однозначное соответствие между элементами в моделях UML и классах или других частях программного кода.

 Более того, ход преобразования определяется проблемной областью; универсальное сопоставление между моделями и кодом невозможно.

 Ниже приведено несколько примеров создания кода на основе моделей.

- **Линейки продуктов**. Компания Fabrikam, Inc. создает и устанавливает системы обработки багажа в аэропорту. Большая часть программного обеспечения совпадает в разных проектах. Различается только конфигурация ПО, которая определяется типом установленного оборудования для обработки багажа и конвейерных лент, соединяющих разные части этого оборудования. В самом начале выполнения контракта аналитики Fabrikam обсудили требования к системам с руководством аэропорта и с помощью схемы деятельности UML составили план оборудования. На основе этой модели команда разработчиков создала файлы конфигурации, программный код, планы и документацию для пользователей. Наконец, в код было внесено вручную несколько добавлений и изменений. Приобретая все больший опыт в таких проектах, команда разработчиков создает все более полные и разнообразные материалы.

- **Шаблоны**. Разработчики из компании Contoso, Ltd часто используют при создании веб-сайтов и разработке схем навигации схемы классов UML. Каждая веб-страница представлена классом, а ссылки навигации — ассоциациями. Большую часть кода для веб-сайта разработчики берут из этой модели. Каждая веб-страница соответствует нескольким классам и записям в файле ресурсов.  Преимущество этого метода в том, что все страницы создаются на основе одного шаблона, что обеспечивает большую надежность и гибкость, чем созданный вручную код. Шаблоны создания фиксируют общие аспекты, а модель — меняющиеся от проекта к проекту.

- **Схемы**. Компания Humongous Insurance работает с тысячами информационных систем по всему миру. В этих системах используются разные базы данных, языки и интерфейсы. Центральная команда системных архитекторов публикует модели бизнес-концепций и бизнес-процессов для внутреннего пользования. На основе этих моделей локальные команды создают компоненты схем баз данных и схем обмена, объявления в программном коде и т. д. Графическое представление моделей помогает командам обсуждать предложения. Команды создают несколько схем, на которых показаны подмножества модели, применимые к разным бизнес-областям. Изменяемые зоны выделяются цветом.

## <a name="important-techniques-for-generating-artifacts"></a>Полезные приемы создания артефактов
 В предыдущих примерах модели использовались для решения разных связанных с бизнесом задач, а реализация элементов моделей (классов и действий) различалась от приложения к приложению. При создании артефактов на основе моделей полезны указанные ниже приемы.

- **Профили**. Даже в пределах одной бизнес-области интерпретация типа элемента может варьироваться. Например, на схеме веб-сайта некоторые классы могут представлять веб-страницы, а другие — блоки содержимого. Чтобы облегчить регистрацию этих различий пользователями, определяются стереотипы. Кроме того, стереотипы позволяют прикреплять дополнительные свойства, применимые к элементам соответствующего вида. Стереотипы упакованы в профили. Дополнительные сведения см. в разделе [Определение профиля для расширения UML](../modeling/define-a-profile-to-extend-uml.md).

     В коде шаблона можно легко получить доступ к определенным для объекта стереотипам. Пример:

    ```
    public bool HasStereotype(IClass c, string profile, string stereo)
    { return c.AppliedStereotypes.Any
       (s => s.Profile == profile && s.Name == stereo ); }
    ```

- **Ограниченные модели**. Не все создаваемые модели можно использовать для любых целей. Например, в моделях систем обработки багажа Fabrikam отсутствие исходящего конвейера на стойке регистрации будет ошибкой. Вы можете определить функции проверки, с помощью которых пользователи будут следить за соблюдением подобных ограничений. Дополнительные сведения см. в разделе [Определение ограничений проверки для моделей UML](../modeling/define-validation-constraints-for-uml-models.md).

- **Сохранение изменений вручную**. Лишь некоторые файлы решения можно создать на основе модели. В большинстве случаев в созданное содержимое приходится вносить добавления и изменения вручную. При этом очень важно, чтобы эти изменения сохранялись при повторном запуске процесса преобразования шаблона.

     Когда шаблоны создают код на [!INCLUDE[TLA2#tla_net](../includes/tla2sharptla-net-md.md)] языках, они должны создавать разделяемые классы, чтобы разработчики могли добавлять методы и код. Полезно создавать каждый класс в виде пары: абстрактный базовый класс с методами и наследующий класс, который содержит только конструктор. Это позволяет разработчикам переопределять методы. Чтобы разрешить переопределение инициализации, это делается не в конструкторах, а в отдельном методе.

     Если с помощью шаблона создается XML-код и другие выходные данные, отделить внесенные вручную изменения от автоматически созданного содержимого может оказаться нелегко. Для этого можно создать задачу в процессе сборки, которая объединяет два файла. Кроме того, разработчики могут скорректировать локальную копию шаблона создания.

- **Перемещение кода в отдельные сборки**. Мы не рекомендуем создавать в шаблонах большие объемы кода. Предпочтительнее отделить созданное содержимое от вычислений. Кроме того, текстовые шаблоны предоставляют ограниченные возможности редактирования кода.

     Если вам нужно выполнять объемные вычисления для создания текста, выполните сборку функций в отдельной сборке и вызывайте ее методы из шаблона.
