---
title: Практическое руководство. Использование транзакций для обновления модели | Документация Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-modeling
ms.topic: conceptual
ms.assetid: e24436a5-7f97-401b-bc83-20d188d10d5b
caps.latest.revision: 9
author: gewarren
ms.author: gewarren
manager: jillfra
ms.openlocfilehash: bbc09543d0ee0297678d3f205becc55a6b6d7714
ms.sourcegitcommit: 94b3a052fb1229c7e7f8804b09c1d403385c7630
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "68181503"
---
# <a name="how-to-use-transactions-to-update-the-model"></a>Практическое руководство. Обновление модели с помощью транзакций
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Транзакций убедитесь, что изменения, внесенные в хранилище, рассматриваются как группу. Изменения, которые группируются можно зафиксировать или откатить как единое целое.  
  
 Каждый раз, когда код программы изменяет, добавляет или удаляет любой элемент в Store в [!INCLUDE[vsprvs](../includes/vsprvs-md.md)] Visualization and Modeling SDK, его необходимо делать это внутри транзакции. Необходимо иметь активный экземпляр <xref:Microsoft.VisualStudio.Modeling.Transaction> связанные с Store, когда происходит изменение. Это относится к всех элементов модели, отношения, фигуры, схемы и их свойства.  
  
 Механизм транзакций помогает избежать нестабильных состояний. Если произошла ошибка во время транзакции, выполняется откат всех изменений. Если пользователь выполняет команду отмены, каждая транзакция последние считается за один шаг. Пользователь не удается отменить части последнее изменение, если только вы явным образом поместите их в отдельных транзакциях.  
  
## <a name="opening-a-transaction"></a>Открытие транзакции  
 Является наиболее удобным способом управления транзакции с `using` инструкция заключена в `try...catch` инструкции:  
  
```  
Store store; ...  
try  
{  
  using (Transaction transaction =  
    store.TransactionManager.BeginTransaction("update model"))  
    // Outermost transaction must always have a name.  
  {  
    // Make several changes in Store:  
    Person p = new Person(store);  
    p.FamilyTreeModel = familyTree;  
    p.Name = "Edward VI";  
    // end of changes to Store  
  
    transaction.Commit(); // Don't forget this!  
  } // transaction disposed here  
}  
catch (Exception ex)  
{  
  // If an exception occurs, the Store will be   
  // rolled back to its previous state.  
}  
```  
  
 Если исключение, которое предотвращает последней `Commit()` происходит во время изменения, Store будут сброшены в предыдущее состояние. Это поможет вам убедиться, что ошибки не оставляйте модель в несогласованном состоянии.  
  
 Можно внести любое количество изменений в рамках одной транзакции. Вы можете открыть новые транзакции внутри активной транзакции. Вложенные транзакции необходимо зафиксировать или откатить до окончания этого содержащего транзакции. Дополнительные сведения см. пример для <xref:Microsoft.VisualStudio.Modeling.Transaction.TransactionDepth%2A> свойство.  
  
 Для внесения постоянных изменений, вы должны `Commit` транзакции до ее удаления. При возникновении исключения, не перехватываемое внутри транзакции, Store будут сброшены в состояние до изменения.  
  
## <a name="rolling-back-a-transaction"></a>Откат транзакции  
 Чтобы убедиться, что остается в Store, или возвращается в состояние до транзакции, можно использовать любой из этих тактик:  
  
1. Исключение не перехватывается внутри области транзакции.  
  
2. Явного отката транзакции:  
  
    ```  
    this.Store.TransactionManager.CurrentTransaction.Rollback();  
    ```  
  
## <a name="transactions-do-not-affect-non-store-objects"></a>Транзакции не влияют на объекты не Store  
 Транзакции только определяют состояние Store. Их нельзя отменить частичные изменения, внесенные в внешние элементы, такие как файлы, базы данных или объекты, которые объявлены с обычные типы за пределами определения DSL.  
  
 Если исключение такого изменения может оставить согласована Store, вы имеете дело с такую возможность в обработчике исключений. Один из способов, чтобы убедиться в том, что внешние ресурсы будут синхронизированы с объектами Store — Создание зависимости между каждого внешнего объекта на элемент в хранилище с помощью обработчиков событий. Дополнительные сведения см. в разделе [обработчики распространения изменений за пределами модели событий](../modeling/event-handlers-propagate-changes-outside-the-model.md).  
  
## <a name="rules-fire-at-the-end-of-a-transaction"></a>Запускаются правила в конце транзакции  
 В конце транзакции до удаления транзакции запускаются правила, присоединенные к элементам в хранилище. Каждое правило — это метод, который применяется к элементу модели, которая была изменена. Например «исправить» правила, которые обновляют состояние фигуры при изменении его элемента модели, и при создании элемента модели, которые создают фигуры. Нет указанного срабатывание порядка. Изменения, внесенные с помощью правила срабатывают другое правило.  
  
 Вы можете определить собственные правила. Дополнительные сведения о правилах см. в разделе [реагирование на события и распространение изменений](../modeling/responding-to-and-propagating-changes.md).  
  
 Правила не срабатывают после отмены, повтора или команду отката.  
  
## <a name="transaction-context"></a>Контекст транзакции  
 Каждая транзакция имеет словарь, в котором можно хранить любые нужные сведения.  
  
 `store.TransactionManager`  
  
 `.CurrentTransaction.TopLevelTransaction`  
  
 `.Context.Add(aKey, aValue);`  
  
 Это особенно полезно для передачи данных между правилами.  
  
## <a name="transaction-state"></a>Состояние транзакции  
 В некоторых случаях нужно избежать распространение изменений, если изменение вызвано Отмена или повтор транзакции. Это может произойти, например, если написать обработчик значения свойства, который может обновить другого значения в Store. Так как операция отмены сбрасывает все значения в Store прежнее состояние, необязательно для вычисления обновленные значения. Используйте следующий код:  
  
```  
if (!this.Store.InUndoRedoOrRollback) {...}  
```  
  
 Правила срабатывают в том случае, когда хранилище изначально загружается из файла. Чтобы не отвечать на эти изменения, используйте следующую команду:  
  
```  
if (!this.Store.InSerializationTransaction) {...}  
  
```
