---
title: Основные сведения о модульных тестах | Документы Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-test
ms.topic: conceptual
f1_keywords:
- vs.UnitTest.CreateUnitTest
ms.assetid: a80ba9cd-4575-483c-b957-af7ed8dc7e20
caps.latest.revision: 29
ms.author: jillfra
manager: jillfra
ms.openlocfilehash: 0657fdd846c201b4f9bff4910bdd9fc271c399c9
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/02/2020
ms.locfileid: "85543784"
---
# <a name="unit-test-basics"></a>Основные сведения о модульных тестах
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Убедитесь, что код работает, как ожидалось, создав и выполнив модульные тесты. Модульное тестирование получило такое название, так как функции программы разбиваются на отдельные тестируемые участки поведения, которые можно протестировать в качестве отдельных *модулей*. Обозреватель тестов Visual Studio предоставляет гибкий и эффективный способ запуска модульных тестов и просмотра результатов в Visual Studio. Visual Studio устанавливает платформы модульного тестирования Microsoft для управляемого и машинного кода. *Платформа модульного тестирования* используется для создания модульных тестов, их запуска и создания отчетов о результатах таких тестов. Завершив внесение изменений, запустите модульные тесты повторно, чтобы убедиться, что код по-прежнему работает правильно. При использовании выпуска Visual Studio Enterprise можно настроить автоматический запуск тестов после каждой сборки.

 Модульное тестирование максимально влияет на качество кода, когда оно является неотъемлемой частью рабочего процесса разработки ПО. После написания функции или другого блока кода приложения создаются модульные тесты, которые проверяют поведение кода в ответ на стандартные, граничные и некорректные случаи ввода данных; также проверяются любые явные или предполагаемые допущения, сделанные кодом. При *разработке, управляемой тестами*, модульные тесты создаются перед написанием кода, поэтому модульные тесты используются в качестве технической документации и спецификации функциональности.

 Можно быстро создавать тестовые проекты и методы теста из кода или создавать тесты вручную при необходимости. При использовании компонента IntelliTest для изучения кода .NET можно создавать тестовые данные и наборы модульных тестов. Для каждого оператора в коде создаются входные данные теста, которые будут выполнять этот оператор. Узнайте, как [создавать модульные тесты для своего кода](https://msdn.microsoft.com/library/dn823749.aspx).

 Обозреватель тестов также может запускать тесты c платформ модульных тестов стороннего производителя и платформ на основе открытого кода, имеющих дополнительные интерфейсы для Обозревателя тестов. Многие из этих платформ могут быть добавлены при помощи Менеджера расширений Visual Studio и Галереи Visual Studio. См. раздел [Установка платформ модульного тестирования сторонних поставщиков](../test/install-third-party-unit-test-frameworks.md)

- [Краткие руководства](#BKMK_Quick_starts)

- [Пример решения MyBank](#BKMK_The_MyBank_Solution_example)

- [Создание проектов модульных тестов и методов теста](#BKMK_Creating_the_unit_test_projects)

- [Написание тестов](#BKMK_Writing_your_tests)

- [Выполнение тестов в обозревателе тестов](#BKMK_Running_tests_in_Test_Explorer)

- [Выполнение и просмотр тестов](#BKMK_Running_and_viewing_tests_from_the_Test_Explorer_toolbar)

## <a name="unit-testing-overview"></a><a name="BKMK_Unit_testing_overview"></a> Общие сведения о модульном тестировании

### <a name="quick-starts"></a><a name="BKMK_Quick_starts"></a> Быстрые запуски
 Для получения информации по введению в модульное тестирование, которое знакомит вас сразу с созданием кода, см. один из следующих разделов.

- [Пошаговое руководство. Создание и запуск модульных тестов для управляемого кода](../test/walkthrough-creating-and-running-unit-tests-for-managed-code.md)

- [Быстрое начало: Разработка на основе тестирования с помощью обозревателя тестов](../test/quick-start-test-driven-development-with-test-explorer.md)

- [Модульное тестирование машинного кода с использованием обозревателя тестов](https://msdn.microsoft.com/8a09d6d8-3613-49d8-9ffe-11375ac4736c)

## <a name="the-mybank-solution-example"></a><a name="BKMK_The_MyBank_Solution_example"></a> Пример решения MyBank
 В данном разделе в качестве примера используется разработка ненастоящего приложения, которое называется `MyBank` . Чтобы следовать разъяснениям в данном разделе, действительного кодирования не потребуется. Методы тестирования написаны на C# и представлены при помощи платформы модульного тестирования Microsoft для управляемого кода, однако концепции легко переносятся на другие языки и платформы.

 ![Решение MyBank](../test/media/ute-mybanksolution.png "UTE_MyBankSolution")

 Первая попытка проектирования приложения `MyBank` включает в себя компонент счетов, который представляет собой лицевой счет и его транзакции с банком, а также компонент базы данных, который включает в себя функции объединения лицевых счетов и управления ими.

 Создается решение `MyBank` , которое содержит два проекта.

- `Accounts`

- `BankDb`

  Первая попытка создания проекта `Accounts` содержит класс для хранения базовой информации о счете, интерфейс, который определяет функции счета любого типа, например, для внесения и снятия средств со счета и класс, производный от интерфейса, который представляет собой текущий счет. Проект Счета начинается с создания следующих исходных файлов:

- `AccountInfo.cs` , определяющего основную информацию о счете;

- `IAccount.cs` , определяющего стандартный интерфейс `IAccount` для счета, включая методы внесения и снятия средств со счета и получения баланса счета;

- `CheckingAccount.cs` , содержащего класс `CheckingAccount` , который реализует интерфейс `IAccounts` для чекового счета.

  Из опыта известно, что при снятии средств с текущего счета необходимо убедиться, что количество снимаемых средств меньше, чем размер баланса счета. Поэтому метод `IAccount.Withdaw` в `CheckingAccount` перекрывается методом, который проверяет данное условие. Метод может выглядеть следующим образом.

```csharp

public void Withdraw(double amount)
{
    if(m_balance >= amount)
    {
        m_balance -= amount;
    }
    else
    {
        throw new ArgumentException(amount, "Withdrawal exceeds balance!")
    }
}

```

 Теперь, когда есть немного кода, можно провести тестирование.

## <a name="create-unit-test-projects-and-test-methods"></a><a name="BKMK_Creating_the_unit_test_projects"></a> Создание проектов модульных тестов и методов теста
 Как правило, создавать проект модульного теста и заглушки модульных тестов проще и быстрее из кода. Кроме того, можно создать проект модульных тестов и тесты вручную в зависимости от потребностей.

 **Создание проекта модульного теста и заглушек модульных тестов**

1. В окне редактора кода щелкните правой кнопкой мыши и выберите в контекстном меню команду **Создать модульные тесты** .

    ![В окне редактора просмотрите контекстное меню](../test/media/createunittestsrightclick.png "креатеуниттестсригхткликк")

2. Нажмите кнопку "ОК", чтобы принять значения по умолчанию для создания модульных тестов, или измените значения, которые использовались для создания и назначения имени проекта модульного теста и модульных тестов. Можно выбрать код, который добавляется по умолчанию в методы модульных тестов.

    ![Справа&#45;щелкните в редакторе и выберите Создать модульные тесты.](../test/media/createunittestsdialog.png "креатеуниттестсдиалог")

3. Заглушки модульных тестов создаются в новом проекте модульного теста для всех методов в классе.

    ![Модульные тесты созданы](../test/media/createunittestsstubs.png "креатеуниттестсстубс")

4. Теперь рассмотрим [добавление кода в методы модульных тестов](#BKMK_Writing_your_tests) (чтобы сделать модульный тест значимым), а также дополнительных модульных тестов, которые могут потребоваться для тщательного тестирования кода.

   **Создание проекта модульного теста и модульных тестов вручную**

   Проект модульного теста отражает структуру проекта кода. В примере MyBank добавляются два проекта модульного тестирования с именами `AccountsTests` и `BankDbTests` в решение `MyBanks` . Имена проекта теста произвольны, но рекомендуется принять концепцию стандартного именования.

   **Добавление нового проекта модульного тестирование в решение**

5. В меню **Файл** выберите **Новый** , затем выберите **Проект** (Сочетание клавиш Ctrl + Shift + N).

6. В диалоговом окне нового проекта разверните узел **Установлено**, выберите требуемый язык для проекта тестирования, затем **Тест**.

7. Чтобы использовать одну из платформ модульного тестирования Microsoft выберите **Проект модульного тестирования** из списка шаблонов проекта. В иных случаях выберите шаблон проекта платформы модульного тестирования, который необходимо использовать. Для тестирования проекта `Accounts` в нашем примере проект будет назван `AccountsTests`.

   > [!WARNING]
   > Не все платформы модульного тестирования сторонних разработчиков и на основе открытого кода предоставляют шаблоны проекта Visual Studio. Просмотрите информацию в документе платформы по созданию проекта.

8. В проекте модульного тестирования добавьте ссылку на проект кода в тесте, а в данном примере — на проект Счета.

    Создание ссылки на проект кода

   1. Выберите проект в обозревателе решений.

   2. В меню **проект** выберите команду **Добавить ссылку**.

   3. В диалоговом окне диспетчера ссылок откройте узел **Решение** и выберите **Проекты**. Выберите наименование проекта кода и закройте диалоговое окно.

   Каждый проект модульного тестирования содержит классы, которые отражают имена классов в проекте кода. В данном примере проект `AccountsTests` будет содержать следующие классы.

- Класс`AccountInfoTests` содержит методы модульного тестирования для класса `AccountInfo` в проекте `BankAccount` .

- Класс`CheckingAccountTests` содержит методы модульного тестирования для класса `CheckingAccount` .

## <a name="write-your-tests"></a><a name="BKMK_Writing_your_tests"></a> Написание тестов
 Платформа модульного тестирования и Visual Studio IntelliSense помогут вам в написании кода модульных тестов для проекта кода. Для запуска в Обозревателе тестов многие платформы требуют добавления особых атрибутов для определения методов модульного тестирования. Платформы также предоставляют способ — обычно при помощи оператора контроля или атрибутов метода -— для определения успешности или не успешности теста. Другие атрибуты определяют необязательные методы установки, которые выполняются при инициализации класса и перед каждым методом тестирования, а также методы разборки, которые запускаются после каждого метода тестирования и после уничтожения класса.

 Модель AAA (размещение, действие, утверждение) является стандартным способом написания модульных тестов для метода тестирования.

- Подраздел **Размещение** метода модульного тестирования инициализирует объекты и устанавливает значение данных, которые переданы методу для теста.

- Подраздел **Действие** вызывает метод для теста с размещенными параметрами.

- Подраздел **Утверждение** проверяет, чтобы метод для теста действовал, как ожидается.

  Для тестирования метода `CheckingAccount.Withdraw` в нашем примере можно написать два теста: один проверит стандартное поведение метода, а другой проверит, что снятие средств в количестве большем, чем указано в балансе, не будет успешным. В классе `CheckingAccountTests` добавьте следующие методы.

```csharp
[TestMethod]
public void Withdraw_ValidAmount_ChangesBalance()
{
    // arrange
    double currentBalance = 10.0;
    double withdrawal = 1.0;
    double expected = 9.0;
    var account = new CheckingAccount("JohnDoe", currentBalance);
    // act
    account.Withdraw(withdrawal);
    double actual = account.Balance;
    // assert
    Assert.AreEqual(expected, actual);
}

[TestMethod]
[ExpectedException(typeof(ArgumentException))]
public void Withdraw_AmountMoreThanBalance_Throws()
{
    // arrange
    var account = new CheckingAccount("John Doe", 10.0);
    // act
    account.Withdraw(20.0);
    // assert is handled by the ExpectedException
}

```

 Заметьте, что `Withdraw_ValidAmount_ChangesBalance` использует явное утверждение `Assert` для определения успешности или неуспешности метода тестирования, в то время как `Withdraw_AmountMoreThanBalance_Throws` использует атрибут `ExpectedException` для определения успешности метода тестирования. Под прикрытием платформа модульного тестирования возвращает методы тестирования в утверждения try/catch. В большинстве случаев, если захвачено исключение, то метод тестирования оказывается неудачным и исключение игнорируется. Атрибут `ExpectedException` успешно завершает метод тестирования, если появляется заданное исключение.

 Дополнительные сведения о Платформах модульного тестирования Microsoft см. в одном из следующих разделов.

- [Написание модульных тестов для платформы .NET Framework с использованием платформы модульного тестирования Майкрософт для управляемого кода](../test/writing-unit-tests-for-the-dotnet-framework-with-the-microsoft-unit-test-framework-for-managed-code.md)

- [Написание модульных тестов для C/C++ с помощью платформы модульного тестирования Майкрософт для C++](../test/writing-unit-tests-for-c-cpp-with-the-microsoft-unit-testing-framework-for-cpp.md)

## <a name="set-timeouts-for-unit-tests"></a>Настройка времени ожидания для модульных тестов
 Задание лимита времени на отдельный метод тестирования

```csharp
[TestMethod]
[Timeout(2000)]  // Milliseconds
public void My_Test()
{ ...
}
```

```vb

```

 Задние лимита времени на максимально разрешенный

```csharp
[TestMethod]
[Timeout(TestTimeout.Infinite)]  // Milliseconds
public void My_Test ()
{ ...
}
```

## <a name="run-tests-in-test-explorer"></a><a name="BKMK_Running_tests_in_Test_Explorer"></a> Запуск тестов в обозревателе тестов
 При построении проекта тестирования тесты появляются в Обозревателе тестов. Если Обозреватель тестов не виден, выберите **Тест** в меню Visual Studio, выберите **Windows**, затем выберите **Обозреватель тестов**.

 ![Обозреватель модульных тестов](../ide/media/ute-failedpassednotrunsummary.png "UTE_FailedPassedNotRunSummary")

 При запуске, написании и повторном запуске тестов вид по умолчанию обозревателя тестов отображает результаты в группах **Неудачные тесты**, **Пройденные тесты**, **Пропущенные тесты** и **Не запущенные тесты**. Можно выбрать заголовок группы, чтобы открыть окно, в котором отображаются все тесты группы.

 Кроме того, можно фильтровать тесты по совпадению текста в поле поиска на глобальном уровне или с помощью одного из предустановленных фильтров. Можно запустить любую выборку тестов в любое время. Результаты запущенного теста появляются сразу же в строке "успешно/не успешно" наверху окна обозревателя. Детальная информация результата метода тестирования отображается при выборе теста.

### <a name="run-and-view-tests"></a><a name="BKMK_Running_and_viewing_tests_from_the_Test_Explorer_toolbar"></a> Запуск и Просмотр тестов
 Панель инструментов Обозревателя тестов помогает найти, организовать и запустить необходимые тесты.

 ![Запуск тестов из панели инструментов обозревателя тестов](../test/media/ute-toolbar.png "UTE_ToolBar")

 Можно выбрать **Запустить все** , чтобы запустить все тесты, или выбрать **Запустить** , чтобы выбрать подмножество тестов для запуска. После запуска набора тестов появляется сводка запущенных тестов внизу окна Обозревателя тестов. Выберите тест, чтобы просмотреть детальную информацию по данному тесту в нижней панели. Выберите **Открыть тест** в контекстном меню (клавиатура: F12), чтобы отобразить исходный код для выбранного теста.

 Если у отдельных тестов нет зависимостей, предотвращающих выполнение этих тестов в любом порядке, включите параллельное тестирование с помощью переключателя ![UTE&#95;parallelicon&#45;small](../test/media/ute-parallelicon-small.png "UTE_parallelicon-малый") на панели инструментов. Это может заметно сократить время, необходимое для выполнения всех тестов.

### <a name="run-tests-after-every-build"></a><a name="BKMK_Running_tests_after_every_build"></a> Выполнять тесты после каждой сборки

> [!WARNING]
> Запуск модульных тестов после каждой сборки поддерживается только в Visual Studio Enterprise.

|Изображение|Описание|
|-|-|
|![Запуск после построения](../test/media/ute-runafterbuild-btn.png "UTE_RunAfterBuild_btn")|Чтобы запустить модульные тесты после каждого локального построения, в стандартном меню выберите **Тест**, затем выберите **Запустить тесты после сборки** в панели инструментов обозревателя тестов.|

### <a name="filter-and-group-the-test-list"></a><a name="BKMK_Filtering_and_grouping_the_test_list"></a> Фильтрация и группировка списка тестов
 Если существует много тестов, можно ввести текст в панели поиска Обозревателя тестов, чтобы отфильтровать список по указанной строке. Можно ограничить фильтр при помощи выбора фильтров из списка.

 ![Категории фильтров поиска](../test/media/ute-searchfilter.png "UTE_SearchFilter")

|Изображение|Описание|
|-|-|
|![Кнопка группы обозревателя тестов](../test/media/ute-groupby-btn.png "UTE_GroupBy_btn")|Для группировки тестов по категории, нажмите кнопку **Группировать по** .|

 Дополнительные сведения см. в статье [выполнение модульных тестов с помощью обозревателя тестов](../test/run-unit-tests-with-test-explorer.md) .

## <a name="qa"></a>Вопросы и ответы
 **Вопрос. Как выполнять отладку модульных тестов?**

 **Ответ.** Чтобы запустить сеанс отладки для тестов, можно использовать обозреватель тестов. Пошагово выполняя код, отладчик Visual Studio плавно переключается назад и вперед между модульными тестами и проектом для тестирования. Начало отладки

1. В редакторе Visual Studio установите точку останова в одном или нескольких методах тестирования, которые вы хотите проверить.

   > [!NOTE]
   > Так как методы тестирования могут запускаться в любом порядке, необходимо устанавливать точки останова во всех методах тестирования, которые необходимо проверить.

2. В обозревателе тестов выберите методы теста, а затем в контекстном меню выберите пункт **Отладить выбранные тесты** .

   См. дополнительные сведения об [отладке модульных тестов](../debugger/debugging-in-visual-studio.md).

   **Вопрос. Если я использую TDD, как я могу создать код из тестов?**

   **Ответ.** Используйте IntelliSense для создания классов и методов в коде проекта. Напишите утверждение в методе тестирования, которое вызывает класс или метод, который необходимо создать, затем откройте меню IntelliSense во время вызова. Если вызов предназначен для конструктора нового класса, выберите **Сформировать новый тип** из меню и следуйте подсказкам мастера, чтобы вставить класс в проект кода. Если вызов предназначен для метода, то выберите **Сформировать новый метод** из меню IntelliSense.

   ![Создать меню-заглушку метода IntelliSense](../test/media/ute-generatemethodstubintellisense.png "UTE_GenerateMethodStubIntellisense")

   **Вопрос. Можно ли создать модульные тесты, которые принимают несколько наборов данных в качестве входных данных для выполнения теста?**

   **Ответ.** Да. *Управляемые данными методы тестирования* позволяют тестировать диапазон значений с помощью одного метода модульного теста. Примените к методу теста атрибут `DataSource` , который определяет источник данных и таблицу, в которых содержатся подлежащие тестированию значения переменных.  В теле метода значения строк присваиваются переменным с помощью `TestContext.DataRow[` *ColumnName* `]` индексатора ColumnName.

> [!NOTE]
> Эти процедуры применяются только к методам тестирования, которые пишутся при помощи платформы модульного тестирования Microsoft для управляемого кода. Если используется другая платформа, проконсультируйтесь с документацией по платформе для эквивалентного функционала.

 Например, предположим, что был добавлен ненужный метод в класс `CheckingAccount`, который называется `AddIntegerHelper`. `AddIntegerHelper` добавляет два целочисленных значения.

 Для создания управляемого данными теста для метода `AddIntegerHelper` сначала создается база данных доступа с именем `AccountsTest.accdb` и таблица с именем `AddIntegerHelperData`. Таблица `AddIntegerHelperData` определяет колонки для указания первого и второго операнда сложения и колонку, указывающую ожидаемый результат. Заполняем несколько рядов соответствующими значениями.

```csharp

[DataSource(
    @"Provider=Microsoft.ACE.OLEDB.12.0;Data Source=C:\Projects\MyBank\TestData\AccountsTest.accdb",
    "AddIntegerHelperData"
)]
[TestMethod()]
public void AddIntegerHelper_DataDrivenValues_AllShouldPass()
{
    var target = new CheckingAccount();
    int x = Convert.ToInt32(TestContext.DataRow["FirstNumber"]);
    int y = Convert.ToInt32(TestContext.DataRow["SecondNumber"]);
    int expected = Convert.ToInt32(TestContext.DataRow["Sum"]);
    int actual = target.AddIntegerHelper(x, y);
    Assert.AreEqual(expected, actual);
}

```

 Метод с атрибутом запускается один раз для каждого ряда в таблице. Обозреватель тестов оповещает о неудачном тесте для метода, если одна из итераций не была успешной. Панель подробных результатов теста для метода показывает статус "прошел/неудачен" для каждого ряда данных.

 Дополнительные сведения о [модульных тестах, управляемых данными](../test/how-to-create-a-data-driven-unit-test.md).

 **Вопрос. Можно ли узнать, какой объем кода проверяется модульными тестами?**

 **Ответ.** Да. Можно определить объем кода, который был фактически проверен модульными тестами, с помощью средства покрытия кода Visual Studio. Поддерживаются машинные и управляемые языки и все платформы модульного тестирования, которые могут быть запущены платформой модульного тестирования.

 Можно запустить покрытие кода на выбранных тестах или на всех тестах решения. Окно результатов покрытия кода отображает процент блоков кода продукта, которые были задействованы по строке, функции, классу, пространству имен и модулю.

 Для запуска покрытия кода для методов теста в решении выберите в меню Visual Studio пункт **Тесты** , а затем **Анализ покрытия кода**.

 Результаты покрытия появляются в окне "Результаты покрытия кода".

 ![Результаты покрытия кода](../test/media/ute-codecoverageresults.png "UTE_CodeCoverageResults")

 Дополнительные сведения о [покрытии кода](../test/using-code-coverage-to-determine-how-much-code-is-being-tested.md) .

 **Вопрос. Можно ли протестировать методы в коде, которые имеют внешние зависимости?**

 **Ответ.** Да. В выпуске Visual Studio Enterprise компонент Microsoft Fakes можно использовать с методами тестов, которые были написаны с помощью платформ модульного тестирования для управляемого кода.

 Microsoft Fakes использует два подхода при создании классов-заменителей для внешних зависимостей.

1. *Заглушки* создают классы на замену, которые являются производными от родительского интерфейса класса зависимости цели. Методы заглушек могут быть заменены на публичные виртуальные методы класса цели.

2. *Оболочки* используют инструментарий среды выполнения для перевода вызовов целевого метода на метод заменяющей оболочки для невиртуальных методов.

   При обоих подходах используются созданные делегаты вызовов для метода зависимости для определения требуемого поведения в данном методе тестирования.

   Дополнительные сведения об [изоляции методов модульного тестирования с помощью Microsoft Fakes](../test/isolating-code-under-test-with-microsoft-fakes.md).

   **В. Можно ли использовать другие платформы модульного тестирования для создания модульных тестов?**

   **О** . Да, выполните инструкции по [поиску и установке других платформ](../test/install-third-party-unit-test-frameworks.md). Перезапустив Visual Studio, повторно откройте решение, чтобы создать модульные тесты, и выберите установленные платформы здесь:

   ![Выбор другой установленной платформы модульного тестирования](../test/media/createunittestsdialogextensions.png "креатеуниттестсдиаложекстенсионс")

   Заглушки модульных тестов будут созданы с помощью выбранной платформы.
