---
title: Использование покрытия кода для определения объема тестируемого кода | Документация Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-test
ms.topic: conceptual
helpviewer_keywords:
- code coverage
ms.assetid: 800fc739-acd2-4242-84cb-1d83b4d82cf9
caps.latest.revision: 38
ms.author: jillfra
manager: jillfra
ms.openlocfilehash: 737311167fc1f444d5c0f8a5d2c27e2fe321da75
ms.sourcegitcommit: c150d0be93b6f7ccbe9625b41a437541502560f5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/10/2020
ms.locfileid: "75851242"
---
# <a name="using-code-coverage-to-determine-how-much-code-is-being-tested"></a>Использование покрытия кода для определения объема протестированного кода
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Чтобы определить, какая часть кода проекта в действительности тестируется закодированными тестами, такими как модульные тесты, можно воспользоваться возможностью покрытия кода в Visual Studio. Для обеспечения эффективной защиты от ошибок тесты должны выполнять ("покрывать") большую часть кода.

 Анализ покрытия кода может применяться и к управляемому (CLI), и к неуправляемому (машинному) коду.

 Покрытие кода возможно при выполнении методов тестов с помощью обозревателя тестов. В таблице результатов отображается процент кода, который был выполнен в каждой сборке, классе и методе. Кроме того, редактор исходного кода показывает, какой код был протестирован.

 ![Результаты покрытия кода с помощью цветов](../test/media/codecoverage1.png "CodeCoverage1")

 **Requirements**

- Visual Studio Enterprise

### <a name="to-analyze-code-coverage-on-unit-tests-in-test-explorer"></a>Анализ покрытия кода в модульных тестах в обозревателе тестов

1. В меню **Тест** щелкните **Анализ покрытия кода**.

2. Чтобы увидеть, какие строки были выполнены, выберите ![Значок "Цвета отображения покрытия кода"](../test/media/codecoverage-showcoloringicon.png "CodeCoverage — Шовколорингикон")**Цвета отображения покрытия кода**.

     Чтобы изменить цвета или использовать полужирный шрифт, последовательно щелкните **Сервис**, **Параметры**, **Среда**, **Шрифты и цвета**, **Параметры для: текстовый редактор**. В разделе **Отображаемые элементы** настройте элементы покрытия.

3. Если результаты показывают низкое покрытие, проверьте, какие части кода не обрабатываются, и напишите несколько дополнительных тестов для их покрытия. Команды разработчиков обычно стремятся покрыть около 80 % кода. В некоторых случаях допустимо более низкое покрытие. Например, более низкое покрытие допустимо, когда некоторый код создается из стандартного шаблона.

> [!TIP]
> Чтобы получить точные результаты, выполните следующие действия.
>
> - Убедитесь, что оптимизация компилятора отключена.
>
>   При работе с неуправляемым (машинным) кодом используйте отладочную сборку.
>   - Убедитесь, что PDB-файлы (файлы символов) создаются для каждой сборки.
>
>   Если полученный результат отличается от ожидаемого, воспользуйтесь рекомендациями из статьи [Troubleshooting Code Coverage](../test/troubleshooting-code-coverage.md) (Устранение неполадок с покрытием кода). . Не забудьте снова выполнить покрытие кода после обновления кода. Результаты покрытия и цвета кода не обновляются автоматически после изменения кода или при выполнении тестов.

## <a name="reporting-in-blocks-or-lines"></a>Отчеты в блоках или строках
 Покрытие кода измеряется в *блоках*. Блок — это часть кода с одной точкой входа и точкой выхода.  Если поток управления программы проходит через блок во время тестового запуска, то этот блок учитывается как покрытый. Количество раз, когда используется блок, не влияет на результат.

 Результаты также можно отобразить в виде строк, щелкнув **Добавить или удалить столбцы** в заголовке таблицы. Если во время тестового запуска все блоки кода были обработаны в любой строке кода, она учитывается как одна строка. Если строка содержит несколько блоков кода, одни из которых были обработаны, а другие — нет, то она учитывается как частичная строка.

 Некоторые пользователи предпочитают считать в строках, поскольку процентные соотношения более точно соответствуют размеру фрагментов, которые можно увидеть в исходном коде. Длинный блок вычислений учитывается как единый блок, даже если он занимает большое количество строк.

## <a name="managing-code-coverage-results"></a>Управление результатами покрытия кода
 В окне "Результаты покрытия кода", как правило, отображается результат последнего запуска. Результаты изменятся, если изменить данные тестов или если каждый раз выполнять только часть тестов.

 Окно покрытия кода также можно использовать для просмотра предыдущих результатов или результатов, полученных на других компьютерах.

 Можно объединить результаты нескольких запусков, например тех, что используют различные данные теста.

- **Чтобы просмотреть предыдущий набор результатов**, выберите его в раскрывающемся меню. В меню отображается временный список, который очищается при открытии нового решения.

- **Чтобы просмотреть результаты предыдущего сеанса**, щелкните **Импортировать результаты покрытия кода**, перейдите к папке TestResults в своем решении и импортируйте COVERAGE-файл.

     Цвета отображения покрытия могут быть неверными, если исходный код был изменен с момента создания COVERAGE-файла.

- **Чтобы представить результаты в виде текста**, щелкните **Экспортировать результаты покрытия кода**. Это приведет к созданию доступного для чтения COVERAGEXML-файла, который можно обработать другими средствами или легко отправить по почте.

- **Чтобы отправить результаты другому пользователю**, отправьте COVERAGE-файл или экспортированный COVERAGEXML-файл. Получатели могут затем импортировать файл. Если у них та же версия исходного кода, то они смогут увидеть цвета отображения покрытия.

## <a name="merging-results-from-different-runs"></a>Объединение результатов различных запусков
 В некоторых ситуациях будут использоваться разные блоки в коде в зависимости от данных теста. Поэтому может потребоваться объединить результаты различных тестовых запусков.

 Например, предположим, что при выполнении теста со входными данными "2" обнаружилось, что покрыто 50 % определенной функции. При выполнении теста во второй раз со входными данными "-2 " в представлении расцветки покрытия видно, что покрыты другие 50% данной функции. Теперь можно объединить результаты двух тестовых запусков, чтобы в отчете и представлении расцветки покрытия было видно, что покрыто 100 % данной функции.

 Для этого используйте команду ![Значок объединения результатов тестирования кода](../test/media/codecoverage-mergeicon.png "CodeCoverage — Мержеикон")**Merge Code Coverage Results** (Объединить результаты тестирования кода). Можно выбрать любые сочетания последних запусков или импортированных результатов. Если требуется объединить экспортированные результаты, в первую очередь необходимо их импортировать.

 Щелкните **Экспортировать результаты покрытия кода**, чтобы сохранить результаты операции слияния.

### <a name="limitations-in-merging"></a>Ограничения объединения

- При объединении данных покрытия из различных версий кода результаты отображаются отдельно, но они не объединяются. Чтобы получить полностью объединенные результаты, используйте одну ту же сборку кода и изменяйте только данные теста.

- При слиянии файла результатов, который был экспортирован, а затем импортирован, результаты можно просматривать только по строкам, но не по блокам. Используйте команду **Добавить или удалить столбцы**, чтобы отобразить данные по строкам.

- При объединении результатов тестов проекта ASP.NET результаты отдельных тестов будут отображаться, но не объединяться. Это относится только к самим артефактам ASP.NET: результаты всех других сборок будут объединяться.

## <a name="excluding-elements-from-the-code-coverage-results"></a>Исключение элементов из результатов покрытия кода
 Иногда требуется исключить конкретные элементы в коде из результатов покрытия, например, если код создан из текстового шаблона. Добавьте атрибут `System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage` к любому из следующих элементов кода: классу, структуре, методу, свойству, методу задания или получения свойства, событию. Обратите внимание, что исключение класса не исключает его производные классы.

 Например:

```csharp

using System.Diagnostics.CodeAnalysis;
...
public class ExampleClass1
{
    [ExcludeFromCodeCoverage]
    void ExampleMethod() {...}

    [ExcludeFromCodeCoverage] // exclude property
    int ExampleProperty1
    { get {...} set{...}}

    int ExampleProperty2
    {
        get
        {
            ...
        }
        [ExcludeFromCodeCoverage] // exclude setter
        set
        {
            ...
        }
    }

}
[ExcludeFromCodeCoverage]
class ExampleClass2 { ... }

```

```vb
Imports System.Diagnostics.CodeAnalysis

Class ExampleClass1
    <ExcludeFromCodeCoverage()>
    Public Sub ExampleSub1()
        ...
    End Sub

    ' Exclude property
    < ExcludeFromCodeCoverage()>
    Property ExampleProperty1 As Integer
        ...
    End Property

    ' Exclude setter
    Property ExampleProperty2 As Integer
        Get
            ...
        End Get
        <ExcludeFromCodeCoverage()>
        Set(ByVal value As Integer)
            ...
        End Set
    End Property
End Class

<ExcludeFromCodeCoverage()>
Class ExampleClass2
...
End Class

```

```cpp#
// A .cpp file compiled as managed (CLI) code.
using namespace System::Diagnostics::CodeAnalysis;
...
public ref class ExampleClass1
{
  public:
    [ExcludeFromCodeCoverage]
    void ExampleFunction1() { ... }

    [ExcludeFromCodeCoverage]
    property int ExampleProperty2 {...}

    property int ExampleProperty2 {
      int get() { ... }
     [ExcludeFromCodeCoverage]
      void set(int value) { ...  }
   }

}

[ExcludeFromCodeCoverage]
public ref class ExampleClass2
{ ... }

```

### <a name="excluding-elements-in-native-c-code"></a>Исключение элементов в машинном коде C++
 Чтобы исключить неуправляемые (машинные) элементы в коде C++, используйте следующий код.

```cpp

#include <CodeCoverage\CodeCoverage.h>
...

// Exclusions must be compiled as unmanaged (native):
#pragma managed(push, off)

// Exclude a particular function:
ExcludeFromCodeCoverage(Exclusion1, L"MyNamespace::MyClass::MyFunction");

// Exclude all the functions in a particular class:
ExcludeFromCodeCoverage(Exclusion2, L"MyNamespace::MyClass2::*");

// Exclude all the functions generated from a particular template:
ExcludeFromCodeCoverage(Exclusion3, L"*::MyFunction<*>");

// Exclude all the code from a particular .cpp file:
ExcludeSourceFromCodeCoverage(Exclusion4, L"*\\unittest1.cpp");

// After setting exclusions, restore the previous managed/unmanaged state:
#pragma managed(pop)

```

 Используйте следующие макросы:

 `ExcludeFromCodeCoverage(` *ExclusionName* `, L"` *FunctionName* `");`

 `ExcludeSourceFromCodeCoverage(` *ExclusionName* `, L"` *SourceFilePath* `");`

- *ExclusionName* — любое уникальное имя.

- *FunctionName* — полное имя функции. Оно может содержать знаки подстановки. Например, чтобы исключить все функции класса, напишите `MyNamespace::MyClass::*`

- *SourceFilePath* — локальный путь или путь UNC к CPP-файлу. Оно может содержать знаки подстановки. В следующем примере исключаются все файлы из определенного каталога: `\\MyComputer\Source\UnitTests\*.cpp`

- `#include <CodeCoverage\CodeCoverage.h>`

- Поместите вызовы макроса исключения в глобальное пространство имен, а не внутри любого пространства имен или класса.

- Исключения можно поместить в файл кода модульного теста или в файл кода приложения.

- Исключения должны компилироваться как неуправляемый (машинный) код с помощью настройки параметра компилятора или с помощью `#pragma managed(off)`.

> [!NOTE]
> Чтобы исключить функции в коде C++/CLI, примените атрибут `[System::Diagnostics::CodeAnalysis::ExcludeFromCodeCoverage]` к функции. Эта процедура не отличается от C#.

### <a name="including-or-excluding-additional-elements"></a>Включение или исключение дополнительных элементов
 Анализ покрытия кода выполняется только для загруженных сборок, для которых PDB-файл доступен в том же каталоге, что и DLL-файл или EXE-файл. Поэтому в некоторых обстоятельствах можно расширить набор сборок, включенный путем получения копий соответствующих PDB-файлов.

 Можно обеспечить более полное управление выбором сборок и элементов для включения в анализ покрытия кода путем записи RUNSETTINGS-файла. Например, можно исключить сборки определенных типов, не добавляя атрибуты к их классам. См. дополнительные сведения по [настройке анализа покрытия кода](../test/customizing-code-coverage-analysis.md).

## <a name="analyzing-code-coverage-in-the-build-service"></a>Анализ покрытия кода в службе сборки
 При проверке кода тесты будут выполняться на сервере сборки вместе с другими тестами от других членов команды. (Если вы еще этого не сделали, см. раздел [Запуск тестов в процессе сборки](https://msdn.microsoft.com/library/d05743a1-c5cf-447e-bed9-bed3cb595e38).) Полезно анализировать покрытие кода в службе сборок, поскольку это дает наиболее актуальную и исчерпывающую картину покрытия всего проекта. Сюда также входят автоматические системные тесты и другие закодированные тесты, которые обычно не выполняются на компьютерах разработчиков.

1. В Team Explorer откройте меню **Сборки**, а затем добавьте или измените определение сборки.

2. На странице **Процесс** разверните **Автоматизированные тесты**, **Исходный код теста**, **Параметры запуска**. Задайте для параметра **Тип файла параметров запуска** значение **Оценка объемов протестированного кода включена**.

    При наличии нескольких определений исходного кода теста повторите этот шаг для каждого из них.

   - <em>Однако не существует поля с именем **Тип файла параметров запуска</em>* .*

      В разделе **Автоматизированные тесты** щелкните **Тестовая сборка** и нажмите кнопку с многоточием **[...]** в конце строки. В диалоговом окне **Добавление/изменение тестового запуска** в разделе **Средство выполнения тестов** щелкните **Средство выполнения тестов Visual Studio**.

   ![Задание определения сборки для покрытия кода](../test/media/codecoverage-plaincc.png "CodeCoverage — Плаинкк")

   После выполнения сборки результаты покрытия кода присоединяются к тестовому запуску и отображаются в сводке сборки.

## <a name="analyzing-code-coverage-in-a-command-line"></a>Анализ покрытия кода в командной строке
 Для выполнения тестов из командной строки используйте vstest.console.exe. Покрытие кода входит в возможности этой служебной программы. Дополнительные сведения см. в статье [Параметры командной строки для VSTest.Console.exe](https://msdn.microsoft.com/library/52e1689d-b1a8-4589-bd98-99a55acd0a11).

1. Запустите командную строку разработчика Visual Studio.

     В меню **Пуск** ОС Windows последовательно щелкните **Все программы**, **Microsoft Visual Studio**, **Инструменты Visual Studio**, **Командная строка разработчика**.

2. Run (Запуск):

     `vstest.console.exe MyTestAssembly.dll /EnableCodeCoverage`

## <a name="troubleshooting"></a>Диагностика
 Если вы не видите результаты покрытия кода, воспользуйтесь рекомендациями из статьи [Troubleshooting Code Coverage](../test/troubleshooting-code-coverage.md) (Устранение неполадок с покрытием кода).

## <a name="external-resources"></a>Внешние ресурсы

### <a name="guidance"></a>Руководство
 [Тестирование непрерывной доставки с Visual Studio 2012 — глава 2. Модульное тестирование. Внутреннее тестирование](https://msdn.microsoft.com/library/jj159340.aspx)

## <a name="see-also"></a>См. также раздел
 [Настройка анализа объема протестированного кода](../test/customizing-code-coverage-analysis.md) [модульное тестирование](../test/unit-test-your-code.md) кода для [устранения проблем](../test/troubleshooting-code-coverage.md) с кодом
