---
title: Формирование и компиляция кода, а также соглашения об именовании в Microsoft Fakes | Документация Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-test
ms.topic: conceptual
ms.assetid: 20221de4-2a9e-4787-b99a-b5855bb90872
caps.latest.revision: 18
ms.author: jillfra
manager: jillfra
ms.openlocfilehash: df937d43c196193593bcfb1244bcc9e59a3c634a
ms.sourcegitcommit: a8e8f4bd5d508da34bbe9f2d4d9fa94da0539de0
ms.translationtype: MTE95
ms.contentlocale: ru-RU
ms.lasthandoff: 10/19/2019
ms.locfileid: "72660674"
---
# <a name="code-generation-compilation-and-naming-conventions-in-microsoft-fakes"></a>Формирование и компиляция кода, а также соглашения об именовании в Microsoft Fakes
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

В этом разделе рассматриваются проблемы и параметры, связанные с созданием и компиляцией кода Fakes, а также описаны соглашения об именовании для созданных типов, членов и параметров Fakes.

 **Требования**

- Visual Studio Enterprise

## <a name="BKMK_In_this_topic"></a> Содержание раздела
 [Формирование и компиляция кода](#BKMK_Code_generation_and_compilation)

- [Настройка формирования кода заглушек](#BKMK_Configuring_code_generation_of_stubs) • [Фильтрация типов](#BKMK_Type_filtering) • [Создание заглушек для конкретных классов и виртуальных методов](#BKMK_Stubbing_concrete_classes_and_virtual_methods) • [Внутренние типы](#BKMK_Internal_types) • [Оптимизация времени сборки](#BKMK_Optimizing_build_times) • [Предотвращение конфликтов имен сборок](#BKMK_Avoiding_assembly_name_clashing)

  [Соглашения об именовании для Fakes](#BKMK_Fakes_naming_conventions)

- [Соглашения об именовании для типов заглушек и типов оболочек](#BKMK_Shim_type_and_stub_type_naming_conventions) • [Соглашения об именовании для свойства делегата оболочки или поля делегата заглушки](#BKMK_Shim_delegate_property_or_stub_delegate_field_naming_conventions) • [Соглашения об именовании для типов параметров](#BKMK_Parameter_type_naming_conventions) • [Рекурсивные правила](#BKMK_Recursive_rules)

  [Внешние ресурсы](#BKMK_External_resources)

- [Руководство](#BKMK_Guidance)

## <a name="BKMK_Code_generation_and_compilation"></a> Формирование и компиляция кода

### <a name="BKMK_Configuring_code_generation_of_stubs"></a> Настройка формирования кода заглушек
 Создание типов заглушек настраивается в XML-файле с расширением FAKES. Платформа Fakes интегрируется в процесс сборки с помощью пользовательских задач MSBuild и обнаруживает эти файлы во время сборки. Генератор кода Fakes компилирует типы заглушек в сборку и добавляет ссылку на проект.

 Следующий пример иллюстрирует типы заглушек, определенные в FileSystem.dll:

```xml
<Fakes xmlns="http://schemas.microsoft.com/fakes/2011/">
    <Assembly Name="FileSystem"/>
</Fakes>

```

### <a name="BKMK_Type_filtering"></a> Фильтрация типов
 Фильтры можно задать в файле FAKES, чтобы ограничить перечень типов, которые должны быть заменены заглушками. Можно добавить неограниченное число элементов Clear, Add, Remove в элемент StubGeneration, чтобы сформировать список выбранных типов.

 Например, этот файл FAKES создает заглушки для типов в пространствах имен System и System.IO, но исключает любой тип, содержащий Handle в пространстве имен System:

```xml
<Fakes xmlns="http://schemas.microsoft.com/fakes/2011/">
  <Assembly Name="mscorlib" />
  <!-- user code -->
  <StubGeneration>
    <Clear />
    <Add Namespace="System!" />
    <Add Namespace="System.IO!"/>
    <Remove TypeName="Handle" />
  </StubGeneration>
  <!-- /user code -->
</Fakes>
```

 В строках фильтра используется простая грамматика для определения того, как именно следует выполнять сопоставление:

- По умолчанию фильтры не учитывают регистр, выполняется сравнение подстрок:

     `el` соответствует значению hello

- Добавление `!` в конец фильтра обеспечит точное совпадение с учетом регистра:

     `el!` не соответствует значению hello

     `hello!` соответствует значению hello

- Добавление `*` в конец фильтра обеспечит соответствие префиксу строки:

     `el*` не соответствует значению hello

     `he*` соответствует значению hello

- Несколько фильтров в списке, разделенных точкой с запятой, объединяются в виде дизъюнкции:

     `el;wo` соответствует значениям hello и world

### <a name="BKMK_Stubbing_concrete_classes_and_virtual_methods"></a> Создание заглушек для конкретных классов и виртуальных методов
 По умолчанию типы заглушек создаются для всех незапечатанных классов. Типы заглушки можно ограничить абстрактными классами с помощью файла конфигурации FAKES:

```xml
<Fakes xmlns="http://schemas.microsoft.com/fakes/2011/">
  <Assembly Name="mscorlib" />
  <!-- user code -->
  <StubGeneration>
    <Types>
      <Clear />
      <Add AbstractClasses="true"/>
    </Types>
  </StubGeneration>
  <!-- /user code -->
</Fakes>
```

### <a name="BKMK_Internal_types"></a> Внутренние типы
 Генератор кода Fakes будет создавать типы оболочек и типы заглушки для типов, которые являются видимыми для созданной сборки Fakes. Чтобы сделать внутренние типы сборки с оболочкой совместимости видимыми для сборки Fakes и тестовой сборки, добавьте атрибуты <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> в код сборки с оболочкой совместимости, отвечающий за видимость для созданной сборки Fakes и тестовой сборки. Ниже приведен пример:

```csharp
// FileSystem\AssemblyInfo.cs
[assembly: InternalsVisibleTo("FileSystem.Fakes")]
[assembly: InternalsVisibleTo("FileSystem.Tests")]
```

 **Внутренние типы в сборках со строгими именами**

 Если сборка с оболочкой совместимости имеет строгое имя и требуется доступ ко внутренним типам сборки:

- Как тестовая сборка, так и сборка Fakes должна иметь строгое имя.

- Необходимо добавить открытые ключи сборки Fakes и тестовой сборки в атрибуты **InternalsVisibleToAttribute** в сборках с оболочкой совместимости. Вот как будут выглядеть наши образцы атрибутов в коде сборки с оболочкой совместимости, когда сборка с оболочкой совместимости имеет строгое имя.

  ```csharp
  // FileSystem\AssemblyInfo.cs
  [assembly: InternalsVisibleTo("FileSystem.Fakes",
      PublicKey=<Fakes_assembly_public_key>)]
  [assembly: InternalsVisibleTo("FileSystem.Tests",
      PublicKey=<Test_assembly_public_key>)]
  ```

  Если сборка с оболочкой совместимости имеет строгое имя, платформа Fakes автоматически назначает созданной сборке Fakes строгую подпись. Тестовой сборке следует назначить строгую подпись. См. статью [Создание и использование сборок со строгими именами](https://msdn.microsoft.com/library/ffbf6d9e-4a88-4a8a-9645-4ce0ee1ee5f9).

  Платформа Fakes использует один и тот же ключ для подписывания всех созданных сборок, поэтому этот фрагмент кода можно использовать в качестве основы для добавления атрибута **InternalsVisibleTo** для сборки Fakes в код сборки с оболочкой совместимости.

```csharp
[assembly: InternalsVisibleTo("FileSystem.Fakes, PublicKey=0024000004800000940000000602000000240000525341310004000001000100e92decb949446f688ab9f6973436c535bf50acd1fd580495aae3f875aa4e4f663ca77908c63b7f0996977cb98fcfdb35e05aa2c842002703cad835473caac5ef14107e3a7fae01120a96558785f48319f66daabc862872b2c53f5ac11fa335c0165e202b4c011334c7bc8f4c4e570cf255190f4e3e2cbc9137ca57cb687947bc")]
```

 Можно указать другой открытый ключ для сборки Fakes, например ключ, созданный для сборки с оболочкой совместимости, указав полный путь к **SNK-файлу**, который содержит альтернативный ключ в виде значения атрибута `KeyFile` в элементе `Fakes`\\`Compilation` **FAKES-файла**. Например:

```xml
<-- FileSystem.Fakes.fakes -->
<Fakes ...>
  <Compilation KeyFile="full_path_to_the_alternate_snk_file" />
</Fakes>

```

 Затем следует использовать открытый ключ из альтернативного **SNK-файла** в качестве второго параметра атрибута InternalVisibleTo для сборки Fakes в коде сборки с оболочкой совместимости:

```csharp
// FileSystem\AssemblyInfo.cs
[assembly: InternalsVisibleTo("FileSystem.Fakes",
    PublicKey=<Alternate_public_key>)]
[assembly: InternalsVisibleTo("FileSystem.Tests",
    PublicKey=<Test_assembly_public_key>)]
```

 В приведенном выше примере значения `Alternate_public_key` и `Test_assembly_public_key` могут быть одинаковыми.

### <a name="BKMK_Optimizing_build_times"></a> Оптимизация времени сборки
 Компиляция сборок Fakes может значительно затянуть время сборки. Можно сократить время сборки, создав сборки имитаций для сборки Fakes для системных сборок платформы .NET системы и сторонних сборок в отдельном централизованном проекте. Поскольку такие сборки редко изменяются на компьютере, созданные сборки Fakes можно повторно использовать в других проектах.

 Из проектов модульных тестов можно просто указать ссылку на скомпилированные сборки Fakes, помещенные в FakesAssemblies в папке проекта.

1. Создайте новую библиотеку классов с версией среды выполнения .NET, соответствующей тестовым проектам. Назовем ее Fakes.Prebuild. Удалите файл class1.cs в проекте, так как он нам не нужен.

2. Добавьте ссылку на все системные и сторонние сборки, для которых требуется Fakes.

3. Добавьте файл FAKES для каждой сборки и выполните сборку.

4. В тестовом проекте

    - Убедитесь в наличии ссылки на библиотеку DLL среды выполнения Fakes:

         C:\Program Files\Microsoft Visual Studio 12.0\Common7\IDE\PublicAssemblies\Microsoft.QualityTools.Testing.Fakes.dll

    - Для каждой сборки, для которой вы создали Fakes, добавьте ссылку на соответствующий файл DLL в папке Fakes.Prebuild\FakesAssemblies проекта.

### <a name="BKMK_Avoiding_assembly_name_clashing"></a> Предотвращение конфликтов имен сборок
 В среде Team Build все выходные данные сборки объединяются в одном каталоге. При работе с несколькими проектами, где используется Fakes, может возникнуть ситуация, когда сборки Fakes из другой версии переопределяют друг друга. Например, как mscorlib.dll сборки Fakes TestProject1 имитаций из .NET Framework 2.0, так и mscorlib.dll сборки Fakes TestProject2 для .NET Framework 4 будут выводить данные в mscorlib. сборку Fakes mscorlib.Fakes.dll.

 Чтобы избежать этой проблемы, платформа Fakes должна автоматически создавать учитывающие версию имена сборок Fakes для ссылок, не относящихся к проектам, при добавлении файлов FAKES. Учитывающее версию имя сборки Fakes внедряет номер версии при создании имени сборки Fakes:

 В случае со сборкой Fakes MyAssembly и версией 1.2.3.4 имя будет иметь вид MyAssembly.1.2.3.4.Fakes.

 Можно изменить или удалить эту версию, изменив атрибут Version элемента Assembly в файле FAKES:

```xml
attribute of the Assembly element in the .fakes:
<Fakes ...>
  <Assembly Name="MyAssembly" Version="1.2.3.4" />
  ...
</Fakes>

```

## <a name="BKMK_Fakes_naming_conventions"></a> Соглашения об именовании для Fakes

### <a name="BKMK_Shim_type_and_stub_type_naming_conventions"></a> Соглашения об именовании для типов заглушек и типов оболочек
 **Пространства имен**

- К пространству имен добавляется суффикс .Fakes.

   Например, `System.Fakes` пространство имен содержит типы оболочек пространства имен System.

- Global.Fakes содержит тип оболочки пустого пространства имен.

  **Имена типов**

- Префикс оболочки добавляется к имени типа для получения имени типа оболочки.

   Например, ShimExample является типом оболочки типа Example.

- Префикс заглушки добавляется к имени типа для получения имени типа заглушки.

   Например, StubIExample является типом заглушки типа IExample.

  **Аргументы типа и структуры вложенных типов**

- Аргументы универсального типа копируются.

- Структура вложенного типа копируется для типов оболочек.

### <a name="BKMK_Shim_delegate_property_or_stub_delegate_field_naming_conventions"></a> Соглашения об именовании для свойства делегата оболочки или поля делегата заглушки
 **Основные правила** для именования полей, начиная с пустого имени:

- Имя метода добавляется.

- Если имя метода является явной реализацией интерфейса, точки удаляются.

- Если метод является универсальным, добавляется `Of`*n*, где *n* — число аргументов универсального метода.

  **Имена особых методов**, таких как методы получения или задания свойства, обрабатываются согласно описанию в следующей таблице.

|Чем является метод...|Пример|Добавление к имени метода|
|-------------------|-------------|--------------------------|
|**Конструктор**|`.ctor`|`Constructor`|
|Статический **конструктор**|`.cctor`|`StaticConstructor`|
|**Метод доступа**, имя которого состоит из двух частей, разделенных символом "_" (например, методы получения свойств)|*kind_name* (распространенный вариант, однако он не является обязательным согласно ECMA)|*NameKind*, где обе части начинаются с прописных букв и поменяны местами|
||Метод получения свойства `Prop`|`PropGet`|
||Метод задания свойства `Prop`|`PropSet`|
||Метод добавления события|`Add`|
||Метод удаления события|`Remove`|
|**Оператор**, состоящий из двух частей|`op_name`|`NameOp`|
|Например, оператор +|`op_Add`|`AddOp`|
|Для **оператора преобразования** добавляется тип возвращаемого значения.|`T op_Implicit`|`ImplicitOpT`|

 **Примечания**

- **Методы получения и задания индексаторов** обрабатываются так же, как и методы для свойств. Для индексаторов имя по умолчанию имеет значение `Item`.

- Имена **типов параметров** преобразуются и объединяются.

- **Тип возвращаемого значения** игнорируется, если нет неоднозначности перегрузки. В этом случае тип возвращаемого значения добавляется в конец имени.

### <a name="BKMK_Parameter_type_naming_conventions"></a> Соглашения об именовании для типов параметров

|Задано|Добавляемая строка...|
|-----------|-------------------------|
|**Тип**`T`|T<br /><br /> Пространство имен, вложенная структура и универсальные регистрации удаляются.|
|**Параметр вывода**`out T`|`TOut`|
|**Параметр ссылки** `ref T`|`TRef`|
|**Тип массива**`T[]`|`TArray`|
|Тип **многомерного массива**`T[ , , ]`|`T3`|
|Тип **указателя**`T*`|`TPtr`|
|**Универсальный тип**`T<R1, …>`|`TOfR1`|
|**Аргумент универсального типа**`!i` для типа `C<TType>`|`Ti`|
|**Аргумент универсального метода**`!!i` для метода `M<MMethod>`|`Mi`|
|**Вложенный тип**`N.T`|Добавляется `N`, затем `T`|

### <a name="BKMK_Recursive_rules"></a> Рекурсивные правила
 Рекурсивно применяются следующие правила:

- Поскольку платформа Fakes использует C# для создания сборок Fakes, любой символ приведет к тому, что недопустимый токен C#, экранируется за «_» (символ подчеркивания).

- Если результирующее имя конфликтует с любым членом объявляющего типа, используется схема нумерации, заключающаяся в добавлении двухзначного счетчика, начиная со значения 01.

## <a name="BKMK_External_resources"></a> Внешние ресурсы

### <a name="BKMK_Guidance"></a> Руководство
 [Тестирование непрерывной доставки с Visual Studio 2012 — глава 2. Модульное тестирование. Внутреннее тестирование](http://go.microsoft.com/fwlink/?LinkID=255188)

## <a name="see-also"></a>См. также
 [Изоляция тестируемого кода с помощью Microsoft Fakes](../test/isolating-code-under-test-with-microsoft-fakes.md)
