---
title: Модульное тестирование существующих приложений C++ с использованием обозревателя тестов | Документы Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-test
ms.topic: conceptual
ms.assetid: 7d08de69-c32e-4f0b-89aa-75347b15fb82
caps.latest.revision: 13
ms.author: jillfra
manager: jillfra
ms.openlocfilehash: 68bff8dbe2d0e5d85c8b18eeafaeaad06ba3982e
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/02/2020
ms.locfileid: "85540079"
---
# <a name="unit-testing-existing-c-applications-with-test-explorer"></a>Модульное тестирование существующих приложений C++ с использованием обозревателя тестов
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Перед изменением существующего приложения рекомендуется убедиться, что оно хорошо охвачено модульными тестами. Это уменьшает шансы того, что будущие изменения создадут новые ошибки. Если приложение не содержит модульные тесты, их можно добавить с помощью методик, продемонстрированных в этом разделе. В этом разделе описывается добавление модульных тестов для существующего кода Visual C++, начиная с выбора метода тестирования кода и заканчивая созданием, кодированием и выполнением тестов.

## <a name="deciding-how-to-test-your-code"></a>Определение способа тестирования кода
 Откройте существующий проект C++ и просмотрите его, чтобы определить способ добавления модульных тестов. Можно использовать средства моделирования, которые помогут понять зависимости в коде и способы взаимодействия его частей. Дополнительные сведения см. в разделе [Визуализация кода](../modeling/visualize-code.md).

 Рекомендуется выделять изменения в небольшие задачи. Перед каждым небольшим изменением напишите модульные тесты для тех аспектов поведения, которые не должны поменяться. Эти тесты будут продолжать успешно выполняться после внесения изменений. Например, если планируется изменить функцию сортировки так, чтобы сортировка списка пользователей выполнялась по фамилиям вместо имен, можно создать модульный тест, который проверяет, что все входные имена будут включены в результат. После внесения изменений может потребоваться добавление новых модульных тестов для нового поведения.

 Если это целесообразно, то все или почти все модульные тесты должны использовать только экспортируемые функции. Но если изменяется только небольшая часть всего приложения, можно использовать неэкспортированные функции. Например, может потребоваться тест, вызывающий внутренние функции, или тесты, которые задают и получают значения внутренних переменных.

 Существует несколько способов проверить код продукта в зависимости от того, представляет ли он интерфейсы, которые требуется проверить. Выберите один из следующих вариантов:

 **Модульные тесты будут использовать только функции, экспортированные из тестируемого кода:** Добавьте отдельный тестовый проект. В тестовом проекте добавьте ссылку на тестируемый проект.

 Перейдите к процедуре [Создание ссылки на экспортируемые функции из тестового проекта](#projectRef).

 Тестируемый **код создается в виде EXE-файла:** Добавьте отдельный тестовый проект. Привяжите его к выходному объектному файлу.

 Перейдите к процедуре [Связывание тестов с объектным файлом или файлом библиотеки](#objectRef).

 **Модульные тесты должны использовать закрытые функции и данные, а тестируемый код можно построить как статическую библиотеку:** Измените тестируемый проект, чтобы он был скомпилирован в LIB-файл. Добавьте отдельные тестовый проект со ссылкой на тестируемый проект.

 Данный подход имеет преимущество использования закрытых членов, но он по-прежнему содержит тесты в отдельном проекте. Однако такой подход может оказаться неподходящим для некоторых приложений, где необходимо иметь библиотеку динамической компоновки (.dll).

 Перейдите к процедуре [Преобразование тестируемого кода в статическую библиотеку](#staticLink).

 **Модульные тесты должны использовать закрытые функции и данные, а код должен быть построен как библиотека динамической компоновки (DLL):** Добавьте модульные тесты в тот же проект, что и код продукта.

 Перейдите к процедуре [Добавление модульных тестов в тот же проект](#sameProject).

## <a name="creating-the-tests"></a>Создание тестов

### <a name="to-change-the-code-under-test-to-a-static-library"></a><a name="staticLink"></a> Преобразование тестируемого кода в статическую библиотеку

- Если тесты должны использовать элементы, которые не экспортированы проектом, а тестируемый проект построен как динамическая библиотека, то следует преобразовать его в статическую библиотеку.

  1. В обозреватель решений в контекстном меню тестируемого проекта выберите пункт **Свойства**. Откроется окно свойств проекта.

  2. Выберите **Свойства конфигурации**, затем **Общие**.

  3. Установите для свойства **Тип конфигурации** значение **Статическая библиотека (.lib)**.

  Продолжите выполнение процедуры [Связывание тестов с объектным файлом или файлом библиотеки](#objectRef).

### <a name="to-reference-exported-functions-from-the-test-project"></a><a name="projectRef"></a> Создание ссылки на экспортируемые функции из тестового проекта

- Если тестируемый проект экспортирует функцию, которую необходимо проверить, можно добавить ссылку на проект кода из тестового проекта.

  1. Создайте тестовый проект С++.

      1. В меню **Файл** выберите **Создать**, **Проект**, **Visual C++, Тест**, **Проект модульного теста C++**.

  2. В обозревателе решений, в контекстном меню тестового проекта выберите пункт **Ссылки**. Откроется окно свойств проекта.

  3. Выберите **Общие свойства**, **.NET Framework и ссылки**, а затем нажмите кнопку **Добавить новую ссылку**.

  4. Выберите **Проекты**, а затем тестируемый проект.

       Выберите кнопку **Добавить**.

  5. В свойствах тестового проекта добавьте расположение тестируемого проекта в каталоги включения.

       Выберите **Свойства конфигурации**, **Каталоги VC++**, **Каталоги включаемых файлов**.

       Выберите **Изменить**, а затем добавьте каталог заголовков тестируемого проекта.

  Перейдите к разделу [Написание модульных тестов](#addTests).

### <a name="to-link-the-tests-to-the-object-or-library-files"></a><a name="objectRef"></a> Связывание тестов с объектным файлом или файлом библиотеки

- Если тестируемый код не экспортирует функции, которые необходимо проверить, можно добавить файл **.obj** или **.lib** в зависимости тестового проекта.

  1. Создайте тестовый проект С++.

      1. В меню **Файл** выберите **Создать**, **Проект**, **Visual C++, Тест**, **Проект модульного теста C++**.

  2. В обозревателе решений в контекстном меню тестового проекта выберите пункт **Свойства**. Откроется окно свойств проекта.

  3. Выберите **Свойства конфигурации**, **Компоновщик**, **Ввод**, **Дополнительные зависимости**.

       Выберите **Изменить** и добавьте имена файлов **.obj** или **.lib**. Не используйте полный путь.

  4. Выберите **Свойства конфигурации**, **Компоновщик**, **Общие**, **Дополнительные каталоги библиотек**.

       Выберите **Изменить** и добавьте путь к каталогу файлов **.obj** или **.lib**. Путь обычно находится внутри папки построения тестируемого проекта.

  5. Выберите **Свойства конфигурации**, **Каталоги VC++**, **Каталоги включаемых файлов**.

       Выберите **Изменить**, а затем добавьте каталог заголовков тестируемого проекта.

  Перейдите к разделу [Написание модульных тестов](#addTests).

### <a name="to-add-unit-tests-in-the-same-project"></a><a name="sameProject"></a> Добавление модульных тестов в тот же проект

1. Измените свойства проекта кода продукта для того, чтобы он включал заголовки и файлы библиотек, которые необходимы для модульного тестирования.

   1. В разделе "Обозреватель решений", в контекстном меню тестируемого проекта выберите пункт "Свойства". Откроется окно свойств проекта.

   2. Выберите **Свойства конфигурации**, **Каталоги VC++**.

   3. Измените каталоги включения и библиотек:

       |Свойство|Значение|
       |-|-|
       |**Каталоги включаемых файлов**|**$(VCInstallDir)UnitTest\include;$(IncludePath)**|
       |**Каталоги библиотек**|**$(VCInstallDir)UnitTest\lib;$(LibraryPath)**|

2. Добавьте файл модульного тестирования С++:

   - В обозревателе решений в контекстном меню проекта выберите **Добавить**, **Создать элемент**, а затем выберите **Модульный тест C++**.

   Перейдите к разделу [Написание модульных тестов](#addTests).

## <a name="writing-the-unit-tests"></a><a name="addTests"></a> Написание модульных тестов

1. В каждом файле кода модульного теста добавьте оператор `#include` для заголовков тестируемого проекта.

2. Добавьте тестовые классы и методы в файлы кода модульного теста. Пример:

   ```cpp
   #include "stdafx.h"
   #include "CppUnitTest.h"
   #include "MyProjectUnderTest.h"
   using namespace Microsoft::VisualStudio::CppUnitTestFramework;
   namespace MyTest
   {
     TEST_CLASS(MyTests)
     {
     public:
         TEST_METHOD(MyTestMethod)
         {
             Assert::AreEqual(MyProject::Multiply(2,3), 6);
         }
     };
   }
   ```

   Дополнительные сведения см. в разделе [Модульное тестирование машинного кода с использованием обозревателя тестов](https://msdn.microsoft.com/8a09d6d8-3613-49d8-9ffe-11375ac4736c).

## <a name="run-the-tests"></a>Запуск тестов

1. В меню **Вид** выберите **Другие окна**, **Обозреватель тестов**.

2. В обозревателе тестов выберите **выполнить все**.

   Дополнительные сведения см. в разделе [Краткое руководство. Разработка на основе тестирования с использованием обозревателя тестов](../test/quick-start-test-driven-development-with-test-explorer.md).
