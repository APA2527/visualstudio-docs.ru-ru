---
title: Пакетная обработка MSBuild | Документы Майкрософт
description: Узнайте, как MSBuild разделяет списки элементов на разные категории или пакеты на основе метаданных элементов и поочередно выполняет целевой объект или задачу с использованием каждого пакета.
ms.custom: SEO-VS-2020
ms.date: 06/09/2020
ms.topic: conceptual
helpviewer_keywords:
- batching [MSBuild]
- MSBuild, batching
ms.assetid: d35c085b-27b8-49d7-b6f8-8f2f3a0eec38
author: ghogen
ms.author: ghogen
manager: jmartens
ms.workload:
- multiple
ms.openlocfilehash: d14a979a166f7378c288453530b46b8ec6c98828
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2021
ms.locfileid: "99919199"
---
# <a name="msbuild-batching"></a>Пакетная обработка MSBuild

MSBuild разделяет списки элементов на разные категории или пакеты на основе метаданных элементов и поочередно выполняет целевой объект или задачу с использованием каждого пакета.

## <a name="task-batching"></a>Пакетная обработка задач

Пакетная обработка задач упрощает работу с файлами проекта, позволяя разделить списки элементов на различные пакеты и передать задаче каждый из этих пакетов отдельно. Это означает, что задачу и ее атрибуты для файла проекта можно объявить всего один раз, а запускать ее можно многократно.

Укажите, что MSBuild нужно выполнить пакетную обработку с помощью задачи, используя нотацию `%(ItemMetaDataName)` в одном из атрибутов задачи. Следующий пример разделяет элемент `Example` на пакеты на основе значения метаданных элемента `Color` и передает их в задачу `MyTask` по отдельности.

> [!NOTE]
> Если вы не ссылаетесь на список элементов в других атрибутах задачи или имя метаданных может быть неоднозначным, можно использовать нотацию %(<ItemCollection.ItemMetaDataName>), чтобы полностью определить значение метаданных элемента для использования при пакетной обработке.

```xml
<Project
    xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

    <ItemGroup>
        <Example Include="Item1">
            <Color>Blue</Color>
        </Example>
        <Example Include="Item2">
            <Color>Red</Color>
        </Example>
    </ItemGroup>

    <Target Name="RunMyTask">
        <MyTask
            Sources = "@(Example)"
            Output = "%(Color)\MyFile.txt"/>
    </Target>

</Project>
```

Более подробные примеры пакетной обработки см. в разделе [Метаданные элементов в пакетной обработке задач](../msbuild/item-metadata-in-task-batching.md).

## <a name="target-batching"></a>Пакетная обработка целевых объектов

MSBuild проверяет актуальность входных и выходных данных целевого объекта перед его выполнением. Если как входные, так и выходные данные актуальны, целевой объект пропускается. Если пакетную обработку использует задача, находящаяся внутри целевого объекта, MSBuild нужно определить актуальность входных и выходных данных для каждого пакета элементов. В противном случае целевой объект выполняется при каждой его активации.

В следующем примере показан элемент `Target`, содержащий атрибут `Outputs` с нотацией `%(ItemMetadataName)`. MSBuild разделит список элементов `Example` на пакеты с учетом метаданных элементов `Color` и проанализирует метки времени выходных файлов для каждого пакета. Если выходные данные пакета не актуальны, выполняется целевой объект. В противном случае он пропускается.

```xml
<Project
    xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

    <ItemGroup>
        <Example Include="Item1">
            <Color>Blue</Color>
        </Example>
        <Example Include="Item2">
            <Color>Red</Color>
        </Example>
    </ItemGroup>

    <Target Name="RunMyTask"
        Inputs="@(Example)"
        Outputs="%(Color)\MyFile.txt">
        <MyTask
            Sources = "@(Example)"
            Output = "%(Color)\MyFile.txt"/>
    </Target>

</Project>
```

Другой пример пакетной обработки целевых объектов см. в разделе [Метаданные элементов в пакетной обработке целевых объектов](../msbuild/item-metadata-in-target-batching.md).

## <a name="item-and-property-mutations"></a>Изменения элементов и свойств

В этом разделе описываются последствия изменения свойств или метаданных элементов при использовании пакетной обработки целевых объектов и задач.

Так как пакетная обработка целевых объектов и пакетная обработка задач — это две разные операции MSBuild, важно понимать, какую форму пакетной обработки использует MSBuild в каждом конкретном случае. Когда синтаксис пакетной обработки `%(ItemMetadataName)` появляется в задаче целевого объекта, а не в его атрибуте, MSBuild использует пакетную обработку задач. Единственный способ указать пакетную обработку целевых объектов — использовать синтаксис пакетной обработки для целевого атрибута (обычно атрибута `Outputs`).

При совместной пакетной обработке целевых объектов и задач пакеты выполняются независимо друг от друга. Все пакеты начинаются с аналогичного копирования первоначального состояния значений метаданных элементов и свойств. Любые изменения значений свойств во время выполнения пакета не видны для других пакетов. Рассмотрим следующий пример.

```xml
  <ItemGroup>
    <Thing Include="2" Color="blue" />
    <Thing Include="1" Color="red" />
  </ItemGroup>

  <Target Name="DemoIndependentBatches">
    <ItemGroup>
      <Thing Condition=" '%(Color)' == 'blue' ">
        <Color>red</Color>
        <NeededColorChange>true</NeededColorChange>
      </Thing>
    </ItemGroup>
    <Message Importance="high"
             Text="Things: @(Thing->'%(Identity) is %(Color); needed change=%(NeededColorChange)')"/>
  </Target>
```

Результат.

```output
Target DemoIndependentBatches:
  Things: 2 is red; needed change=true;1 is red; needed change=
```

`ItemGroup` в целевом объекте неявно является задачей, а пакетная обработка задачи выполняется, начиная с элемента `%(Color)` в атрибуте `Condition`. Существует два пакета: один для красного, а другой — для синего содержимого. Свойство `%(NeededColorChange)` задается только в том случае, если метаданные `%(Color)` обозначены синим. Параметр влияет только на отдельный элемент, соответствующий условию при выполнении синего пакета. Атрибут `Text` задачи `Message` не запускает пакетную обработку, несмотря на синтаксис `%(ItemMetadataName)` (из-за использования внутри преобразования элемента).

Пакеты выполняются независимо, но не параллельно. Это важно, когда вы получаете доступ к значениям метаданных, которые изменяются при пакетном выполнении. Если вы задали свойство на основе определенных метаданных в пакетном выполнении, свойство принимает *последнее* заданное значение:

```xml
   <PropertyGroup>
       <SomeProperty>%(SomeItem.MetadataValue)</SomeProperty>
   </PropertyGroup>
```

После выполнения пакета свойство сохраняет конечное значение `%(MetadataValue)`.

Хотя пакеты выполняются независимо друг от друга, важно учитывать разницу между пакетной обработкой целевых объектов и задач, а также определить, какой тип применяется к вашей ситуации. Рассмотрим следующий пример, чтобы лучше понять важность этого различия.

Задачи могут быть неявными (в отличие от явных задач), что может запутать при выполнении их пакетной обработки. Если элемент `PropertyGroup` или `ItemGroup` появляется в `Target`, каждое объявление свойства в группе неявно обрабатывается как отдельная задача [CreateProperty](createproperty-task.md) или [CreateItem](createitem-task.md). Это означает, что поведение отличается при наличии пакетной обработки целевого объекта и ее отсутствии (то есть, если в атрибуте `Outputs` отсутствует синтаксис `%(ItemMetadataName)`). При пакетной обработке целевого объекта элемент `ItemGroup` выполняется один раз для каждого объекта, но если ее нет, для неявных эквивалентов задач `CreateItem` или `CreateProperty` выполняется пакетная обработка задач. Поэтому целевой объект выполняется только один раз, а для каждого элемента или свойства в группе выполняется отдельная пакетная обработка задач.

В следующем примере показаны пакетная обработка целевых объектов и пакетная обработка задач, когда метаданные изменяются. Рассмотрим ситуацию, когда у вас есть папки A и B с файлами:

```
A\1.stub
B\2.stub
B\3.stub
```

Теперь рассмотрим выходные данные этих двух схожих проектов.

```xml
    <ItemGroup>
      <StubFiles Include="$(MSBuildThisFileDirectory)**\*.stub"/>

      <StubDirs Include="@(StubFiles->'%(RecursiveDir)')"/>
    </ItemGroup>

    <Target Name="Test1" AfterTargets="Build" Outputs="%(StubDirs.Identity)">
      <PropertyGroup>
        <ComponentDir>%(StubDirs.Identity)</ComponentDir>
        <ComponentName>$(ComponentDir.TrimEnd('\'))</ComponentName>
      </PropertyGroup>

      <Message Text=">> %(StubDirs.Identity) '$(ComponentDir)' '$(ComponentName)'"/>
    </Target>
```

Результат.

```output
Test1:
  >> A\ 'A\' 'A'
Test1:
  >> B\ 'B\' 'B'
```

Далее удалите атрибут `Outputs`, в котором указана пакетная обработка целевых объектов.

```xml
    <ItemGroup>
      <StubFiles Include="$(MSBuildThisFileDirectory)**\*.stub"/>

      <StubDirs Include="@(StubFiles->'%(RecursiveDir)')"/>
    </ItemGroup>

    <Target Name="Test1" AfterTargets="Build">
      <PropertyGroup>
        <ComponentDir>%(StubDirs.Identity)</ComponentDir>
        <ComponentName>$(ComponentDir.TrimEnd('\'))</ComponentName>
      </PropertyGroup>

      <Message Text=">> %(StubDirs.Identity) '$(ComponentDir)' '$(ComponentName)'"/>
    </Target>
```

Результат.

```output
Test1:
  >> A\ 'B\' 'B'
  >> B\ 'B\' 'B'
```

Обратите внимание, что заголовок `Test1` выводится только один раз, хотя в предыдущем примере он выводился дважды. Это означает, что пакетная обработка целевого объекта не выполнялась.  В результате выходные данные отличаются, что может запутать.

Причина заключается в том, что при каждой пакетной обработке целевых объектов выполняются все операции в целевом объекте с использованием собственной независимой копии всех свойств и элементов. При этом, когда вы пропускаете атрибут `Outputs`, отдельные строки в группе свойств обрабатываются как отдельные задачи пакетной обработки. В этом случае для задачи `ComponentDir` выполнена пакетная обработка (используется синтаксис `%(ItemMetadataName)`). Поэтому в момент выполнения строки `ComponentName` обе операции пакетной обработки строки `ComponentDir` завершены (при этом вторая операция определяет значение, указанное во второй строке).

## <a name="property-functions-using-metadata"></a>Функции свойств с использованием метаданных

Пакетной обработкой можно управлять с помощью функций свойств, включающих метаданные. Например, примененная к объекту директива

`$([System.IO.Path]::Combine($(RootPath),%(Compile.Identity)))`

использует <xref:System.IO.Path.Combine%2A> для объединения пути к корневой папке с путем элемента компиляции.

Функции свойств не могут находиться внутри значений метаданных. Например, примененная к объекту директива

`%(Compile.FullPath.Substring(0,3))`

запрещено.

Дополнительные сведения о функциях свойств см. в разделе [Функции свойств](../msbuild/property-functions.md).

## <a name="see-also"></a>См. также

- [Элемент ItemMetadata (MSBuild)](../msbuild/itemmetadata-element-msbuild.md)
- [Основные понятия MSBuild](../msbuild/msbuild-concepts.md)
- [Справочные сведения о MSBuild](../msbuild/msbuild-reference.md)
- [Дополнительные возможности](../msbuild/msbuild-advanced-concepts.md)
