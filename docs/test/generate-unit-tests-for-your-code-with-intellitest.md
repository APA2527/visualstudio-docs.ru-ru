---
title: Создание модульных тестов для кода с помощью IntelliTest
ms.date: 10/05/2015
ms.topic: conceptual
f1_keywords:
- vs.UnitTest.CreateIntelliTest
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
author: mikejo5000
ms.openlocfilehash: 65b1de58f195b957d080bd21144c22479b1aafed
ms.sourcegitcommit: d233ca00ad45e50cf62cca0d0b95dc69f0a87ad6
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/01/2020
ms.locfileid: "75589595"
---
# <a name="how-to-generate-unit-tests-by-using-intellitest"></a>Практическое руководство. Создание модульных тестов с помощью IntelliTest

IntelliTest изучает код .NET, чтобы создать тестовые данные и набор модульных тестов. Для каждого оператора в коде создаются входные данные теста, которые будут выполнять этот оператор. Анализ случая выполняется для каждой условной ветви в коде. Например, анализируются операторы `if`, утверждения и все операции, которые могут вызывать исключения. Этот анализ используется в целях создания данных теста для параметризованного модульного теста для каждого из методов, создающих модульные тесты с высоким покрытием кода.

При запуске IntelliTest легко увидеть, какие тесты завершились сбоем, и добавить код для их исправления. Вы можете выбрать, какие созданные тесты следует сохранить в тестовый проект, чтобы предоставить набор регрессий. Изменив код, необходимо перезапустить IntelliTest, чтобы синхронизировать созданные тесты с изменениями в коде.

## <a name="availability-and-extensions"></a>Высокая доступность и расширения

Команды меню **Создать IntelliTest** и **Запустить IntelliTest**

* Доступны в только в версии Visual Studio Enterprise Edition.

* Поддерживают только код C#, предназначенный для .NET Framework.

* [Расширяемые](#extend-framework) и поддерживают порождающие тесты в формате MSTest, MSTest V2, NUnit и xUnit.

* Не поддерживают конфигурацию x64.

## <a name="explore-use-intellitest-to-explore-your-code-and-generate-unit-tests"></a>Изучение. Использование IntelliTest для изучения кода и создания модульных тестов

Для формирования модульных тестов типы должны быть открытыми.

1. Откройте решение в Visual Studio и откройте файл класса, содержащий методы, которые вы хотите протестировать.

2. Щелкните правой кнопкой мыши метод и выберите пункт **Запустить IntelliTest**, чтобы создать модульные тесты для кода в используемом методе.

   ![Щелкните правой кнопкой мыши поле в методе, чтобы создать модульные тесты](../test/media/runpex.png)

   IntelliTest выполняет код несколько раз с разными вводными данными. Каждое выполнение представлено в таблице с входными данными теста и выходными результатами или исключением.

   ![Окно "Результаты просмотра" отображается с тестами](../test/media/pexexplorationresults.png)

Чтобы создать модульные тесты для всех общедоступных методов в классе, просто щелкните правой кнопкой мыши класс, а не конкретный метод, а затем выберите команду **Запустить IntelliTest**. Используйте раскрывающийся список в окне **Результаты просмотра**, чтобы отобразить модульные тесты и входные данные для каждого метода в классе.

![Выберите результаты теста для просмотра из списка](../test/media/selectpextest.png)

Убедитесь, что полученные результаты для выполненных тестов в столбце результатов соответствуют ожидаемому коду. Для тестов, которые завершились ошибкой, исправьте код соответствующим образом. Затем перезапустите IntelliTest для проверки исправлений.

## <a name="persist-save-the-unit-tests-as-a-regression-suite"></a>Сохранение. Сохранение модульных тестов в виде набора регрессий

1. Выберите строки данных, которые следует сохранить с параметризованным модульным тестом в тестовый проект.

     ![Выберите тесты; щелкните правой кнопкой мыши и выберите пункт "Сохранить"](../test/media/savepextests.png)

     Можно просмотреть тестовый проект и параметризованный модульный тест, который был создан, — отдельные модульные тесты, соответствующие каждой строке, сохраняются в файл *.g.cs* в тестовом проекте, а параметризованный модульный тест сохраняется в соответствующий *CS-файл*. Вы можете запускать модульные тесты и просматривать результаты в обозревателе тестов так же, как в случае с любыми созданными вручную модульными тестами.

     ![Откройте файл класса в методе теста для просмотра модульного теста](../test/media/testmethodpex.png)

     Все необходимые ссылки также добавляются в тестовый проект.

     При изменении кода метода перезапустите IntelliTest, чтобы синхронизировать модульные тесты с внесенными изменениями.

## <a name="assist-use-intellitest-to-focus-code-exploration"></a>Помощь. Использование IntelliTest для просмотра кода

1. Если у вас имеется более сложный код, IntelliTest поможет сконцентрироваться на просмотре кода. Например, при наличии метода с интерфейсом в виде параметра и более одного класса, который реализует этот интерфейс, IntelliTest обнаружит эти классы и выдаст предупреждение.

     Просмотрите предупреждения, чтобы решить, что следует сделать.

     ![Просмотр предупреждений](../test/media/pexviewwarning.png)

2. После изучения кода и выбора цели тестирования можно исправить предупреждение, чтобы выбрать классы для тестирования интерфейса.

     ![Щелкните предупреждение правой кнопкой мыши и выберите пункт "Исправить"](../test/media/pexfixwarning.png)

     Выбранные элементы добавляются в файл *PexAssemblyInfo.cs*.

     `[assembly: PexUseType(typeof(Camera))]`

3. Теперь можно перезапустить IntelliTest, чтобы создать параметризованный модульный тест и данные теста c использованием одного только исправленного класса.

     ![Перезапустите IntelliTest, чтобы создать данные теста](../test/media/pexwarningsfixed.png)

## <a name="specify-use-intellitest-to-validate-correctness-properties-that-you-specify-in-code"></a>Указание. Использование IntelliTest для проверки правильности свойств, указанных в коде

Укажите общую связь между входными и выходными данными, которые должны быть проверены созданными модульными тестами. Эта спецификация инкапсулируется в метод, который подобен методу тестирования, но связан квантором общности. Это метод параметризованного модульного теста, и все утверждения должны сохраняться для всех возможных входных значений, создаваемых IntelliTest.

## <a name="q--a"></a>Вопросы и ответы

### <a name="q-can-you-use-intellitest-for-unmanaged-code"></a>Вопрос: Можно ли использовать IntelliTest для неуправляемого кода?

**Ответ.** Нет. IntelliTest работает только с управляемым кодом.

### <a name="q-when-does-a-generated-test-pass-or-fail"></a>Вопрос: Каковы условия выполнения или сбоя созданного теста?

**Ответ.** Он, как и любой модульный тест, выполняется в случае отсутствия исключений. Сбой происходит при сбое утверждений или если код в тесте вызывает необработанное исключение.

Если у вас есть тест, который может быть выполнен при возникновении определенных исключений, можно задать один из следующих атрибутов на основе требований в методе тестирования, тестовом классе и уровне сборки:

- **PexAllowedExceptionAttribute**

- **PexAllowedExceptionFromTypeAttribute**

- **PexAllowedExceptionFromTypeUnderTestAttribute**

- **PexAllowedExceptionFromAssemblyAttribute**

### <a name="q-can-i-add-assumptions-to-the-parameterized-unit-test"></a>Вопрос: Можно ли добавить допущения в параметризованный модульный тест?

**Ответ.** Да, используйте допущения, чтобы указать, какие данные теста не нужны для модульного теста при использовании определенного метода. Используйте класс <xref:Microsoft.Pex.Framework.PexAssume> для добавления допущений. Например, можно добавить допущение, что переменная `lengths` не является NULL в отличие от этой.

`PexAssume.IsNotNull(lengths);`

Если добавляется допущение и перезапускается IntelliTest, тестовые данные, которые больше не нужны, будут удалены.

### <a name="q-can-i-add-assertions-to-the-parameterized-unit-test"></a>Вопрос: Можно ли добавить утверждения в параметризованный модульный тест?

**Ответ.** Да, IntelliTest проверит правильность утверждения в операторе при запуске модульных тестов. Для добавления утверждений используйте класс <xref:Microsoft.Pex.Framework.PexAssert> или API утверждения, входящий в состав платформы тестирования. Например, можно добавить утверждение о равенстве двух переменных.

`PexAssert.AreEqual(a, b);`

Если добавляется допущение и перезапускается IntelliTest, инструмент проверяет допустимость утверждения. Если утверждение недопустимо, происходит сбой теста.

### <a name="NoRun"></a> Вопрос. Можно ли создавать параметризованные модульные тесты, не запуская предварительно IntelliTest?

**Ответ.** Да, щелкните правой кнопкой мыши в коде класса или метода и выберите пункт **Создать IntelliTest**.

![Щелкните редактор правой кнопкой мыши и выберите пункт "Создать IntelliTest"](../test/media/pexcreateintellitest.png)

Примите формат по умолчанию для формирования тестов или измените способ именования вашего проекта и тестов. Вы можете создать новый тестовый проект или сохранить тесты в существующем проекте.

![Создание IntelliTest с MSTest по умолчанию](../test/media/pexcreateintellitestmstest.png)

<a name="extend-framework"></a>
### <a name="q-can-i-use-other-unit-test-frameworks-with-intellitest"></a>Вопрос: Можно ли использовать другие платформы модульного тестирования с IntelliTest?

**Ответ.** Да, выполните инструкции по [поиску и установке других платформ](../test/install-third-party-unit-test-frameworks.md).
Расширения платформы тестирования также доступны в Visual Studio Marketplace, например [генератор тестов NUnit](https://marketplace.visualstudio.com/items?itemName=NUnitDevelopers.TestGeneratorNUnitextension-18371).

Перезапустив Visual Studio и открыв решение повторно, щелкните правой кнопкой мыши в коде класса или метода и выберите пункт **Создать IntelliTest**. Выберите установленную платформу здесь:

![Выбор другой платформы модульного тестирования для IntelliTest](../test/media/pexcreateintellitestextensions.png)

Затем запустите IntelliTest, чтобы сформировать отдельные модульные тесты в соответствующих файлах *.g.cs*.

### <a name="q-can-i-learn-more-about-how-the-tests-are-generated"></a>Вопрос: Можно получить более подробную информацию о создании тестов?

**Ответ.** Да, общий обзор приведен в этой [записи блога](https://devblogs.microsoft.com/devops/intellitest-one-test-to-rule-them-all/).
