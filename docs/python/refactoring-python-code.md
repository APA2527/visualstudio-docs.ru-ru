---
title: Рефакторинг кода Python
description: Узнайте, как легко выполнить рефакторинг кода Python в Visual Studio путем переименования идентификаторов, извлечения методов, добавления импортов и удаления неиспользуемых импортов.
ms.date: 03/13/2019
ms.topic: conceptual
author: JoshuaPartlow
ms.author: joshuapa
manager: jillfra
ms.custom: seodec18
ms.workload:
- python
- data-science
ms.openlocfilehash: db1a551e20c597f98052471910bcb696c878675f
ms.sourcegitcommit: 94b3a052fb1229c7e7f8804b09c1d403385c7630
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62429902"
---
# <a name="refactor-python-code"></a>Рефакторинг кода Python

Visual Studio предлагает несколько команд для автоматического преобразования и очистки исходного кода Python.

- [Переименовать](#rename) — переименовывает указанный класс, метод или переменную.
- [Извлечение метода](#extract-method) — создает новый метод из выбранного фрагмента кода.
- [Добавление импорта](#add-import) — предоставляет смарт-тег для добавления отсутствующего импорта.
- [Удаление неиспользуемых инструкций import](#remove-unused-imports) — удаляет неиспользуемые операции импорта.

## <a name="rename"></a>Переименовать

1. Щелкните правой кнопкой мыши идентификатор, который нужно переименовать, и выберите команду **Переименовать** или поместите курсор на идентификатор и выберите команду меню **Правка** > **Рефакторинг** > **Переименовать** (**F2**).
2. В окне **Переименовать** введите новое имя для выбранного идентификатора и нажмите кнопку **ОК**.

   ![Переименовать. Запрос на ввод нового имени идентификатора](media/code-refactor-rename-1.png)

3. В следующем диалоговом окне выберите файлы и экземпляры, к которым следует применить переименование. Здесь можно выбрать любой отдельный экземпляр для предварительного просмотра конкретных изменений:

   ![Переименовать. Диалоговое окно для выбора мест применения изменений](media/code-refactor-rename-2.png)

4. Нажмите **Применить**, чтобы внести изменения в файлы исходного кода. (Это действие невозможно отменить.)

## <a name="extract-method"></a>Извлечение метода

1. Выберите строки кода или выражение, из которых хотите создать отдельный метод.
2. Выберите команду меню **Правка** > **Рефакторинг** > **Извлечь метод** или нажмите клавиши **CTRL**+**R** > **M**.
3. В открывшемся диалоговом окне введите имя для нового метода, укажите место для его создания и выберите переменные для закрытия. Переменные, которые не будут выбраны для закрытия, преобразуются в аргументы метода:

   ![Диалоговое окно извлечения метода](media/code-refactor-extract-method-1.png)

4. Нажмите кнопку **ОК**, и код будет изменен соответствующим образом:

   ![Результат извлечения метода](media/code-refactor-extract-method-2.png)

## <a name="add-import"></a>Добавление импорта

При наведении курсора на идентификатор, для которого отсутствует информация о типе, Visual Studio предоставляет смарт-тег (значок лампочки слева от кода). Если его щелкнуть, можно выполнить команды для добавления необходимого оператора `import` или `from ... import`:

![Смарт-тег для добавления импорта](media/code-refactor-add-import-1.png)

Visual Studio предоставляет завершения `import` для модулей и пакетов верхнего уровня в текущем проекте и стандартной библиотеке. Visual Studio также предоставляет завершения `from ... import` для подмодулей и подпакетов, а также элементов модуля. В эти завершения входят функции, классы и экспортированные данные. Если вы выберете любой из вариантов, будет добавлена соответствующая инструкция в верхней части файла, сразу после других инструкций import или внутри существующей инструкции `from ... import`, если указанный модуль уже импортирован.

![Результат добавления импорта](media/code-refactor-add-import-2.png)

Visual Studio старается отфильтровать те члены, которые не определены в самом модуле, например модули, импортированные в другой модуль, но не являющиеся дочерними для модуля, выполняющего импорт. Например, во многих модулях используется `import sys` вместо `from xyz import sys`, поэтому отсутствует вариант завершения для импорта `sys` из других модулей, даже если в них нет элемента `__all__`, исключающего `sys`.

Аналогичным образом Visual Studio фильтрует функции, импортированные из других модулей или из встроенного пространства имен. Например, если модуль импортирует функцию `settrace` из модуля `sys`, теоретически вы вправе импортировать ее из этого модуля. Но гораздо лучше напрямую использовать `import settrace from sys`, поэтому Visual Studio предлагает добавить именно такую инструкцию.

И, наконец, если некоторая сущность по общим признакам должна быть исключена из предложений, но для нее существуют другие значения, которые обычно следует включить в список (например, если в модуле этому имени присваивается значение), Visual Studio все равно исключает импорт из предложений. Такое поведение основано на предположении, что рассматриваемая сущность не должна импортироваться, поскольку определена в другом модуле. При этом дополнительное назначение считается фиктивным и не подлежащим экспорту.

## <a name="remove-unused-imports"></a>Удаление неиспользуемых инструкций import

Нередко получается так, что в коде сохраняются инструкции `import` для модулей, которые вообще не используются. Visual Studio анализирует код и может автоматически определить, нужна ли в нем инструкция `import`, изучив использование импортированного имени во всех областях ниже той, где встречается эта инструкция.

Щелкните правой кнопкой мыши в любом месте редактора и выберите команду **Удалить инструкции import**, которая позволяет выполнить удаление **из всех областей** или только **из текущей области**:

![Меню удаления инструкций import](media/code-refactor-remove-imports-1.png)

Visual Studio внесет соответствующие изменения в код:

![Результат удаления инструкций import](media/code-refactor-remove-imports-2.png)

Обратите внимание, что Visual Studio не учитывает поток управления. Если имя указано в коде до оператора `import`, это все равно рассматривается как использование имени. Кроме того, Visual Studio игнорирует все операции импорта `from __future__`, а также выполняемые внутри определения класса и из инструкций `from ... import *`.
