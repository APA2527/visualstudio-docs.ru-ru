---
title: Обзор правил качества кода
ms.date: 08/27/2020
ms.topic: reference
f1_keywords:
- CA1000
- CA1001
- CA1002
- CA1003
- CA1004
- CA1005
- CA1006
- CA1007
- CA1008
- CA1009
- CA1010
- CA1011
- CA1012
- CS1013
- CS1014
- CA1016
- CA1017
- CA1018
- CA1019
- CA1020
- CA1021
- CA1022
- CA1023
- CA1024
- CS1025
- CA1026
- CA1027
- CA1028
- CA1029
- CA1030
- CA1031
- CA1032
- CA1033
- CA1034
- CA1035
- CA1036
- CA1037
- CA1038
- CA1039
- CA1040
- CA1041
- CA1042
- CA1043
- CA1044
- CA1045
- CA1046
- CA1047
- CA1048
- CA1049
- CA1050
- CA1051
- CA1052
- CA1053
- CA1054
- CA1055
- CA1056
- CA1057
- CA1058
- CA1059
- CA1060
- CA1061
- CA1062
- CA1063
- CA1064
- CA1065
- CA1066
- CA1067
- CA1068
- CA1069
- CA1070
- CA1200
- CA1300
- CA1301
- CA1302
- CA1303
- CA1304
- CA1305
- CA1306
- CA1307
- CA1308
- CA1309
- CA1310
- CA1400
- CA1401
- CA1402
- CA1403
- CA1404
- CA1405
- CA1406
- CA1407
- CA1408
- CA1409
- CA1410
- CA1411
- CA1412
- CA1413
- CA1414
- CA1415
- CA1417
- CA1500
- CA1501
- CA1502
- CA1503
- CA1504
- CA1505
- CA1506
- CA1507
- CA1508
- CA1509
- CA1600
- CA1601
- CA1700
- CA1701
- CA1702
- CA1703
- CA1704
- CA1707
- CA1708
- CA1709
- CA1710
- CA1711
- CA1712
- CA1713
- CA1714
- CA1715
- VA1716
- CA1717
- CA1719
- CA1720
- CA1721
- CA1722
- CA1723
- CA1724
- CA1725
- CA1726
- CA1727
- CA1728
- CA1729
- CA1730
- CA1800
- CA1801
- CA1802
- CA1803
- CA1804
- CA1805
- CA1806
- CA1809
- CA1810
- CA1811
- CA1812
- CA1813
- CA1814
- CA1815
- CA1816
- CA1819
- CA1820
- CA1821
- CA1822
- CA1823
- CA1824
- CA1825
- CA1826
- CA1827
- CA1828
- CA1829
- CA1830
- CA1831
- CA1832
- CA1833
- CA1835
- CA1836
- CA1837
- CA1838
- CA1900
- CA1901
- CA1903
- CA2000
- CA2001
- CA2002
- CA2003
- CA2004
- CA2006
- CA2007
- CA2008
- CA2009
- CA2011
- CA2012
- CA2013
- CA2014
- CA2015
- CA2016
- CA2100
- CA2101
- CA2102
- CA2103
- CA2104
- CA2105
- CA2106
- CA2107
- CA2108
- CA2109
- CA2110
- CA2111
- CA2112
- CA2114
- CA2115
- CA2116
- CA2117
- CA2118
- CA2119
- CA2120
- CA2121
- CA2122
- CA2123
- CA2124
- CA2126
- CA2127
- CA2128
- CA2129
- CA2130
- CA2131
- CA2132
- CA2133
- CA2134
- CA2135
- CA2136
- CA2137
- CA2138
- CA2139
- CA2140
- CA2141
- CA2142
- CA2143
- CA2144
- CA2145
- CA2146
- CA2147
- CA2148
- CA2149
- CA2150
- CA2151
- CA2200
- CA2201
- CA2202
- CA2204
- CA2205
- CA2207
- CA2208
- CA2210
- CA2211
- CA2212
- CA2213
- CA2214
- CA2215
- CA2216
- CA2217
- CA2218
- CA2219
- CA2220
- CA2221
- CA2222
- CA2223
- CA2224
- CA2225
- CA2226
- CA2228
- CA2229
- CA2227
- CA2230
- CA2231
- CA2232
- CA2233
- CA2234
- CA2235
- CA2236
- CA2237
- CA2238
- CA2239
- CA2240
- CA2241
- CA2242
- CA2243
- CA2245
- CA2246
- CA2247
- CA5122
- CA5374
- IL3000
- IL3001
ms.assetid: 5cb221f6-dc59-4abf-9bfa-adbd6f907f96
author: mikadumont
ms.author: midumont
manager: jillfra
ms.workload:
- dotnet
ms.openlocfilehash: 05937cef7187726134a7116edae4d74ee004de1d
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/02/2020
ms.locfileid: "89219755"
---
# <a name="code-analysis-warnings-for-managed-code-by-checkid"></a>Предупреждения анализа кода для управляемого кода с помощью CheckId

В следующей таблице перечислены предупреждения анализа управляемого кода по идентификатору CheckId предупреждения.

| CheckId | Предупреждение | Описание |
|---------| - | - |
| CA1000 | [CA1000. Не объявляйте статические члены в универсальных типах](../code-quality/ca1000.md) | При вызове статического элемента универсального типа нужно указать аргумент этого типа. При вызове универсального экземпляра элемента, не поддерживающего вывод типа, для элемента нужно указать аргумент типа. В этих двух случаях синтаксис для определения аргумента типа различен, и его можно легко спутать. |
| CA1001 | [CA1001. Типы, которым принадлежат освобождаемые поля, должны быть освобождаемыми](../code-quality/ca1001.md) | В классе объявляется и реализуется поле экземпляра, которое принадлежит типу System.IDisposable, однако класс не реализует интерфейс IDisposable. Класс, в котором объявляется поле IDisposable, неявно владеет неуправляемым ресурсом и должен реализовывать интерфейс IDisposable. |
| CA1002 | [CA1002. Не предоставляйте универсальные списки](../code-quality/ca1002.md) | System. Collections. Generic. List< (of \<(T> ) >) — это универсальная коллекция, предназначенная для повышения производительности, а не для наследования. Поэтому виртуальные элементы в списке отсутствуют. Вместо этого для наследования следует предоставить универсальную коллекцию. |
| CA1003 | [CA1003. Используйте экземпляры обработчика универсальных событий](../code-quality/ca1003.md) |Тип содержит делегат, возвращающий значение void, сигнатура которого содержит два параметра (первый — объект, а второй — тип, который может быть назначен EventArgs), а включающая сборка предназначена для платформы Microsoft .NET Framework 2.0. |
| CA1004 | [CA1004. Универсальные методы должны предоставлять параметр типа](../code-quality/ca1004.md) | Вывод – это то, как аргумент типа универсального метода определяется по типу аргумента, переданного методу, а не по явному указанию аргумента типа. Чтобы задействовать вывод, сигнатура параметра универсального метода должна включать параметр, тип которого совпадает с параметром типа для метода. В этом случае аргумент типа указывать не обязательно. При использовании вывода для всех параметров типа синтаксис вызова универсальных и неуниверсальных методов экземпляра является одинаковым; он повышает удобство использования универсальных методов. |
| CA1005 | [CA1005. Не используйте слишком много параметров в универсальных типах](../code-quality/ca1005.md) | Чем больше параметров типов содержит универсальный тип, тем сложнее знать и запоминать, что представляет каждый параметр типа. Обычно очевидно с одним параметром типа, как в списке \<T> , и в некоторых случаях с двумя параметрами типа, как в словаре \<TKey, TValue> . Если же используется более двух параметров типов, многие пользователи начинают испытывать большие трудности. |
| CA1006 | [CA1006. Не создавайте вложенные универсальные типы в сигнатурах членов](../code-quality/ca1006.md) | Аргумент вложенного типа также является аргументом универсального типа. Чтобы вызвать член, сигнатура которого содержит аргумент вложенного типа, пользователь должен создать экземпляр одного универсального типа и передать этот тип конструктору второго универсального типа. Это приводит к усложнению процедуры и синтаксиса, чего следует избегать. |
| CA1007 |[CA1007. По возможности используйте универсальные объекты](../code-quality/ca1007.md) | Видимый извне метод содержит ссылочный параметр типа System.Object. Использование универсального метода позволяет передавать в метод все типы без предварительного приведения к типу ссылочного параметра при условии выполнения некоторых ограничений. |
| CA1008 | [CA1008. Перечисляемые типы должны иметь нулевое значение](../code-quality/ca1008.md) | Значение по умолчанию неинициализированного перечисления, как и других типов значений, равно нулю. Перечисление без флагов в качестве атрибутов должно определять член с использованием нулевого значения так, чтобы значение по умолчанию было допустимым значением перечисления. Если перечисление с примененным атрибутом FlagsAttribute определяет член с нулевым значением, для него должно быть задано имя None, свидетельствующее о том, что в перечислении не были заданы значения. |
| CA1009 | [CA1009. Правильно объявляйте обработчики событий](../code-quality/ca1009.md) | Методы обработчиков событий принимают два параметра. Первый параметр принадлежит типу System.Object и называется "sender". Это объект, вызвавший событие. Второй параметр принадлежит типу System.EventArgs и называется "e". Это данные, связанные с событием. Методы обработки событий не должны возвращать значение; в языке программирования C# оно обозначается типом возвращаемого значения void. |
| CA1010 | [CA1010. Коллекции должны реализовать универсальный интерфейс](../code-quality/ca1010.md) | Чтобы расширить возможности использования коллекции, реализуйте один из универсальных интерфейсов коллекции. Затем данную коллекцию можно использовать для заполнения универсальных типов коллекции. |
| CA1011 |[CA1011. Попробуйте передать базовые типы в качестве параметров](../code-quality/ca1011.md) | Если в объявлении метода в качестве параметра указан базовый тип, любой тип, производный от базового, можно передать методу в качестве соответствующего аргумента. Если дополнительные функции, предоставляемые производным типом параметра, не требуются, то использование базового типа позволит более широко применять данный метод. |
| CA1012 | [CA1012. Абстрактные типы не должны иметь конструкторы](../code-quality/ca1012.md) | Конструкторы абстрактных типов могут быть вызваны только производными типами. Открытые конструкторы создают экземпляры типа. Невозможно создавать экземпляры абстрактного типа; абстрактный тип с открытым конструктором является недопустимым. |
| CA1013 | [CA1013. Перегружайте оператор равенства при перегрузке операторов сложения и вычитания](../code-quality/ca1013.md) | Открытый или защищенный тип реализует операторы сложения или вычитания без реализации оператора равенства. |
| CA1014 | [CA1014. Пометьте сборки с помощью CLSCompliantAttribute](../code-quality/ca1014.md) | Спецификация среды CLS определяет ограничения по именованию, типам данных и правилам, которым должны соответствовать сборки, предназначенные для использования в нескольких языках программирования. Для всех сборок рекомендуется явным образом указывать совместимость с CLS с помощью атрибута <xref:System.CLSCompliantAttribute>. Если этот атрибут у сборки отсутствует, сборка несовместима. |
| CA1016 | [CA1016. Пометьте сборки с помощью AssemblyVersionAttribute](../code-quality/ca1016.md) | .NET использует номер версии для уникальной идентификации сборки и привязки к типам в сборках со строгими именами. Номер версии используется наряду с политикой версий и издателя. По умолчанию приложения выполняются только с версией сборки, которая использовалась для их построения. |
| CA1017 | [CA1017. Пометьте сборки с помощью ComVisibleAttribute](../code-quality/ca1017.md) |Атрибут ComVisibleAttribute определяет порядок обращения клиентов COM к управляемому коду. Для правильной разработки сборки должны явным образом указывать видимость COM. Можно задать видимость COM для всей сборки, а затем переопределить ее для отдельных типов и элементов типов. Если атрибут отсутствует, содержимое сборки будет видимым клиентам COM. |
| CA1018 | [CA1018. Пометьте атрибуты с помощью AttributeUsageAttribute](../code-quality/ca1018.md) | При определении настраиваемого атрибута его нужно пометить атрибутом AttributeUsageAttribute, чтобы указать, где можно применять этот настраиваемый атрибут в исходном коде. Допустимое положение атрибута в коде зависит от значения атрибута и его применения. |
| CA1019 | [CA1019. Определите методы доступа для аргументов атрибута](../code-quality/ca1019.md) | Атрибуты могут определять обязательные аргументы, которые должны быть указаны при применении атрибута к целевому объекту. Они также известны как позиционные аргументы, поскольку предоставляются для конструкторов атрибутов в качестве позиционных параметров. Для каждого обязательного аргумента атрибут должен предоставлять соответствующее свойство, доступное только для чтения, чтобы извлечь значение аргумента во время выполнения. Кроме того, атрибуты могут определять дополнительные параметры, известные как именованные аргументы. Эти аргументы предоставляются для конструкторов атрибутов по имени и должны иметь соответствующее свойство чтения/записи. |
| CA1020 | [CA1020. Не используйте пространства имен с несколькими типами](../code-quality/ca1020.md) | Убедитесь, что каждое из используемых пространств имен имеет логическую организацию и существует веская причина для помещения типов в сильно разреженное пространство имен. |
| CA1021 | [CA1021. Не используйте параметры out](../code-quality/ca1021.md) | Для реализации передачи типов по ссылке (с помощью ключевого слова out или ref) от разработчика требуется опыт работы с указателями, понимание отличия между типами значения и ссылочными типами и умение работать с методами с несколькими возвращаемыми значениями. Кроме того, далеко не все понимают разницу между параметрами out и ref. |
| CA1023 | [CA1023. Индексы не должны быть многомерными](../code-quality/ca1023.md) | Для индексаторов (индексированных свойств) должен использоваться один индекс. Многомерные индексаторы могут крайне отрицательно сказаться на удобстве работы с библиотекой. |
| CA1024 | [CA1024. По возможности используйте свойства](../code-quality/ca1024.md) | Имя открытого или защищенного метода начинается с Get, он не принимает параметры и возвращает значение, не являющееся массивом. Возможно, этот метод лучше преобразовать в свойство. |
| CA1025 | [CA1025. Замените повторяющиеся аргументы массивом параметров](../code-quality/ca1025.md) | Если точное число аргументов неизвестно и эти аргументы принадлежат одному типу или могут быть переданы как аргументы одного типа, используйте вместо повторяющихся аргументов массив параметров. |
| CA1026 | [CA1026. Не следует использовать параметры по умолчанию](../code-quality/ca1026.md) | Методы, использующие параметры по умолчанию, разрешены по спецификации CLS; однако спецификация CLS разрешает компиляторам не учитывать значения, присвоенные этим параметрам. Для однородной работы с различными языками программирования следует заменять методы, использующие параметры по умолчанию, на перегрузки методов, предоставляющие параметры по умолчанию. |
| CA1027 |[CA1027. Пометьте перечисляемые типы с помощью FlagsAttribute](../code-quality/ca1027.md) | Перечисление является типом значения, которое определяет набор связанных именованных констант. Атрибут FlagsAttribute применяется к перечислению, когда его именованные константы могут быть объединены осмысленным образом. |
| CA1028 | [CA1028. Хранилище перечисляемых типов должно относиться к типу Int32](../code-quality/ca1028.md) | Перечисление является типом значения, которое определяет набор связанных именованных констант. По умолчанию для хранения значения константы используется тип данных System.Int32. Этот базовый тип можно изменить, но это не требуется и в большинстве случаев не рекомендуется. |
| CA1030 | [CA1030. По возможности используйте события](../code-quality/ca1030.md) |Данное правило отслеживает методы с именами, которые, как правило, используются для событий. Если метод вызывается в ответ на четко определенное изменение состояния, то этот вызов должен осуществляться с помощью обработчика событий. Объекты, вызывающие методы, должны создавать события, а не вызывать методы напрямую. |
| CA1031 | [CA1031. Не перехватывайте типы общих исключений](../code-quality/ca1031.md) | Общие исключения не должны перехватываться. Нужно перехватить исключение более конкретного характера или повторно выдать общее исключение в последнем операторе блока catch. |
| CA1032 |[CA1032. Реализуйте стандартные конструкторы исключений](../code-quality/ca1032.md) | Для правильной обработки исключений необходимо предоставить полный набор конструкторов. |
| CA1033 | [CA1033. Методы интерфейса должны быть доступны для вызова дочерними типами](../code-quality/ca1033.md) | Незапечатанный тип, доступный для внешнего кода, предоставляет явную реализацию метода открытого интерфейса и не предоставляет доступный для внешнего кода альтернативный метод с тем же именем. |
| CA1034 | [CA1034. Вложенные типы не должны быть видимыми](../code-quality/ca1034.md) | Вложенный тип — это тип, объявленный внутри области другого типа. Вложенные типы удобно использовать для инкапсуляции закрытых сведений о реализациях содержащего их типа. В силу этого вложенные типы не должны быть видимыми для внешнего кода. |
| CA1035 | [CA1035. В составе реализаций ICollection есть члены со строгим типом](../code-quality/ca1035.md) | Это правило требует, чтобы реализации ICollection предоставляли строго типизированные элементы, поскольку тогда пользователям не придется приводить аргументы к типу Object при использовании функциональных возможностей интерфейса. В этом правиле предполагается, что тип, реализующий интерфейс ICollection, делает это для управления коллекцией экземпляров типа, более строгого, чем Object. |
| CA1036 | [CA1036. Переопределите методы в сопоставимых типах](../code-quality/ca1036.md) |Открытый или защищенный тип реализует интерфейс System.IComparable. Он не переопределяет метод Object.Equals и не перегружает языковой оператор равенства, неравенства, "больше" или "меньше". |
| CA1038 | [CA1038. Перечислители должны иметь строгие типы](../code-quality/ca1038.md) | Это правило требует, чтобы реализации IEnumerator предоставляли строго типизированную версию свойства Current, поскольку тогда пользователям не придется приводить возвращаемое значение к строгому типу при использовании функциональных возможностей интерфейса. |
| CA1039 | [CA1039. Списки имеют строгие типы](../code-quality/ca1039.md) | Это правило требует, чтобы реализации IList предоставляли строго типизированные элементы, поскольку тогда пользователям не придется приводить аргументы к типу System.Object при использовании функциональных возможностей интерфейса. |
| CA1040 |[CA1040. Не используйте пустые интерфейсы](../code-quality/ca1040.md) | Интерфейсы определяют члены, предоставляющие поведение или соглашение об использовании. Функциональность, описанная интерфейсом, может быть использована любым типом вне зависимости от расположения типа в иерархии интерфейса. Тип реализует интерфейс путем предоставления реализаций для членов интерфейса. Пустой интерфейс не определяет никаких элементов, поэтому он не определяет контракт, который можно реализовать. |
| CA1041 | [CA1041. Укажите сообщение ObsoleteAttribute](../code-quality/ca1041.md) | Тип или элемент помечен атрибутом System.ObsoleteAttribute, для которого не указано свойство ObsoleteAttribute.Message. При компиляции типа или элемента, помеченного атрибутом ObsoleteAttribute, отображается текст свойства Message этого атрибута. Это предоставляет пользователю сведения об устаревшем типе или члене. |
| CA1043 | [CA1043. Используйте целый или строковый аргумент для индексаторов](../code-quality/ca1043.md) | Индексаторы (индексированные свойства) должны использовать для индекса целочисленные или строковые типы. Эти типы обычно используются для индексации структур данных и повышения удобства использования библиотеки. Тип Object следует использовать только в том случае, если во время разработки невозможно указать определенный целочисленный или строковый тип. |
| CA1044 | [CA1044. Свойства не должны быть доступными только для записи](../code-quality/ca1044.md) | Несмотря на то, что допустимо, а часто и необходимо иметь свойство, доступное только на чтение, рекомендации по разработке запрещают использование свойств, доступных только на запись. Это связано с тем, что если позволить пользователю задать значение, а затем запретить ему просматривать это значение, то таким образом не будет обеспечиваться какая-либо безопасность. Кроме того, при отсутствии доступа на чтение нельзя просмотреть состояние общих объектов, что снижает их полезность. |
| CA1045 |[CA1045. Не передавайте типы по ссылке](../code-quality/ca1045.md) | Для реализации передачи типов по ссылке (с помощью ключевого слова out или ref) от разработчика требуется опыт работы с указателями, понимание отличия между типами значения и ссылочными типами и умение работать с методами с несколькими возвращаемыми значениями. Архитекторы библиотек, которые разрабатывается для общей аудитории, не должны ждать, чтобы пользователи работали с главными рабочими `out` `ref` параметрами или. |
| CA1046 | [CA1046. Не перегружайте оператор равенства для ссылочных типов](../code-quality/ca1046.md) | Реализация оператора равенства по умолчанию почти всегда правильно работает для ссылочных типов. По умолчанию две ссылки равны, если они указывают на один объект. |
| CA1047 |[CA1047. Не объявляйте защищенные члены в запечатанных типах](../code-quality/ca1047.md) | Типы объявляют защищенный члены таким образом, чтобы наследующие типы могли получить доступ к члену или переопределить его. По определению наследовать запечатанные типы нельзя; это означает, что вызов защищенных методов для запечатанных типов невозможен. |
| CA1048 | [CA1048. Не объявляйте виртуальные члены в запечатанных типах](../code-quality/ca1048.md) | Типы объявляют методы как виртуальные, чтобы наследующие типы могли переопределять реализацию виртуального метода. По определению наследовать запечатанный тип нельзя. При этом виртуальный метод запечатанного типа теряет смысл. |
| CA1049 | [CA1049. Типы, которым принадлежат собственные ресурсы, должны быть освобождаемыми](../code-quality/ca1049.md) | Типы, выделяющие неуправляемые ресурсы, должны реализовывать интерфейс IDisposable, чтобы вызывающие методы могли высвобождать эти ресурсы по требованию и сокращать время существования объектов, занимающих ресурсы. |
| CA1050 | [CA1050. Объявите типы в пространствах имен](../code-quality/ca1050.md) | Типы объявляются в пространствах имен во избежание конфликтов имен и с целью упорядочения связанных типов в иерархии объектов. |
| CA1051 | [CA1051. Не объявляйте видимые поля экземпляров](../code-quality/ca1051.md) | Поля главным образом следует использовать для данных реализации. Поля должны быть помечены как private или internal и должны быть представлены с помощью свойств. |
| CA1052 | [CA1052. Типы со статическими заполнителями должны быть запечатаны](../code-quality/ca1052.md) | Открытый или защищенный тип содержит только статические элементы и не объявлен с модификатором sealed (справочник по C#) (NotInheritable). Тип, для которого нельзя создавать унаследованные типы, должен быть помечен модификатором sealed, чтобы его нельзя было использовать как базовый тип. |
| CA1053 |[CA1053. Типы со статическими заполнителями не должны иметь конструкторы](../code-quality/ca1053.md) | В открытом или вложенном открытом типе объявляются только статические элементы и имеется открытый или защищенный конструктор по умолчанию. Конструктор не нужен, поскольку при вызове статических членов не требуется экземпляр типа. Для обеспечения безопасности перегруженная строка должна вызывать перегрузку универсального кода ресурса (URI), используя строковый аргумент. |
| CA1054 | [CA1054. Параметры URI не должны быть строками](../code-quality/ca1054.md) | Если метод принимает строковое представление универсального кода ресурса (URI), необходимо предоставить соответствующую перегрузку, принимающую экземпляр класса URI, который предоставляет эти услуги безопасным образом. |
| CA1055 | [CA1055. Возвращаемые значения URI не должны быть строками](../code-quality/ca1055.md) | В этом правиле предполагается, что метод возвращает универсальный код ресурса (URI). В строковых представлениях кода URI часто встречаются ошибки синтаксического анализа и кодирования, которые могут привести к уязвимостям системы безопасности. Класс System.Uri предоставляет аналогичные услуги более надежным и безопасным способом. |
| CA1056 | [CA1056. Свойства URI не должны быть строками](../code-quality/ca1056.md) | В этом правиле предполагается, что свойство является универсальным кодом ресурса (URI). В строковых представлениях кода URI часто встречаются ошибки синтаксического анализа и кодирования, которые могут привести к уязвимостям системы безопасности. Класс System.Uri предоставляет аналогичные услуги более надежным и безопасным способом. |
| CA1057 | [CA1057. Перегрузки строковых параметров URI вызывают перегрузки System.Uri](../code-quality/ca1057.md) | Тип объявляет перегрузки метода, которые отличаются только заменой строкового параметра на параметр System.Uri. Эта перегрузка, которая принимает строковый параметр, не вызывает перегрузку, которая принимает параметр URI. |
| CA1058 | [CA1058. Типы не должны расширять определенные базовые типы](../code-quality/ca1058.md) | Видимый извне тип расширяет некоторые базовые типы. Используйте только один вариант. |
| CA1059 |[CA1059. Члены не должны предоставлять определенные конкретные типы](../code-quality/ca1059.md) | Устойчивый тип – это тип, который имеет полную реализацию и экземпляр которого можно создать. Чтобы иметь возможность широкого использования этого элемента, замените конкретный тип предложенным интерфейсом. |
| CA1060 | [CA1060: перемещение P/Invoke в класс NativeMethods](../code-quality/ca1060.md) | Методы PInvoke, например методы, помеченные атрибутом System.Runtime.InteropServices.DllImportAttribute, или методы, определенные с помощью ключевого слова Declare в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)], обращаются к неуправляемому коду. Эти методы должны относиться к классу NativeMethods, SafeNativeMethods или UnsafeNativeMethods. |
| CA1061 |[CA1061. Не скрывайте методы базовых классов](../code-quality/ca1061.md) | Метод в базовом типе скрыт методом с таким же именем в производном типе. Сигнатура параметра производного метода отличается только типами, которые являются более слабыми, чем соответствующие типы в сигнатуре параметра базового метода. |
| CA1062 | [CA1062. Проверьте аргументы или открытые методы](../code-quality/ca1062.md) | Все ссылочные аргументы, передаваемые в видимые для внешнего кода методы, должны проверяться на равенство значению NULL. |
| CA1063 | [CA1063. Правильно реализуйте IDisposable](../code-quality/ca1063.md) | Все типы IDisposable должны правильно реализовывать шаблон "Dispose". |
| CA1064 | [CA1064. Исключения должны быть общими](../code-quality/ca1064.md) | Внутреннее исключение видно только внутри своей внутренней области. После выхода исключения за пределы внутренней области для перехвата исключения можно использовать только базовое исключение. Если внутреннее исключение наследуется от <xref:System.Exception> , <xref:System.SystemException> или <xref:System.ApplicationException> , внешний код не будет иметь достаточных сведений, чтобы узнать, что делать с этим исключением. |
| CA1065 | [CA1065. Не вызывайте исключения в непредвиденных местах](../code-quality/ca1065.md) | Метод вызывает исключение, хотя не должен этого делать. |
| CA1066 | [CA1066: реализация IEquatable при переопределении Equals](../code-quality/ca1066.md) | Тип значения переопределяет <xref:System.Object.Equals%2A> метод, но не реализует <xref:System.IEquatable%601> . |
| CA1067 | [CA1067: переопределение Equals при реализации IEquatable](../code-quality/ca1067.md) | Тип реализует <xref:System.IEquatable%601> , но не переопределяет <xref:System.Object.Equals%2A> метод. |
| CA1068 | [CA1068: Параметры CancellationToken должны быть последними](../code-quality/ca1068.md) | Метод имеет параметр CancellationToken, который не является последним параметром. |
| CA1069 | [CA1069: перечисления не должны иметь повторяющихся значений](../code-quality/ca1069.md) | Перечисление содержит несколько членов, которым явным образом присвоено одно и то же значение константы. |
| CA1070 | [CA1070: не объявляйте поля событий как виртуальные](../code-quality/ca1070.md) | [Событие, похожее на поле](/dotnet/csharp/language-reference/language-specification/classes#field-like-events) , было объявлено как виртуальное. |
| CA1200 | [CA1200: Избегайте использования тегов cref с префиксом](../code-quality/ca1200.md) | Атрибут [cref](/dotnet/csharp/programming-guide/xmldoc/cref-attribute) в ТЕГЕ документации XML означает "ссылка на код". Он указывает, что текст внутри тега представляет собой элемент кода, например тип, метод или свойство. Старайтесь не использовать `cref` теги с префиксами, так как это не позволяет компилятору проверять ссылки. Это также предотвращает Поиск и обновление этих ссылок на символы во время рефакторинга в интегрированной среде разработки (IDE) Visual Studio. |
| CA1300 | [CA1300. Укажите MessageBoxOptions](../code-quality/ca1300.md) | Чтобы окно сообщения для языков, в которых используется порядок чтения справа налево, отображалось правильно, методу Show следует передать члены RightAlign и RtlReading перечисления MessageBoxOptions. |
| CA1301 | [CA1301. Избегайте повторяющихся акселераторов](../code-quality/ca1301.md) | Клавиша доступа, также называемая клавишей быстрого доступа, обеспечивает клавиатурный доступ к элементу управления с помощью клавиши ALT. Если несколько элементов управления имеют дублирующиеся клавиши доступа, поведение клавиши доступа определено нечетко. |
| CA1302 | [CA1302. Не указывайте прямо в коде строки, зависящие от языковых стандартов](../code-quality/ca1302.md) | Перечисление System.Environment.SpecialFolder содержит члены, ссылающиеся на специальные системные папки. Расположение этих папок может различаться в разных ОС, пользователь может менять расположение этих папок, их имена могут быть локализованы. Метод Environment.GetFolderPath возвращает связанные с перечислением Environment.SpecialFolder расположения в локализованной форме, подходящей для использования на работающем в данный момент компьютере. |
| CA1303 | [CA1303. Не передавайте литералы в качестве локализованных параметров](../code-quality/ca1303.md) | Метод, видимый извне, передает строковый литерал в качестве параметра в конструктор или метод .NET, и эта строка должна быть локализуемой. |
| CA1304 | [CA1304. Указывайте CultureInfo](../code-quality/ca1304.md) | Метод или конструктор вызывает член, имеющий перегрузку, которая принимает параметр System.Globalization.CultureInfo, вместо того чтобы вызвать перегрузку, принимающую параметр CultureInfo. Если объект CultureInfo или System.IFormatProvider не предоставляется, значение по умолчанию, поставляемое перегруженным членом, может не оказать ожидаемого воздействия во всех языковых стандартах. |
| CA1305 | [CA1305. Указывайте IFormatProvider](../code-quality/ca1305.md) | Метод или конструктор вызывает один или несколько членов, имеющих перегрузки, которые принимают параметр System.IFormatProvider, вместо того чтобы вызвать перегрузку, принимающую параметр IFormatProvider. Если объект System.Globalization.CultureInfo или IFormatProvider не предоставляется, значение по умолчанию, поставляемое перегруженным членом, может не оказать ожидаемого воздействия во всех языковых стандартах. |
| CA1306 | [CA1306. Задавайте языковой стандарт для типов данных](../code-quality/ca1306.md) | Язык и региональные параметры определяют представление элементов данных, таких как формат чисел, обозначение денежных единиц и порядок сортировки. При создании объектов DataTable или DataSet следует явным образом указывать языковой стандарт. |
| CA1307 | [CA1307: укажите StringComparison для ясности](../code-quality/ca1307.md) | В операции сравнения строк используется перегрузка метода, которая не задает параметр StringComparison. |
| CA1308 |[CA1308. Нормализуйте строки в верхний регистр](../code-quality/ca1308.md) | Строки следует нормализовать в верхний регистр. Существует небольшая группа символов, которые после преобразования в нижний регистр не могут участвовать в круговом перемещении. |
| CA1309 | [CA1309. Используйте порядковый параметр StringComparison](../code-quality/ca1309.md) | Операция сравнения строк, не являющаяся лингвистической, не задает для параметра StringComparison ни значения Ordinal, ни значения OrdinalIgnoreCase. После явного задания для параметра значения StringComparison.Ordinal или StringComparison.OrdinalIgnoreCase код часто становится более надежным и правильным, кроме того, увеличивается скорость его выполнения. |
| CA1310 | [CA1310: укажите StringComparison для корректности](../code-quality/ca1310.md) | Операция сравнения строк использует перегрузку метода, которая не задает параметр StringComparison и использует сравнение строк по умолчанию для определенного языка и региональных параметров. |
| CA1400 | [CA1400: должны существовать точки входа P/Invoke](../code-quality/ca1400.md) |Открытый или защищенный метод, помеченный атрибутом System.Runtime.InteropServices.DllImportAttribute. Не удается найти неуправляемую библиотеку либо не удается сопоставить метод функции в библиотеке. |
| CA1401 | [CA1401: методы P/Invoke не должны быть видимыми](../code-quality/ca1401.md) | Открытый или защищенный метод в открытом типе имеет атрибут System.Runtime.InteropServices.DllImportAttribute (также реализуется в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)] с помощью ключевого слова Declare). Такие методы не следует делать видимыми. |
| CA1402 |[CA1402. Избегайте перегрузок в видимых COM-интерфейсах](../code-quality/ca1402.md) | Когда перегруженные методы предоставляются клиентам COM, сохраняется имя только первой перегрузки метода. Последующие перегрузки переименовываются уникальным образом путем добавления к имени символа подчеркивания (_) и целого числа, соответствующего порядку объявления перегрузки. |
| CA1403 | [CA1403. Типы с автомакетом не должны быть видимыми для COM](../code-quality/ca1403.md) | Тип значения, видимый для COM, помечен с помощью атрибута System. Runtime. InteropServices. StructLayoutAttribute, установленного в LayoutKind. Auto. Макет этих типов может изменяться в разных версиях .NET, что приведет к нарушению работы клиентов COM, которые предполагают наличие определенного макета. |
| CA1404 | [CA1404: вызов GetLastError сразу после P/Invoke](../code-quality/ca1404.md) | Выполняется вызов метода Marshal. GetLastWin32Error или эквивалентной [!INCLUDE[TLA2#tla_win32](../code-quality/includes/tla2sharptla_win32_md.md)] функции GetLastError, а предыдущий вызов не является методом вызова операционной системы. |
| CA1405 | [CA1405. Базовые типы, относящиеся к типу, видимому для COM, должны быть видимыми для COM](../code-quality/ca1405.md) | Тип, видимый для модели COM, наследует от типа, который не является видимым для COM. |
| CA1406 |[CA1406. Не используйте аргументы Int64 для клиентов Visual Basic 6](../code-quality/ca1406.md) | COM-клиенты VisualBasic 6 не могут получать доступ к 64-разрядным целым числам. |
| CA1407 |[CA1407. Не используйте статические члены в типах, видимых для COM](../code-quality/ca1407.md) | Модель COM не поддерживает статические методы. |
| CA1408 | [CA1408. Не используйте тип AutoDual ClassInterfaceType](../code-quality/ca1408.md) | Типы, использующие сдвоенный интерфейс, позволяют клиентам выполнять привязку к определенному макету интерфейса. Все изменения в будущей версии макета типа и в базовых типах приведут к нарушению работы COM-клиентов, связанных с интерфейсом. По умолчанию, если атрибут ClassInterfaceAttribute не указан, используется только диспетчерский интерфейс. |
| CA1409 | [CA1409. Видимые для COM типы должны быть создаваемыми](../code-quality/ca1409.md) |Ссылочный тип, который специально помечен как видимый для модели COM, содержит открытый параметризованный конструктор, но не содержит открытого конструктора по умолчанию (без параметров). COM-клиенты не могут создавать объекты типа, не содержащего открытый конструктор по умолчанию. |
| CA1410 | [CA1410. Методы регистрации COM должны быть согласованными](../code-quality/ca1410.md) | Тип объявляет метод, помеченный атрибутом System.Runtime.InteropServices.ComRegisterFunctionAttribute, но не объявляет метод, помеченный атрибутом System.Runtime.InteropServices.ComUnregisterFunctionAttribute, или наоборот. |
| CA1411 | [CA1411. Методы регистрации COM не должны быть видимыми](../code-quality/ca1411.md) | Метод, помеченный атрибутом System.Runtime.InteropServices.ComRegisterFunctionAttribute или атрибутом System.Runtime.InteropServices.ComUnregisterFunctionAttribute, видим извне. |
| CA1412 | [CA1412. Пометьте интерфейсы ComSource как IDispatch](../code-quality/ca1412.md) | Тип помечен атрибутом System.Runtime.InteropServices.ComSourceInterfacesAttribute, однако по крайней мере один из указанных интерфейсов не помечен атрибутом System.Runtime.InteropServices.InterfaceTypeAttribute, значение которого равно ComInterfaceType.InterfaceIsIDispatch. |
| CA1413 | [CA1413. Не используйте неоткрытые поля в типах значений, видимых для COM](../code-quality/ca1413.md) | Не являющиеся общедоступными поля экземпляров типов значений, отображаемых для модели COM, отображаются для COM-клиентов. Проверьте содержимое полей на наличие сведений, к которым не должен предоставляться доступ или которые могут оказать непреднамеренное воздействие на разработку или безопасность. |
| CA1414 | [CA1414: помечайте логические аргументы P/Invoke с помощью MarshalAs](../code-quality/ca1414.md) | Логический тип данных имеет несколько представлений в неуправляемом коде. |
| CA1415 | [CA1415: правильно объявляйте P/Invoke](../code-quality/ca1415.md) | Это правило используется для поиска объявлений методов вызова операционной системы, предназначенных для функций [!INCLUDE[TLA2#tla_win32](../code-quality/includes/tla2sharptla_win32_md.md)], имеющих указатель на параметр структуры OVERLAPPED, если соответствующий управляемый параметр не является указателем на структуру System.Threading.NativeOverlapped. |
| CA1417 | [CA1417: не используйте `OutAttribute` в строковых параметрах для P/Invoke](../code-quality/ca1417.md) | Строковые параметры, передаваемые по значению, `OutAttribute` могут дестабилизировать среду выполнения, если строка является интернированной строкой. |
| CA1500 | [CA1500. Имена переменных не должны совпадать с именами полей](../code-quality/ca1500.md) | Метод экземпляра объявляет параметр или локальную переменную, чье имя совпадает с именем поля экземпляра объявляющего типа, что ведет к возникновению ошибок. |
| CA1501 | [CA1501. Избегайте излишнего наследования](../code-quality/ca1501.md) | Тип расположен глубже четырех уровней в иерархии наследования. Глубокие иерархии вложенных типов трудно отслеживать, понимать и поддерживать. |
| CA1502 | [CA1502. Избегайте чрезмерной сложности](../code-quality/ca1502.md) | Это правило измеряет число линейно независимых путей в методе, которое определяется числом и сложностью условных ветвей. |
| CA1504 | [CA1504. Проверьте имена полей, которые могут ввести в заблуждение](../code-quality/ca1504.md) | Имя поля экземпляра начинается с "s_" или имя статического (Shared в Visual Basic) поля начинается с "m_". |
| CA1505 | [CA1505. Избегайте кода, неудобного для поддержки](../code-quality/ca1505.md) | Тип или метод имеет низкий индекс обслуживаемости. Низкий индекс удобства поддержки означает, что тип или метод, вероятно, трудно поддерживать, поэтому их следует переработать. |
| CA1506 | [CA1506. Избегайте чрезмерной взаимозависимости классов](../code-quality/ca1506.md) | Данное правило измеряет взаимозависимость классов путем подсчета количества уникальных ссылок на типы, содержащихся в типе или методе. |
| CA1507 | [CA1507: Используйте nameof вместо строки](../code-quality/ca1507.md) | Строковый литерал используется в качестве аргумента, где `nameof` можно использовать выражение. |
| CA1508 | [CA1508: Избегайте появления неиспользуемого условного кода](../code-quality/ca1508.md) | Метод имеет условный код, который всегда вычисляется как `true` или `false` во время выполнения. Это приводит к неработающему коду в `false` ветви условия. |
| CA1509 | [CA1509: недопустимая запись в файле конфигурации метрик кода](../code-quality/ca1509.md) | Правила метрик кода, такие как [CA1501](ca1501.md), [CA1502](ca1502.md), [CA1505](ca1505.md) и [CA1506](ca1506.md), указали файл конфигурации с именем `CodeMetricsConfig.txt` , который имеет недопустимую запись. |
| CA1600 | [CA1600. Не используйте приоритет процесса простоя](../code-quality/ca1600.md) | Не задавайте для приоритета процесса значение Idle. Процессы с приоритетом System.Diagnostics.ProcessPriorityClass.Idle будут занимать ЦП, который иначе простаивал бы, и тем самым блокировать работу в режиме ожидания. |
| CA1601 | [CA1601. Не используйте таймеры, препятствующие изменению состояния электропитания](../code-quality/ca1601.md) | Повышение частоты периодических действий приводит к дополнительной нагрузке на ЦП и препятствует работе таймеров энергосберегающих режимов, которые отключают монитор и жесткие диски. |
| CA1700 | [CA1700. Не присваивайте перечисляемым значениям имя Reserved](../code-quality/ca1700.md) | В данном правиле предполагается, что член перечисления, имя которого содержит слово "reserved", не используется в настоящее время, а является местозаполнителем, который будет в дальнейшем переименован или удален. Переименование или удаление элемента — это критическое изменение. |
| CA1701 | [CA1701. Правильно используйте прописные и строчные буквы в составных словах строк ресурса](../code-quality/ca1701.md) | Каждое слово в строке ресурса разделяется на лексемы на основе регистра (заглавных букв). Каждое непрерывное сочетание двух токенов проверяется библиотекой проверки орфографии Майкрософт. При совпадении слово создает нарушение правила. |
| CA1702 | [CA1702. Для сложных слов следует использовать правильный регистр](../code-quality/ca1702.md) | Имя идентификатора состоит из нескольких слов, и по крайней мере одно из них является составным словом в неправильном регистре. |
| CA1703 | [CA1703. Строки ресурса должны иметь правильное правописание](../code-quality/ca1703.md) | Строка ресурса содержит одно или несколько слов, не распознанных библиотекой системы проверки правописания Майкрософт. |
| CA1704 | [CA1704. Идентификаторы должны иметь правильное правописание](../code-quality/ca1704.md) | Имя видимого для внешнего кода идентификатора содержит одно или несколько слов, не распознаваемых библиотекой средства проверки орфографии (Microsoft). |
| CA1707 | [CA1707. Идентификаторы не должны содержать символы подчеркивания](../code-quality/ca1707.md) | В соответствии с соглашением имена идентификаторов не могут содержать знак подчеркивания (_). Это правило позволяет проверить пространства имен, типы, элементы и параметры. |
| CA1708 | [CA1708. Идентификаторы должны отличаться не только прописными и строчными буквами](../code-quality/ca1708.md) | Идентификаторы пространств имен, типов, членов и параметров не могут отличаться только регистром знаков, поскольку языки программирования, поддерживаемые средой CLR, не обязательно учитывают регистр знаков. |
| CA1709 | [CA1709. Идентификаторы должны иметь правильное сочетание прописных и строчных букв](../code-quality/ca1709.md) | В соответствии с соглашением, в именах параметров используется смешанный регистр знаков, а в именах пространств имен, типов и членов — стиль языка Pascal. |
| CA1710 | [CA1710. Идентификаторы должны иметь правильные суффиксы](../code-quality/ca1710.md) |По правилам имена типов, расширяющих определенные базовые типы или реализующих определенные интерфейсы, а также типов, являющихся производными от первых, имеют суффикс, связанный с базовым типом или интерфейсом. |
| CA1711 | [CA1711. Идентификаторы не должны иметь неправильные суффиксы](../code-quality/ca1711.md) | В соответствии с соглашением об именовании, определенные зарезервированные суффиксы должны добавляться только к именам типов, которые расширяют некоторые базовые типы или реализуют определенные интерфейсы, а также производных от них типов. В именах других типов зарезервированные суффиксы использоваться не должны. |
| CA1712 | [CA1712. Не добавляйте имя типа перед перечисляемыми значениями](../code-quality/ca1712.md) | Имена членов перечисления не должны содержать префиксов в виде имени типа, поскольку предполагается, что сведения о типе предоставляются средствами разработки. |
| CA1713 | [CA1713. События не должны иметь префикс before или after](../code-quality/ca1713.md) | Имя события начинается с Before или After. Чтобы дать имена связанным событиям, возникающим в определенной последовательности, используйте настоящее или прошедшее время, чтобы обозначить положение события в последовательности действий. |
| CA1714 | [CA1714. У перечислений флагов должны быть имена во множественном числе](../code-quality/ca1714.md) | Открытое перечисление содержит атрибут System.FlagsAttribute, и имя перечисления не заканчивается на "s". Имена типов, помеченных атрибутом FlagsAttribute, используются во множественном числе, поскольку данный атрибут указывает на возможность задания нескольких значений. |
| CA1715 | [CA1715. Идентификаторы должны иметь правильные префиксы](../code-quality/ca1715.md) | Имя доступного для внешнего кода интерфейса не начинается с заглавной буквы "I". Имя параметра универсального типа в доступном для внешнего кода типе или методе не начинается с заглавной буквы "Т". |
| CA1716 | [CA1716. Идентификаторы не должны совпадать с ключевыми словами](../code-quality/ca1716.md) | Имя пространства имен или типа совпадает с ключевым словом, зарезервированным в языке программирования. Идентификаторы пространств имен и типов не должны совпадать с ключевыми словами, определенными в языках, поддерживаемых в среде CLR. |
| CA1717 | [CA1717. Только перечисления FlagsAttribute должны иметь имена во множественном числе](../code-quality/ca1717.md) | Согласно правилам именования множественное число имени перечисления указывает, что одновременно можно задать несколько значений перечисления. |
| CA1719 | [CA1719. Имена параметров не должны совпадать с именами членов](../code-quality/ca1719.md) | Имя параметра должно передавать смысловое значение параметра, а имя члена — смысловое значение члена. Они могут совпадать лишь в очень редких случаях. Присвоение параметру имени содержащего его члена кажется неестественным и затрудняет использование библиотеки. |
| CA1720 |[CA1720. Идентификаторы не должны содержать имена типов](../code-quality/ca1720.md) | Имя параметра в доступном для внешнего кода элементе содержит имя типа данных, или имя доступного для внешнего кода элемента содержит языковое имя типа данных. |
| CA1721 | [CA1721. Имена свойств не должны совпадать с именами методов get](../code-quality/ca1721.md) |Имя открытого или защищенного элемента начинается с Get и соответствует имени открытого или защищенного свойства и по другим параметрам. Методы Get и свойства должны иметь имена, позволяющие четко различать их функции. |
| CA1722 | [CA1722. Идентификаторы не должны иметь неправильные префиксы](../code-quality/ca1722.md) | В соответствии с соглашением об именовании, только некоторые элементы программирования могут иметь имена, которые начинаются с особого префикса. |
| CA1724 | [CA1724. Имена типов не должны совпадать с именами пространства имен](../code-quality/ca1724.md) | Имена типов не должны совпадать с именами пространств имен .NET. Нарушение этого правила приводит к уменьшению функциональности библиотеки. |
| CA1725 | [CA1725. Имена параметров должны соответствовать базовому объявлению](../code-quality/ca1725.md) | Согласованное именование параметров в иерархии переопределений увеличивает удобство использования переопределений метода. Если имя параметра в производном методе отличается от имени в базовом объявлении, может возникнуть путаница в определении того, чем является метод: переопределением базового метода или новой перегрузкой. |
| CA1726 | [CA1726. Используйте предпочтительные термины](../code-quality/ca1726.md) | Имя видимого снаружи идентификатора включает термин, для которого существует другой предпочтительный термин. Кроме того, имя содержит термин Flag или Flags. |
| CA1800 | [CA1800. Не делайте лишних приведений](../code-quality/ca1800.md) | Повторяющиеся приведения снижают производительность, особенно если приведения выполняются в компактных операторах итераций. |
| CA1801 | [CA1801. Проверьте неиспользуемые параметры](../code-quality/ca1801.md) | Сигнатура метода включает параметр, не использующийся в основной части метода. |
| CA1802 |[CA1802. По возможности используйте литералы](../code-quality/ca1802.md) |Поле объявляется статичным и доступным только для чтения (Shared и ReadOnly в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]) и инициализируется со значением, вычисляемым во время компиляции. Так как значение, назначенное целевому полю, вычисляемым во время компиляции, измените объявление на const (const в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)] ) поле, чтобы значение было вычислено во время компиляции, а не во время выполнения. |
| CA1804 | [CA1804. Удалите неиспользуемые локальные переменные](../code-quality/ca1804.md) | Неиспользуемые локальные переменные и ненужные присвоения увеличивают размер сборки и снижают производительность. |
| CA1805 | [CA1805: Не делайте лишних инициализаций](../code-quality/ca1805.md) | Среда выполнения .NET инициализирует все поля ссылочных типов значениями по умолчанию перед выполнением конструктора. В большинстве случаев явное инициализация поля значением по умолчанию является избыточным, что добавляет к затратам на обслуживание и может привести к снижению производительности (например, при увеличении размера сборки). |
| CA1806 | [CA1806. Не игнорируйте результаты метода](../code-quality/ca1806.md) | Создается, но никогда не используется новый объект, либо вызывается метод, который создает и возвращает новую строку, и такая новая строка никогда не используется, либо метод COM или P/Invoke возвращает HRESULT или код ошибки, который никогда не используется. |
| CA1809 |[CA1809. Избегайте лишних локальных переменных](../code-quality/ca1809.md) | Обычно для оптимизации производительности рекомендуется хранить значение не в памяти, а в регистре процессора. Это называется регистрацией значения. Чтобы повысить вероятность регистрации всех локальных переменных, следует ограничить их количество 64. |
| CA1810 | [CA1810. Инициализируйте статические поля ссылочных типов при объявлении](../code-quality/ca1810.md) | Если в типе объявляется явный статический конструктор, компилятор JIT добавляет проверку в каждый статический метод и конструктор экземпляров этого типа, чтобы убедиться, что статический конструктор уже вызывался ранее. Проверки статических конструкторов могут привести к снижению производительности. |
| CA1811 | [CA1811. Избегайте невызываемого частного кода](../code-quality/ca1811.md) | Закрытый или внутренний член (член уровня сборки) не вызывается ни объектами сборки, ни средой CLR, ни делегатом. |
| CA1812 | [CA1812. Избегайте неиспользуемых внутренних классов](../code-quality/ca1812.md) | Экземпляр типа уровня сборки не создается кодом в сборке. |
| CA1813 | [CA1813. Избегайте незапечатанных атрибутов](../code-quality/ca1813.md) | .NET предоставляет методы для извлечения пользовательских атрибутов. По умолчанию эти методы осуществляют поиск иерархии наследования атрибутов. Если запечатать атрибут, поиск в иерархии наследования выполняться не будет, в результате чего может повыситься производительность. |
| CA1814 | [CA1814. Используйте массивы массивов вместо многомерных массивов](../code-quality/ca1814.md) | Массив массивов — это массив, элементы которого сами являются массивами. Массивы, которые составляют элементы, могут иметь различные размеры, что позволяет экономить пространство для некоторых наборов данных. |
| CA1815 | [CA1815. Переопределяйте операторы Equals и равенства для типов значений](../code-quality/ca1815.md) | В унаследованной реализации Equals для типов значений используется библиотека отражения и сравнивается содержимое всех полей. Отражение является процессом, требующим с точки зрения вычислений больших затрат, и сравнение каждого поля на равенство может быть лишним. Если предполагается, что пользователи будут сравнивать, сортировать экземпляры или использовать их в качестве ключей хэш-таблиц, тип значения должен реализовывать Equals. |
| CA1816 | [CA1816. Вызов GC.SuppressFinalize должен осуществляться правильно](../code-quality/ca1816.md) | Метод, являющийся реализацией Dispose, не вызывает GC.SuppressFinalize, либо метод, не являющийся реализацией Dispose, вызывает GC.SuppressFinalize, либо метод вызывает GC.SuppressFinalize и передает что-либо другое (Me в Visual Basic). |
| CA1819 | [CA1819. Свойства не должны возвращать массивы](../code-quality/ca1819.md) | Массивы, возвращаемые свойствами, не защищены от записи, даже если свойство доступно только для чтения. Чтобы защитить массив от изменений, свойство должно возвращать копию массива. Как правило, пользователи не понимают требований к производительности при вызове такого свойства. |
| CA1820 | [CA1820. Проверяйте наличие пустых строк, используя длину строки](../code-quality/ca1820.md) | Сравнивать строки с использованием свойства String.Length или метода String.IsNullOrEmpty значительно быстрее, чем с помощью Equals. |
| CA1821 | [CA1821. Удалите пустые методы завершения](../code-quality/ca1821.md) | Если возможно, старайтесь не использовать финализаторы, поскольку из-за отслеживания жизненного срока объектов снижается производительность программы. Пустой метод завершения создает дополнительную нагрузку на систему, не обеспечивая никаких преимуществ. |
| CA1822 |[CA1822. Пометьте члены как статические](../code-quality/ca1822.md) | Члены, не обращающиеся к данным экземпляра и не вызывающие методы экземпляра, можно пометить как статические (Shared в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]). Если пометить методы как статические, компилятор предоставит этим членам невиртуальные места вызова. Это обеспечивает значительное повышение производительности при работе с кодом, для которого важна высокая производительность системы. |
| CA1823 | [CA1823. Избегайте неиспользуемых частных полей](../code-quality/ca1823.md) | Обнаружены закрытые поля, доступ к которым, судя по всему, не предоставляется в сборке. |
| CA1824 |[CA1824. Помечайте сборки с помощью NeutralResourcesLanguageAttribute](../code-quality/ca1824.md) | Атрибут NeutralResourcesLanguage информирует диспетчер ресурсов о языке, который использовался для вывода ресурсов нейтральной культуры для сборки. При этом повышается эффективность поиска первого загружаемого ресурса и может сократиться рабочее множество. |
| CA1825 |[CA1825: Избегайте выделения массивов нулевой длины](../code-quality/ca1825.md) | Инициализация массива нулевой длины приводит к ненужному выделению памяти. Вместо этого используйте статический выделенный экземпляр пустого массива, вызвав метод <xref:System.Array.Empty%2A?displayProperty=nameWithType> . Выделение памяти является общим для всех вызовов этого метода. |
| CA1826 |[CA1826: Используйте свойство вместо метода Enumerable в LINQ](../code-quality/ca1826.md) | <xref:System.Linq.Enumerable> Метод LINQ использовался для типа, который поддерживает эквивалентное, более эффективное свойство. |
| CA1827 |[CA1827: Не используйте Count/LongCount, если можно использовать Any](../code-quality/ca1827.md) | <xref:System.Linq.Enumerable.Count%2A><xref:System.Linq.Enumerable.LongCount%2A>метод или был использован, когда <xref:System.Linq.Enumerable.Any%2A> метод был бы более эффективным. |
| CA1828 |[CA1828: Не используйте CountAsync/LongCountAsync, если можно использовать AnyAsync](../code-quality/ca1828.md) | <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A>метод или был использован, когда <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> метод был бы более эффективным. |
| CA1829 |[CA1829: Используйте свойство Length/Count вместо метода Enumerable.Count](../code-quality/ca1829.md) | <xref:System.Linq.Enumerable.Count%2A> Метод LINQ использовался для типа, который поддерживает эквивалентное, более эффективное `Length` или `Count` свойство. |
| CA1830 |[CA1830: предпочитать строго типизированные перегрузки методов Append и Insert в StringBuilder](../code-quality/ca1830.md) | <xref:System.Text.StringBuilder.Append%2A> и <xref:System.Text.StringBuilder.Insert%2A> предоставляют перегрузки для нескольких типов, кроме <xref:System.String> .  По возможности рекомендуется использовать строго типизированные перегрузки с использованием ToString () и перегрузки на основе строк. |
| CA1831 |[CA1831: при необходимости используйте AsSpan вместо индексаторов на основе диапазона для строки](../code-quality/ca1831.md) | При использовании индексатора диапазона для строки и неявного присваивания значения Реадонлиспан &lt; &gt; типу Char метод <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> будет использоваться вместо <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , который создает копию запрошенной части строки. |
| CA1832 |[CA1832: используйте AsSpan или AsMemory вместо индексаторов на основе диапазона для получения части массива ReadOnlySpan или ReadOnlyMemory](../code-quality/ca1832.md) | При использовании индексатора диапазонов для массива и неявного присваивания значения <xref:System.ReadOnlySpan%601> <xref:System.ReadOnlyMemory%601> типу или, метод <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> будет использоваться вместо <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , который создает копию запрошенной части массива. |
| CA1833 |[CA1833: используйте AsSpan или AsMemory вместо индексаторов на основе диапазона для получения части массива Span или Memory](../code-quality/ca1833.md) | При использовании индексатора диапазонов для массива и неявного присваивания значения <xref:System.Span%601> <xref:System.Memory%601> типу или, метод <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> будет использоваться вместо <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , который создает копию запрошенной части массива. |
| CA1835 |[CA1835: предпочитать перегрузки на основе Мемори' для "ReadAsync" и "WriteAsync"](../code-quality/ca1835.md) | "Stream" имеет перегрузку "ReadAsync", которая принимает " &lt; байт памяти &gt; " в качестве первого аргумента, и перегрузка "WriteAsync", принимающая в &lt; &gt; качестве первого аргумента значение "реадонлимемори Byte". Предпочитать вызов перегрузок на основе памяти, что более эффективно. |
| CA1836 |[CA1836: предпочитать `IsEmpty` `Count` при доступности](../code-quality/ca1836.md) | Предпочитать `IsEmpty` свойство, которое более эффективно, чем `Count` , `Length` , <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> или, <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> чтобы определить, содержит ли объект какие-либо элементы или нет. |
| CA1837 | [CA1837: используйте `Environment.ProcessId` вместо `Process.GetCurrentProcess().Id`](../code-quality/ca1837.md) | `Environment.ProcessId` проще и быстрее, чем `Process.GetCurrentProcess().Id` . |
| CA1838 | [CA1838: Избегайте `StringBuilder` параметров для вызовов P/Invoke](../code-quality/ca1838.md) | При упаковке "StringBuilder" всегда создается собственная копия буфера, что приводит к многократному выделению для одной операции упаковки. |
| CA1900 | [CA1900. Поля типов значений должны быть переносимыми](../code-quality/ca1900.md) | Это правило проверяет правильность выравнивания структур, объявленных с явной разметкой, при маршалировании в неуправляемый код на 64-разрядных операционных системах. |
| CA1901 | [CA1901: объявления P/Invoke должны быть переносимыми](../code-quality/ca1901.md) | Данное правило вычисляет размер каждого параметра и возвращаемого значения вызова P/Invoke и проверяет правильность размера параметра при маршалировании в неуправляемый код на 32-разрядных и 64-разрядных операционных системах. |
| CA1903 | [CA1903. Используйте API только из целевой рабочей среды](../code-quality/ca1903.md) | Член или тип использует член или тип, который был впервые представлен в пакете обновления, не включенном в целевую среду проекта. |
| CA2000 | [CA2000. Ликвидируйте объекты перед потерей области](../code-quality/ca2000.md) | Необходимо явно удалить объект до того, как все ссылки на него окажутся вне области действия, так как может произойти исключительное событие, которое воспрепятствует выполнению метода завершения объекта. |
| CA2001 | [CA2001. Избегайте вызова проблемных методов](../code-quality/ca2001.md) | Член вызывает потенциально опасный или проблемный метод. |
| CA2002 |[CA2002. Не блокируйте объекты с ненадежными удостоверениями](../code-quality/ca2002.md) |К объекту со слабой идентификацией может быть получен прямой доступ через границы домена приложения. Поток пытается получить блокировку объекта со слабой идентификацией, который может быть заблокирован вторым потоком в другом домене приложения, имеющим блокировку того же объекта. |
| CA2003 |[CA2003. Не рассматривайте волокна в качестве потоков](../code-quality/ca2003.md) | Управляемый поток обрабатывается как поток [!INCLUDE[TLA2#tla_win32](../code-quality/includes/tla2sharptla_win32_md.md)]. |
| CA2004 | [CA2004. Удалите вызовы GC.KeepAlive](../code-quality/ca2004.md) | При переходе к использованию класса SafeHandle необходимо удалить все вызовы метода GC.KeepAlive (объект). В этом случаев классам не требуется вызывать метод GC.KeepAlive. При этом предполагается, что для завершения дескриптора ОС они используют не метод завершения, а класс SafeHandle. |
| CA2006 | [CA2006. Используйте SafeHandle для инкапсуляции собственных ресурсов](../code-quality/ca2006.md) | Использование указателя IntPtr в управляемом коде может указывать на потенциальную проблему безопасности и надежности. Необходимо изучить все случаи использования указателя IntPtr, чтобы определить, не следует ли использовать вместо него класс SafeHandle или другую подобную технологию. |
| CA2007 | [CA2007. Не следует напрямую ожидать Task](ca2007.md) | Асинхронный метод [ожидает](/dotnet/csharp/language-reference/keywords/await) <xref:System.Threading.Tasks.Task> непосредственного. Когда асинхронный метод ожидает <xref:System.Threading.Tasks.Task> непосредственного выполнения, продолжение происходит в том же потоке, в котором была создана задача. Такое поведение может быть дорогостоящим в плане производительности и может привести к взаимоблокировке потока пользовательского интерфейса. Рассмотрите возможность вызова <xref:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)?displayProperty=nameWithType> , чтобы сообщить о намерении к продолжению. |
| CA2008 | [CA2008: не создавать задачи без передачи TaskScheduler](ca2008.md) | Операция создания или продолжения задачи использует перегрузку метода, в которой не указан <xref:System.Threading.Tasks.TaskScheduler> параметр. |
| CA2009 | [CA2009: Не вызывайте ToImmutableCollection для значения ImmutableCollection](ca2009.md) | `ToImmutable` метод не обязательно был вызван для неизменяемой коллекции из <xref:System.Collections.Immutable> пространства имен. |
| CA2011 | [CA2011: не присваивайте свойство в методе задания](ca2011.md) | Свойству было случайно присвоено значение в собственном [методе доступа set](/dotnet/csharp/programming-guide/classes-and-structs/using-properties#the-set-accessor). |
| CA2012 | [CA2012: используйте ValueTasks правильно](ca2012.md) | Валуетаскс, возвращенные из вызовов членов, должны быть непосредственно ожидаются.  Попытки использовать ValueTask несколько раз или для прямого доступа к одному результату до его завершения могут привести к возникновению исключения или повреждения.  Пропуск такого ValueTask, скорее всего, указывает на функциональную ошибку и может привести к снижению производительности. |
| CA2013 | [CA2013: не используйте ReferenceEquals с типами значений](ca2013.md) | При сравнении значений с помощью <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> , если обжа и обжб являются типами значений, они упаковываются перед передачей в <xref:System.Object.ReferenceEquals%2A> метод. Это означает, что даже если оба обжа и Обжб представляют один и тот же экземпляр типа значения, <xref:System.Object.ReferenceEquals%2A> метод, тем не менее, возвращает значение false. |
| CA2014 | [CA2014: не используйте stackalloc в циклах.](ca2014.md) | Пространство стека, выделенное stackalloc, освобождается только в конце вызова текущего метода.  Использование в цикле может привести к неограниченному росту стека и появлению условий переполнения стека. |
| CA2015 | [CA2015: не определяйте методы завершения для типов, производных от Мемориманажер &lt; T&gt;](ca2015.md) | Добавление метода завершения к типу, производному от, <xref:System.Buffers.MemoryManager%601> может привести к освобождению памяти, пока она еще используется <xref:System.Span%601> . |
| CA2016 | [CA2016: Переадресовывать параметр CancellationToken методам, которые его принимают](ca2016.md) | Перешлите `CancellationToken` параметр методам, принимающим один из них, чтобы убедиться, что уведомления об отмене операций правильно распространены, или явно передать, `CancellationToken.None` чтобы указать намеренно не распространять маркер. |
| CA2100 | [CA2100. Проверьте запросы SQL на наличие уязвимостей системы безопасности](../code-quality/ca2100.md) | Метод задает свойство System.Data.IDbCommand.CommandText с использованием строки, созданной из строкового аргумента метода. Это правило предполагает, что строковый аргумент содержит введенные пользователем данные. Созданная из введенных пользователем данных командная строка SQL уязвима перед атаками путем внедрения кода SQL. |
| CA2101 |[CA2101: укажите маршалирование для строковых аргументов P/Invoke](../code-quality/ca2101.md) | Член вызова неуправляемого кода, разрешающий вызовы с частичным доверием, содержит строковый параметр и не выполняет явный маршалинг и преобразование этой строки. Это может стать причиной потенциальной уязвимости безопасности. |
| CA2102 | [CA2102. Перехватывайте исключения, не являющиеся CLSCompliant, с помощью общих обработчиков](../code-quality/ca2102.md) | Элемент в сборке, не помеченной атрибутом RuntimeCompatibilityAttribute или помеченной атрибутом RuntimeCompatibility(WrapNonExceptionThrows = false), содержит блок catch, который обрабатывает исключения System.Exception, однако непосредственно за этим блоком не следует общий блок catch. |
| CA2103 | [CA2103. Проверьте принудительную безопасность](../code-quality/ca2103.md) |Метод использует принудительную безопасность и может обеспечить создание разрешения с помощью сведений о состоянии или возвращаемых значений, которые могут измениться в период активности требования. Поэтому по возможности следует использовать декларативную безопасность. |
| CA2104 |[CA2104. Не объявляйте изменяющиеся ссылочные типы только для чтения](../code-quality/ca2104.md) | Видимый извне тип содержит видимое извне и доступное только для чтение поле, являющееся изменяемым ссылочным типом. Изменяемый тип — это тип, экземпляр которого может быть изменен. |
| CA2105 | [CA2105. Поля массивов не должны быть доступны только для чтения](../code-quality/ca2105.md) |При применении модификатора "только для чтения" (ReadOnly в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]) к полю, содержащему массив, это поле нельзя изменить, связав его с другим массивом. Однако элементы массива, хранящегося в доступном только для чтения поле, можно будет изменить. |
| CA2106 | [CA2106. Обеспечьте безопасность утверждений](../code-quality/ca2106.md) | Метод подтверждает разрешения без выполнения проверок безопасности для вызывающего объекта. Подтверждение разрешений безопасности без выполнения проверок безопасности может привести к возникновению в коде уязвимости системы безопасности, которой могут воспользоваться злоумышленники. |
| CA2107 | [CA2107. Проверьте использование Deny и Permit Only](../code-quality/ca2107.md) |Действия метода PermitOnly и CodeAccessPermission. Deny Security должны использоваться только теми, у кого есть опыт работы с безопасностью .NET. Код, который использует эти действия безопасности, должен быть тщательно проанализирован на предмет безопасности. |
| CA2108 | [CA2108. Проверьте объявляемые параметры безопасности типов значений](../code-quality/ca2108.md) | Открытый или защищенный тип значения защищен средствами доступа к данным или требованиями ссылки. |
| CA2109 | [CA2109. Проверьте видимые обработчики событий](../code-quality/ca2109.md) | Обнаружен открытый или защищенный метод обработки событий. Методы обработки событий следует раскрывать только в тех случаях, когда это совершенно необходимо. |
| CA2111 |[CA2111. Указатели не должны быть видимыми](../code-quality/ca2111.md) | Указатель не является закрытым, внутренним или доступным только для чтения. Вредоносный код может изменить значение указателя, что потенциально приведет к предоставлению доступа к произвольным областям памяти или сбоям приложения или системы. |
| CA2112 | [CA2112. Защищенные типы не должны предоставлять поля](../code-quality/ca2112.md) | Открытый или защищенный тип содержит открытые поля и защищен требованиями ссылки. Если код имеет доступ к экземпляру типа, защищенного запросом компоновки, то для получения доступа к полям типа коду не требуется удовлетворять запросу компоновки. |
| CA2114 | [CA2114. Безопасность метода должна быть надмножеством типа](../code-quality/ca2114.md) | Метод не должен обладать декларативной безопасностью для одного и того же действия, как на уровне метода, так и на уровне типа. |
| CA2115 | [CA2115. Вызывайте GC.KeepAlive при использовании собственных ресурсов](../code-quality/ca2115.md) | Данное правило обнаруживает ошибки, которые могут возникать из-за завершения неуправляемых ресурсов, по-прежнему используемых в машинном коде. |
| CA2116 | [CA2116. APTCA-методы должны вызывать только APTCA-методы](../code-quality/ca2116.md) |Если в полностью доверенной сборке присутствует атрибут APTCA (AllowPartiallyTrustedCallersAttribute) и она выполняет код в другой сборке, для которой не разрешены частично доверенные вызовы, возможно возникновение уязвимости безопасности. |
| CA2117 | [CA2117. APTCA-типы должны расширять только базовые APTCA-типы](../code-quality/ca2117.md) | Если сборка с полным доверием помечена атрибутом APTCA и тип в сборке наследует от типа, который не разрешает вызовы с неполным доверием, возможно возникновение уязвимости для эксплойта. |
| CA2118 | [CA2118. Проверьте использование атрибута SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2118.md) |Атрибут SuppressUnmanagedCodeSecurityAttribute изменяет поведение системы безопасности, определенное по умолчанию, для элементов, выполняющих неуправляемый код за счет COM-взаимодействия или вызова операционной системы. Этот атрибут служит в основном для повышения производительности; однако, прирост производительности сопряжен со значительными рисками безопасности. |
| CA2119 | [CA2119. Запечатайте методы, соответствующие частным интерфейсам](../code-quality/ca2119.md) | Наследуемый открытый тип предоставляет реализацию переопределяемого метода внутреннего (Friend в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]) интерфейса. Для устранения нарушения данного правила следует исключить возможность переопределения метода за пределами сборки. |
| CA2120 | [CA2120. Обеспечьте безопасность конструкторов сериализации](../code-quality/ca2120.md) | Для этого типа предусмотрен конструктор, который принимает объекты System.Runtime.Serialization.SerializationInfo и System.Runtime.Serialization.StreamingContext (сигнатура конструктора сериализации). Этот конструктор не защищен проверкой безопасности, однако один или несколько обычных конструкторов этого типа защищены. |
| CA2121 | [CA2121. Статические конструкторы должны быть частными](../code-quality/ca2121.md) | Система вызывает статический конструктор перед созданием первого экземпляра типа или ссылкой на любые статические члены. Если статический конструктор не является закрытым, он может быть вызван кодом, находящимся за пределами системы. В зависимости от операций, выполняемых в конструкторе, это может стать причиной непредвиденного поведения |
| CA2122 | [CA2122. Не используйте косвенное представление методов с требованиями ссылки](../code-quality/ca2122.md) | У открытого или защищенного члена есть требования ссылки, и он вызывается членом, который не выполняет какие-либо проверки безопасности. Запрос компоновки проверяет разрешения только непосредственно вызывающего метода. |
| CA2123 | [CA2123. Переопределяющие требования ссылки должны быть идентичны базовым](../code-quality/ca2123.md) | Это правило сравнивает метод с его базовым методом (который является интерфейсом или виртуальным методом другого типа), а затем сравнивает запросы ссылок для каждого из них. Если это правило нарушается, то вредоносный вызывающий объект может обойти запрос ссылок путем вызова небезопасного метода. |
| CA2124 | [CA2124. Ограничьте уязвимые предложения finally во внешних блоках try](../code-quality/ca2124.md) | Открытый или защищенный метод содержит блок try/finally. Блок finally сбрасывает состояние безопасности и не заключен в блок finally. |
| CA2126 | [CA2126. Для требований ссылок на тип необходимы требования наследования](../code-quality/ca2126.md) | Открытый незапечатанный тип защищен требованием ссылки и имеет переопределяемый метод. Ни тип, ни метод не защищены с помощью требования наследования. |
| CA2130 | [CA2130. Важные константы безопасности должны быть прозрачными](../code-quality/ca2130.md) | Принудительная прозрачность не применяется для постоянных значений, чтобы во время выполнения не требовалась подстановка значений. Константные поля должны быть прозрачными для системы безопасности, чтобы анализаторы кода не предполагали, что прозрачный для системы безопасности код не может получить доступ к константе. |
| CA2131 | [CA2131. Критические для безопасности типы не могут участвовать в эквивалентности типов](../code-quality/ca2131.md) | Тип участвует в эквивалентности типов, а сам тип или член или поле типа помечены атрибутом SecurityCriticalAttribute. Это правило применяется ко всем критическим типам или к типам, содержащим критические методы или поля, участвующие в эквивалентности типов. Когда среда CLR обнаруживает такой тип, она не загружает его и выдает исключение TypeLoadException во время выполнения. Обычно это правило применяется, только когда пользователи вручную реализуют эквивалентность типов, вместо использования tlbimp и компиляторов. |
| CA2132 | [CA2132. Конструкторы по умолчанию должны быть по меньшей мере такими же критическими, как конструкторы по умолчанию базового типа](../code-quality/ca2132.md) |Типы и члены с атрибутом SecurityCriticalAttribute не могут использоваться в коде приложений Silverlight. Критичные в плане безопасности типы и элементы могут использоваться только надежным кодом в среде .NET Framework для библиотеки классов Silverlight. Поскольку открытая или защищенная конструкция в производном классе должна иметь ту же или большую прозрачность, чем ее базовый класс, класс в приложении не может быть производным от класса, помеченного как SecurityCritical. |
| CA2133 | [CA2133. Делегаты должны быть привязаны к методам с соответствующей прозрачностью](../code-quality/ca2133.md) | Это предупреждение вызывается методом, который привязывает делегат, помеченный атрибутом SecurityCriticalAttribute, к методу, который является прозрачным или помечен атрибутом SecuritySafeCriticalAttribute. Предупреждение также выдается для метода, который привязывает прозрачный или безопасный делегат к критическому методу. |
| CA2134 | [CA2134. Методы должны сохранять одинаковую прозрачность при переопределении базовых методов](../code-quality/ca2134.md) |Это правило применяется, когда метод, помеченный атрибутом SecurityCriticalAttribute, переопределяет прозрачный метод или метод, помеченный атрибутом SecuritySafeCriticalAttribute. Это правило также применяется, когда прозрачный метод или метод, помеченный атрибутом SecurityCriticalAttribute, переопределяет метод, помеченный атрибутом SecuritySafeCriticalAttribute. Это правило применяется при переопределении виртуального метода или реализации интерфейса. |
| CA2135 | [CA2135. Сборки уровня 2 не должны содержать LinkDemands](../code-quality/ca2135.md) | Требования LinkDemand являются устаревшими в наборе правил безопасности уровня 2. Вместо использования требования LinkDemand для обеспечения безопасности во время JIT-компиляции пометьте методы, типы и поля атрибутом SecurityCriticalAttribute. |
| CA2127 | [CA2136. Члены не должны иметь противоречащие заметки прозрачности](../code-quality/ca2136.md) | Критический код не может возникать в сборке, прозрачной для 100%. Это правило анализирует 100% прозрачных сборок для любых аннотаций SecurityCritical на уровнях типа, поля и метода. |
| CA2136 | [CA2136. Члены не должны иметь противоречащие заметки прозрачности](../code-quality/ca2136.md) | Атрибуты прозрачности применяются из элементов кода большей области к элементам меньшей области. Атрибуты прозрачности элементов кода с большей областью имеют приоритет по сравнению с атрибутами прозрачности элементов кода, которые содержатся в первом элементе. Например, класс, помеченный атрибутом SecurityCriticalAttribute, не может содержать метод, помеченный атрибутом SecuritySafeCriticalAttribute. |
| CA2137 | [CA2137. Прозрачные методы должны содержать только поддающийся проверке промежуточный язык](../code-quality/ca2137.md) | Метод содержит непроверяемый код или возвращает тип по ссылке. Это правило срабатывает при попытках прозрачного кода безопасности выполнить непроверяемый MISL. Однако это правило не содержит полную проверку IL, и вместо нее использует эвристику для выявления большинства нарушений проверки MSIL. |
| CA2138 | [CA2138. Прозрачные методы не должны вызывать методы с атрибутом SuppressUnmanagedCodeSecurity](../code-quality/ca2138.md) | Прозрачный с точки зрения безопасности метод вызывает метод, помеченный атрибутом SuppressUnmanagedCodeSecurityAttribute. |
| CA2139 | [CA2139. Прозрачные методы могут не использовать атрибут HandleProcessCorruptingExceptions](../code-quality/ca2139.md) | Это правило запускается любым прозрачным методом, который пытается обработать исключение повреждения процесса с помощью атрибута HandleProcessCorruptedStateExceptionsAttribute. Исключение повреждения процесса – это классификация версии 4.0 среды CLR таких исключений, как AccessViolationException. Атрибут HandleProcessCorruptedStateExceptionsAttribute может использоваться только критичными в плане безопасности методами и будет игнорироваться при применении для прозрачного метода. |
| CA2129 | [CA2140. Прозрачный код не должен ссылаться на критические для безопасности элементы](../code-quality/ca2140.md) | Методы, помеченные атрибутом SecurityTransparentAttribute, вызывают закрытые члены, помеченные как SecurityCritical. Это правило позволяет проанализировать все методы и типы в смешанной (прозрачной и критической) сборке и пометить все вызовы закрытого критического кода из прозрачного кода, которые не помечены как SecurityTreatAsSafe. |
| CA2140 | [CA2140. Прозрачный код не должен ссылаться на критические для безопасности элементы](../code-quality/ca2140.md) | Элемент кода, помеченный атрибутом SecurityCriticalAttribute, является критическим с точки зрения безопасности. Прозрачный метод не может использовать элемент, критический с точки зрения безопасности. Если прозрачный тип пытается использовать тип, критический с точки зрения безопасности, то вызывается исключение TypeAccessException, MethodAccessException или FieldAccessException. |
| CA2141 |[CA2141: прозрачные методы не должны удовлетворять требования LinkDemand](../code-quality/ca2141.md) | Прозрачный с точки зрения безопасности метод вызывает метод в сборке, не помеченной атрибутом APTCA, либо прозрачный с точки зрения безопасности метод удовлетворяет требованию LinkDemand по типу или методу. |
| CA2142 | [CA2142. Прозрачный код не должен быть защищен проверками LinkDemands](../code-quality/ca2142.md) | Это правило срабатывает для прозрачных методов, для доступа к которым требуется LinkDemand. Прозрачный для системы безопасности код не должен отвечать за проверку безопасности операции и поэтому не должен требовать разрешений. |
| CA2143 | [CA2143. Прозрачные методы не должны использовать требования безопасности](../code-quality/ca2143.md) | Прозрачный для системы безопасности код не должен отвечать за проверку безопасности операции и поэтому не должен требовать разрешений. Прозрачный для системы безопасности код должен использовать полные требования для принятия решений по безопасности, и критичный в плане безопасности код не должен полагаться на прозрачный код, чтобы создать полное требование. |
| CA2144 | [CA2144. Прозрачный код не должен выполнять загрузку сборок из массивов байтов](../code-quality/ca2144.md) | Проверка безопасности для прозрачного кода не так тщательна, как проверка безопасности для критического кода, поскольку прозрачный код не может выполнять действия, требующие особых мер безопасности. Сборки, загруженные из массива байтов, могут остаться незамеченными в прозрачном коде, и этот массив байтов может содержать критичный или, что более важно, критичный в плане безопасности код, который подлежит аудиту. |
| CA2145 | [CA2145. Прозрачные методы не должны быть отмечены атрибутом SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2145.md) | Методы, оснащенные атрибутом SuppressUnmanagedCodeSecurityAttribute, имеют неявную проверку LinkDemand, применяемую к любому вызывающему их методу. Для этой проверки LinkDemand требуется, чтобы вызывающий код был критическим с точки зрения безопасности. Пометка метода, который использует SuppressUnmanagedCodeSecurity с атрибутом SecurityCriticalAttribute, делает это требование более очевидным для тех, кто вызывает этот метод. |
| CA2146 | [CA2146. Типы должны быть по крайней мере настолько же критическими, как их базовые типы и интерфейсы](../code-quality/ca2146.md) | Это правило срабатывает, если у производного типа есть атрибут прозрачности безопасности, не такой критический, как базовый тип или реализованный интерфейс. От критических базовых типов или реализованных критических интерфейсов могут производиться только критические типы, и от критических в плане безопасности базовых типов или реализованных интерфейсов могут производиться только критические в плане безопасности типы. |
| CA2128 |[CA2147. Прозрачные методы могут не использовать утверждения безопасности](../code-quality/ca2147.md) | Это правило анализирует все методы и типы в сборке, которая имеет значение 100 процентов прозрачная или смешанная прозрачная или критическая, и помечает любое декларативное или императивное использование Assert. |
| CA2147 |[CA2147. Прозрачные методы могут не использовать утверждения безопасности](../code-quality/ca2147.md) | Коду, помеченному атрибутом SecurityTransparentAttribute, не предоставляются достаточные для утверждения разрешения. |
| CA2149 | [CA2149. Прозрачные методы не должны вызывать машинный код](../code-quality/ca2149.md) | Это правило применяется в любом прозрачном методе, который напрямую вызывает машинный код (например, с помощью P/Invoke). Нарушение этого правила приводит к исключению MethodAccessException на уровне 2 модели прозрачности и вызову полного требования UnmanagedCode на уровне 1 модели прозрачности. |
| CA2151 |[CA2151. Поля с критическими типами должны быть критическими с точки зрения безопасности](../code-quality/ca2151.md) | Для использования критических с точки зрения безопасности типов код, который ссылается на тип, должен быть либо критическим с точки зрения безопасности, либо надежным с точки зрения безопасности. Это верно даже в случае косвенной ссылки. Поэтому применять прозрачное для безопасности поле или поле, надежное с точки зрения безопасности, не рекомендуется, поскольку прозрачный код по-прежнему не сможет получить доступ к полю. |
| CA2200 | [CA2200. Повторно порождайте исключения для сохранения сведений стека](../code-quality/ca2200.md) | В операторе throw повторно создается и явным образом задается исключение. Если исключение повторно создается заданием исключения в операторе throw, список вызовов метода между исходным методом, создавшим исключение, и текущим методом будет утерян. |
| CA2201 | [CA2201. Не порождайте исключения зарезервированных типов](../code-quality/ca2201.md) | Из-за этого становится трудно обнаружить и отладить изначальную ошибку. |
| CA2202 | [CA2202. Не ликвидируйте объекты несколько раз](../code-quality/ca2202.md) |Реализация метода содержит пути кода, которые могли стать причиной многократного вызова метода System.IDisposable.Dispose или эквивалентного метода Dispose (например, метода Close() для некоторых типов) для одного и того же объекта. |
| CA2204 | [CA2204. Литералы должны иметь правильное правописание](../code-quality/ca2204.md) | Литеральная строка в теле метода содержит одно или несколько слов, не распознаваемых библиотекой системы проверки орфографии Майкрософт. |
| CA2205 | [CA2205. Используйте управляемые эквиваленты Win32 API](../code-quality/ca2205.md) | Определен метод вызова операционной системы, и доступен метод .NET, имеющий эквивалентную функциональность. |
| CA2207 | [CA2207. Используйте встроенную инициализацию статических полей типов значений](../code-quality/ca2207.md) | Тип значения объявляет явный статический конструктор. Чтобы устранить нарушение данного правила, выполните инициализацию всех статических данных при их объявлении и удалите статический конструктор. |
| CA2208 |[CA2208. Правильно создавайте экземпляры исключений аргументов](../code-quality/ca2208.md) | Вызывается конструктор по умолчанию (без параметров), принадлежащий к типу исключения ArgumentException или унаследованный от него, или неправильный аргумент строки передается параметризованному конструктору, принадлежащему к типу исключения ArgumentException или унаследованному от него. |
| CA2210 |[CA2210. Сборки должны иметь допустимые строгие имена](../code-quality/ca2210.md) | Строгое имя защищает клиентов от случайной загрузки сборки, которая была подменена. Сборки без строгих имен следует развертывать лишь в крайне небольшом числе случаев. При обмене или распространении сборок без правильной подписи сборки могут быть подменены, среда CLR может не загрузить сборку или пользователь может быть вынужден отключить проверку на своем компьютере. |
| CA2211 |[CA2211. Поля, не являющиеся константами, не должны быть видимыми](../code-quality/ca2211.md) | Для статических полей, которые не являются константными и доступными только для чтения, невозможно обеспечить потокобезопасность. Доступ к подобным полям должен тщательно контролироваться, и для синхронизации доступа к такому объекту класса требуются дополнительные методы программирования. |
| CA2212 | [CA2212. Не помечайте обслуживаемые компоненты с помощью WebMethod](../code-quality/ca2212.md) |Метод в типе, унаследованном от System.EnterpriseServices.ServicedComponent, помечен атрибутом System.Web.Services.WebMethodAttribute. Так как атрибут WebMethodAttribute и метод ServicedComponent имеют разное поведение и предъявляют конфликтующие требования к контексту и потоку транзакций, в некоторых сценариях поведение метода будет неправильным. |
| CA2213 | [CA2213. Следует высвобождать высвобождаемые поля](../code-quality/ca2213.md) | Тип, реализующий System.IDisposable, объявляет поля, принадлежащие к типам, которые также реализуют IDisposable. Метод Dispose поля не вызывается методом Dispose объявляющего типа. |
| CA2214 | [CA2214. Не вызывайте переопределяемые методы в конструкторах](../code-quality/ca2214.md) | Когда конструктор вызывает виртуальный метод, возможна ситуация, когда конструктор для экземпляра, вызывающего метод, не выполняется. |
| CA2215 | [CA2215. Метод Dispose должен вызывать базовый класс Dispose](../code-quality/ca2215.md) | Если тип наследуется от удаляемого типа, он должен вызвать метод Dispose базового типа из собственного метода Dispose. |
| CA2216 |[CA2216. Высвобождаемые типы должны объявлять методы завершения](../code-quality/ca2216.md) | Тип, который реализует System.IDisposable и имеет поля, предусматривающие использование неуправляемых ресурсов, не реализует метод завершения, как описано в Object.Finalize. |
| CA2217 | [CA2217. Не помечайте перечисляемые типы с помощью FlagsAttribute](../code-quality/ca2217.md) |Доступное для внешнего кода перечисление помечено атрибутом FlagsAttribute и имеет одно или несколько значений, которые не являются степенью двойки или сочетанием других определенных значений в перечислении. |
| CA2218 |[CA2218. Переопределяйте GetHashCode при переопределении Equals](../code-quality/ca2218.md) | GetHashCode возвращает значение на основе текущего экземпляра, используемое для алгоритмов хэширования и структур данных, таких как хэш-таблица. Два равных объекта, принадлежащие к одному и тому же типу, должны возвращать один и тот же хэш-код. |
| CA2219 | [CA2219. В предложениях с исключениями не должны порождаться исключения](../code-quality/ca2219.md) | Если исключение создается в предложении finally или fault, новое исключение скрывает активное исключение. Если исключение создается в предложении filter, среда выполнения перехватывает исключение без оповещения. Из-за этого становится трудно обнаружить и отладить изначальную ошибку. |
| CA2220 | [CA2220. Методы завершения должны вызывать метод завершения базового класса](../code-quality/ca2220.md) | Финализация должна распространятся посредством иерархии наследования. Для этого типы должны вызывать свой метод Finalize базового класса из собственного метода Finalize. |
| CA2221 |[CA2221. Методы завершения должны быть защищенными](../code-quality/ca2221.md) | В методах завершения должен использоваться модификатор доступа из семейства. |
| CA2222 | [CA2222. Не уменьшайте видимость наследуемого члена](../code-quality/ca2222.md) |Не следует изменять модификатор доступа для унаследованных членов. Если сделать унаследованный член закрытым, то доступ вызывающих объектов к реализации метода базового класса все равно не будет запрещен. |
| CA2223 | [CA2223. Члены должны различаться не только возвращаемым типом](../code-quality/ca2223.md) | Среда CLR позволяет использовать возвращаемые типы для различения совпадающих в остальном членов, однако эта функция не входит в спецификацию CLS и поддерживается не всеми языками программирования .NET. |
| CA2224 | [CA2224. Переопределяйте Equals при перегрузке оператора равенства](../code-quality/ca2224.md) | Открытый тип реализует оператор равенства, но не переопределяет Object.Equals. |
| CA2225 | [CA2225. Для перегрузок операторов существуют варианты с именами](../code-quality/ca2225.md) |Обнаружена перегрузка оператора, однако не найден ожидаемый именованный альтернативный метод. Именованный альтернативный член предоставляет те же функции, что и основной оператор, и его могут использовать разработчики, которые программируют на языках, не поддерживающих перегрузку операторов. |
| CA2226 | [CA2226. Перегрузки операторов должны быть симметричными](../code-quality/ca2226.md) | Тип реализует оператор равенства или неравенства, но не реализует противоположный оператор. |
| CA2227 |[CA2227. Свойства, возвращающие коллекции, должны быть доступными только для чтения](../code-quality/ca2227.md) |Свойство коллекции, допускающее запись, позволяет пользователю заменять одну коллекцию другой. Свойство только для чтения предотвращает замену коллекции, но по-прежнему допускает установку, настройку отдельных членов. |
| CA2228 | [CA2228. Не поставляйте предварительные форматы ресурсов](../code-quality/ca2228.md) | Файлы ресурсов, созданные с помощью предварительных версий .NET, могут не использоваться поддерживаемыми версиями .NET. |
| CA2229 | [CA2229. Реализуйте конструкторы сериализации](../code-quality/ca2229.md) | Чтобы устранить нарушение этого правила, реализуйте конструктор сериализации. Для запечатанного класса конструктор должен быть закрытым, а в иных случаях — защищенным. |
| CA2230 | [CA2230. Используйте параметры для аргументов переменной](../code-quality/ca2230.md) | Открытый или защищенный тип содержит открытый или защищенный метод, который использует соглашение о вызовах VarArgs вместо ключевого слова params. |
| CA2231 | [CA2231. Перегрузите оператор равенства на переопределяющем типе ValueType.Equals](../code-quality/ca2231.md) | Тип значения переопределяет Object.Equals, но не реализует оператор равенства. |
| CA2232 | [CA2232. Отметьте точки входа Windows Forms меткой STAThread](../code-quality/ca2232.md) | Атрибут STAThreadAttribute указывает, что потоковой моделью COM для приложения является однопотоковое подразделение. Данный атрибут должен находиться в точке входа любого приложения, использующего Windows Forms; если он отсутствует, компоненты Windows могут работать неправильно. |
| CA2233 |[CA2233. В операциях не должно быть переполнений](../code-quality/ca2233.md) | Не следует выполнять арифметические операции без предварительной проверки операндов. Это гарантирует, что результат операции находится в диапазоне возможных значений для используемых типов данных. |
| CA2234 | [CA2234. Передавайте объекты System.Uri вместо строк](../code-quality/ca2234.md) | Вызывается метод, имеющий параметр строки, имя которого содержит uri, URI, urn, URN, url или URL. Объявляющий тип метода содержит соответствующую перегрузку метода, которая имеет параметр System.Uri. |
| CA2235 | [CA2235. Пометьте все несериализуемые поля](../code-quality/ca2235.md) | Экземпляр поля несериализуемого типа объявлен в сериализуемом типе. |
| CA2236 | [CA2236. Вызывайте методы базового класса для типов ISerializable](../code-quality/ca2236.md) | Чтобы устранить нарушение этого правила, вызовите метод базового типа GetObjectData или конструктор сериализации из соответствующего метода производного типа или конструктора. |
| CA2237 | [CA2237. Пометьте типы ISerializable атрибутом SerializableAttribute](../code-quality/ca2237.md) | Чтобы среда CLR распознавала тип как сериализуемый, он должен быть помечен атрибутом SerializableAttribute, даже если тип использует пользовательскую процедуру сериализации посредством реализации интерфейса ISerializable. |
| CA2238 |[CA2238. Правильно реализуйте методы сериализации](../code-quality/ca2238.md) | Метод, обрабатывающий событие сериализации, не имеет правильной сигнатуры, типа возвращаемого значения или отображения. |
| CA2239 | [CA2239. Обеспечьте наличие методов десериализации в необязательных полях](../code-quality/ca2239.md) | Тип имеет поле, помеченное атрибутом System.Runtime.Serialization.OptionalFieldAttribute, и не предоставляет методы обработки событий десериализации. |
| CA2240 | [CA2240. Правильно реализуйте ISerializable](../code-quality/ca2240.md) | Чтобы устранить нарушение данного правила, сделайте метод GetObjectData доступным для внешнего кода и переопределяемым и убедитесь, что все поля экземпляра включены в процесс сериализации или явно помечены атрибутом NonSerializedAttribute. |
| CA2241 | [CA2241. Задайте правильные аргументы для методов форматирования](../code-quality/ca2241.md) | Аргумент формата, переданный методу System.String.Format, не содержит элемент форматирования, соответствующий каждому аргументу объекта, или наоборот. |
| CA2242 |[CA2242. Правильно выполняйте проверку NaN](../code-quality/ca2242.md) | Это выражение проверяет значение на соответствие Single.Nan или Double.Nan. Используйте Single.IsNan(Single) или Double.IsNan(Double) для проверки значения. |
| CA2243 |[CA2243. Синтаксический разбор строковых литералов должен осуществляться правильно](../code-quality/ca2243.md) | Не удается правильно выполнить синтаксический анализ параметра строкового литерала атрибута для URL-адреса, идентификатора GUID или версии. |
| CA2244 | [CA2244: не повторяйте инициализацию индексируемых элементов](../code-quality/ca2244.md) | Инициализатор объекта имеет более одного инициализатора индексированных элементов с одинаковым индексом константы. Все, кроме последнего инициализатора, являются избыточными. |
| CA2245 | [CA2245: не назначайте свойство самому себе](../code-quality/ca2245.md) | Свойство было случайно назначено самому себе. |
| CA2246 | [CA2246: не присваивайте значения символу и его элементу в одном операторе](../code-quality/ca2246.md) | Не рекомендуется назначать символ и его член, то есть поле или свойство в одной и той же инструкции. Неясно, если доступ к члену был предназначен для использования старого значения символа до присваивания или нового значения из назначения в этой инструкции. |
| CA2247 | [CA2247: аргумент, переданный в конструктор TaskCompletionSource, должен быть TaskCreationOptions enum вместо TaskContinuationOptions Enum.](../code-quality/ca2247.md) | TaskCompletionSource имеет конструкторы, принимающие TaskCreationOptions, которые управляют базовой задачей, и конструкторы, которые принимают состояние объекта, сохраненное в задаче.  Случайная передача TaskContinuationOptions вместо TaskCreationOptions приведет к тому, что в вызове будут рассматриваться параметры как состояние. |
| CA2249 | [CA2249: CA2249: рекомендуется использовать String. Contains вместо String. IndexOf](../code-quality/ca2249.md) | Вызовы, `string.IndexOf` где результат используется для проверки наличия и отсутствия подстроки, можно заменить на `string.Contains` . |
| CA5122 | [Объявления CA5122 P/Invoke не должны быть безопасными](../code-quality/ca5122.md) | Методы отмечаются как SecuritySafeCritical, если они выполняют критически важные для безопасности операции и являются безопасными для использования в прозрачном коде. Прозрачный код может никогда не вызывать машинный код напрямую с помощью P/Invoke. Поэтому, если метод P/Invoke отметить как надежный с точки зрения безопасности, это не приведет к тому, что прозрачный код будет вызывать его, и может ввести в заблуждение при анализе безопасности. |
| CA5359 | [CA5359 не отключают проверку сертификата](../code-quality/ca5359.md) | Сертификат может помочь при проверке подлинности удостоверения сервера. Клиенты должны проверить сертификат сервера, чтобы обеспечить отправку запросов на предполагаемый сервер. Если ServerCertificateValidationCallback всегда возвращает значение `true` , любой сертификат будет проходить проверку. |
| CA5360 | [CA5360 не вызывают опасные методы при десериализации](../code-quality/ca5360.md) | Небезопасная десериализация — это уязвимость, которая возникает, когда ненадежные данные используются для нарушения логики приложения, наноситься атаки типа "отказ в обслуживании" или даже для выполнения произвольного кода после десериализации. Пользователям-злоумышленникам часто могут быть нарушены эти функции десериализации, когда приложение десериализует ненадежные данные, которые находятся под их контролем. В частности, следует вызывать опасные методы в процессе десериализации. Успешная атака небезопасной десериализации может позволить злоумышленнику выполнять атаки, такие как атаки DoS, обход проверки подлинности и удаленный запуск программного кода. |
| CA5362 | [CA5362 возможных циклических ссылок в графе десериализованных объектов](../code-quality/ca5362.md) | При десериализации ненадежных данных любой код, обрабатывающий десериализованный граф объекта, должен обрабатывать циклы ссылок без перехода в бесконечные циклы. Это включает в себя код, который является частью обратного вызова десериализации, и код, обрабатывающий граф объекта после завершения десериализации. В противном случае злоумышленник может выполнить атаку типа "отказ в обслуживании" с вредоносными данными, содержащими цикл ссылок. |
| CA5365 | [CA5365 не отключают проверку заголовка HTTP](../code-quality/ca5365.md) | Проверка HTTP-заголовка позволяет кодировать символы возврата каретки и новой строки, \r и \n, которые находятся в заголовках ответа. Эта кодировка позволяет избежать атак путем внедрения, которые используют приложение, которое выводит недоверенные данные, содержащиеся в заголовке. |
| CA5366 | [CA5366. Использование XmlReader для чтения XML-данных](../code-quality/ca5366.md) | При использовании <xref:System.Data.DataSet> для чтения XML с ненадежными данными могут загружаться опасные внешние ссылки, которые должны быть ограничены с помощью <xref:System.Xml.XmlReader> защищенного распознавателя или с отключенной обработкой DTD. |
| CA5367 | [CA5367 не сериализуются типы с полями указателя](../code-quality/ca5367.md) | Это правило проверяет, существует ли сериализуемый класс с полем указателя или свойством. Элементы, которые не могут быть сериализованы, могут быть указателями, такими как статические члены или поля, помеченные атрибутом <xref:System.NonSerializedAttribute> . |
| CA5368 | [CA5368 Set ViewStateUserKey для классов, производных от страницы](../code-quality/ca5368.md) | Задание <xref:System.Web.UI.Page.ViewStateUserKey> свойства может помочь предотвратить атаки на приложение, позволяя назначить идентификатор переменной состояния представления для отдельных пользователей, чтобы злоумышленники не могли использовать эту переменную для создания атаки. В противном случае будут обнаружены уязвимости подделки запросов между сайтами. |
| CA5374 | [CA5374 не используют XslTransform](../code-quality/ca5374.md) | Это правило проверяет <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> , создан ли экземпляр в коде. <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> теперь является устаревшим и не должен использоваться. |
| CA5375 | [CA5375 не использовать подпись общего доступа учетной записи](../code-quality/ca5375.md) | SAS учетной записи может делегировать доступ к операциям чтения, записи и удаления в контейнерах больших двоичных объектов, таблицах, очередях и общих файловых ресурсах, которые не разрешены с помощью SAS службы. Однако он не поддерживает политики уровня контейнера и обладает меньшей гибкостью и контролирует предоставляемые разрешения. После получения вредоносных пользователей ваша учетная запись хранения будет легко скомпрометирована. |
| CA5376 | [CA5376 использовать Шаредакцесспротокол Хттпсонли](../code-quality/ca5376.md) | SAS — это конфиденциальные данные, которые нельзя переносить в виде обычного текста по протоколу HTTP. |
| CA5377 | [CA5377 использовать политику доступа на уровне контейнера](../code-quality/ca5377.md) | Политику доступа на уровне контейнера можно изменить или отозвать в любое время. Он обеспечивает большую гибкость и контроль над предоставляемыми разрешениями. |
| CA5379 | [CA5379 не используют алгоритм функции наследования слабых ключей](../code-quality/ca5379.md) | <xref:System.Security.Cryptography.Rfc2898DeriveBytes>Класс по умолчанию использует <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> алгоритм. Необходимо указать хэш-алгоритм для использования в некоторых перегрузках конструктора с <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> или выше. Обратите внимание, что <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> свойство имеет только `get` метод доступа и не имеет `overriden` модификатора. |
| CA5382 | [CA5382 использовать безопасные файлы cookie в ASP.NET Core](../code-quality/ca5382.md) | Приложения, доступные по протоколу HTTPS, должны использовать безопасные файлы cookie, которые указывают браузеру, что файл cookie следует передавать только с помощью SSL (SSL). |
| CA5383 | [CA5383 Обеспечьте использование защищенных файлов cookie в ASP.NET Core](../code-quality/ca5383.md) | Приложения, доступные по протоколу HTTPS, должны использовать безопасные файлы cookie, которые указывают браузеру, что файл cookie следует передавать только с помощью SSL (SSL). |
| CA5384 | [CA5384 не используют алгоритм цифровых подписей (DSA)](../code-quality/ca5384.md) | DSA — это алгоритм слабого асимметричного шифрования. |
| CA5385 | [CA5385 использование алгоритма Ривест – Шамир – Адельман (RSA) с достаточным размером ключа](../code-quality/ca5385.md) | Ключ RSA, размер которого меньше 2048 бит, более уязвим для атак методом подбора. |
| CA5387 | [CA5387 не используют функцию формирования ключа с нестрогим наследованием с недостаточным числом итераций](../code-quality/ca5387.md) | Это правило проверяет, был ли криптографический ключ создан <xref:System.Security.Cryptography.Rfc2898DeriveBytes> с числом итераций менее 100 000. Более высокие числа итераций могут помочь в предотвращении атак из словарей, которые пытаются угадать созданный криптографический ключ. |
| CA5388 | [CA5388 обеспечивают достаточное число итераций при использовании функции формирования неслабых ключей](../code-quality/ca5388.md) | Это правило проверяет, был ли криптографический ключ создан <xref:System.Security.Cryptography.Rfc2898DeriveBytes> с числом итераций, которое может быть меньше 100 000. Более высокие числа итераций могут помочь в предотвращении атак из словарей, которые пытаются угадать созданный криптографический ключ. |
| CA5390 | [CA5390 не жестко кодировать ключ шифрования](../code-quality/ca5390.md) | Для успешного выполнения симметричного алгоритма секретный ключ должен быть известен только отправителю и получателю. Если ключ жестко закодирован, его легко обнаружить. Даже при использовании скомпилированных двоичных файлов пользователи-злоумышленники могут легко их извлечь. После компрометации закрытого ключа текст шифра может быть расшифрован напрямую и больше не защищен. |
| CA5391 | [CA5391 использование маркеров подделки в ASP.NET Core контроллерах MVC](../code-quality/ca5391.md) | Обработка `POST` запроса, `PUT` , `PATCH` или `DELETE` без проверки маркера подделки может быть уязвима для атак с подделкой межсайтовых запросов. Атака подделки межсайтовых запросов может отправить вредоносные запросы от пользователя, прошедшего проверку подлинности, на ASP.NET Core контроллер MVC. |
| CA5392 | [CA5392 использовать атрибут Дефаултдллимпортсеарчпасс для вызовов P/Invoke](../code-quality/ca5392.md) | По умолчанию функции P/Invoke используют <xref:System.Runtime.InteropServices.DllImportAttribute> пробу нескольких каталогов, включая текущий рабочий каталог для загрузки библиотеки. Это может быть проблемой безопасности для некоторых приложений, что приводит к захвату библиотек DLL. |
| CA5393 | [CA5393 не используют ненадежное значение Дллимпортсеарчпас](../code-quality/ca5393.md) | В каталогах поиска DLL по умолчанию и каталогах сборок может быть вредоносная библиотека DLL. Или, в зависимости от места запуска приложения, в каталоге приложения может быть вредоносная библиотека DLL. |
| CA5394 | [CA5394 не используют небезопасные случайные](../code-quality/ca5394.md) | Использование криптографического слабого генератора случайных чисел может позволить злоумышленнику предсказать, какое значение с учетом безопасности будет создано. |
| CA5395 | [Атрибут CA5395 промахов Хттпверб для методов действия](../code-quality/ca5395.md) | Все методы действий, которые создают, изменяют, удаляют или иным образом изменяют данные, должны быть защищены с помощью атрибута защиты от подделки запросов между сайтами. Операция GET должна быть защищенной операцией, которая не имеет побочных эффектов и не изменяет сохраненные данные. |
| CA5396 | [CA5396 задайте для параметра HttpOnly значение true для HttpCookie](../code-quality/ca5396.md) | В качестве меры глубокой защиты убедитесь, что файлы cookie HTTP с защитой безопасности помечены как HttpOnly. Это означает, что веб-браузеры не должны запрещать скриптам доступ к файлам cookie. Внедренные вредоносные сценарии — это распространенный способ кражи файлов cookie. |
| CA5399 | [CA5399 определенно отключить проверку списка отзыва сертификатов HttpClient](../code-quality/ca5399.md) | Отозванный сертификат больше не является доверенным. Она может использоваться злоумышленниками для передачи вредоносных данных или кражи конфиденциальных данных при взаимодействии по протоколу HTTPS. |
| CA5400 | [CA5400 убедитесь, что проверка списка отзыва сертификатов HttpClient не отключена.](../code-quality/ca5400.md) | Отозванный сертификат больше не является доверенным. Она может использоваться злоумышленниками для передачи вредоносных данных или кражи конфиденциальных данных при взаимодействии по протоколу HTTPS. |
| CA5401 | [CA5401 не используют Креатинкриптор с вектором инициализации, отличным от значения по умолчанию](../code-quality/ca5401.md) | Для предотвращения атак с использованием словаря симметричное шифрование всегда должно использовать неповторяемый вектор инициализации. |
| CA5402 | [CA5402 использовать Креатинкриптор с вектором инициализации по умолчанию](../code-quality/ca5402.md) | Для предотвращения атак с использованием словаря симметричное шифрование всегда должно использовать неповторяемый вектор инициализации. |
| IL3000 | [IL3000 избегать доступа к пути к файлу сборки при публикации в виде одного файла](../code-quality/il3000.md) | Избегайте использования пути к файлу сборки при публикации в виде одного файла |
| IL3001 | [IL3001 избегать доступа к пути к файлу сборки при публикации в виде одного файла](../code-quality/il3001.md) | Избегайте доступа к пути к файлу сборки при публикации в виде одного файла |
