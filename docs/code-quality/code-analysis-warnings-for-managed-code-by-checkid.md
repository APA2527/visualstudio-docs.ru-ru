---
title: Предупреждения при анализе управляемого кода по идентификатору CheckId
ms.date: 04/18/2019
ms.topic: reference
f1_keywords:
- CA1000
- CA1001
- CA1002
- CA1003
- CA1004
- CA1005
- CA1006
- CA1007
- CA1008
- CA1009
- CA1010
- CA1011
- CA1012
- CS1013
- CS1014
- CA1016
- CA1017
- CA1018
- CA1019
- CA1020
- CA1021
- CA1022
- CA1023
- CA1024
- CS1025
- CA1026
- CA1027
- CA1028
- CA1029
- CA1030
- CA1031
- CA1032
- CA1033
- CA1034
- CA1035
- CA1036
- CA1037
- CA1038
- CA1039
- CA1040
- CA1041
- CA1042
- CA1043
- CA1044
- CA1045
- CA1046
- CA1047
- CA1048
- CA1049
- CA1050
- CA1051
- CA1052
- CA1053
- CA1054
- CA1055
- CA1056
- CA1057
- CA1058
- CA1059
- CA1060
- CA1061
- CA1062
- CA1063
- CA1064
- CA1065
- CA1068
- CA1200
- CA1300
- CA1301
- CA1302
- CA1303
- CA1304
- CA1305
- CA1306
- CA1307
- CA1308
- CA1309
- CA1400
- CA1401
- CA1402
- CA1403
- CA1404
- CA1405
- CA1406
- CA1407
- CA1408
- CA1409
- CA1410
- CA1411
- CA1412
- CA1413
- CA1414
- CA1415
- CA1500
- CA1501
- CA1502
- CA1503
- CA1504
- CA1505
- CA1506
- CA1507
- CA1600
- CA1601
- CA1700
- CA1701
- CA1702
- CA1703
- CA1704
- CA1707
- CA1708
- CA1709
- CA1710
- CA1711
- CA1712
- CA1713
- CA1714
- CA1715
- VA1716
- CA1717
- CA1719
- CA1720
- CA1721
- CA1722
- CA1723
- CA1724
- CA1725
- CA1726
- CA1727
- CA1728
- CA1729
- CA1730
- CA1800
- CA1801
- CA1802
- CA1803
- CA1804
- CA1806
- CA1809
- CA1810
- CA1811
- CA1812
- CA1813
- CA1814
- CA1815
- CA1816
- CA1819
- CA1820
- CA1821
- CA1822
- CA1823
- CA1824
- CA1825
- CA1900
- CA1901
- CA1903
- CA2000
- CA2001
- CA2002
- CA2003
- CA2004
- CA2006
- CA2007
- CA2100
- CA2101
- CA2102
- CA2103
- CA2104
- CA2105
- CA2106
- CA2107
- CA2108
- CA2109
- CA2110
- CA2111
- CA2112
- CA2114
- CA2115
- CA2116
- CA2117
- CA2118
- CA2119
- CA2120
- CA2121
- CA2122
- CA2123
- CA2124
- CA2126
- CA2127
- CA2128
- CA2129
- CA2130
- CA2131
- CA2132
- CA2133
- CA2134
- CA2135
- CA2136
- CA2137
- CA2138
- CA2139
- CA2140
- CA2141
- CA2142
- CA2143
- CA2144
- CA2145
- CA2146
- CA2147
- CA2148
- CA2149
- CA2150
- CA2151
- CA2200
- CA2201
- CA2202
- CA2204
- CA2205
- CA2207
- CA2208
- CA2210
- CA2211
- CA2212
- CA2213
- CA2214
- CA2215
- CA2216
- CA2217
- CA2218
- CA2219
- CA2220
- CA2221
- CA2222
- CA2223
- CA2224
- CA2225
- CA2226
- CA2228
- CA2229
- CA2227
- CA2230
- CA2231
- CA2232
- CA2233
- CA2234
- CA2235
- CA2236
- CA2237
- CA2238
- CA2239
- CA2240
- CA2241
- CA2242
- CA2243
- CA5122
ms.assetid: 5cb221f6-dc59-4abf-9bfa-adbd6f907f96
author: gewarren
ms.author: gewarren
manager: jillfra
ms.workload:
- dotnet
ms.openlocfilehash: 6ac6fccb69770c003f21875e5ab3809c2d6415b4
ms.sourcegitcommit: 034c503ae04e22cf840ccb9770bffd012e40fb2d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/14/2019
ms.locfileid: "72305876"
---
# <a name="code-analysis-warnings-for-managed-code-by-checkid"></a>Предупреждения анализа кода для управляемого кода по идентификатору CheckId

В следующей таблице перечислены предупреждения анализа управляемого кода по идентификатору CheckId предупреждения.

| CheckId | Предупреждение | Описание |
|---------| - | - |
| CA1000 | @NO__T 0CA1000: Не объявляйте статические члены в универсальных типах @ no__t-0 | При вызове статического элемента универсального типа нужно указать аргумент этого типа. При вызове универсального экземпляра элемента, не поддерживающего вывод типа, для элемента нужно указать аргумент типа. В этих двух случаях синтаксис для определения аргумента типа различен, и его можно легко спутать. |
| CA1001 | [CA1001: типы, которым принадлежат освобождаемые поля, должны быть освобождаемыми](../code-quality/ca1001-types-that-own-disposable-fields-should-be-disposable.md) | В классе объявляется и реализуется поле экземпляра, которое принадлежит типу System.IDisposable, однако класс не реализует интерфейс IDisposable. Класс, в котором объявляется поле IDisposable, неявно владеет неуправляемым ресурсом и должен реализовывать интерфейс IDisposable. |
| CA1002 | @NO__T 0CA1002: Не предоставляйте универсальные списки @ no__t-0 | System.Collections.Generic.List < (из \<(T >) >) — это универсальная коллекция, которая предназначена для обеспечения производительности, а не для наследования. Поэтому виртуальные элементы в списке отсутствуют. Вместо этого для наследования следует предоставить универсальную коллекцию. |
| CA1003 | @NO__T 0CA1003: Использовать экземпляры обработчика универсальных событий @ no__t-0 |Тип содержит делегат, возвращающий значение void, сигнатура которого содержит два параметра (первый объект, а второй — тип, который может быть назначен EventArgs), а включающая сборка предназначена для Microsoft .NET Framework 2.0. |
| CA1004 | @NO__T 0CA1004: Универсальные методы должны предоставлять параметр типа @ no__t-0 | Вывод – это то, как аргумент типа универсального метода определяется по типу аргумента, переданного методу, а не по явному указанию аргумента типа. Чтобы задействовать вывод, сигнатура параметра универсального метода должна включать параметр, тип которого совпадает с параметром типа для метода. В этом случае аргумент типа указывать не обязательно. При использовании вывода для всех параметров типа синтаксис вызова универсальных и неуниверсальных методов экземпляра является одинаковым; он повышает удобство использования универсальных методов. |
| CA1005 | @NO__T 0CA1005: Избегайте чрезмерно излишних параметров в универсальных типах @ no__t-0 | Чем больше параметров типов содержит универсальный тип, тем сложнее знать и запоминать, что представляет каждый параметр типа. Обычно ситуация очевидна при использовании одного параметра типа, как и в списке\<T > и в ряде случаев при двух параметрах типов, как в Dictionary\<TKey, TValue >. Если же используется более двух параметров типов, многие пользователи начинают испытывать большие трудности. |
| CA1006 | @NO__T 0CA1006: Не вкладывать универсальные типы в сигнатуры членов @ no__t-0 | Аргумент вложенного типа также является аргументом универсального типа. Чтобы вызвать член, сигнатура которого содержит аргумент вложенного типа, пользователь должен создать экземпляр одного универсального типа и передать этот тип конструктору второго универсального типа. Это приводит к усложнению процедуры и синтаксиса, чего следует избегать. |
| CA1007 |@NO__T 0CA1007: Используйте универсальные шаблоны, где подходит @ no__t-0 | Видимый извне метод содержит ссылочный параметр типа System.Object. Использование универсального метода позволяет передавать в метод все типы без предварительного приведения к типу ссылочного параметра при условии выполнения некоторых ограничений. |
| CA1008 | @NO__T 0CA1008: Перечисляемые типы должны иметь нулевое значение @ no__t-0 | Значение по умолчанию неинициализированного перечисления, как и других типов значений, равно нулю. Перечисление без флагов в качестве атрибутов должно определять член с использованием нулевого значения так, чтобы значение по умолчанию было допустимым значением перечисления. Если перечисление с примененным атрибутом FlagsAttribute определяет член с нулевым значением, для него должно быть задано имя None, свидетельствующее о том, что в перечислении не были заданы значения. |
| CA1009 | @NO__T 0CA1009: Правильно объявляйте обработчики событий @ no__t-0 | Методы обработчиков событий принимают два параметра. Первый параметр принадлежит типу System.Object и называется "sender". Это объект, вызвавший событие. Второй параметр принадлежит типу System.EventArgs и называется "e". Это данные, связанные с событием. Методы обработки событий не должны возвращать значение; в языке программирования C# оно обозначается возвращаемым типом void. |
| CA1010 | @NO__T 0CA1010: Коллекции должны реализовывать универсальный интерфейс @ no__t-0 | Чтобы расширить возможности использования коллекции, реализуйте один из универсальных интерфейсов коллекции. Затем данную коллекцию можно использовать для заполнения универсальных типов коллекции. |
| CA1011 |@NO__T 0CA1011: Рассмотрите возможность передачи базовых типов в качестве параметров @ no__t-0 | Если в объявлении метода в качестве параметра указан базовый тип, любой тип, производный от базового, можно передать методу в качестве соответствующего аргумента. Если дополнительные функции, предоставляемые производным типом параметра, не требуются, то использование базового типа позволит более широко применять данный метод. |
| CA1012 | @NO__T 0CA1012: Абстрактные типы не должны иметь конструкторы @ no__t-0 | Конструкторы абстрактных типов могут быть вызваны только производными типами. Открытые конструкторы создают экземпляры типа. Невозможно создавать экземпляры абстрактного типа; абстрактный тип с открытым конструктором является недопустимым. |
| CA1013 | @NO__T 0CA1013: Перегруженный оператор равен при перегрузке Add и Subtract @ no__t-0 | Открытый или защищенный тип реализует операторы сложения или вычитания без реализации оператора равенства. |
| CA1014 | @NO__T 0CA1014: Пометить сборки с помощью CLSCompliantAttribute @ no__t-0 | Спецификация среды CLS определяет ограничения по именованию, типам данных и правилам, которым должны соответствовать сборки, предназначенные для использования в нескольких языках программирования. Для всех сборок рекомендуется явным образом указывать совместимость с CLS с помощью атрибута <xref:System.CLSCompliantAttribute>. Если этот атрибут у сборки отсутствует, сборка несовместима. |
| CA1016 | @NO__T 0CA1016: Пометить сборки с помощью AssemblyVersionAttribute @ no__t-0 | .NET использует номер версии для уникальной идентификации сборки и привязки к типам в сборках со строгими именами. Номер версии используется наряду с политикой версий и издателя. По умолчанию приложения выполняются только с версией сборки, которая использовалась для их построения. |
| CA1017 | @NO__T 0CA1017: Пометить сборки с помощью ComVisibleAttribute @ no__t-0 |Атрибут ComVisibleAttribute определяет порядок обращения клиентов COM к управляемому коду. Для правильной разработки сборки должны явным образом указывать видимость COM. Можно задать видимость COM для всей сборки, а затем переопределить ее для отдельных типов и элементов типов. Если атрибут отсутствует, содержимое сборки будет видимым клиентам COM. |
| CA1018 | @NO__T 0CA1018: Пометка атрибутов с помощью AttributeUsageAttribute @ no__t-0 | При определении настраиваемого атрибута его нужно пометить атрибутом AttributeUsageAttribute, чтобы указать, где можно применять этот настраиваемый атрибут в исходном коде. Допустимое положение атрибута в коде зависит от значения атрибута и его применения. |
| CA1019 | @NO__T 0CA1019: Определение методов доступа для аргументов атрибутов @ no__t-0 | Атрибуты могут определять обязательные аргументы, которые должны быть указаны при применении атрибута к целевому объекту. Они также известны как позиционные аргументы, поскольку предоставляются для конструкторов атрибутов в качестве позиционных параметров. Для каждого обязательного аргумента атрибут должен предоставлять соответствующее свойство, доступное только для чтения, чтобы извлечь значение аргумента во время выполнения. Кроме того, атрибуты могут определять дополнительные параметры, известные как именованные аргументы. Эти аргументы предоставляются для конструкторов атрибутов по имени и должны иметь соответствующее свойство чтения/записи. |
| CA1020 | @NO__T 0CA1020: Избегайте пространств имен с несколькими типами @ no__t-0 | Убедитесь, что каждое из используемых пространств имен имеет логическую организацию и существует веская причина для помещения типов в сильно разреженное пространство имен. |
| CA1021 | @NO__T 0CA1021: Избегайте вывода параметров @ no__t-0 | Для реализации передачи типов по ссылке (с помощью ключевого слова out или ref) от разработчика требуется опыт работы с указателями, понимание отличия между типами значения и ссылочными типами и умение работать с методами с несколькими возвращаемыми значениями. Кроме того, далеко не все понимают разницу между параметрами out и ref. |
| CA1023 | @NO__T 0CA1023: Индексаторы не должны быть многомерными @ no__t-0 | Для индексаторов (индексированных свойств) должен использоваться один индекс. Многомерные индексаторы могут крайне отрицательно сказаться на удобстве работы с библиотекой. |
| CA1024 | @NO__T 0CA1024: Используйте свойства, если это уместно @ no__t-0 | Имя открытого или защищенного метода начинается с Get, он не принимает параметры и возвращает значение, не являющееся массивом. Возможно, этот метод лучше преобразовать в свойство. |
| CA1025 | @NO__T 0CA1025: Замените повторяющиеся аргументы массивом params @ no__t-0 | Если точное число аргументов неизвестно и эти аргументы принадлежат одному типу или могут быть переданы как аргументы одного типа, используйте вместо повторяющихся аргументов массив параметров. |
| CA1026 | @NO__T 0CA1026: Не следует использовать параметры по умолчанию @ no__t-0 | Методы, использующие параметры по умолчанию, разрешены по спецификации CLS; однако спецификация CLS разрешает компиляторам не учитывать значения, присвоенные этим параметрам. Для однородной работы с различными языками программирования следует заменять методы, использующие параметры по умолчанию, на перегрузки методов, предоставляющие параметры по умолчанию. |
| CA1027 |@NO__T 0CA1027: Пометьте перечисления атрибутом FlagsAttribute @ no__t-0 | Перечисление является типом значения, которое определяет набор связанных именованных констант. Атрибут FlagsAttribute применяется к перечислению, когда его именованные константы могут быть объединены осмысленным образом. |
| CA1028 | @NO__T 0CA1028: Хранилище перечислений должно иметь тип Int32 @ no__t-0 | Перечисление является типом значения, которое определяет набор связанных именованных констант. По умолчанию для хранения значения константы используется тип данных System.Int32. Этот базовый тип можно изменить, но это не требуется и в большинстве случаев не рекомендуется. |
| CA1030 | @NO__T 0CA1030: Используйте события, если соответствующие @ no__t-0 |Данное правило отслеживает методы с именами, которые, как правило, используются для событий. Если метод вызывается в ответ на четко определенное изменение состояния, то этот вызов должен осуществляться с помощью обработчика событий. Объекты, вызывающие методы, должны создавать события, а не вызывать методы напрямую. |
| CA1031 | @NO__T 0CA1031: Не перехватывайте общие типы исключений @ no__t-0 | Общие исключения не должны перехватываться. Нужно перехватить исключение более конкретного характера или повторно выдать общее исключение в последнем операторе блока catch. |
| CA1032 |@NO__T 0CA1032: Реализуйте стандартные конструкторы исключений @ no__t-0 | Для правильной обработки исключений необходимо предоставить полный набор конструкторов. |
| CA1033 | @NO__T 0CA1033: Методы интерфейса должны вызываться дочерними типами @ no__t-0 | Незапечатанный тип, доступный для внешнего кода, предоставляет явную реализацию метода открытого интерфейса и не предоставляет доступный для внешнего кода альтернативный метод с тем же именем. |
| CA1034 | @NO__T 0CA1034: Вложенные типы не должны быть видимыми @ no__t-0 | Вложенный тип — это тип, объявленный внутри области другого типа. Вложенные типы удобно использовать для инкапсуляции закрытых сведений о реализациях содержащего их типа. В силу этого вложенные типы не должны быть видимыми для внешнего кода. |
| CA1035 | @NO__T 0CA1035: Реализации ICollection имеют строго типизированные члены @ no__t-0 | Это правило требует, чтобы реализации ICollection предоставляли строго типизированные элементы, поскольку тогда пользователям не придется приводить аргументы к типу Object при использовании функциональных возможностей интерфейса. В этом правиле предполагается, что тип, реализующий интерфейс ICollection, делает это для управления коллекцией экземпляров типа, более строгого, чем Object. |
| CA1036 | @NO__T 0CA1036: Переопределяйте методы в сопоставимых типах @ no__t-0 |Открытый или защищенный тип реализует интерфейс System.IComparable. Он не переопределяет метод Object.Equals и не перегружает языковой оператор равенства, неравенства, "больше" или "меньше". |
| CA1038 | @NO__T 0CA1038: Перечислители должны быть строго типизированы @ no__t-0 | Это правило требует, чтобы реализации IEnumerator предоставляли строго типизированную версию свойства Current, поскольку тогда пользователям не придется приводить возвращаемое значение к строгому типу при использовании функциональных возможностей интерфейса. |
| CA1039 | @NO__T 0CA1039: Списки строго типизированы @ no__t-0 | Это правило требует, чтобы реализации IList предоставляли строго типизированные элементы, поскольку тогда пользователям не придется приводить аргументы к типу System.Object при использовании функциональных возможностей интерфейса. |
| CA1040 |@NO__T 0CA1040: Избегайте пустых интерфейсов @ no__t-0 | Интерфейсы определяют члены, предоставляющие поведение или соглашение об использовании. Функциональность, описанная интерфейсом, может быть использована любым типом вне зависимости от расположения типа в иерархии интерфейса. Тип реализует интерфейс путем предоставления реализаций для членов интерфейса. Пустой интерфейс не определяет никаких элементов, поэтому он не определяет контракт, который можно реализовать. |
| CA1041 | @NO__T 0CA1041: Укажите ObsoleteAttribute Message @ no__t-0 | Тип или элемент помечен атрибутом System.ObsoleteAttribute, для которого не указано свойство ObsoleteAttribute.Message. При компиляции типа или элемента, помеченного атрибутом ObsoleteAttribute, отображается текст свойства Message этого атрибута. Это предоставляет пользователю сведения об устаревшем типе или члене. |
| CA1043 | @NO__T 0CA1043: Использование целочисленного или строкового аргумента для индексаторов @ no__t-0 | Индексаторы (индексированные свойства) должны использовать для индекса целочисленные или строковые типы. Эти типы обычно используются для индексации структур данных и повышения удобства использования библиотеки. Тип Object следует использовать только в том случае, если во время разработки невозможно указать определенный целочисленный или строковый тип. |
| CA1044 | @NO__T 0CA1044: Свойства не должны быть только Write @ no__t-0 | Несмотря на то, что допустимо, а часто и необходимо иметь свойство, доступное только на чтение, рекомендации по разработке запрещают использование свойств, доступных только на запись. Это связано с тем, что если позволить пользователю задать значение, а затем запретить ему просматривать это значение, то таким образом не будет обеспечиваться какая-либо безопасность. Кроме того, при отсутствии доступа на чтение нельзя просмотреть состояние общих объектов, что снижает их полезность. |
| CA1045 |@NO__T 0CA1045: Не передавайте типы по ссылке @ no__t-0 | Для реализации передачи типов по ссылке (с помощью ключевого слова out или ref) от разработчика требуется опыт работы с указателями, понимание отличия между типами значения и ссылочными типами и умение работать с методами с несколькими возвращаемыми значениями. Архитекторы библиотек, которые разрабатывает общую аудиторию, не должны ждать, чтобы пользователи работали с параметрами `out` или `ref`. |
| CA1046 | @NO__T 0CA1046: Не перегружать оператор Equals в ссылочных типах @ no__t-0 | Реализация оператора равенства по умолчанию почти всегда правильно работает для ссылочных типов. По умолчанию две ссылки равны, если они указывают на один объект. |
| CA1047 |@NO__T 0CA1047: Не объявляйте защищенные члены в запечатанных типах @ no__t-0 | Типы объявляют защищенный члены таким образом, чтобы наследующие типы могли получить доступ к члену или переопределить его. По определению наследовать запечатанные типы нельзя; это означает, что вызов защищенных методов для запечатанных типов невозможен. |
| CA1048 | @NO__T 0CA1048: Не объявляйте виртуальные элементы в запечатанных типах @ no__t-0 | Типы объявляют методы как виртуальные, чтобы наследующие типы могли переопределять реализацию виртуального метода. По определению наследовать запечатанный тип нельзя. При этом виртуальный метод запечатанного типа теряет смысл. |
| CA1049 | @NO__T 0CA1049: Типы, владеющие собственными ресурсами, должны быть уничтожены @ no__t-0 | Типы, выделяющие неуправляемые ресурсы, должны реализовывать интерфейс IDisposable, чтобы вызывающие методы могли высвобождать эти ресурсы по требованию и сокращать время существования объектов, занимающих ресурсы. |
| CA1050 | @NO__T 0CA1050: Объявите типы в пространствах имен @ no__t-0 | Типы объявляются в пространствах имен во избежание конфликтов имен и с целью упорядочения связанных типов в иерархии объектов. |
| CA1051 | @NO__T 0CA1051: Не объявляйте видимые поля экземпляра @ no__t-0 | Поля главным образом следует использовать для данных реализации. Поля должны быть помечены как private или internal и должны быть представлены с помощью свойств. |
| CA1052 | @NO__T 0CA1052: Типы со статическими заполнителями должны быть запечатаны @ no__t-0 | Открытый или защищенный тип содержит только статические элементы и не объявлен с модификатором sealed (справочник по C#) (NotInheritable). Тип, для которого нельзя создавать унаследованные типы, должен быть помечен модификатором sealed, чтобы его нельзя было использовать как базовый тип. |
| CA1053 |@NO__T 0CA1053: Типы статических владельцев не должны иметь конструкторы @ no__t-0 | В открытом или вложенном открытом типе объявляются только статические элементы и имеется открытый или защищенный конструктор по умолчанию. Конструктор не нужен, поскольку при вызове статических членов не требуется экземпляр типа. Для обеспечения безопасности перегруженная строка должна вызывать перегрузку универсального кода ресурса (URI), используя строковый аргумент. |
| CA1054 | @NO__T 0CA1054: Параметры URI не должны быть строками @ no__t-0 | Если метод принимает строковое представление универсального кода ресурса (URI), необходимо предоставить соответствующую перегрузку, принимающую экземпляр класса URI, который предоставляет эти услуги безопасным образом. |
| CA1055 | @NO__T 0CA1055: Возвращаемые значения URI не должны быть строками @ no__t-0 | В этом правиле предполагается, что метод возвращает универсальный код ресурса (URI). В строковых представлениях кода URI часто встречаются ошибки синтаксического анализа и кодирования, которые могут привести к уязвимостям системы безопасности. Класс System.Uri предоставляет аналогичные услуги более надежным и безопасным способом. |
| CA1056 | @NO__T 0CA1056: Свойства URI не должны быть строками @ no__t-0 | В этом правиле предполагается, что свойство является универсальным кодом ресурса (URI). В строковых представлениях кода URI часто встречаются ошибки синтаксического анализа и кодирования, которые могут привести к уязвимостям системы безопасности. Класс System.Uri предоставляет аналогичные услуги более надежным и безопасным способом. |
| CA1057 | @NO__T 0CA1057: Перегрузки строковых URI вызывают перегрузки System. URI @ no__t-0 | Тип объявляет перегрузки метода, которые отличаются только заменой строкового параметра на параметр System.Uri. Эта перегрузка, которая принимает строковый параметр, не вызывает перегрузку, которая принимает параметр URI. |
| CA1058 | @NO__T 0CA1058: Типы не должны расширять определенные базовые типы](../code-quality/ca1058-types-should-not-extend-certain-base-types.md) | Видимый извне тип расширяет некоторые базовые типы. Используйте только один вариант. |
| CA1059 |@NO__T 0CA1059: Члены не должны предоставлять определенные конкретные типы @ no__t-0 | Устойчивый тип – это тип, который имеет полную реализацию и экземпляр которого можно создать. Чтобы иметь возможность широкого использования этого элемента, замените конкретный тип предложенным интерфейсом. |
| CA1060 | @NO__T 0CA1060: Перемещение P/Invoke в класс NativeMethods @ no__t-0 | Методы PInvoke, например методы, помеченные атрибутом System.Runtime.InteropServices.DllImportAttribute, или методы, определенные с помощью ключевого слова Declare в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)], обращаются к неуправляемому коду. Эти методы должны относиться к классу NativeMethods, SafeNativeMethods или UnsafeNativeMethods. |
| CA1061 |@NO__T 0CA1061: Не скрывать методы базового класса @ no__t-0 | Метод в базовом типе скрыт методом с таким же именем в производном типе. Сигнатура параметра производного метода отличается только типами, которые являются более слабыми, чем соответствующие типы в сигнатуре параметра базового метода. |
| CA1062 | @NO__T 0CA1062: Проверка аргументов открытых методов @ no__t-0 | Все ссылочные аргументы, передаваемые в видимые для внешнего кода методы, должны проверяться на равенство значению NULL. |
| CA1063 | @NO__T 0CA1063: Правильно реализуйте IDisposable @ no__t-0 | Все типы IDisposable должны правильно реализовывать шаблон "Dispose". |
| CA1064 | @NO__T 0CA1064: Исключения должны быть открытыми @ no__t-0 | Внутреннее исключение видно только внутри своей внутренней области. После выхода исключения за пределы внутренней области для перехвата исключения можно использовать только базовое исключение. Если внутренне исключение унаследовано от <xref:System.Exception>, <xref:System.SystemException>, или <xref:System.ApplicationException>, внешний код не будет иметь достаточно сведений, чтобы знать, что делать с исключением. |
| CA1065 | @NO__T 0CA1065: Не вызывайте исключения в непредвиденных расположениях @ no__t-0 | Метод вызывает исключение, хотя не должен этого делать. |
| CA1068 | @NO__T 0CA1068: Параметры CancellationToken должны быть последними @ no__t-0 | Метод имеет параметр CancellationToken, который не является последним параметром. |
| CA1200 | @NO__T 0CA1200: Избегайте использования тегов cref с префиксом @ no__t-0 | Атрибут [cref](https://docs.microsoft.com/dotnet/csharp/programming-guide/xmldoc/cref-attribute) в ТЕГЕ документации XML означает "ссылка на код". Он указывает, что текст внутри тега представляет собой элемент кода, например тип, метод или свойство. Старайтесь не использовать теги `cref` с префиксами, так как это не позволяет компилятору проверять ссылки. Это также предотвращает Поиск и обновление этих ссылок на символы во время рефакторинга в интегрированной среде разработки (IDE) Visual Studio. |
| CA1300 | @NO__T 0CA1300: Укажите MessageBoxOptions @ no__t-0 | Чтобы окно сообщения для языков, в которых используется порядок чтения справа налево, отображалось правильно, методу Show следует передать члены RightAlign и RtlReading перечисления MessageBoxOptions. |
| CA1301 | @NO__T 0CA1301: Избегайте дублирования ускорителей @ no__t-0 | Клавиша доступа, также называемая клавишей быстрого доступа, обеспечивает клавиатурный доступ к элементу управления с помощью клавиши ALT. Если несколько элементов управления имеют одинаковые ключи доступа, поведение клавиши доступа определено нечетко. |
| CA1302 | @NO__T 0CA1302: Не жестко кодировать строки, специфичные для локали @ no__t-0 | Перечисление System.Environment.SpecialFolder содержит члены, ссылающиеся на специальные системные папки. Расположение этих папок может различаться в разных ОС, пользователь может менять расположение этих папок, их имена могут быть локализованы. Метод Environment.GetFolderPath возвращает связанные с перечислением Environment.SpecialFolder расположения в локализованной форме, подходящей для использования на работающем в данный момент компьютере. |
| CA1303 | @NO__T 0CA1303: Не передавайте литералы в качестве локализованных параметров @ no__t-0 | Метод, видимый извне, передает строковый литерал в качестве параметра в конструктор или метод .NET, и эта строка должна быть локализуемой. |
| CA1304 | @NO__T 0CA1304: Укажите CultureInfo @ no__t-0 | Метод или конструктор вызывает член, имеющий перегрузку, которая принимает параметр System.Globalization.CultureInfo, вместо того чтобы вызвать перегрузку, принимающую параметр CultureInfo. Если объект CultureInfo или System.IFormatProvider не предоставляется, значение по умолчанию, поставляемое перегруженным членом, может не оказать ожидаемого воздействия во всех языковых стандартах. |
| CA1305 | @NO__T 0CA1305: Указание IFormatProvider @ no__t-0 | Метод или конструктор вызывает один или несколько членов, имеющих перегрузки, которые принимают параметр System.IFormatProvider, вместо того чтобы вызвать перегрузку, принимающую параметр IFormatProvider. Если объект System.Globalization.CultureInfo или IFormatProvider не предоставляется, значение по умолчанию, поставляемое перегруженным членом, может не оказать ожидаемого воздействия во всех языковых стандартах. |
| CA1306 | @NO__T 0CA1306: Задать языковой стандарт для типов данных @ no__t-0 | Язык и региональные параметры определяют представление элементов данных, таких как формат чисел, обозначение денежных единиц и порядок сортировки. При создании объектов DataTable или DataSet следует явным образом указывать языковой стандарт. |
| CA1307 | @NO__T 0CA1307: Укажите StringComparison @ no__t-0 | В операции сравнения строк используется перегрузка метода, которая не задает параметр StringComparison. |
| CA1308 |@NO__T 0CA1308: Нормализация строк до верхнего регистра @ no__t-0 | Строки следует нормализовать в верхний регистр. Существует небольшая группа символов, которые после преобразования в нижний регистр не могут участвовать в круговом перемещении. |
| CA1309 | @NO__T 0CA1309: Использовать Ordinal StringComparison @ no__t-0 | Операция сравнения строк, не являющаяся лингвистической, не задает для параметра StringComparison ни значения Ordinal, ни значения OrdinalIgnoreCase. После явного задания для параметра значения StringComparison.Ordinal или StringComparison.OrdinalIgnoreCase код часто становится более надежным и правильным, кроме того, увеличивается скорость его выполнения. |
| CA1400 | @NO__T 0CA1400: Должны существовать точки входа P/Invoke @ no__t-0 |Открытый или защищенный метод, помеченный атрибутом System.Runtime.InteropServices.DllImportAttribute. Не удается найти неуправляемую библиотеку либо не удается сопоставить метод функции в библиотеке. |
| CA1401 | @NO__T 0CA1401: Методы P/Invoke не должны быть видимыми @ no__t-0 | Открытый или защищенный метод в открытом типе имеет атрибут System.Runtime.InteropServices.DllImportAttribute (также реализуется в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)] с помощью ключевого слова Declare). Такие методы не следует делать видимыми. |
| CA1402 |@NO__T 0CA1402: Избегайте перегрузок в видимых COM-интерфейсах @ no__t-0 | Когда перегруженные методы предоставляются клиентам COM, сохраняется имя только первой перегрузки метода. Последующие перегрузки переименовываются уникальным образом путем добавления к имени символа подчеркивания (_) и целого числа, соответствующего порядку объявления перегрузки. |
| CA1403 | @NO__T 0CA1403: Типы автоматического макета не должны быть видимыми для COM @ no__t-0 | Видимый для модели COM тип значения помечается атрибутом System.Runtime.InteropServices.StructLayoutAttribute, имеющим значение LayoutKind.Auto. Макет этих типов может изменяться в разных версиях .NET, что приведет к нарушению работы клиентов COM, которые предполагают наличие определенного макета. |
| CA1404 | @NO__T 0CA1404: Вызовите GetLastError сразу после P/Invoke @ no__t-0 | Выполняется вызов метода Marshal.GetLastWin32Error или эквивалентной [!INCLUDE[TLA2#tla_win32](../code-quality/includes/tla2sharptla_win32_md.md)] Функция GetLastError, а непосредственно предшествующий вызов не операционную систему вызов метода. |
| CA1405 | @NO__T 0CA1405: Базовые типы видимого COM-типа должны быть видимыми для COM @ no__t-0 | Тип, видимый для модели COM, наследует от типа, который не является видимым для COM. |
| CA1406 |@NO__T 0CA1406: Избегайте аргументов Int64 для Visual Basic 6 клиентов @ no__t-0 | Клиенты COM Visual Basic 6 не может получить доступ к 64-разрядных целых чисел. |
| CA1407 |@NO__T 0CA1407: Не используйте статические члены в видимых типах COM @ no__t-0 | Модель COM не поддерживает статические методы. |
| CA1408 | @NO__T 0CA1408: Не используйте двойное ClassInterfaceType @ no__t-0 | Типы, использующие сдвоенный интерфейс, позволяют клиентам выполнять привязку к определенному макету интерфейса. Все изменения в будущей версии макета типа и в базовых типах приведут к нарушению работы COM-клиентов, связанных с интерфейсом. По умолчанию, если атрибут ClassInterfaceAttribute не указан, используется только диспетчерский интерфейс. |
| CA1409 | @NO__T 0CA1409: Видимые типы COM должны быть создаваемыми @ no__t-0 |Ссылочный тип, который специально помечен как видимый для модели COM, содержит открытый параметризованный конструктор, но не содержит открытого конструктора по умолчанию (без параметров). COM-клиенты не могут создавать объекты типа, не содержащего открытый конструктор по умолчанию. |
| CA1410 | @NO__T 0CA1410: Методы регистрации COM должны быть сопоставлены с @ no__t-0 | Тип объявляет метод, помеченный атрибутом System.Runtime.InteropServices.ComRegisterFunctionAttribute, но не объявляет метод, помеченный атрибутом System.Runtime.InteropServices.ComUnregisterFunctionAttribute, или наоборот. |
| CA1411 | @NO__T 0CA1411: Методы регистрации COM не должны быть видимыми @ no__t-0 | Метод, помеченный атрибутом System.Runtime.InteropServices.ComRegisterFunctionAttribute или атрибутом System.Runtime.InteropServices.ComUnregisterFunctionAttribute, видим извне. |
| CA1412 | @NO__T 0CA1412: Пометьте интерфейсы пометьте comsource как IDispatch @ no__t-0 | Тип помечен атрибутом System.Runtime.InteropServices.ComSourceInterfacesAttribute, однако по крайней мере один из указанных интерфейсов не помечен атрибутом System.Runtime.InteropServices.InterfaceTypeAttribute, значение которого равно ComInterfaceType.InterfaceIsIDispatch. |
| CA1413 | @NO__T 0CA1413: Избегайте использования полей, не являющихся открытыми, в видимых типах значений COM @ no__t-0 | Не являющиеся общедоступными поля экземпляров типов значений, отображаемых для модели COM, отображаются для COM-клиентов. Проверьте содержимое полей на наличие сведений, к которым не должен предоставляться доступ или которые могут оказать непреднамеренное воздействие на разработку или безопасность. |
| CA1414 | @NO__T 0CA1414: Пометьте логические аргументы P/Invoke с помощью MarshalAs @ no__t-0 | Логический тип данных имеет несколько представлений в неуправляемом коде. |
| CA1415 | @NO__T 0CA1415: Корректное объявление P/Invoked @ no__t-0 | Это правило используется для поиска объявлений методов вызова операционной системы, предназначенных для функций [!INCLUDE[TLA2#tla_win32](../code-quality/includes/tla2sharptla_win32_md.md)], имеющих указатель на параметр структуры OVERLAPPED, если соответствующий управляемый параметр не является указателем на структуру System.Threading.NativeOverlapped. |
| CA1500 | @NO__T 0CA1500: Имена переменных не должны совпадать с именами полей @ no__t-0 | Метод экземпляра объявляет параметр или локальную переменную, чье имя совпадает с именем поля экземпляра объявляющего типа, что ведет к возникновению ошибок. |
| CA1501 | @NO__T 0CA1501: Избегайте чрезмерного наследования @ no__t-0 | Тип расположен глубже четырех уровней в иерархии наследования. Глубокие иерархии вложенных типов трудно отслеживать, понимать и поддерживать. |
| CA1502 | @NO__T 0CA1502: Избегайте чрезмерной сложности @ no__t-0 | Это правило измеряет число линейно независимых путей в методе, которое определяется числом и сложностью условных ветвей. |
| CA1504 | @NO__T 0CA1504: Проверить ошибочные имена полей @ no__t-0 | Имя поля экземпляра начинается с «s_» или имя статического (Shared в Visual Basic) поля начинается с «m_». |
| CA1505 | @NO__T 0CA1505: Избегайте неподдерживаемого кода @ no__t-0 | Тип или метод имеет низкий индекс обслуживаемости. Низкий индекс удобства поддержки означает, что тип или метод, вероятно, трудно поддерживать, поэтому их следует переработать. |
| CA1506 |@NO__T 0CA1506: Избегайте чрезмерного связывания классов @ no__t-0 | Данное правило измеряет взаимозависимость классов путем подсчета количества уникальных ссылок на типы, содержащихся в типе или методе. |
| CA1600 | @NO__T 0CA1600: Не использовать приоритет процесса простоя @ no__t-0 | Не задавайте для приоритета процесса значение Idle. Процессы с приоритетом System.Diagnostics.ProcessPriorityClass.Idle будут занимать ЦП, который иначе простаивал бы, и тем самым блокировать работу в режиме ожидания. |
| CA1601 | @NO__T 0CA1601: Не используйте таймеры, препятствующие изменениям состояния электропитания @ no__t-0 | Повышение частоты периодических действий приводит к дополнительной нагрузке на ЦП и препятствует работе таймеров энергосберегающих режимов, которые отключают монитор и жесткие диски. |
| CA1700 | @NO__T 0CA1700: Не назовите значения enum "reserved" ](../code-quality/ca1700-do-not-name-enum-values-reserved.md) | В данном правиле предполагается, что член перечисления, имя которого содержит слово "reserved", не используется в настоящее время, а является местозаполнителем, который будет в дальнейшем переименован или удален. Переименование или удаление элемента — это критическое изменение. |
| CA1701 | @NO__T 0CA1701: В составных словах строк ресурсов следует указывать правильный регистр @ no__t-0 | Каждое слово в строке ресурса разделяется на лексемы на основе регистра (заглавных букв). Каждое непрерывное сочетание двух токенов проверяется библиотекой проверки орфографии Майкрософт. При совпадении слово создает нарушение правила. |
| CA1702 | @NO__T 0CA1702: Составные слова должны иметь правильный регистр @ no__t-0 | Имя идентификатора состоит из нескольких слов, и по крайней мере одно из них является составным словом в неправильном регистре. |
| CA1703 | @NO__T 0CA1703: Строки ресурсов должны быть написаны правильно. @ no__t-0 | Строка ресурса содержит одно или несколько слов, не распознанных библиотекой системы проверки правописания Майкрософт. |
| CA1704 | @NO__T 0CA1704: Идентификаторы должны быть правильно написаны @ no__t-0 | Имя видимого для внешнего кода идентификатора содержит одно или несколько слов, не распознаваемых библиотекой средства проверки орфографии (Microsoft). |
| CA1707 | @NO__T 0CA1707: Идентификаторы не должны содержать знаки подчеркивания @ no__t-0 | В соответствии с соглашением имена идентификаторов не могут содержать знак подчеркивания (_). Это правило позволяет проверить пространства имен, типы, элементы и параметры. |
| CA1708 | @NO__T 0CA1708: Идентификаторы должны отличаться более чем регистром @ no__t-0 | Идентификаторы пространств имен, типов, членов и параметров не могут отличаться только регистром знаков, поскольку языки программирования, поддерживаемые средой CLR, не обязательно учитывают регистр знаков. |
| CA1709 | @NO__T 0CA1709: Идентификаторы должны иметь правильный регистр @ no__t-0 | В соответствии с соглашением, в именах параметров используется смешанный регистр знаков, а в именах пространств имен, типов и членов — стиль языка Pascal. |
| CA1710 | @NO__T 0CA1710: Идентификаторы должны иметь правильные суффиксы @ no__t-0 |По правилам имена типов, расширяющих определенные базовые типы или реализующих определенные интерфейсы, а также типов, являющихся производными от первых, имеют суффикс, связанный с базовым типом или интерфейсом. |
| CA1711 | @NO__T 0CA1711: Идентификаторы не должны иметь неверные суффиксы @ no__t-0 | В соответствии с соглашением об именовании, определенные зарезервированные суффиксы должны добавляться только к именам типов, которые расширяют некоторые базовые типы или реализуют определенные интерфейсы, а также производных от них типов. В именах других типов зарезервированные суффиксы использоваться не должны. |
| CA1712 | @NO__T 0CA1712: Не добавляйте значения перечисления с именем типа @ no__t-0 | Имена членов перечисления не должны содержать префиксов в виде имени типа, поскольку предполагается, что сведения о типе предоставляются средствами разработки. |
| CA1713 | @NO__T 0CA1713: События не должны иметь до или после префикса @ no__t-0 | Имя события начинается с Before или After. Чтобы дать имена связанным событиям, возникающим в определенной последовательности, используйте настоящее или прошедшее время, чтобы обозначить положение события в последовательности действий. |
| CA1714 | @NO__T 0CA1714: Перечисления flags должны иметь имена во множественном числе @ no__t-0 | Открытое перечисление содержит атрибут System.FlagsAttribute, и имя перечисления не заканчивается на "s". Имена типов, помеченных атрибутом FlagsAttribute, используются во множественном числе, поскольку данный атрибут указывает на возможность задания нескольких значений. |
| CA1715 | @NO__T 0CA1715: Идентификаторы должны иметь правильный префикс @ no__t-0 | Имя доступного для внешнего кода интерфейса не начинается с заглавной буквы "I". Имя параметра универсального типа в доступном для внешнего кода типе или методе не начинается с заглавной буквы "Т". |
| CA1716 | @NO__T 0CA1716: Идентификаторы не должны совпадать с ключевыми словами @ no__t-0 | Имя пространства имен или типа совпадает с ключевым словом, зарезервированным в языке программирования. Идентификаторы пространств имен и типов не должны совпадать с ключевыми словами, определенными в языках, поддерживаемых в среде CLR. |
| CA1717 | @NO__T 0CA1717: Только перечисления FlagsAttribute должны иметь имена во множественном числе @ no__t-0 | Согласно правилам именования множественное число имени перечисления указывает, что одновременно можно задать несколько значений перечисления. |
| CA1719 | @NO__T 0CA1719: Имена параметров не должны совпадать с именами членов @ no__t-0 | Имя параметра должно передавать смысловое значение параметра, а имя члена — смысловое значение члена. Они могут совпадать лишь в очень редких случаях. Присвоение параметру имени содержащего его члена кажется неестественным и затрудняет использование библиотеки. |
| CA1720 |@NO__T 0CA1720: Идентификаторы не должны содержать имена типов @ no__t-0 | Имя параметра в доступном для внешнего кода элементе содержит имя типа данных, или имя доступного для внешнего кода элемента содержит языковое имя типа данных. |
| CA1721 | @NO__T 0CA1721: Имена свойств не должны совпадать с именами методов Get @ no__t-0 |Имя открытого или защищенного элемента начинается с Get и соответствует имени открытого или защищенного свойства и по другим параметрам. Методы Get и свойства должны иметь имена, позволяющие четко различать их функции. |
| CA1722 | @NO__T 0CA1722: Идентификаторы не должны иметь неправильных префиксов @ no__t-0 | В соответствии с соглашением об именовании, только некоторые элементы программирования могут иметь имена, которые начинаются с особого префикса. |
| CA1724 | @NO__T 0CA1724: Имена типов не должны совпадать с именами пространства имен @ no__t-0 | Имена типов не должны совпадать с именами пространств имен .NET. Нарушение этого правила приводит к уменьшению функциональности библиотеки. |
| CA1725 | @NO__T 0CA1725: Имена параметров должны соответствовать базовому объявлению @ no__t-0 | Согласованное именование параметров в иерархии переопределений увеличивает удобство использования переопределений метода. Если имя параметра в производном методе отличается от имени в базовом объявлении, может возникнуть путаница в определении того, чем является метод: переопределением базового метода или новой перегрузкой. |
| CA1726 | @NO__T 0CA1726: Использовать предпочтительные термины @ no__t-0 | Имя видимого снаружи идентификатора включает термин, для которого существует другой предпочтительный термин. Кроме того, имя содержит термин Flag или Flags. |
| CA1800 | @NO__T 0CA1800: Не выведите необязательное значение @ no__t-0 | Повторяющиеся приведения снижают производительность, особенно если приведения выполняются в компактных операторах итераций. |
| CA1801 | @NO__T 0CA1801: Проверьте неиспользуемые параметры @ no__t-0 | Сигнатура метода включает параметр, не использующийся в основной части метода. |
| CA1802 |@NO__T 0CA1802: Используйте литералы, где подходит @ no__t-0 |Поле объявляется статичным и доступным только для чтения (Shared и ReadOnly в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]) и инициализируется со значением, вычисляемым во время компиляции. Поскольку значение, присвоенное конечному полю, вычисляется во время компиляции, замените объявление полем const (Const в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]) таким образом, чтобы значение вычисляется во время компиляции, а не во время выполнения. |
| CA1804 | @NO__T 0CA1804: Удалить неиспользуемые локальные переменные @ no__t-0 | Неиспользуемые локальные переменные и ненужные присвоения увеличивают размер сборки и снижают производительность. |
| CA1806 | @NO__T 0CA1806: Не пропускать результаты метода @ no__t-0 | Создается, но никогда не используется новый объект, либо вызывается метод, который создает и возвращает новую строку, и такая новая строка никогда не используется, либо метод COM или P/Invoke возвращает HRESULT или код ошибки, который никогда не используется. |
| CA1809 |@NO__T 0CA1809: Избегайте чрезмерных локальных переменных @ no__t-0 | Обычно для оптимизации производительности рекомендуется хранить значение не в памяти, а в регистре процессора. Это называется регистрацией значения. Чтобы увеличить вероятность того, что все локальные переменные, следует ограничить их, Ограничьте число локальных переменных до 64. |
| CA1810 | @NO__T 0CA1810: Инициализируйте статические поля ссылочного типа встроенным @ no__t-0 | Если в типе объявляется явный статический конструктор, компилятор JIT добавляет проверку в каждый статический метод и конструктор экземпляров этого типа, чтобы убедиться, что статический конструктор уже вызывался ранее. Проверки статических конструкторов могут привести к снижению производительности. |
| CA1811 | @NO__T 0CA1811: Избегайте невызванного закрытого кода @ no__t-0 | Закрытый или внутренний член (член уровня сборки) не вызывается ни объектами сборки, ни средой CLR, ни делегатом. |
| CA1812 | @NO__T 0CA1812: Избегайте использования внутренних классов без экземпляров @ no__t-0 | Экземпляр типа уровня сборки не создается кодом в сборке. |
| CA1813 | @NO__T 0CA1813: Не используйте незапечатанные атрибуты @ no__t-0 | .NET предоставляет методы для извлечения пользовательских атрибутов. По умолчанию эти методы осуществляют поиск иерархии наследования атрибутов. Если запечатать атрибут, поиск в иерархии наследования выполняться не будет, в результате чего может повыситься производительность. |
| CA1814 | @NO__T 0CA1814: Предпочитать массивы массива по многомерной @ no__t-0 | Массив массивов — это массив, элементы которого сами являются массивами. Массивы, которые составляют элементы, могут иметь различные размеры, что позволяет экономить пространство для некоторых наборов данных. |
| CA1815 | @NO__T 0CA1815: Переопределяйте операторы Equals и равенства для типов значений](../code-quality/ca1815-override-equals-and-operator-equals-on-value-types.md) | В унаследованной реализации Equals для типов значений используется библиотека отражения и сравнивается содержимое всех полей. Отражение является процессом, требующим с точки зрения вычислений больших затрат, и сравнение каждого поля на равенство может быть лишним. Если предполагается, что пользователи будут сравнивать, сортировать экземпляры или использовать их в качестве ключей хэш-таблиц, тип значения должен реализовывать Equals. |
| CA1816 | @NO__T 0CA1816: Вызовите GC. SuppressFinalize правильно @ no__t-0 | Метод, являющийся реализацией Dispose, не вызывает сборщик Мусора. SuppressFinalize; или метод, не являющийся реализацией Dispose вызывает сборщик Мусора. SuppressFinalize; или вызовы методов сборки Мусора. SuppressFinalize и передает что-то другое (Me в Visual Basic). |
| CA1819 | @NO__T 0CA1819: Свойства не должны возвращать массивы @ no__t-0 | Массивы, возвращаемые свойствами, не защищены от записи, даже если свойство доступно только для чтения. Чтобы защитить массив от изменений, свойство должно возвращать копию массива. Как правило, пользователи не понимают требований к производительности при вызове такого свойства. |
| CA1820 | @NO__T 0CA1820: Проверка на наличие пустых строк с использованием длины строки @ no__t-0 | Сравнивать строки с использованием свойства String.Length или метода String.IsNullOrEmpty значительно быстрее, чем с помощью Equals. |
| CA1821 | [CA1821: удалите пустые завершающие методы](../code-quality/ca1821-remove-empty-finalizers.md) | Если возможно, старайтесь не использовать финализаторы, поскольку из-за отслеживания жизненного срока объектов снижается производительность программы. Пустой метод завершения создает дополнительную нагрузку на систему, не обеспечивая никаких преимуществ. |
| CA1822 |@NO__T 0CA1822: Пометьте члены как статические @ no__t-0 | Члены, не обращающиеся к данным экземпляра и не вызывающие методы экземпляра, можно пометить как статические (Shared в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]). Если пометить методы как статические, компилятор предоставит этим членам невиртуальные места вызова. Это обеспечивает значительное повышение производительности при работе с кодом, для которого важна высокая производительность системы. |
| CA1823 | @NO__T 0CA1823: Избегайте неиспользуемых закрытых полей @ no__t-0 | Обнаружены закрытые поля, доступ к которым, судя по всему, не предоставляется в сборке. |
| CA1824 |@NO__T 0CA1824: Пометить сборки с помощью NeutralResourcesLanguageAttribute @ no__t-0 | Атрибут NeutralResourcesLanguage информирует диспетчер ресурсов о языке, который использовался для вывода ресурсов нейтральной культуры для сборки. При этом повышается эффективность поиска первого загружаемого ресурса и может сократиться рабочее множество. |
| CA1825 |@NO__T 0CA1825: Избегайте выделения массивов нулевой длины @ no__t-0 | Инициализация массива нулевой длины приводит к ненужному выделению памяти. Вместо этого используйте статически выделенный экземпляр пустого массива, вызвав <xref:System.Array.Empty%2A?displayProperty=nameWithType>. Выделение памяти является общим для всех вызовов этого метода. |
| CA1900 | @NO__T 0CA1900: Поля типа значения должны быть переносимыми @ no__t-0 | Это правило проверяет правильность выравнивания структур, объявленных с явной разметкой, при маршалировании в неуправляемый код на 64-разрядных операционных системах. |
| CA1901 | @NO__T 0CA1901: Объявления P/Invoke должны быть переносимыми @ no__t-0 | Данное правило вычисляет размер каждого параметра и возвращаемого значения вызова P/Invoke и проверяет правильность размера параметра при маршалировании в неуправляемый код на 32-разрядных и 64-разрядных операционных системах. |
| CA1903 | @NO__T 0CA1903: Использовать API только из целевой платформы @ no__t-0 | Член или тип использует член или тип, который был впервые представлен в пакете обновления, не включенном в целевую среду проекта. |
| CA2000 | @NO__T 0CA2000: Удалить объекты до потери области @ no__t-0 | Необходимо явно удалить объект до того, как все ссылки на него окажутся вне области действия, так как может произойти исключительное событие, которое воспрепятствует выполнению метода завершения объекта. |
| CA2001 | @NO__T 0CA2001: Избегайте вызова проблемных методов @ no__t-0 | Член вызывает потенциально опасный или проблемный метод. |
| CA2002 |@NO__T 0CA2002: Не блокируйте объекты с слабым удостоверением @ no__t-0 |К объекту со слабой идентификацией может быть получен прямой доступ через границы домена приложения. Поток пытается получить блокировку объекта со слабой идентификацией, который может быть заблокирован вторым потоком в другом домене приложения, имеющим блокировку того же объекта. |
| CA2003 |@NO__T 0CA2003: Не рассматривайте волокна как потоки @ no__t-0 | Управляемый поток обрабатывается как поток [!INCLUDE[TLA2#tla_win32](../code-quality/includes/tla2sharptla_win32_md.md)]. |
| CA2004 | @NO__T 0CA2004: Удалите вызовы GC. KeepAlive @ no__t-0 | При переходе к использованию класса SafeHandle необходимо удалить все вызовы метода GC.KeepAlive (объект). В этом случаев классам не требуется вызывать метод GC.KeepAlive. При этом предполагается, что для завершения дескриптора ОС они используют не метод завершения, а класс SafeHandle. |
| CA2006 | @NO__T 0CA2006: Использование SafeHandle для инкапсуляции машинных ресурсов @ no__t-0 | Использование указателя IntPtr в управляемом коде может указывать на потенциальную проблему безопасности и надежности. Необходимо изучить все случаи использования указателя IntPtr, чтобы определить, не следует ли использовать вместо него класс SafeHandle или другую подобную технологию. |
| CA2007 | @NO__T 0CA2007: Не ожидать непосредственно задачи @ no__t-0 | Асинхронный метод [ожидает](/dotnet/csharp/language-reference/keywords/await) <xref:System.Threading.Tasks.Task> напрямую. Когда асинхронный метод ожидает <xref:System.Threading.Tasks.Task> напрямую, продолжение происходит в том же потоке, в котором была создана задача. Такое поведение может быть дорогостоящим в плане производительности и может привести к взаимоблокировке потока пользовательского интерфейса. Попробуйте вызвать <xref:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)?displayProperty=nameWithType>, чтобы сообщить о намерении к продолжению. |
| CA2100 | @NO__T 0CA2100: Обзор запросов SQL для уязвимостей безопасности @ no__t-0 | Метод задает свойство System.Data.IDbCommand.CommandText с использованием строки, созданной из строкового аргумента метода. Это правило предполагает, что строковый аргумент содержит введенные пользователем данные. Созданная из введенных пользователем данных командная строка SQL уязвима перед атаками путем внедрения кода SQL. |
| CA2101 |@NO__T 0CA2101: Укажите метод маршалирования для строковых аргументов P/Invoke @ no__t-0 | Член вызова неуправляемого кода, разрешающий вызовы с частичным доверием, содержит строковый параметр и не выполняет явный маршалинг и преобразование этой строки. Это может стать причиной потенциальной уязвимости безопасности. |
| CA2102 | @NO__T 0CA2102: Перехват исключений, не являющихся CLSCompliant, в общих обработчиках @ no__t-0 | Элемент в сборке, не помеченной атрибутом RuntimeCompatibilityAttribute или помеченной атрибутом RuntimeCompatibility(WrapNonExceptionThrows = false), содержит блок catch, который обрабатывает исключения System.Exception, однако непосредственно за этим блоком не следует общий блок catch. |
| CA2103 | @NO__T 0CA2103: Проверка императивной безопасности @ no__t-0 |Метод использует принудительную безопасность и может обеспечить создание разрешения с помощью сведений о состоянии или возвращаемых значений, которые могут измениться в период активности требования. Поэтому по возможности следует использовать декларативную безопасность. |
| CA2104 |@NO__T 0CA2104: Не объявляйте изменяемые ссылочные типы только для чтения @ no__t-0 | Видимый извне тип содержит видимое извне и доступное только для чтение поле, являющееся изменяемым ссылочным типом. Изменяемый тип — это тип, экземпляр которого может быть изменен. |
| CA2105 | @NO__T 0CA2105: Поля массива не должны быть доступны только для чтения @ no__t-0 |При применении модификатора "только для чтения" (ReadOnly в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]) к полю, содержащему массив, это поле нельзя изменить, связав его с другим массивом. Однако элементы массива, хранящегося в доступном только для чтения поле, можно будет изменить. |
| CA2106 | @NO__T 0CA2106: Безопасные утверждения @ no__t-0 | Метод подтверждает разрешения без выполнения проверок безопасности для вызывающего объекта. Подтверждение разрешений безопасности без выполнения проверок безопасности может привести к возникновению в коде уязвимости системы безопасности, которой могут воспользоваться злоумышленники. |
| CA2107 | @NO__T 0CA2107: Проверка запрета и разрешение только на использование @ no__t-0 |Действия метода PermitOnly и CodeAccessPermission. Deny Security должны использоваться только теми, у кого есть опыт работы с безопасностью .NET. Код, который использует эти действия безопасности, должен быть тщательно проанализирован на предмет безопасности. |
| CA2108 | @NO__T 0CA2108: Проверка декларативной безопасности для типов значений @ no__t-0 | Открытый или защищенный тип значения защищен средствами доступа к данным или требованиями ссылки. |
| CA2109 | @NO__T 0CA2109: Просмотр видимых обработчиков событий @ no__t-0 | Обнаружен открытый или защищенный метод обработки событий. Методы обработки событий следует раскрывать только в тех случаях, когда это совершенно необходимо. |
| CA2111 |@NO__T 0CA2111: Указатели не должны быть видимыми @ no__t-0 | Указатель не является закрытым, внутренним или доступным только для чтения. Вредоносный код может изменить значение указателя, что потенциально приведет к предоставлению доступа к произвольным областям памяти или сбоям приложения или системы. |
| CA2112 | @NO__T 0CA2112: Защищенные типы не должны предоставлять поля @ no__t-0 | Открытый или защищенный тип содержит открытые поля и защищен требованиями ссылки. Если код имеет доступ к экземпляру типа, защищенного запросом компоновки, то для получения доступа к полям типа коду не требуется удовлетворять запросу компоновки. |
| CA2114 | @NO__T 0CA2114: Безопасность метода должна быть надмножеством типа @ no__t-0 | Метод не должен обладать декларативной безопасностью для одного и того же действия, как на уровне метода, так и на уровне типа. |
| CA2115 | @NO__T 0CA2115: Вызовите GC. KeepAlive при использовании собственных ресурсов @ no__t-0 | Данное правило обнаруживает ошибки, которые могут возникать из-за завершения неуправляемых ресурсов, по-прежнему используемых в машинном коде. |
| CA2116 | @NO__T 0CA2116: Методы APTCA должны вызывать только методы APTCA @ no__t-0 |Если в полностью доверенной сборке присутствует атрибут APTCA (AllowPartiallyTrustedCallersAttribute) и она выполняет код в другой сборке, для которой не разрешены частично доверенные вызовы, возможно возникновение уязвимости безопасности. |
| CA2117 | @NO__T 0CA2117: APTCA-типы должны расширять только базовые типы APTCA @ no__t – 0 | Если сборка с полным доверием помечена атрибутом APTCA и тип в сборке наследует от типа, который не разрешает вызовы с неполным доверием, возможно возникновение уязвимости для эксплойта. |
| CA2118 | @NO__T 0CA2118: Проверка использования SuppressUnmanagedCodeSecurityAttribute @ no__t-0 |Атрибут SuppressUnmanagedCodeSecurityAttribute изменяет поведение системы безопасности, определенное по умолчанию, для элементов, выполняющих неуправляемый код за счет COM-взаимодействия или вызова операционной системы. Этот атрибут служит в основном для повышения производительности; однако, прирост производительности сопряжен со значительными рисками безопасности. |
| CA2119 | @NO__T 0CA2119: Запечатайте методы, которые соответствуют частным интерфейсам @ no__t-0 | Наследуемый открытый тип предоставляет реализацию переопределяемого метода внутреннего (Friend в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]) интерфейса. Для устранения нарушения данного правила следует исключить возможность переопределения метода за пределами сборки. |
| CA2120 | @NO__T 0CA2120: Безопасные конструкторы сериализации @ no__t-0 | Для этого типа предусмотрен конструктор, который принимает объекты System.Runtime.Serialization.SerializationInfo и System.Runtime.Serialization.StreamingContext (сигнатура конструктора сериализации). Этот конструктор не защищен проверкой безопасности, однако один или несколько обычных конструкторов этого типа защищены. |
| CA2121 | @NO__T 0CA2121: Статические конструкторы должны быть частными](../code-quality/ca2121-static-constructors-should-be-private.md) | Система вызывает статический конструктор перед созданием первого экземпляра типа или ссылкой на любые статические члены. Если статический конструктор не является закрытым, он может быть вызван кодом, находящимся за пределами системы. В зависимости от операций, выполняемых в конструкторе, это может стать причиной непредвиденного поведения |
| CA2122 | @NO__T 0CA2122: Не следует косвенно предоставлять методы с запросами компоновки @ no__t-0 | У открытого или защищенного члена есть требования ссылки, и он вызывается членом, который не выполняет какие-либо проверки безопасности. Запрос компоновки проверяет разрешения только непосредственно вызывающего метода. |
| CA2123 | @NO__T 0CA2123: Запросы на переопределение ссылок должны быть идентичны базовым @ no__t-0 | Это правило сравнивает метод с его базовым методом (который является интерфейсом или виртуальным методом другого типа), а затем сравнивает запросы ссылок для каждого из них. Если это правило нарушается, то вредоносный вызывающий объект может обойти запрос ссылок путем вызова небезопасного метода. |
| CA2124 | @NO__T 0CA2124: Переносить уязвимые предложения finally во внешнее предложение try @ no__t-0 | Открытый или защищенный метод содержит блок try/finally. Блок finally сбрасывает состояние безопасности и не заключен в блок finally. |
| CA2126 | @NO__T 0CA2126: Требования компоновки типа должны требовать наследование требований @ no__t-0 | Открытый незапечатанный тип защищен требованием ссылки и имеет переопределяемый метод. Ни тип, ни метод не защищены с помощью требования наследования. |
| CA2127 | @NO__T 0CA2136: Элементы не должны иметь конфликтующие аннотации прозрачности @ no__t-0 | В 100 процентов прозрачной сборкой не может содержаться критический код. Это правило позволяет проанализировать сборки, прозрачные на 100 процентов для аннотаций SecurityCritical на уровне типов, полей и методов. |
| CA2128 |@NO__T 0CA2147: Прозрачные методы не могут использовать утверждения безопасности @ no__t-0 | Это правило анализирует все методы и типы в сборке, которая является смешанной либо прозрачный с точки зрения 100 процентов прозрачной и критической и пометить декларативное и императивное использование Assert. |
| CA2129 | @NO__T 0CA2140: Прозрачный код не должен ссылаться на критически важные элементы безопасности @ no__t-0 | Методы, помеченные атрибутом SecurityTransparentAttribute, вызывают закрытые члены, помеченные как SecurityCritical. Это правило позволяет проанализировать все методы и типы в смешанной (прозрачной и критической) сборке и пометить все вызовы закрытого критического кода из прозрачного кода, которые не помечены как SecurityTreatAsSafe. |
| CA2130 | @NO__T 0CA2130: Критические константы безопасности должны быть прозрачными @ no__t-0 | Принудительная прозрачность не применяется для постоянных значений, чтобы во время выполнения не требовалась подстановка значений. Константные поля должны быть прозрачными для системы безопасности, чтобы анализаторы кода не предполагали, что прозрачный для системы безопасности код не может получить доступ к константе. |
| CA2131 | @NO__T 0CA2131: Критические для безопасности типы не могут участвовать в эквивалентности типов @ no__t-0 | Тип участвует в эквивалентности типов, а сам тип или член или поле типа помечены атрибутом SecurityCriticalAttribute. Это правило применяется ко всем критическим типам или к типам, содержащим критические методы или поля, участвующие в эквивалентности типов. Когда среда CLR обнаруживает такой тип, она не загружает его и выдает исключение TypeLoadException во время выполнения. Обычно это правило применяется, только когда пользователи вручную реализуют эквивалентность типов, вместо использования tlbimp и компиляторов. |
| CA2132 | @NO__T 0CA2132: Конструкторы по умолчанию должны иметь по крайней мере такие же критические, как конструкторы по умолчанию базового типа @ no__t-0 |Типы и члены с атрибутом SecurityCriticalAttribute не могут использоваться в коде приложений Silverlight. Критичные в плане безопасности типы и элементы могут использоваться только надежным кодом в среде .NET Framework для библиотеки классов Silverlight. Поскольку открытая или защищенная конструкция в производном классе должна иметь ту же или большую прозрачность, чем ее базовый класс, класс в приложении не может быть производным от класса, помеченного как SecurityCritical. |
| CA2133 | @NO__T 0CA2133: Делегаты должны быть привязаны к методам с одинаковой прозрачностью @ no__t-0 | Это предупреждение вызывается методом, который привязывает делегат, помеченный атрибутом SecurityCriticalAttribute, к методу, который является прозрачным или помечен атрибутом SecuritySafeCriticalAttribute. Предупреждение также выдается для метода, который привязывает прозрачный или безопасный делегат к критическому методу. |
| CA2134 | @NO__T 0CA2134: Методы должны иметь постоянную прозрачность при переопределении базовых методов @ no__t-0 |Это правило применяется, когда метод, помеченный атрибутом SecurityCriticalAttribute, переопределяет прозрачный метод или метод, помеченный атрибутом SecuritySafeCriticalAttribute. Это правило также применяется, когда прозрачный метод или метод, помеченный атрибутом SecurityCriticalAttribute, переопределяет метод, помеченный атрибутом SecuritySafeCriticalAttribute. Это правило применяется при переопределении виртуального метода или реализации интерфейса. |
| CA2135 | @NO__T 0CA2135: Сборки уровня 2 не должны содержать LinkDemands @ no__t-0 | Требования LinkDemand являются устаревшими в наборе правил безопасности уровня 2. Вместо использования требования LinkDemand для обеспечения безопасности во время JIT-компиляции пометьте методы, типы и поля атрибутом SecurityCriticalAttribute. |
| CA2136 | @NO__T 0CA2136: Элементы не должны иметь конфликтующие аннотации прозрачности @ no__t-0 | Атрибуты прозрачности применяются из элементов кода большей области к элементам меньшей области. Атрибуты прозрачности элементов кода с большей областью имеют приоритет по сравнению с атрибутами прозрачности элементов кода, которые содержатся в первом элементе. Например, класс, помеченный атрибутом SecurityCriticalAttribute, не может содержать метод, помеченный атрибутом SecuritySafeCriticalAttribute. |
| CA2137 | @NO__T 0CA2137: Прозрачные методы должны содержать только проверяемый IL @ no__t-0 | Метод содержит непроверяемый код или возвращает тип по ссылке. Это правило срабатывает при попытках прозрачного кода безопасности выполнить непроверяемый MISL. Однако это правило не содержит полную проверку IL, и вместо нее использует эвристику для выявления большинства нарушений проверки MSIL. |
| CA2138 | @NO__T 0CA2138: Прозрачные методы не должны вызывать методы с атрибутом SuppressUnmanagedCodeSecurity @ no__t-0 | Прозрачный с точки зрения безопасности метод вызывает метод, помеченный атрибутом SuppressUnmanagedCodeSecurityAttribute. |
| CA2139 | @NO__T 0CA2139: Прозрачные методы не могут использовать атрибут HandleProcessCorruptingExceptions @ no__t-0 | Это правило запускается любым прозрачным методом, который пытается обработать исключение повреждения процесса с помощью атрибута HandleProcessCorruptedStateExceptionsAttribute. Исключение повреждения процесса – это классификация версии 4.0 среды CLR таких исключений, как AccessViolationException. Атрибут HandleProcessCorruptedStateExceptionsAttribute может использоваться только критичными в плане безопасности методами и будет игнорироваться при применении для прозрачного метода. |
| CA2140 | @NO__T 0CA2140: Прозрачный код не должен ссылаться на критически важные элементы безопасности @ no__t-0 | Элемент кода, помеченный атрибутом SecurityCriticalAttribute, является критическим с точки зрения безопасности. Прозрачный метод не может использовать элемент, критический с точки зрения безопасности. Если прозрачный тип пытается использовать тип, критический с точки зрения безопасности, то вызывается исключение TypeAccessException, MethodAccessException или FieldAccessException. |
| CA2141 |[CA2141: прозрачные методы не должны удовлетворять требования LinkDemand](../code-quality/ca2141-transparent-methods-must-not-satisfy-linkdemands.md) | Прозрачный с точки зрения безопасности метод вызывает метод в сборке, не помеченной атрибутом APTCA, либо прозрачный с точки зрения безопасности метод удовлетворяет требованию LinkDemand по типу или методу. |
| CA2142 | @NO__T 0CA2142: Прозрачный код не должен быть защищен с помощью LinkDemand @ no__t-0 | Это правило срабатывает для прозрачных методов, для доступа к которым требуется LinkDemand. Прозрачный для системы безопасности код не должен отвечать за проверку безопасности операции и поэтому не должен требовать разрешений. |
| CA2143 | @NO__T 0CA2143: Прозрачные методы не должны использовать требования безопасности @ no__t-0 | Прозрачный для системы безопасности код не должен отвечать за проверку безопасности операции и поэтому не должен требовать разрешений. Прозрачный для системы безопасности код должен использовать полные требования для принятия решений по безопасности, и критичный в плане безопасности код не должен полагаться на прозрачный код, чтобы создать полное требование. |
| CA2144 | @NO__T 0CA2144: Прозрачный код не должен загружать сборки из массивов байтов @ no__t-0 | Проверка безопасности для прозрачного кода не так тщательна, как проверка безопасности для критического кода, поскольку прозрачный код не может выполнять действия, требующие особых мер безопасности. Сборки, загруженные из массива байтов, могут остаться незамеченными в прозрачном коде, и этот массив байтов может содержать критичный или, что более важно, критичный в плане безопасности код, который подлежит аудиту. |
| CA2145 | @NO__T 0CA2145: Прозрачные методы не должны быть дополнены атрибутом SuppressUnmanagedCodeSecurityAttribute @ no__t-0 | Методы, оснащенные атрибутом SuppressUnmanagedCodeSecurityAttribute, имеют неявную проверку LinkDemand, применяемую к любому вызывающему их методу. Для этой проверки LinkDemand требуется, чтобы вызывающий код был критическим с точки зрения безопасности. Пометка метода, который использует SuppressUnmanagedCodeSecurity с атрибутом SecurityCriticalAttribute, делает это требование более очевидным для тех, кто вызывает этот метод. |
| CA2146 | @NO__T 0CA2146: Типы должны быть не менее важными, чем их базовые типы и интерфейсы @ no__t-0 | Это правило срабатывает, если у производного типа есть атрибут прозрачности безопасности, не такой критический, как базовый тип или реализованный интерфейс. От критических базовых типов или реализованных критических интерфейсов могут производиться только критические типы, и от критических в плане безопасности базовых типов или реализованных интерфейсов могут производиться только критические в плане безопасности типы. |
| CA2147 |@NO__T 0CA2147: Прозрачные методы не могут использовать утверждения безопасности @ no__t-0 | Коду, помеченному атрибутом SecurityTransparentAttribute, не предоставляются достаточные для утверждения разрешения. |
| CA2149 | @NO__T 0CA2149: Прозрачные методы не должны вызывать машинный код @ no__t-0 | Это правило применяется в любом прозрачном методе, который напрямую вызывает машинный код (например, с помощью P/Invoke). Нарушение этого правила приводит к исключению MethodAccessException на уровне 2 модели прозрачности и вызову полного требования UnmanagedCode на уровне 1 модели прозрачности. |
| CA2151 |@NO__T 0CA2151: Поля с критическими типами должны быть критически важными для безопасности @ no__t-0 | Для использования критических с точки зрения безопасности типов код, который ссылается на тип, должен быть либо критическим с точки зрения безопасности, либо надежным с точки зрения безопасности. Это верно даже в случае косвенной ссылки. Поэтому применять прозрачное для безопасности поле или поле, надежное с точки зрения безопасности, не рекомендуется, поскольку прозрачный код по-прежнему не сможет получить доступ к полю. |
| CA2200 | @NO__T 0CA2200: Повторное создание для сохранения сведений о стеке @ no__t-0 | В операторе throw повторно создается и явным образом задается исключение. Если исключение повторно создается заданием исключения в операторе throw, список вызовов метода между исходным методом, создавшим исключение, и текущим методом будет утерян. |
| CA2201 | @NO__T 0CA2201: Не вызывайте зарезервированные типы исключений @ no__t-0 | Из-за этого становится трудно обнаружить и отладить изначальную ошибку. |
| CA2202 | @NO__T 0CA2202: Не удалять объекты несколько раз @ no__t-0 |Реализация метода содержит пути кода, которые могли стать причиной многократного вызова метода System.IDisposable.Dispose или эквивалентного метода Dispose (например, метода Close() для некоторых типов) для одного и того же объекта. |
| CA2204 | @NO__T 0CA2204: Литералы должны быть правильно написаны @ no__t-0 | Литеральная строка в теле метода содержит одно или несколько слов, не распознаваемых библиотекой системы проверки орфографии Майкрософт. |
| CA2205 | @NO__T 0CA2205: Использование управляемых эквивалентов Win32 API @ no__t-0 | Определен метод вызова операционной системы, и доступен метод .NET, имеющий эквивалентную функциональность. |
| CA2207 | @NO__T 0CA2207: Инициализируйте статические поля типа значения во встроенном @ no__t-0 | Тип значения объявляет явный статический конструктор. Чтобы устранить нарушение данного правила, выполните инициализацию всех статических данных при их объявлении и удалите статический конструктор. |
| CA2208 |@NO__T 0CA2208: Правильное создание экземпляров исключений аргументов @ no__t-0 | Вызывается конструктор по умолчанию (без параметров), принадлежащий к типу исключения ArgumentException или унаследованный от него, или неправильный аргумент строки передается параметризованному конструктору, принадлежащему к типу исключения ArgumentException или унаследованному от него. |
| CA2210 |@NO__T 0CA2210: Сборки должны иметь допустимые строгие имена @ no__t-0 | Строгое имя защищает клиентов от случайной загрузки сборки, которая была подменена. Сборки без строгих имен следует развертывать лишь в крайне небольшом числе случаев. При обмене или распространении сборок без правильной подписи сборки могут быть подменены, среда CLR может не загрузить сборку или пользователь может быть вынужден отключить проверку на своем компьютере. |
| CA2211 |@NO__T 0CA2211: Неконстантные поля не должны быть видимыми @ no__t-0 | Для статических полей, которые не являются константными и доступными только для чтения, невозможно обеспечить потокобезопасность. Доступ к подобным полям должен тщательно контролироваться, и для синхронизации доступа к такому объекту класса требуются дополнительные методы программирования. |
| CA2212 | @NO__T 0CA2212: Не помечать обслуживаемые компоненты с помощью WebMethod @ no__t-0 |Метод в типе, унаследованном от System.EnterpriseServices.ServicedComponent, помечен атрибутом System.Web.Services.WebMethodAttribute. Так как атрибут WebMethodAttribute и метод ServicedComponent имеют разное поведение и предъявляют конфликтующие требования к контексту и потоку транзакций, в некоторых сценариях поведение метода будет неправильным. |
| CA2213 | [CA2213: следует высвобождать высвобождаемые поля](../code-quality/ca2213-disposable-fields-should-be-disposed.md) | Тип, реализующий System.IDisposable, объявляет поля, принадлежащие к типам, которые также реализуют IDisposable. Метод Dispose поля не вызывается методом Dispose объявляющего типа. |
| CA2214 | @NO__T 0CA2214: Не Вызывайте переопределяемые методы в конструкторах @ no__t-0 | Когда конструктор вызывает виртуальный метод, возможна ситуация, когда конструктор для экземпляра, вызывающего метод, не выполняется. |
| CA2215 | @NO__T 0CA2215: Методы Dispose должны вызывать базовый класс Dispose @ no__t-0 | Если тип наследуется от удаляемого типа, он должен вызвать метод Dispose базового типа из собственного метода Dispose. |
| CA2216 |@NO__T 0CA2216: Удаляемые типы должны объявлять финализатор @ no__t-0 | Тип, который реализует System.IDisposable и имеет поля, предусматривающие использование неуправляемых ресурсов, не реализует метод завершения, как описано в Object.Finalize. |
| CA2217 | @NO__T 0CA2217: Не помечать перечисления атрибутом FlagsAttribute @ no__t-0 |Доступное для внешнего кода перечисление помечено атрибутом FlagsAttribute и имеет одно или несколько значений, которые не являются степенью двойки или сочетанием других определенных значений в перечислении. |
| CA2218 |@NO__T 0CA2218: Переопределить GetHashCode при переопределении Equals @ no__t-0 | GetHashCode возвращает значение на основе текущего экземпляра, используемое для алгоритмов хэширования и структур данных, таких как хэш-таблица. Два равных объекта, принадлежащие к одному и тому же типу, должны возвращать один и тот же хэш-код. |
| CA2219 | @NO__T 0CA2219: Не вызывайте исключения в предложениях исключений @ no__t-0 | Если исключение создается в предложении finally или fault, новое исключение скрывает активное исключение. Если исключение создается в предложении filter, среда выполнения перехватывает исключение без оповещения. Из-за этого становится трудно обнаружить и отладить изначальную ошибку. |
| CA2220 | @NO__T 0CA2220: Методы завершения должны вызывать метод завершения базового класса @ no__t-0 | Финализация должна распространятся посредством иерархии наследования. Для этого типы должны вызывать свой метод Finalize базового класса из собственного метода Finalize. |
| CA2221 |@NO__T 0CA2221: Методы завершения должны быть защищены @ no__t-0 | В методах завершения должен использоваться модификатор доступа из семейства. |
| CA2222 | @NO__T 0CA2222: Не уменьшайте видимость унаследованного члена @ no__t-0 |Не следует изменять модификатор доступа для унаследованных членов. Если сделать унаследованный член закрытым, то доступ вызывающих объектов к реализации метода базового класса все равно не будет запрещен. |
| CA2223 | @NO__T 0CA2223: Члены должны отличаться больше, чем возвращаемый тип @ no__t-0 | Среда CLR позволяет использовать типы возвращаемого значения для различения совпадающих в остальном членов, однако эта функция не входит в спецификацию CLS и поддерживается не всеми языками программирования .NET. |
| CA2224 | @NO__T 0CA2224: Переопределить Equals при перегрузке оператора равным @ no__t-0 | Открытый тип реализует оператор равенства, но не переопределяет Object.Equals. |
| CA2225 | @NO__T 0CA2225: Перегрузки операторов имеют именованные варианты @ no__t-0 |Обнаружена перегрузка оператора, однако не найден ожидаемый именованный альтернативный метод. Именованный альтернативный член предоставляет те же функции, что и основной оператор, и его могут использовать разработчики, которые программируют на языках, не поддерживающих перегрузку операторов. |
| CA2226 | @NO__T 0CA2226: Операторы должны иметь симметричную перегрузку @ no__t-0 | Тип реализует оператор равенства или неравенства, но не реализует противоположный оператор. |
| CA2227 |@NO__T 0CA2227: Свойства коллекции должны быть доступны только для чтения @ no__t-0 |Свойство коллекции, допускающее запись, позволяет пользователю заменять одну коллекцию другой. Свойство только для чтения предотвращает замену коллекции, но по-прежнему допускает установку, настройку отдельных членов. |
| CA2228 | @NO__T 0CA2228: Не поставлять невыпущенные форматы ресурсов @ no__t-0 | Файлы ресурсов, созданные с помощью предварительных версий .NET, могут не использоваться поддерживаемыми версиями .NET. |
| CA2229 | [CA2229: реализуйте конструкторы сериализации](../code-quality/ca2229-implement-serialization-constructors.md) | Чтобы устранить нарушение этого правила, реализуйте конструктор сериализации. Для запечатанного класса конструктор должен быть закрытым, а в иных случаях — защищенным. |
| CA2230 | @NO__T 0CA2230: Использовать параметры для переменных аргументов @ no__t-0 | Открытый или защищенный тип содержит открытый или защищенный метод, который использует соглашение о вызовах VarArgs вместо ключевого слова params. |
| CA2231 | [CA2231: перегрузите оператор равенства на переопределяющем типе ValueType.Equals](../code-quality/ca2231-overload-operator-equals-on-overriding-valuetype-equals.md) | Тип значения переопределяет Object.Equals, но не реализует оператор равенства. |
| CA2232 | @NO__T 0CA2232: Пометьте Windows Forms точки входа с помощью STAThread @ no__t-0 | Атрибут STAThreadAttribute указывает, что потоковой моделью COM для приложения является однопотоковое подразделение. Данный атрибут должен находиться в точке входа любого приложения, использующего Windows Forms; если он отсутствует, компоненты Windows могут работать неправильно. |
| CA2233 |@NO__T 0CA2233: Операции не должны переполнены @ no__t-0 | Не следует выполнять арифметические операции без предварительной проверки операндов. Это гарантирует, что результат операции находится в диапазоне возможных значений для используемых типов данных. |
| CA2234 | @NO__T 0CA2234: Передавать объекты System. URI вместо строк @ no__t-0 | Вызывается метод, имеющий параметр строки, имя которого содержит uri, URI, urn, URN, url или URL. Объявляющий тип метода содержит соответствующую перегрузку метода, которая имеет параметр System.Uri. |
| CA2235 | [CA2235. Пометьте все несериализуемые поля](../code-quality/ca2235-mark-all-non-serializable-fields.md) | Экземпляр поля несериализуемого типа объявлен в сериализуемом типе. |
| CA2236 | @NO__T 0CA2236: Вызов методов базового класса для типов ISerializable @ no__t-0 | Чтобы устранить нарушение этого правила, вызовите метод базового типа GetObjectData или конструктор сериализации из соответствующего метода производного типа или конструктора. |
| CA2237 | [CA2237. Пометьте типы ISerializable с SerializableAttribute @ no__t-0 | Чтобы среда CLR распознавала тип как сериализуемый, он должен быть помечен атрибутом SerializableAttribute, даже если тип использует пользовательскую процедуру сериализации посредством реализации интерфейса ISerializable. |
| CA2238 |@NO__T 0CA2238: Правильно реализуйте методы сериализации @ no__t-0 | Метод, обрабатывающий событие сериализации, не имеет правильной сигнатуры, типа возвращаемого значения или отображения. |
| CA2239 | @NO__T 0CA2239: Укажите методы десериализации для необязательных полей @ no__t-0 | Тип имеет поле, помеченное атрибутом System.Runtime.Serialization.OptionalFieldAttribute, и не предоставляет методы обработки событий десериализации. |
| CA2240 | @NO__T 0CA2240: Правильно реализуйте ISerializable @ no__t-0 | Чтобы устранить нарушение данного правила, сделайте метод GetObjectData доступным для внешнего кода и переопределяемым и убедитесь, что все поля экземпляра включены в процесс сериализации или явно помечены атрибутом NonSerializedAttribute. |
| CA2241 | @NO__T 0CA2241: Укажите правильные аргументы для методов форматирования @ no__t-0 | Аргумент формата, переданный методу System.String.Format, не содержит элемент форматирования, соответствующий каждому аргументу объекта, или наоборот. |
| CA2242 |@NO__T 0CA2242: Правильно протестируйте NaN @ no__t-0 | Это выражение проверяет значение на соответствие Single.Nan или Double.Nan. Используйте Single.IsNan(Single) или Double.IsNan(Double) для проверки значения. |
| CA2243 |@NO__T 0CA2243: Строковые литералы атрибутов должны анализироваться правильно @ no__t-0 | Не удается правильно выполнить синтаксический анализ параметра строкового литерала атрибута для URL-адреса, идентификатора GUID или версии. |
| CA5122 | [CA5122. Объявления P/Invoke не могут быть надежными с точки зрения безопасности](../code-quality/ca5122-p-invoke-declarations-should-not-be-safe-critical.md) | Методы отмечаются как SecuritySafeCritical, если они выполняют критически важные для безопасности операции и являются безопасными для использования в прозрачном коде. Прозрачный код может никогда не вызывать машинный код напрямую с помощью P/Invoke. Поэтому, если метод P/Invoke отметить как надежный с точки зрения безопасности, это не приведет к тому, что прозрачный код будет вызывать его, и может ввести в заблуждение при анализе безопасности. |
