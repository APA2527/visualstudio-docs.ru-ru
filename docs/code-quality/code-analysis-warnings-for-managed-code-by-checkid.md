---
title: Предупреждения при анализе управляемого кода по идентификатору CheckId
ms.date: 04/18/2019
ms.topic: reference
f1_keywords:
- CA1000
- CA1001
- CA1002
- CA1003
- CA1004
- CA1005
- CA1006
- CA1007
- CA1008
- CA1009
- CA1010
- CA1011
- CA1012
- CS1013
- CS1014
- CA1016
- CA1017
- CA1018
- CA1019
- CA1020
- CA1021
- CA1022
- CA1023
- CA1024
- CS1025
- CA1026
- CA1027
- CA1028
- CA1029
- CA1030
- CA1031
- CA1032
- CA1033
- CA1034
- CA1035
- CA1036
- CA1037
- CA1038
- CA1039
- CA1040
- CA1041
- CA1042
- CA1043
- CA1044
- CA1045
- CA1046
- CA1047
- CA1048
- CA1049
- CA1050
- CA1051
- CA1052
- CA1053
- CA1054
- CA1055
- CA1056
- CA1057
- CA1058
- CA1059
- CA1060
- CA1061
- CA1062
- CA1063
- CA1064
- CA1065
- CA1300
- CA1301
- CA1302
- CA1303
- CA1304
- CA1305
- CA1306
- CA1307
- CA1308
- CA1309
- CA1400
- CA1401
- CA1402
- CA1403
- CA1404
- CA1405
- CA1406
- CA1407
- CA1408
- CA1409
- CA1410
- CA1411
- CA1412
- CA1413
- CA1414
- CA1415
- CA1500
- CA1501
- CA1502
- CA1503
- CA1504
- CA1505
- CA1506
- CA1507
- CA1600
- CA1601
- CA1700
- CA1701
- CA1702
- CA1703
- CA1704
- CA1707
- CA1708
- CA1709
- CA1710
- CA1711
- CA1712
- CA1713
- CA1714
- CA1715
- VA1716
- CA1717
- CA1719
- CA1720
- CA1721
- CA1722
- CA1723
- CA1724
- CA1725
- CA1726
- CA1727
- CA1728
- CA1729
- CA1730
- CA1800
- CA1801
- CA1802
- CA1803
- CA1804
- CA1806
- CA1809
- CA1810
- CA1811
- CA1812
- CA1813
- CA1814
- CA1815
- CA1816
- CA1819
- CA1820
- CA1821
- CA1822
- CA1823
- CA1824
- CA1900
- CA1901
- CA1903
- CA2000
- CA2001
- CA2002
- CA2003
- CA2004
- CA2006
- CA2007
- CA2100
- CA2101
- CA2102
- CA2103
- CA2104
- CA2105
- CA2106
- CA2107
- CA2108
- CA2109
- CA2110
- CA2111
- CA2112
- CA2114
- CA2115
- CA2116
- CA2117
- CA2118
- CA2119
- CA2120
- CA2121
- CA2122
- CA2123
- CA2124
- CA2126
- CA2127
- CA2128
- CA2129
- CA2130
- CA2131
- CA2132
- CA2133
- CA2134
- CA2135
- CA2136
- CA2137
- CA2138
- CA2139
- CA2140
- CA2141
- CA2142
- CA2143
- CA2144
- CA2145
- CA2146
- CA2147
- CA2148
- CA2149
- CA2150
- CA2151
- CA2200
- CA2201
- CA2202
- CA2204
- CA2205
- CA2207
- CA2208
- CA2210
- CA2211
- CA2212
- CA2213
- CA2214
- CA2215
- CA2216
- CA2217
- CA2218
- CA2219
- CA2220
- CA2221
- CA2222
- CA2223
- CA2224
- CA2225
- CA2226
- CA2228
- CA2229
- CA2227
- CA2230
- CA2231
- CA2232
- CA2233
- CA2234
- CA2235
- CA2236
- CA2237
- CA2238
- CA2239
- CA2240
- CA2241
- CA2242
- CA2243
- CA5122
ms.assetid: 5cb221f6-dc59-4abf-9bfa-adbd6f907f96
author: gewarren
ms.author: gewarren
manager: jillfra
ms.workload:
- dotnet
ms.openlocfilehash: 87461cfe06ac1c038176c3b9d4dcd513733e8d43
ms.sourcegitcommit: 5483e399f14fb01f528b3b194474778fd6f59fa6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/05/2019
ms.locfileid: "66714510"
---
# <a name="code-analysis-warnings-for-managed-code-by-checkid"></a>Предупреждения анализа кода для управляемого кода по идентификатору CheckId

В следующей таблице перечислены предупреждения анализа управляемого кода по идентификатору CheckId предупреждения.

| CheckId | Предупреждение | Описание |
|---------| - | - |
| CA1000 | [CA1000: Не объявляйте статические элементы в универсальных типах](../code-quality/ca1000-do-not-declare-static-members-on-generic-types.md) | При вызове статического элемента универсального типа нужно указать аргумент этого типа. При вызове универсального экземпляра элемента, не поддерживающего вывод типа, для элемента нужно указать аргумент типа. В этих двух случаях синтаксис для определения аргумента типа различен, и его можно легко спутать. |
| CA1001 | [CA1001: типы, которым принадлежат освобождаемые поля, должны быть освобождаемыми](../code-quality/ca1001-types-that-own-disposable-fields-should-be-disposable.md) | В классе объявляется и реализуется поле экземпляра, которое принадлежит типу System.IDisposable, однако класс не реализует интерфейс IDisposable. Класс, в котором объявляется поле IDisposable, неявно владеет неуправляемым ресурсом и должен реализовывать интерфейс IDisposable. |
| CA1002 | [CA1002: Не следует раскрывать универсальные списки](../code-quality/ca1002-do-not-expose-generic-lists.md) | System.Collections.Generic.List < (из \<(T >) >) — это универсальная коллекция, которая предназначена для обеспечения производительности, а не для наследования. Поэтому виртуальные элементы в списке отсутствуют. Вместо этого для наследования следует предоставить универсальную коллекцию. |
| CA1003 | [CA1003: Используйте экземпляры обработчика универсальных событий](../code-quality/ca1003-use-generic-event-handler-instances.md) |Тип содержит делегат, возвращающий значение void, сигнатура которого содержит два параметра (первый объект, а второй — тип, который может быть назначен EventArgs), а включающая сборка предназначена для Microsoft .NET Framework 2.0. |
| CA1004 | [CA1004: Универсальные методы должны предоставлять параметр типа](../code-quality/ca1004-generic-methods-should-provide-type-parameter.md) | Вывод – это то, как аргумент типа универсального метода определяется по типу аргумента, переданного методу, а не по явному указанию аргумента типа. Чтобы задействовать вывод, сигнатура параметра универсального метода должна включать параметр, тип которого совпадает с параметром типа для метода. В этом случае аргумент типа указывать не обязательно. При использовании вывода для всех параметров типа синтаксис вызова универсальных и неуниверсальных методов экземпляра является одинаковым; он повышает удобство использования универсальных методов. |
| CA1005 | [CA1005: Избегайте слишком много параметров в универсальных типах](../code-quality/ca1005-avoid-excessive-parameters-on-generic-types.md) | Чем больше параметров типов содержит универсальный тип, тем сложнее знать и запоминать, что представляет каждый параметр типа. Обычно ситуация очевидна при использовании одного параметра типа, как и в списке\<T > и в ряде случаев при двух параметрах типов, как в Dictionary\<TKey, TValue >. Если же используется более двух параметров типов, многие пользователи начинают испытывать большие трудности. |
| CA1006 | [CA1006: Не вкладывайте универсальные типы в сигнатурах членов](../code-quality/ca1006-do-not-nest-generic-types-in-member-signatures.md) | Аргумент вложенного типа также является аргументом универсального типа. Чтобы вызвать член, сигнатура которого содержит аргумент вложенного типа, пользователь должен создать экземпляр одного универсального типа и передать этот тип конструктору второго универсального типа. Это приводит к усложнению процедуры и синтаксиса, чего следует избегать. |
| CA1007 |[CA1007: Используйте универсальные типы в том случае, если это уместно](../code-quality/ca1007-use-generics-where-appropriate.md) | Видимый извне метод содержит ссылочный параметр типа System.Object. Использование универсального метода позволяет передавать в метод все типы без предварительного приведения к типу ссылочного параметра при условии выполнения некоторых ограничений. |
| CA1008 | [CA1008: Перечисления должны иметь нулевое значение](../code-quality/ca1008-enums-should-have-zero-value.md) | Значение по умолчанию неинициализированного перечисления, как и других типов значений, равно нулю. Перечисление без флагов в качестве атрибутов должно определять член с использованием нулевого значения так, чтобы значение по умолчанию было допустимым значением перечисления. Если перечисление с примененным атрибутом FlagsAttribute определяет член с нулевым значением, для него должно быть задано имя None, свидетельствующее о том, что в перечислении не были заданы значения. |
| CA1009 | [CA1009: Правильно объявите обработчики событий](../code-quality/ca1009-declare-event-handlers-correctly.md) | Методы обработчиков событий принимают два параметра. Первый параметр принадлежит типу System.Object и называется "sender". Это объект, вызвавший событие. Второй параметр принадлежит типу System.EventArgs и называется "e". Это данные, связанные с событием. Методы обработки событий не должны возвращать значение; в языке программирования C# оно обозначается возвращаемым типом void. |
| CA1010 | [CA1010: Коллекции должны реализовывать универсальный интерфейс](../code-quality/ca1010-collections-should-implement-generic-interface.md) | Чтобы расширить возможности использования коллекции, реализуйте один из универсальных интерфейсов коллекции. Затем данную коллекцию можно использовать для заполнения универсальных типов коллекции. |
| CA1011 |[CA1011: Попробуйте передать базовые типы в качестве параметров](../code-quality/ca1011-consider-passing-base-types-as-parameters.md) | Если в объявлении метода в качестве параметра указан базовый тип, любой тип, производный от базового, можно передать методу в качестве соответствующего аргумента. Если дополнительные функции, предоставляемые производным типом параметра, не требуются, то использование базового типа позволит более широко применять данный метод. |
| CA1012 | [CA1012: Абстрактные типы не должны иметь конструкторы](../code-quality/ca1012-abstract-types-should-not-have-constructors.md) | Конструкторы абстрактных типов могут быть вызваны только производными типами. Открытые конструкторы создают экземпляры типа. Невозможно создавать экземпляры абстрактного типа; абстрактный тип с открытым конструктором является недопустимым. |
| CA1013 | [CA1013: Перегружайте оператор равенства при перегрузке Добавление и вычитание](../code-quality/ca1013-overload-operator-equals-on-overloading-add-and-subtract.md) | Открытый или защищенный тип реализует операторы сложения или вычитания без реализации оператора равенства. |
| CA1014 | [CA1014: Пометьте сборки атрибутом CLSCompliantAttribute](../code-quality/ca1014-mark-assemblies-with-clscompliantattribute.md) | Спецификация среды CLS определяет ограничения по именованию, типам данных и правилам, которым должны соответствовать сборки, предназначенные для использования в нескольких языках программирования. Для всех сборок рекомендуется явным образом указывать совместимость с CLS с помощью атрибута <xref:System.CLSCompliantAttribute>. Если этот атрибут у сборки отсутствует, сборка несовместима. |
| CA1016 | [CA1016: Пометьте сборки атрибутом AssemblyVersionAttribute](../code-quality/ca1016-mark-assemblies-with-assemblyversionattribute.md) | Архитектура .NET использует номер версии для уникального обозначения сборки и для привязки к типам в сборках со строгими именами. Номер версии используется наряду с политикой версий и издателя. По умолчанию приложения выполняются только с версией сборки, которая использовалась для их построения. |
| CA1017 | [CA1017: Пометьте сборки атрибутом ComVisibleAttribute](../code-quality/ca1017-mark-assemblies-with-comvisibleattribute.md) |Атрибут ComVisibleAttribute определяет порядок обращения клиентов COM к управляемому коду. Для правильной разработки сборки должны явным образом указывать видимость COM. Можно задать видимость COM для всей сборки, а затем переопределить ее для отдельных типов и элементов типов. Если атрибут отсутствует, содержимое сборки будет видимым клиентам COM. |
| CA1018 | [CA1018: Пометьте атрибуты с помощью AttributeUsageAttribute](../code-quality/ca1018-mark-attributes-with-attributeusageattribute.md) | При определении настраиваемого атрибута его нужно пометить атрибутом AttributeUsageAttribute, чтобы указать, где можно применять этот настраиваемый атрибут в исходном коде. Допустимое положение атрибута в коде зависит от значения атрибута и его применения. |
| CA1019 | [CA1019: НЕОБХОДИМО Определять методы доступа для аргументов атрибутов](../code-quality/ca1019-define-accessors-for-attribute-arguments.md) | Атрибуты могут определять обязательные аргументы, которые должны быть указаны при применении атрибута к целевому объекту. Они также известны как позиционные аргументы, поскольку предоставляются для конструкторов атрибутов в качестве позиционных параметров. Для каждого обязательного аргумента атрибут должен предоставлять соответствующее свойство, доступное только для чтения, чтобы извлечь значение аргумента во время выполнения. Кроме того, атрибуты могут определять дополнительные параметры, известные как именованные аргументы. Эти аргументы предоставляются для конструкторов атрибутов по имени и должны иметь соответствующее свойство чтения/записи. |
| CA1020 | [CA1020: Не используйте пространства имен с несколькими типами](../code-quality/ca1020-avoid-namespaces-with-few-types.md) | Убедитесь, что каждое из используемых пространств имен имеет логическую организацию и существует веская причина для помещения типов в сильно разреженное пространство имен. |
| CA1021 | [CA1021: Не используйте параметры out](../code-quality/ca1021-avoid-out-parameters.md) | Для реализации передачи типов по ссылке (с помощью ключевого слова out или ref) от разработчика требуется опыт работы с указателями, понимание отличия между типами значения и ссылочными типами и умение работать с методами с несколькими возвращаемыми значениями. Кроме того, далеко не все понимают разницу между параметрами out и ref. |
| CA1023 | [CA1023: ИНДЕКСЫ Индексаторы не должны быть многомерными](../code-quality/ca1023-indexers-should-not-be-multidimensional.md) | Для индексаторов (индексированных свойств) должен использоваться один индекс. Многомерные индексаторы могут крайне отрицательно сказаться на удобстве работы с библиотекой. |
| CA1024 | [CA1024: Используйте свойства, если это уместно](../code-quality/ca1024-use-properties-where-appropriate.md) | Имя открытого или защищенного метода начинается с Get, он не принимает параметры и возвращает значение, не являющееся массивом. Возможно, этот метод лучше преобразовать в свойство. |
| CA1025 | [CA1025: Замените повторяющиеся аргументы массивом параметров](../code-quality/ca1025-replace-repetitive-arguments-with-params-array.md) | Если точное число аргументов неизвестно и эти аргументы принадлежат одному типу или могут быть переданы как аргументы одного типа, используйте вместо повторяющихся аргументов массив параметров. |
| CA1026 | [CA1026: Не следует использовать параметры по умолчанию](../code-quality/ca1026-default-parameters-should-not-be-used.md) | Методы, использующие параметры по умолчанию, разрешены по спецификации CLS; однако спецификация CLS разрешает компиляторам не учитывать значения, присвоенные этим параметрам. Для однородной работы с различными языками программирования следует заменять методы, использующие параметры по умолчанию, на перегрузки методов, предоставляющие параметры по умолчанию. |
| CA1027 |[CA1027: СЛЕДУЕТ Помечать перечисления атрибутом FlagsAttribute](../code-quality/ca1027-mark-enums-with-flagsattribute.md) | Перечисление является типом значения, которое определяет набор связанных именованных констант. Атрибут FlagsAttribute применяется к перечислению, когда его именованные константы могут быть объединены осмысленным образом. |
| CA1028 | [CA1028: Хранилище перечислений должно иметь тип Int32](../code-quality/ca1028-enum-storage-should-be-int32.md) | Перечисление является типом значения, которое определяет набор связанных именованных констант. По умолчанию для хранения значения константы используется тип данных System.Int32. Этот базовый тип можно изменить, но это не требуется и в большинстве случаев не рекомендуется. |
| CA1030 | [CA1030: Используйте события, если это уместно](../code-quality/ca1030-use-events-where-appropriate.md) |Данное правило отслеживает методы с именами, которые, как правило, используются для событий. Если метод вызывается в ответ на четко определенное изменение состояния, то этот вызов должен осуществляться с помощью обработчика событий. Объекты, вызывающие методы, должны создавать события, а не вызывать методы напрямую. |
| CA1031 | [CA1031: Не перехватывайте типы общих исключений](../code-quality/ca1031-do-not-catch-general-exception-types.md) | Общие исключения не должны перехватываться. Нужно перехватить исключение более конкретного характера или повторно выдать общее исключение в последнем операторе блока catch. |
| CA1032 |[CA1032: Реализуйте стандартные конструкторы исключения](../code-quality/ca1032-implement-standard-exception-constructors.md) | Для правильной обработки исключений необходимо предоставить полный набор конструкторов. |
| CA1033 | [CA1033: Методы интерфейса должны быть дочерним типам](../code-quality/ca1033-interface-methods-should-be-callable-by-child-types.md) | Незапечатанный тип, доступный для внешнего кода, предоставляет явную реализацию метода открытого интерфейса и не предоставляет доступный для внешнего кода альтернативный метод с тем же именем. |
| CA1034 | [CA1034: Вложенные типы не должны быть видимыми](../code-quality/ca1034-nested-types-should-not-be-visible.md) | Вложенный тип — это тип, объявленный внутри области другого типа. Вложенные типы удобно использовать для инкапсуляции закрытых сведений о реализациях содержащего их типа. В силу этого вложенные типы не должны быть видимыми для внешнего кода. |
| CA1035 | [CA1035: Реализаций ICollection есть строго типизированные элементы](../code-quality/ca1035-icollection-implementations-have-strongly-typed-members.md) | Это правило требует, чтобы реализации ICollection предоставляли строго типизированные элементы, поскольку тогда пользователям не придется приводить аргументы к типу Object при использовании функциональных возможностей интерфейса. В этом правиле предполагается, что тип, реализующий интерфейс ICollection, делает это для управления коллекцией экземпляров типа, более строгого, чем Object. |
| CA1036 | [CA1036: Переопределите методы в сравнимых типах](../code-quality/ca1036-override-methods-on-comparable-types.md) |Открытый или защищенный тип реализует интерфейс System.IComparable. Он не переопределяет метод Object.Equals и не перегружает языковой оператор равенства, неравенства, "больше" или "меньше". |
| CA1038 | [CA1038: Перечислители должны быть строго типизированы](../code-quality/ca1038-enumerators-should-be-strongly-typed.md) | Это правило требует, чтобы реализации IEnumerator предоставляли строго типизированную версию свойства Current, поскольку тогда пользователям не придется приводить возвращаемое значение к строгому типу при использовании функциональных возможностей интерфейса. |
| CA1039 | [CA1039: Списки обладают строгой типизацией](../code-quality/ca1039-lists-are-strongly-typed.md) | Это правило требует, чтобы реализации IList предоставляли строго типизированные элементы, поскольку тогда пользователям не придется приводить аргументы к типу System.Object при использовании функциональных возможностей интерфейса. |
| CA1040 |[CA1040: Избегайте пустых интерфейсов](../code-quality/ca1040-avoid-empty-interfaces.md) | Интерфейсы определяют члены, предоставляющие поведение или соглашение об использовании. Функциональность, описанная интерфейсом, может быть использована любым типом вне зависимости от расположения типа в иерархии интерфейса. Тип реализует интерфейс путем предоставления реализаций для членов интерфейса. Пустой интерфейс не определяет никаких элементов, поэтому он не определяет контракт, который можно реализовать. |
| CA1041 | [CA1041: Укажите сообщение ObsoleteAttribute](../code-quality/ca1041-provide-obsoleteattribute-message.md) | Тип или элемент помечен атрибутом System.ObsoleteAttribute, для которого не указано свойство ObsoleteAttribute.Message. При компиляции типа или элемента, помеченного атрибутом ObsoleteAttribute, отображается текст свойства Message этого атрибута. Это предоставляет пользователю сведения об устаревшем типе или члене. |
| CA1043 | [CA1043: Используйте целый или строковый аргумент для индексаторов](../code-quality/ca1043-use-integral-or-string-argument-for-indexers.md) | Индексаторы (индексированные свойства) должны использовать для индекса целочисленные или строковые типы. Эти типы обычно используются для индексации структур данных и повышения удобства использования библиотеки. Тип Object следует использовать только в том случае, если во время разработки невозможно указать определенный целочисленный или строковый тип. |
| CA1044 | [CA1044: Свойства не должны быть доступны только для записи](../code-quality/ca1044-properties-should-not-be-write-only.md) | Несмотря на то, что допустимо, а часто и необходимо иметь свойство, доступное только на чтение, рекомендации по разработке запрещают использование свойств, доступных только на запись. Это связано с тем, что если позволить пользователю задать значение, а затем запретить ему просматривать это значение, то таким образом не будет обеспечиваться какая-либо безопасность. Кроме того, при отсутствии доступа на чтение нельзя просмотреть состояние общих объектов, что снижает их полезность. |
| CA1045 |[CA1045: Не передавайте типы по ссылке](../code-quality/ca1045-do-not-pass-types-by-reference.md) | Для реализации передачи типов по ссылке (с помощью ключевого слова out или ref) от разработчика требуется опыт работы с указателями, понимание отличия между типами значения и ссылочными типами и умение работать с методами с несколькими возвращаемыми значениями. Архитекторам библиотеки для широкого использования, не стоит ожидать, пользователи, разрабатывающим `out` или `ref` параметров. |
| CA1046 | [CA1046: Не перегружайте оператор равенства для ссылочных типов](../code-quality/ca1046-do-not-overload-operator-equals-on-reference-types.md) | Реализация оператора равенства по умолчанию почти всегда правильно работает для ссылочных типов. По умолчанию две ссылки равны, если они указывают на один объект. |
| CA1047 |[CA1047: Не объявляйте защищенные члены в запечатанных типах](../code-quality/ca1047-do-not-declare-protected-members-in-sealed-types.md) | Типы объявляют защищенный члены таким образом, чтобы наследующие типы могли получить доступ к члену или переопределить его. По определению наследовать запечатанные типы нельзя; это означает, что вызов защищенных методов для запечатанных типов невозможен. |
| CA1048 | [CA1048: Не объявляйте виртуальные члены в запечатанных типах](../code-quality/ca1048-do-not-declare-virtual-members-in-sealed-types.md) | Типы объявляют методы как виртуальные, чтобы наследующие типы могли переопределять реализацию виртуального метода. По определению наследовать запечатанный тип нельзя. При этом виртуальный метод запечатанного типа теряет смысл. |
| CA1049 | [CA1049: Типы, которым принадлежат собственные ресурсы, должны быть освобождаемыми](../code-quality/ca1049-types-that-own-native-resources-should-be-disposable.md) | Типы, выделяющие неуправляемые ресурсы, должны реализовывать интерфейс IDisposable, чтобы вызывающие методы могли высвобождать эти ресурсы по требованию и сокращать время существования объектов, занимающих ресурсы. |
| CA1050 | [CA1050: Объявите типы в пространствах имен](../code-quality/ca1050-declare-types-in-namespaces.md) | Типы объявляются в пространствах имен во избежание конфликтов имен и с целью упорядочения связанных типов в иерархии объектов. |
| CA1051 | [CA1051: Не объявляйте видимые поля экземпляров](../code-quality/ca1051-do-not-declare-visible-instance-fields.md) | Поля главным образом следует использовать для данных реализации. Поля должны быть помечены как private или internal и должны быть представлены с помощью свойств. |
| CA1052 | [CA1052: Типы со статическими заполнителями должны быть запечатаны](../code-quality/ca1052-static-holder-types-should-be-sealed.md) | Открытый или защищенный тип содержит только статические элементы и не объявлен с модификатором sealed (справочник по C#) (NotInheritable). Тип, для которого нельзя создавать унаследованные типы, должен быть помечен модификатором sealed, чтобы его нельзя было использовать как базовый тип. |
| CA1053 |[CA1053: Типы со статическими заполнителями не должны иметь конструкторы](../code-quality/ca1053-static-holder-types-should-not-have-constructors.md) | В открытом или вложенном открытом типе объявляются только статические элементы и имеется открытый или защищенный конструктор по умолчанию. Конструктор не нужен, поскольку при вызове статических членов не требуется экземпляр типа. Для обеспечения безопасности перегруженная строка должна вызывать перегрузку универсального кода ресурса (URI), используя строковый аргумент. |
| CA1054 | [CA1054: Параметры URI не должны быть строками](../code-quality/ca1054-uri-parameters-should-not-be-strings.md) | Если метод принимает строковое представление универсального кода ресурса (URI), необходимо предоставить соответствующую перегрузку, принимающую экземпляр класса URI, который предоставляет эти услуги безопасным образом. |
| CA1055 | [CA1055: URI возвращать значения не должны быть строками](../code-quality/ca1055-uri-return-values-should-not-be-strings.md) | В этом правиле предполагается, что метод возвращает универсальный код ресурса (URI). В строковых представлениях кода URI часто встречаются ошибки синтаксического анализа и кодирования, которые могут привести к уязвимостям системы безопасности. Класс System.Uri предоставляет аналогичные услуги более надежным и безопасным способом. |
| CA1056 | [CA1056: Свойства URI не должны быть строками](../code-quality/ca1056-uri-properties-should-not-be-strings.md) | В этом правиле предполагается, что свойство является универсальным кодом ресурса (URI). В строковых представлениях кода URI часто встречаются ошибки синтаксического анализа и кодирования, которые могут привести к уязвимостям системы безопасности. Класс System.Uri предоставляет аналогичные услуги более надежным и безопасным способом. |
| CA1057 | [CA1057: Строка URI вызывают перегрузки System.Uri](../code-quality/ca1057-string-uri-overloads-call-system-uri-overloads.md) | Тип объявляет перегрузки метода, которые отличаются только заменой строкового параметра на параметр System.Uri. Эта перегрузка, которая принимает строковый параметр, не вызывает перегрузку, которая принимает параметр URI. |
| CA1058 | [CA1058: Типы не должны расширять определенные базовые типы](../code-quality/ca1058-types-should-not-extend-certain-base-types.md) | Видимый извне тип расширяет некоторые базовые типы. Используйте только один вариант. |
| CA1059 |[CA1059: Члены не должны предоставлять определенные устойчивые типы](../code-quality/ca1059-members-should-not-expose-certain-concrete-types.md) | Устойчивый тип – это тип, который имеет полную реализацию и экземпляр которого можно создать. Чтобы иметь возможность широкого использования этого элемента, замените конкретный тип предложенным интерфейсом. |
| CA1060 | [CA1060: Переместите P/Invokes в класс NativeMethods](../code-quality/ca1060-move-p-invokes-to-nativemethods-class.md) | Методы PInvoke, например методы, помеченные атрибутом System.Runtime.InteropServices.DllImportAttribute, или методы, определенные с помощью ключевого слова Declare в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)], обращаются к неуправляемому коду. Эти методы должны относиться к классу NativeMethods, SafeNativeMethods или UnsafeNativeMethods. |
| CA1061 |[CA1061: Не следует скрывать методы базового класса](../code-quality/ca1061-do-not-hide-base-class-methods.md) | Метод в базовом типе скрыт методом с таким же именем в производном типе. Сигнатура параметра производного метода отличается только типами, которые являются более слабыми, чем соответствующие типы в сигнатуре параметра базового метода. |
| CA1062 | [CA1062: Проверьте аргументы открытых методов](../code-quality/ca1062-validate-arguments-of-public-methods.md) | Все ссылочные аргументы, передаваемые в видимые для внешнего кода методы, должны проверяться на равенство значению NULL. |
| CA1063 | [CA1063: Правильно реализуйте IDisposable](../code-quality/ca1063-implement-idisposable-correctly.md) | Все типы IDisposable должны правильно реализовывать шаблон "Dispose". |
| CA1064 | [CA1064: Исключения должны быть открытыми](../code-quality/ca1064-exceptions-should-be-public.md) | Внутреннее исключение видно только внутри своей внутренней области. После выхода исключения за пределы внутренней области для перехвата исключения можно использовать только базовое исключение. Если внутренне исключение унаследовано от <xref:System.Exception>, <xref:System.SystemException>, или <xref:System.ApplicationException>, внешний код не будет иметь достаточно сведений, чтобы знать, что делать с исключением. |
| CA1065 | [CA1065: Не вызывайте исключения в непредвиденных местах](../code-quality/ca1065-do-not-raise-exceptions-in-unexpected-locations.md) | Метод вызывает исключение, хотя не должен этого делать. |
| CA1300 | [CA1300: Укажите MessageBoxOptions](../code-quality/ca1300-specify-messageboxoptions.md) | Чтобы окно сообщения для языков, в которых используется порядок чтения справа налево, отображалось правильно, методу Show следует передать члены RightAlign и RtlReading перечисления MessageBoxOptions. |
| CA1301 | [CA1301: Не](../code-quality/ca1301-avoid-duplicate-accelerators.md) | Клавиша доступа, также называемая клавишей быстрого доступа, обеспечивает клавиатурный доступ к элементу управления с помощью клавиши ALT. При нескольких элементов управления имеют дублирующиеся клавиши доступа, поведение клавиши доступа не является четко определенным. |
| CA1302 | [CA1302: Делать не следует жестко кодировать строки](../code-quality/ca1302-do-not-hardcode-locale-specific-strings.md) | Перечисление System.Environment.SpecialFolder содержит члены, ссылающиеся на специальные системные папки. Расположение этих папок может различаться в разных ОС, пользователь может менять расположение этих папок, их имена могут быть локализованы. Метод Environment.GetFolderPath возвращает связанные с перечислением Environment.SpecialFolder расположения в локализованной форме, подходящей для использования на работающем в данный момент компьютере. |
| CA1303 | [CA1303: Не следует передавать литералы в виде локализованных параметров](../code-quality/ca1303-do-not-pass-literals-as-localized-parameters.md) | Внешне видимый метод передает строку литерал в качестве параметра .NET конструктору или методу, и эта строка должна быть локализуемой. |
| CA1304 | [CA1304: Укажите CultureInfo](../code-quality/ca1304-specify-cultureinfo.md) | Метод или конструктор вызывает член, имеющий перегрузку, которая принимает параметр System.Globalization.CultureInfo, вместо того чтобы вызвать перегрузку, принимающую параметр CultureInfo. Если объект CultureInfo или System.IFormatProvider не предоставляется, значение по умолчанию, поставляемое перегруженным членом, может не оказать ожидаемого воздействия во всех языковых стандартах. |
| CA1305 | [CA1305: Укажите IFormatProvider](../code-quality/ca1305-specify-iformatprovider.md) | Метод или конструктор вызывает один или несколько членов, имеющих перегрузки, которые принимают параметр System.IFormatProvider, вместо того чтобы вызвать перегрузку, принимающую параметр IFormatProvider. Если объект System.Globalization.CultureInfo или IFormatProvider не предоставляется, значение по умолчанию, поставляемое перегруженным членом, может не оказать ожидаемого воздействия во всех языковых стандартах. |
| CA1306 | [CA1306: Задавайте языковой стандарт для типов данных](../code-quality/ca1306-set-locale-for-data-types.md) | Язык и региональные параметры определяют представление элементов данных, таких как формат чисел, обозначение денежных единиц и порядок сортировки. При создании объектов DataTable или DataSet следует явным образом указывать языковой стандарт. |
| CA1307 | [CA1307: Укажите StringComparison](../code-quality/ca1307-specify-stringcomparison.md) | В операции сравнения строк используется перегрузка метода, которая не задает параметр StringComparison. |
| CA1308 |[CA1308: Строки следует нормализовать в верхний регистр](../code-quality/ca1308-normalize-strings-to-uppercase.md) | Строки следует нормализовать в верхний регистр. Существует небольшая группа символов, которые после преобразования в нижний регистр не могут участвовать в круговом перемещении. |
| CA1309 | [CA1309: Используйте порядковый параметр StringComparison](../code-quality/ca1309-use-ordinal-stringcomparison.md) | Операция сравнения строк, не являющаяся лингвистической, не задает для параметра StringComparison ни значения Ordinal, ни значения OrdinalIgnoreCase. После явного задания для параметра значения StringComparison.Ordinal или StringComparison.OrdinalIgnoreCase код часто становится более надежным и правильным, кроме того, увеличивается скорость его выполнения. |
| CA1400 | [CA1400: Должны существовать точки входа P/Invoke](../code-quality/ca1400-p-invoke-entry-points-should-exist.md) |Открытый или защищенный метод, помеченный атрибутом System.Runtime.InteropServices.DllImportAttribute. Не удается найти неуправляемую библиотеку либо не удается сопоставить метод функции в библиотеке. |
| CA1401 | [CA1401: P/Invoke не должны быть видимыми](../code-quality/ca1401-p-invokes-should-not-be-visible.md) | Открытый или защищенный метод в открытом типе имеет атрибут System.Runtime.InteropServices.DllImportAttribute (также реализуется в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)] с помощью ключевого слова Declare). Такие методы не следует делать видимыми. |
| CA1402 |[CA1402: Не используйте перегрузки в интерфейсах, видимых COM](../code-quality/ca1402-avoid-overloads-in-com-visible-interfaces.md) | Когда перегруженные методы предоставляются клиентам COM, сохраняется имя только первой перегрузки метода. Последующие перегрузки переименовываются уникальным образом путем добавления к имени символа подчеркивания (_) и целого числа, соответствующего порядку объявления перегрузки. |
| CA1403 | [CA1403: Типы с автомакетом не должны быть видимыми для COM](../code-quality/ca1403-auto-layout-types-should-not-be-com-visible.md) | Видимый для модели COM тип значения помечается атрибутом System.Runtime.InteropServices.StructLayoutAttribute, имеющим значение LayoutKind.Auto. Макеты этих типов можно изменить в разных версиях .NET, что нарушит работу клиентов COM, которые ожидают определенного макета. |
| CA1404 | [CA1404: Вызывайте GetLastError сразу после P/Invoke](../code-quality/ca1404-call-getlasterror-immediately-after-p-invoke.md) | Выполняется вызов метода Marshal.GetLastWin32Error или эквивалентной [!INCLUDE[TLA2#tla_win32](../code-quality/includes/tla2sharptla_win32_md.md)] Функция GetLastError, а непосредственно предшествующий вызов не операционную систему вызов метода. |
| CA1405 | [CA1405: Базовые типы типу видимых COM должны быть видимыми для COM](../code-quality/ca1405-com-visible-type-base-types-should-be-com-visible.md) | Тип, видимый для модели COM, наследует от типа, который не является видимым для COM. |
| CA1406 |[CA1406: Не используйте аргументы Int64 для клиентов Visual Basic 6](../code-quality/ca1406-avoid-int64-arguments-for-visual-basic-6-clients.md) | Клиенты COM Visual Basic 6 не может получить доступ к 64-разрядных целых чисел. |
| CA1407 |[CA1407: Не используйте статические члены в видимых COM типах](../code-quality/ca1407-avoid-static-members-in-com-visible-types.md) | Модель COM не поддерживает статические методы. |
| CA1408 | [CA1408: Не используйте AutoDual ClassInterfaceType](../code-quality/ca1408-do-not-use-autodual-classinterfacetype.md) | Типы, использующие сдвоенный интерфейс, позволяют клиентам выполнять привязку к определенному макету интерфейса. Все изменения в будущей версии макета типа и в базовых типах приведут к нарушению работы COM-клиентов, связанных с интерфейсом. По умолчанию, если атрибут ClassInterfaceAttribute не указан, используется только диспетчерский интерфейс. |
| CA1409 | [CA1409: Видимые COM-типы должны быть создаваемыми](../code-quality/ca1409-com-visible-types-should-be-creatable.md) |Ссылочный тип, который специально помечен как видимый для модели COM, содержит открытый параметризованный конструктор, но не содержит открытого конструктора по умолчанию (без параметров). COM-клиенты не могут создавать объекты типа, не содержащего открытый конструктор по умолчанию. |
| CA1410 | [CA1410: Методы регистрации COM должны быть соответствующими](../code-quality/ca1410-com-registration-methods-should-be-matched.md) | Тип объявляет метод, помеченный атрибутом System.Runtime.InteropServices.ComRegisterFunctionAttribute, но не объявляет метод, помеченный атрибутом System.Runtime.InteropServices.ComUnregisterFunctionAttribute, или наоборот. |
| CA1411 | [CA1411: Методы регистрации COM не должны быть видимыми](../code-quality/ca1411-com-registration-methods-should-not-be-visible.md) | Метод, помеченный атрибутом System.Runtime.InteropServices.ComRegisterFunctionAttribute или атрибутом System.Runtime.InteropServices.ComUnregisterFunctionAttribute, видим извне. |
| CA1412 | [CA1412: Помечайте интерфейсы ComSource как IDispatch](../code-quality/ca1412-mark-comsource-interfaces-as-idispatch.md) | Тип помечен атрибутом System.Runtime.InteropServices.ComSourceInterfacesAttribute, однако по крайней мере один из указанных интерфейсов не помечен атрибутом System.Runtime.InteropServices.InterfaceTypeAttribute, значение которого равно ComInterfaceType.InterfaceIsIDispatch. |
| CA1413 | [CA1413: Избегайте не открытых полей в видимых типах значений COM](../code-quality/ca1413-avoid-non-public-fields-in-com-visible-value-types.md) | Не являющиеся общедоступными поля экземпляров типов значений, отображаемых для модели COM, отображаются для COM-клиентов. Проверьте содержимое полей на наличие сведений, к которым не должен предоставляться доступ или которые могут оказать непреднамеренное воздействие на разработку или безопасность. |
| CA1414 | [CA1414: Пометьте логические аргументы P/Invoke с помощью атрибута MarshalAs](../code-quality/ca1414-mark-boolean-p-invoke-arguments-with-marshalas.md) | Логический тип данных имеет несколько представлений в неуправляемом коде. |
| CA1415 | [CA1415: Правильно объявляйте методы P/Invoke](../code-quality/ca1415-declare-p-invokes-correctly.md) | Это правило используется для поиска объявлений методов вызова операционной системы, предназначенных для функций [!INCLUDE[TLA2#tla_win32](../code-quality/includes/tla2sharptla_win32_md.md)], имеющих указатель на параметр структуры OVERLAPPED, если соответствующий управляемый параметр не является указателем на структуру System.Threading.NativeOverlapped. |
| CA1500 | [CA1500: Имена переменных не должны совпадать с именами полей](../code-quality/ca1500-variable-names-should-not-match-field-names.md) | Метод экземпляра объявляет параметр или локальную переменную, чье имя совпадает с именем поля экземпляра объявляющего типа, что ведет к возникновению ошибок. |
| CA1501 | [CA1501: Избегайте излишнего наследования](../code-quality/ca1501-avoid-excessive-inheritance.md) | Тип расположен глубже четырех уровней в иерархии наследования. Глубокие иерархии вложенных типов трудно отслеживать, понимать и поддерживать. |
| CA1502 | [CA1502: Избегайте чрезмерной сложности](../code-quality/ca1502-avoid-excessive-complexity.md) | Это правило измеряет число линейно независимых путей в методе, которое определяется числом и сложностью условных ветвей. |
| CA1504 | [CA1504: Проверьте имена полей, вводит в заблуждение](../code-quality/ca1504-review-misleading-field-names.md) | Имя поля экземпляра начинается с «s_» или имя статического (Shared в Visual Basic) поля начинается с «m_». |
| CA1505 | [CA1505: Избегайте кода, неудобного для поддержки](../code-quality/ca1505-avoid-unmaintainable-code.md) | Тип или метод имеет низкий индекс обслуживаемости. Низкий индекс удобства поддержки означает, что тип или метод, вероятно, трудно поддерживать, поэтому их следует переработать. |
| CA1506 |[CA1506: Избегайте чрезмерного соединения классов](../code-quality/ca1506-avoid-excessive-class-coupling.md) | Данное правило измеряет взаимозависимость классов путем подсчета количества уникальных ссылок на типы, содержащихся в типе или методе. |
| CA1600 | [CA1600: Не используйте приоритет процессов](../code-quality/ca1600-do-not-use-idle-process-priority.md) | Не задавайте для приоритета процесса значение Idle. Процессы с приоритетом System.Diagnostics.ProcessPriorityClass.Idle будут занимать ЦП, который иначе простаивал бы, и тем самым блокировать работу в режиме ожидания. |
| CA1601 | [CA1601: Не используйте таймеры, препятствующие изменению состояния электропитания](../code-quality/ca1601-do-not-use-timers-that-prevent-power-state-changes.md) | Повышение частоты периодических действий приводит к дополнительной нагрузке на ЦП и препятствует работе таймеров энергосберегающих режимов, которые отключают монитор и жесткие диски. |
| CA1700 | [CA1700: Не значения перечислений именем «Reserved»](../code-quality/ca1700-do-not-name-enum-values-reserved.md) | В данном правиле предполагается, что член перечисления, имя которого содержит слово "reserved", не используется в настоящее время, а является местозаполнителем, который будет в дальнейшем переименован или удален. Переименование или удаление элемента — это критическое изменение. |
| CA1701 | [CA1701: Составных словах строк ресурса должны иметь правильный регистр](../code-quality/ca1701-resource-string-compound-words-should-be-cased-correctly.md) | Каждое слово в строке ресурса разделяется на лексемы на основе регистра (заглавных букв). Каждое непрерывное сочетание двух токенов проверяется библиотекой проверки орфографии Майкрософт. При совпадении слово создает нарушение правила. |
| CA1702 | [CA1702: Составные слова должны иметь правильный регистр](../code-quality/ca1702-compound-words-should-be-cased-correctly.md) | Имя идентификатора состоит из нескольких слов, и по крайней мере одно из них является составным словом в неправильном регистре. |
| CA1703 | [CA1703: Строки ресурсов должны иметь правильное правописание](../code-quality/ca1703-resource-strings-should-be-spelled-correctly.md) | Строка ресурса содержит одно или несколько слов, не распознанных библиотекой системы проверки правописания Майкрософт. |
| CA1704 | [CA1704: Идентификаторы должны иметь правильное правописание](../code-quality/ca1704-identifiers-should-be-spelled-correctly.md) | Имя видимого для внешнего кода идентификатора содержит одно или несколько слов, не распознаваемых библиотекой средства проверки орфографии (Microsoft). |
| CA1707 | [CA1707: Идентификаторы не должны содержать знак подчеркивания](../code-quality/ca1707-identifiers-should-not-contain-underscores.md) | В соответствии с соглашением имена идентификаторов не могут содержать знак подчеркивания (_). Это правило позволяет проверить пространства имен, типы, элементы и параметры. |
| CA1708 | [CA1708: Идентификаторы должны отличаться регистром](../code-quality/ca1708-identifiers-should-differ-by-more-than-case.md) | Идентификаторы пространств имен, типов, членов и параметров не могут отличаться только регистром знаков, поскольку языки программирования, поддерживаемые средой CLR, не обязательно учитывают регистр знаков. |
| CA1709 | [CA1709: Идентификаторы должны иметь правильный регистр](../code-quality/ca1709-identifiers-should-be-cased-correctly.md) | В соответствии с соглашением, в именах параметров используется смешанный регистр знаков, а в именах пространств имен, типов и членов — стиль языка Pascal. |
| CA1710 | [CA1710: Идентификаторы должны иметь правильные суффиксы](../code-quality/ca1710-identifiers-should-have-correct-suffix.md) |По правилам имена типов, расширяющих определенные базовые типы или реализующих определенные интерфейсы, а также типов, являющихся производными от первых, имеют суффикс, связанный с базовым типом или интерфейсом. |
| CA1711 | [CA1711: Идентификаторы не должны иметь неверных суффиксов](../code-quality/ca1711-identifiers-should-not-have-incorrect-suffix.md) | В соответствии с соглашением об именовании, определенные зарезервированные суффиксы должны добавляться только к именам типов, которые расширяют некоторые базовые типы или реализуют определенные интерфейсы, а также производных от них типов. В именах других типов зарезервированные суффиксы использоваться не должны. |
| CA1712 | [CA1712: Не добавляйте префикс в виде значения перечисления с именем типа](../code-quality/ca1712-do-not-prefix-enum-values-with-type-name.md) | Имена членов перечисления не должны содержать префиксов в виде имени типа, поскольку предполагается, что сведения о типе предоставляются средствами разработки. |
| CA1713 | [CA1713: События не должны иметь префикс before или after](../code-quality/ca1713-events-should-not-have-before-or-after-prefix.md) | Имя события начинается с Before или After. Чтобы дать имена связанным событиям, возникающим в определенной последовательности, используйте настоящее или прошедшее время, чтобы обозначить положение события в последовательности действий. |
| CA1714 | [CA1714: Перечислений флагов должны быть имена во множественном числе](../code-quality/ca1714-flags-enums-should-have-plural-names.md) | Открытое перечисление содержит атрибут System.FlagsAttribute, и имя перечисления не заканчивается на "s". Имена типов, помеченных атрибутом FlagsAttribute, используются во множественном числе, поскольку данный атрибут указывает на возможность задания нескольких значений. |
| CA1715 | [CA1715: Идентификаторы должны иметь правильные префиксы](../code-quality/ca1715-identifiers-should-have-correct-prefix.md) | Имя доступного для внешнего кода интерфейса не начинается с заглавной буквы "I". Имя параметра универсального типа в доступном для внешнего кода типе или методе не начинается с заглавной буквы "Т". |
| CA1716 | [CA1716: Идентификаторы не должны совпадать с ключевыми словами](../code-quality/ca1716-identifiers-should-not-match-keywords.md) | Имя пространства имен или типа совпадает с ключевым словом, зарезервированным в языке программирования. Идентификаторы пространств имен и типов не должны совпадать с ключевыми словами, определенными в языках, поддерживаемых в среде CLR. |
| CA1717 | [CA1717: Только перечисления FlagsAttribute должны иметь имена во множественном числе](../code-quality/ca1717-only-flagsattribute-enums-should-have-plural-names.md) | Согласно правилам именования множественное число имени перечисления указывает, что одновременно можно задать несколько значений перечисления. |
| CA1719 | [CA1719: Имена параметров не должны совпадать с именами элементов](../code-quality/ca1719-parameter-names-should-not-match-member-names.md) | Имя параметра должно передавать смысловое значение параметра, а имя члена — смысловое значение члена. Они могут совпадать лишь в очень редких случаях. Присвоение параметру имени содержащего его члена кажется неестественным и затрудняет использование библиотеки. |
| CA1720 |[CA1720: Идентификаторы не должны содержать имен типов](../code-quality/ca1720-identifiers-should-not-contain-type-names.md) | Имя параметра в доступном для внешнего кода элементе содержит имя типа данных, или имя доступного для внешнего кода элемента содержит языковое имя типа данных. |
| CA1721 | [CA1721: Методы get не должны совпадать с именами свойств](../code-quality/ca1721-property-names-should-not-match-get-methods.md) |Имя открытого или защищенного элемента начинается с Get и соответствует имени открытого или защищенного свойства и по другим параметрам. Методы Get и свойства должны иметь имена, позволяющие четко различать их функции. |
| CA1722 | [CA1722: Идентификаторы не должны иметь неверные префиксы](../code-quality/ca1722-identifiers-should-not-have-incorrect-prefix.md) | В соответствии с соглашением об именовании, только некоторые элементы программирования могут иметь имена, которые начинаются с особого префикса. |
| CA1724 | [CA1724: Имена типов не должны совпадать с пространствами имен](../code-quality/ca1724-type-names-should-not-match-namespaces.md) | Имена типов не должны совпадать с именами пространств имен .NET. Нарушение этого правила приводит к уменьшению функциональности библиотеки. |
| CA1725 | [CA1725: Имена параметров должны соответствовать базовому объявлению](../code-quality/ca1725-parameter-names-should-match-base-declaration.md) | Согласованное именование параметров в иерархии переопределений увеличивает удобство использования переопределений метода. Если имя параметра в производном методе отличается от имени в базовом объявлении, может возникнуть путаница в определении того, чем является метод: переопределением базового метода или новой перегрузкой. |
| CA1726 | [CA1726: Используйте предпочитаемые термины](../code-quality/ca1726-use-preferred-terms.md) | Имя видимого снаружи идентификатора включает термин, для которого существует другой предпочтительный термин. Кроме того, имя содержит термин Flag или Flags. |
| CA1800 | [CA1800: Не делайте лишних приведений](../code-quality/ca1800-do-not-cast-unnecessarily.md) | Повторяющиеся приведения снижают производительность, особенно если приведения выполняются в компактных операторах итераций. |
| CA1801 | [CA1801: Проверьте неиспользуемые параметры](../code-quality/ca1801-review-unused-parameters.md) | Сигнатура метода включает параметр, не использующийся в основной части метода. |
| CA1802 |[CA1802: При необходимости использовать литералы](../code-quality/ca1802-use-literals-where-appropriate.md) |Поле объявляется статичным и доступным только для чтения (Shared и ReadOnly в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]) и инициализируется со значением, вычисляемым во время компиляции. Поскольку значение, присвоенное конечному полю, вычисляется во время компиляции, замените объявление полем const (Const в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]) таким образом, чтобы значение вычисляется во время компиляции, а не во время выполнения. |
| CA1804 | [CA1804: Удалите неиспользуемые локальные переменные](../code-quality/ca1804-remove-unused-locals.md) | Неиспользуемые локальные переменные и ненужные присвоения увеличивают размер сборки и снижают производительность. |
| CA1806 | [CA1806: Не игнорируйте результаты метода](../code-quality/ca1806-do-not-ignore-method-results.md) | Создается, но никогда не используется новый объект, либо вызывается метод, который создает и возвращает новую строку, и такая новая строка никогда не используется, либо метод COM или P/Invoke возвращает HRESULT или код ошибки, который никогда не используется. |
| CA1809 |[CA1809: Избегайте чрезмерного использования локальных переменных](../code-quality/ca1809-avoid-excessive-locals.md) | Обычно для оптимизации производительности рекомендуется хранить значение не в памяти, а в регистре процессора. Это называется регистрацией значения. Чтобы увеличить вероятность того, что все локальные переменные, следует ограничить их, Ограничьте число локальных переменных до 64. |
| CA1810 | [CA1810: Инициализируйте статические поля ссылочного типа встроенными](../code-quality/ca1810-initialize-reference-type-static-fields-inline.md) | Если в типе объявляется явный статический конструктор, компилятор JIT добавляет проверку в каждый статический метод и конструктор экземпляров этого типа, чтобы убедиться, что статический конструктор уже вызывался ранее. Проверки статических конструкторов могут привести к снижению производительности. |
| CA1811 | [CA1811: Не используйте Невызываемый закрытый код](../code-quality/ca1811-avoid-uncalled-private-code.md) | Закрытый или внутренний член (член уровня сборки) не вызывается ни объектами сборки, ни средой CLR, ни делегатом. |
| CA1812 | [CA1812: Избегайте неиспользуемых внутренних классов](../code-quality/ca1812-avoid-uninstantiated-internal-classes.md) | Экземпляр типа уровня сборки не создается кодом в сборке. |
| CA1813 | [CA1813: Избегайте распечатанных атрибутов](../code-quality/ca1813-avoid-unsealed-attributes.md) | .NET предоставляет методы для извлечения пользовательских атрибутов. По умолчанию эти методы осуществляют поиск иерархии наследования атрибутов. Если запечатать атрибут, поиск в иерархии наследования выполняться не будет, в результате чего может повыситься производительность. |
| CA1814 | [CA1814: Используйте массивы массивов вместо многомерных](../code-quality/ca1814-prefer-jagged-arrays-over-multidimensional.md) | Массив массивов — это массив, элементы которого сами являются массивами. Массивы, которые составляют элементы, могут иметь различные размеры, что позволяет экономить пространство для некоторых наборов данных. |
| CA1815 | [CA1815: СЛЕДУЕТ Переопределяйте операторы Equals и равенства для типов значений](../code-quality/ca1815-override-equals-and-operator-equals-on-value-types.md) | В унаследованной реализации Equals для типов значений используется библиотека отражения и сравнивается содержимое всех полей. Отражение является процессом, требующим с точки зрения вычислений больших затрат, и сравнение каждого поля на равенство может быть лишним. Если предполагается, что пользователи будут сравнивать, сортировать экземпляры или использовать их в качестве ключей хэш-таблиц, тип значения должен реализовывать Equals. |
| CA1816 | [CA1816: Вызовите GC. SuppressFinalize правильно](../code-quality/ca1816-call-gc-suppressfinalize-correctly.md) | Метод, являющийся реализацией Dispose, не вызывает сборщик Мусора. SuppressFinalize; или метод, не являющийся реализацией Dispose вызывает сборщик Мусора. SuppressFinalize; или вызовы методов сборки Мусора. SuppressFinalize и передает что-то другое (Me в Visual Basic). |
| CA1819 | [CA1819: Свойства не должны возвращать массивы](../code-quality/ca1819-properties-should-not-return-arrays.md) | Массивы, возвращаемые свойствами, не защищены от записи, даже если свойство доступно только для чтения. Чтобы защитить массив от изменений, свойство должно возвращать копию массива. Как правило, пользователи не понимают требований к производительности при вызове такого свойства. |
| CA1820 | [CA1820: Проверьте наличие пустых строк, длины строки](../code-quality/ca1820-test-for-empty-strings-using-string-length.md) | Сравнивать строки с использованием свойства String.Length или метода String.IsNullOrEmpty значительно быстрее, чем с помощью Equals. |
| CA1821 | [CA1821: удалите пустые завершающие методы](../code-quality/ca1821-remove-empty-finalizers.md) | Если возможно, старайтесь не использовать финализаторы, поскольку из-за отслеживания жизненного срока объектов снижается производительность программы. Пустой метод завершения создает дополнительную нагрузку на систему, не обеспечивая никаких преимуществ. |
| CA1822 |[CA1822: Пометьте члены как статические](../code-quality/ca1822-mark-members-as-static.md) | Члены, не обращающиеся к данным экземпляра и не вызывающие методы экземпляра, можно пометить как статические (Shared в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]). Если пометить методы как статические, компилятор предоставит этим членам невиртуальные места вызова. Это обеспечивает значительное повышение производительности при работе с кодом, для которого важна высокая производительность системы. |
| CA1823 | [CA1823: Избегайте неиспользуемых частных полей](../code-quality/ca1823-avoid-unused-private-fields.md) | Обнаружены закрытые поля, доступ к которым, судя по всему, не предоставляется в сборке. |
| CA1824 |[CA1824: СЛЕДУЕТ Пометьте сборки атрибутом NeutralResourcesLanguageAttribute](../code-quality/ca1824-mark-assemblies-with-neutralresourceslanguageattribute.md) | Атрибут NeutralResourcesLanguage сообщает диспетчеру ресурсов языка, который использовался для отображения для сборки ресурсов нейтрального языка и региональных параметров. При этом повышается эффективность поиска первого загружаемого ресурса и может сократиться рабочее множество. |
| CA1900 | [CA1900: Поля типа значения должны быть переносимыми](../code-quality/ca1900-value-type-fields-should-be-portable.md) | Это правило проверяет правильность выравнивания структур, объявленных с явной разметкой, при маршалировании в неуправляемый код на 64-разрядных операционных системах. |
| CA1901 | [CA1901: Объявления P/Invoke должны быть переносимыми](../code-quality/ca1901-p-invoke-declarations-should-be-portable.md) | Данное правило вычисляет размер каждого параметра и возвращаемого значения вызова P/Invoke и проверяет правильность размера параметра при маршалировании в неуправляемый код на 32-разрядных и 64-разрядных операционных системах. |
| CA1903 | [CA1903: Используйте API-Интерфейс только из целевой версии .NET framework](../code-quality/ca1903-use-only-api-from-targeted-framework.md) | Член или тип использует член или тип, который был впервые представлен в пакете обновления, не включенном в целевую среду проекта. |
| CA2000 | [CA2000: Ликвидировать объекты перед потерей области](../code-quality/ca2000-dispose-objects-before-losing-scope.md) | Необходимо явно удалить объект до того, как все ссылки на него окажутся вне области действия, так как может произойти исключительное событие, которое воспрепятствует выполнению метода завершения объекта. |
| CA2001 | [CA2001: Избегайте вызовов проблемных методов](../code-quality/ca2001-avoid-calling-problematic-methods.md) | Член вызывает потенциально опасный или проблемный метод. |
| CA2002 |[CA2002: Не блокировать объекты со слабой идентификацией](../code-quality/ca2002-do-not-lock-on-objects-with-weak-identity.md) |К объекту со слабой идентификацией может быть получен прямой доступ через границы домена приложения. Поток пытается получить блокировку объекта со слабой идентификацией, который может быть заблокирован вторым потоком в другом домене приложения, имеющим блокировку того же объекта. |
| CA2003 |[CA2003: Не следует обрабатывать нити как потоки](../code-quality/ca2003-do-not-treat-fibers-as-threads.md) | Управляемый поток обрабатывается как поток [!INCLUDE[TLA2#tla_win32](../code-quality/includes/tla2sharptla_win32_md.md)]. |
| CA2004 | [CA2004: Удалите вызов GC. KeepAlive](../code-quality/ca2004-remove-calls-to-gc-keepalive.md) | При переходе к использованию класса SafeHandle необходимо удалить все вызовы метода GC.KeepAlive (объект). В этом случаев классам не требуется вызывать метод GC.KeepAlive. При этом предполагается, что для завершения дескриптора ОС они используют не метод завершения, а класс SafeHandle. |
| CA2006 | [CA2006: Используйте SafeHandle для инкапсуляции машинных ресурсов](../code-quality/ca2006-use-safehandle-to-encapsulate-native-resources.md) | Использование указателя IntPtr в управляемом коде может указывать на потенциальную проблему безопасности и надежности. Необходимо изучить все случаи использования указателя IntPtr, чтобы определить, не следует ли использовать вместо него класс SafeHandle или другую подобную технологию. |
| CA2007 | [CA2007: Не следует напрямую ожидать задачу](ca2007-do-not-directly-await-task.md) | Асинхронный метод [ожидает](/dotnet/csharp/language-reference/keywords/await) <xref:System.Threading.Tasks.Task> напрямую. Когда асинхронный метод ожидает <xref:System.Threading.Tasks.Task> напрямую, продолжение происходит в том же потоке, который создал задачу. Это поведение может быть дорогостоящей с точки зрения производительности и может привести к взаимоблокировке в потоке пользовательского интерфейса. Рассмотрите возможность вызова <xref:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)?displayProperty=nameWithType> сигнала вы собираетесь для продолжения. |
| CA2100 | [CA2100: Проверка запросов SQL на наличие уязвимостей безопасности](../code-quality/ca2100-review-sql-queries-for-security-vulnerabilities.md) | Метод задает свойство System.Data.IDbCommand.CommandText с использованием строки, созданной из строкового аргумента метода. Это правило предполагает, что строковый аргумент содержит введенные пользователем данные. Созданная из введенных пользователем данных командная строка SQL уязвима перед атаками путем внедрения кода SQL. |
| CA2101 |[CA2101: Укажите тип маршалинга для строковых аргументов P/Invoke](../code-quality/ca2101-specify-marshaling-for-p-invoke-string-arguments.md) | Член вызова неуправляемого кода, разрешающий вызовы с частичным доверием, содержит строковый параметр и не выполняет явный маршалинг и преобразование этой строки. Это может стать причиной потенциальной уязвимости безопасности. |
| CA2102 | [CA2102: Перехватывайте исключения, не являющиеся CLSCompliant, с помощью общих обработчиков](../code-quality/ca2102-catch-non-clscompliant-exceptions-in-general-handlers.md) | Элемент в сборке, не помеченной атрибутом RuntimeCompatibilityAttribute или помеченной атрибутом RuntimeCompatibility(WrapNonExceptionThrows = false), содержит блок catch, который обрабатывает исключения System.Exception, однако непосредственно за этим блоком не следует общий блок catch. |
| CA2103 | [CA2103: Проверьте императивную безопасность](../code-quality/ca2103-review-imperative-security.md) |Метод использует принудительную безопасность и может обеспечить создание разрешения с помощью сведений о состоянии или возвращаемых значений, которые могут измениться в период активности требования. Поэтому по возможности следует использовать декларативную безопасность. |
| CA2104 |[CA2104: Не объявляйте чтения только изменяемые ссылочные типы](../code-quality/ca2104-do-not-declare-read-only-mutable-reference-types.md) | Видимый извне тип содержит видимое извне и доступное только для чтение поле, являющееся изменяемым ссылочным типом. Изменяемый тип — это тип, экземпляр которого может быть изменен. |
| CA2105 | [CA2105: Поля массивов не должны считываться только](../code-quality/ca2105-array-fields-should-not-be-read-only.md) |При применении модификатора "только для чтения" (ReadOnly в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]) к полю, содержащему массив, это поле нельзя изменить, связав его с другим массивом. Однако элементы массива, хранящегося в доступном только для чтения поле, можно будет изменить. |
| CA2106 | [CA2106: Обеспечьте безопасность утверждений](../code-quality/ca2106-secure-asserts.md) | Метод подтверждает разрешения без выполнения проверок безопасности для вызывающего объекта. Подтверждение разрешений безопасности без выполнения проверок безопасности может привести к возникновению в коде уязвимости системы безопасности, которой могут воспользоваться злоумышленники. |
| CA2107 | [CA2107: Просмотрите deny и permit only](../code-quality/ca2107-review-deny-and-permit-only-usage.md) |Метод PermitOnly и действия безопасности CodeAccessPermission.Deny следует использовать только пользователями, обладающие специальными знаниями в области безопасности .NET. Код, который использует эти действия безопасности, должен быть тщательно проанализирован на предмет безопасности. |
| CA2108 | [CA2108: Проверьте объявляемые параметры безопасности типов значений](../code-quality/ca2108-review-declarative-security-on-value-types.md) | Открытый или защищенный тип значения защищен средствами доступа к данным или требованиями ссылки. |
| CA2109 | [CA2109: Проверьте видимые обработчики событий](../code-quality/ca2109-review-visible-event-handlers.md) | Обнаружен открытый или защищенный метод обработки событий. Методы обработки событий следует раскрывать только в тех случаях, когда это совершенно необходимо. |
| CA2111 |[CA2111: Указатели не должны быть видимыми](../code-quality/ca2111-pointers-should-not-be-visible.md) | Указатель не является закрытым, внутренним или доступным только для чтения. Вредоносный код может изменить значение указателя, что потенциально приведет к предоставлению доступа к произвольным областям памяти или сбоям приложения или системы. |
| CA2112 | [CA2112: Защищенные типы не должны предоставлять поля](../code-quality/ca2112-secured-types-should-not-expose-fields.md) | Открытый или защищенный тип содержит открытые поля и защищен требованиями ссылки. Если код имеет доступ к экземпляру типа, защищенного запросом компоновки, то для получения доступа к полям типа коду не требуется удовлетворять запросу компоновки. |
| CA2114 | [CA2114: Безопасность метода должна быть надмножеством типа](../code-quality/ca2114-method-security-should-be-a-superset-of-type.md) | Метод не должен обладать декларативной безопасностью для одного и того же действия, как на уровне метода, так и на уровне типа. |
| CA2115 | [CA2115: Вызовите GC. KeepAlive при использовании машинных ресурсов](../code-quality/ca2115-call-gc-keepalive-when-using-native-resources.md) | Данное правило обнаруживает ошибки, которые могут возникать из-за завершения неуправляемых ресурсов, по-прежнему используемых в машинном коде. |
| CA2116 | [CA2116: Методы APTCA должны вызывать только методы APTCA](../code-quality/ca2116-aptca-methods-should-only-call-aptca-methods.md) |Если в полностью доверенной сборке присутствует атрибут APTCA (AllowPartiallyTrustedCallersAttribute) и она выполняет код в другой сборке, для которой не разрешены частично доверенные вызовы, возможно возникновение уязвимости безопасности. |
| CA2117 | [CA2117: APTCA-типы должны расширять только базовые APTCA-типы](../code-quality/ca2117-aptca-types-should-only-extend-aptca-base-types.md) | Если сборка с полным доверием помечена атрибутом APTCA и тип в сборке наследует от типа, который не разрешает вызовы с неполным доверием, возможно возникновение уязвимости для эксплойта. |
| CA2118 | [CA2118: Проверьте использование SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2118-review-suppressunmanagedcodesecurityattribute-usage.md) |Атрибут SuppressUnmanagedCodeSecurityAttribute изменяет поведение системы безопасности, определенное по умолчанию, для элементов, выполняющих неуправляемый код за счет COM-взаимодействия или вызова операционной системы. Этот атрибут служит в основном для повышения производительности; однако, прирост производительности сопряжен со значительными рисками безопасности. |
| CA2119 | [CA2119: Запечатайте методы, соответствующие частным интерфейсам](../code-quality/ca2119-seal-methods-that-satisfy-private-interfaces.md) | Наследуемый открытый тип предоставляет реализацию переопределяемого метода внутреннего (Friend в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]) интерфейса. Для устранения нарушения данного правила следует исключить возможность переопределения метода за пределами сборки. |
| CA2120 | [CA2120: Обеспечьте безопасность конструкторов сериализации](../code-quality/ca2120-secure-serialization-constructors.md) | Для этого типа предусмотрен конструктор, который принимает объекты System.Runtime.Serialization.SerializationInfo и System.Runtime.Serialization.StreamingContext (сигнатура конструктора сериализации). Этот конструктор не защищен проверкой безопасности, однако один или несколько обычных конструкторов этого типа защищены. |
| CA2121 | [CA2121: Статические конструкторы должны быть частными](../code-quality/ca2121-static-constructors-should-be-private.md) | Система вызывает статический конструктор перед созданием первого экземпляра типа или ссылкой на любые статические члены. Если статический конструктор не является закрытым, он может быть вызван кодом, находящимся за пределами системы. В зависимости от операций, выполняемых в конструкторе, это может стать причиной непредвиденного поведения |
| CA2122 | [CA2122: Не используйте косвенное представление методов с запросами компоновки](../code-quality/ca2122-do-not-indirectly-expose-methods-with-link-demands.md) | У открытого или защищенного члена есть требования ссылки, и он вызывается членом, который не выполняет какие-либо проверки безопасности. Запрос компоновки проверяет разрешения только непосредственно вызывающего метода. |
| CA2123 | [CA2123: Компоновки переопределения должны быть идентичны базовым](../code-quality/ca2123-override-link-demands-should-be-identical-to-base.md) | Это правило сравнивает метод с его базовым методом (который является интерфейсом или виртуальным методом другого типа), а затем сравнивает запросы ссылок для каждого из них. Если это правило нарушается, то вредоносный вызывающий объект может обойти запрос ссылок путем вызова небезопасного метода. |
| CA2124 | [CA2124: Помещайте уязвимые предложения finally во внешний блок try](../code-quality/ca2124-wrap-vulnerable-finally-clauses-in-outer-try.md) | Открытый или защищенный метод содержит блок try/finally. Блок finally сбрасывает состояние безопасности и не заключен в блок finally. |
| CA2126 | [CA2126: ЗАПРОСЫ Запросы компоновки типа требуют запросы наследования](../code-quality/ca2126-type-link-demands-require-inheritance-demands.md) | Открытый незапечатанный тип защищен требованием ссылки и имеет переопределяемый метод. Ни тип, ни метод не защищены с помощью требования наследования. |
| CA2127 | [CA2136: Элементы не должны иметь конфликтующие пометки прозрачности](../code-quality/ca2136-members-should-not-have-conflicting-transparency-annotations.md) | В 100 процентов прозрачной сборкой не может содержаться критический код. Это правило позволяет проанализировать сборки, прозрачные на 100 процентов для аннотаций SecurityCritical на уровне типов, полей и методов. |
| CA2128 |[CA2147: Прозрачные методы не могут использовать безопасность утверждений](../code-quality/ca2147-transparent-methods-may-not-use-security-asserts.md) | Это правило анализирует все методы и типы в сборке, которая является смешанной либо прозрачный с точки зрения 100 процентов прозрачной и критической и пометить декларативное и императивное использование Assert. |
| CA2129 | [CA2140: Прозрачный код не должна ссылаться на элементы, критичные безопасности](../code-quality/ca2140-transparent-code-must-not-reference-security-critical-items.md) | Методы, помеченные атрибутом SecurityTransparentAttribute, вызывают закрытые члены, помеченные как SecurityCritical. Это правило позволяет проанализировать все методы и типы в смешанной (прозрачной и критической) сборке и пометить все вызовы закрытого критического кода из прозрачного кода, которые не помечены как SecurityTreatAsSafe. |
| CA2130 | [CA2130: Константы критической безопасности должны быть прозрачными](../code-quality/ca2130-security-critical-constants-should-be-transparent.md) | Принудительная прозрачность не применяется для постоянных значений, чтобы во время выполнения не требовалась подстановка значений. Константные поля должны быть прозрачными для системы безопасности, чтобы анализаторы кода не предполагали, что прозрачный для системы безопасности код не может получить доступ к константе. |
| CA2131 | [CA2131: Типы критической безопасности могут не участвовать в эквивалентности типа](../code-quality/ca2131-security-critical-types-may-not-participate-in-type-equivalence.md) | Тип участвует в эквивалентности типов, а сам тип или член или поле типа помечены атрибутом SecurityCriticalAttribute. Это правило применяется ко всем критическим типам или к типам, содержащим критические методы или поля, участвующие в эквивалентности типов. Когда среда CLR обнаруживает такой тип, она не загружает его и выдает исключение TypeLoadException во время выполнения. Обычно это правило применяется, только когда пользователи вручную реализуют эквивалентность типов, вместо использования tlbimp и компиляторов. |
| CA2132 | [CA2132: Конструкторы по умолчанию должно быть по крайней мере настолько критичными, как конструкторы базовых типов по умолчанию](../code-quality/ca2132-default-constructors-must-be-at-least-as-critical-as-base-type-default-constructors.md) |Типы и члены с атрибутом SecurityCriticalAttribute не могут использоваться в коде приложений Silverlight. Критичные в плане безопасности типы и элементы могут использоваться только надежным кодом в среде .NET Framework для библиотеки классов Silverlight. Поскольку открытая или защищенная конструкция в производном классе должна иметь ту же или большую прозрачность, чем ее базовый класс, класс в приложении не может быть производным от класса, помеченного как SecurityCritical. |
| CA2133 | [CA2133: Делегаты должны привязываться к методам с согласованной прозрачностью](../code-quality/ca2133-delegates-must-bind-to-methods-with-consistent-transparency.md) | Это предупреждение вызывается методом, который привязывает делегат, помеченный атрибутом SecurityCriticalAttribute, к методу, который является прозрачным или помечен атрибутом SecuritySafeCriticalAttribute. Предупреждение также выдается для метода, который привязывает прозрачный или безопасный делегат к критическому методу. |
| CA2134 | [CA2134: Методы должны сохранять согласованную прозрачность при переопределении базовых методов](../code-quality/ca2134-methods-must-keep-consistent-transparency-when-overriding-base-methods.md) |Это правило применяется, когда метод, помеченный атрибутом SecurityCriticalAttribute, переопределяет прозрачный метод или метод, помеченный атрибутом SecuritySafeCriticalAttribute. Это правило также применяется, когда прозрачный метод или метод, помеченный атрибутом SecurityCriticalAttribute, переопределяет метод, помеченный атрибутом SecuritySafeCriticalAttribute. Это правило применяется при переопределении виртуального метода или реализации интерфейса. |
| CA2135 | [CA2135: СБОРКИ Уровень 2 не должны содержать требования LinkDemand](../code-quality/ca2135-level-2-assemblies-should-not-contain-linkdemands.md) | Требования LinkDemand являются устаревшими в наборе правил безопасности уровня 2. Вместо использования требования LinkDemand для обеспечения безопасности во время JIT-компиляции пометьте методы, типы и поля атрибутом SecurityCriticalAttribute. |
| CA2136 | [CA2136: Элементы не должны иметь конфликтующие пометки прозрачности](../code-quality/ca2136-members-should-not-have-conflicting-transparency-annotations.md) | Атрибуты прозрачности применяются из элементов кода большей области к элементам меньшей области. Атрибуты прозрачности элементов кода с большей областью имеют приоритет по сравнению с атрибутами прозрачности элементов кода, которые содержатся в первом элементе. Например, класс, помеченный атрибутом SecurityCriticalAttribute, не может содержать метод, помеченный атрибутом SecuritySafeCriticalAttribute. |
| CA2137 | [CA2137: Прозрачные методы должны содержать только проверяемые IL](../code-quality/ca2137-transparent-methods-must-contain-only-verifiable-il.md) | Метод содержит непроверяемый код или возвращает тип по ссылке. Это правило срабатывает при попытках прозрачного кода безопасности выполнить непроверяемый MISL. Однако это правило не содержит полную проверку IL, и вместо нее использует эвристику для выявления большинства нарушений проверки MSIL. |
| CA2138 | [CA2138: Прозрачные методы не должны вызывать методы с атрибутом SuppressUnmanagedCodeSecurity](../code-quality/ca2138-transparent-methods-must-not-call-methods-with-the-suppressunmanagedcodesecurity-attribute.md) | Прозрачный с точки зрения безопасности метод вызывает метод, помеченный атрибутом SuppressUnmanagedCodeSecurityAttribute. |
| CA2139 | [CA2139: Прозрачные методы не могут использовать атрибут HandleProcessCorruptingExceptions](../code-quality/ca2139-transparent-methods-may-not-use-the-handleprocesscorruptingexceptions-attribute.md) | Это правило запускается любым прозрачным методом, который пытается обработать исключение повреждения процесса с помощью атрибута HandleProcessCorruptedStateExceptionsAttribute. Исключение повреждения процесса – это классификация версии 4.0 среды CLR таких исключений, как AccessViolationException. Атрибут HandleProcessCorruptedStateExceptionsAttribute может использоваться только критичными в плане безопасности методами и будет игнорироваться при применении для прозрачного метода. |
| CA2140 | [CA2140: Прозрачный код не должна ссылаться на элементы, критичные безопасности](../code-quality/ca2140-transparent-code-must-not-reference-security-critical-items.md) | Элемент кода, помеченный атрибутом SecurityCriticalAttribute, является критическим с точки зрения безопасности. Прозрачный метод не может использовать элемент, критический с точки зрения безопасности. Если прозрачный тип пытается использовать тип, критический с точки зрения безопасности, то вызывается исключение TypeAccessException, MethodAccessException или FieldAccessException. |
| CA2141 |[CA2141: прозрачные методы не должны удовлетворять требования LinkDemand](../code-quality/ca2141-transparent-methods-must-not-satisfy-linkdemands.md) | Прозрачный с точки зрения безопасности метод вызывает метод в сборке, не помеченной атрибутом APTCA, либо прозрачный с точки зрения безопасности метод удовлетворяет требованию LinkDemand по типу или методу. |
| CA2142 | [CA2142: Прозрачный код не должен быть защищен с помощью требований LinkDemand](../code-quality/ca2142-transparent-code-should-not-be-protected-with-linkdemands.md) | Это правило срабатывает для прозрачных методов, для доступа к которым требуется LinkDemand. Прозрачный для системы безопасности код не должен отвечать за проверку безопасности операции и поэтому не должен требовать разрешений. |
| CA2143 | [CA2143: Прозрачные методы не должны использовать требования безопасности](../code-quality/ca2143-transparent-methods-should-not-use-security-demands.md) | Прозрачный для системы безопасности код не должен отвечать за проверку безопасности операции и поэтому не должен требовать разрешений. Прозрачный для системы безопасности код должен использовать полные требования для принятия решений по безопасности, и критичный в плане безопасности код не должен полагаться на прозрачный код, чтобы создать полное требование. |
| CA2144 | [CA2144: Прозрачный код не должен загружать сборки из массивов байтов](../code-quality/ca2144-transparent-code-should-not-load-assemblies-from-byte-arrays.md) | Проверка безопасности для прозрачного кода не так тщательна, как проверка безопасности для критического кода, поскольку прозрачный код не может выполнять действия, требующие особых мер безопасности. Сборки, загруженные из массива байтов, могут остаться незамеченными в прозрачном коде, и этот массив байтов может содержать критичный или, что более важно, критичный в плане безопасности код, который подлежит аудиту. |
| CA2145 | [CA2145: Прозрачные методы не должны быть снабжены атрибутом SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2145-transparent-methods-should-not-be-decorated-with-the-suppressunmanagedcodesecurityattribute.md) | Методы, оснащенные атрибутом SuppressUnmanagedCodeSecurityAttribute, имеют неявную проверку LinkDemand, применяемую к любому вызывающему их методу. Для этой проверки LinkDemand требуется, чтобы вызывающий код был критическим с точки зрения безопасности. Пометка метода, который использует SuppressUnmanagedCodeSecurity с атрибутом SecurityCriticalAttribute, делает это требование более очевидным для тех, кто вызывает этот метод. |
| CA2146 | [CA2146: Типы должны быть по крайней мере настолько критичными, как их базовые типы и интерфейсы](../code-quality/ca2146-types-must-be-at-least-as-critical-as-their-base-types-and-interfaces.md) | Это правило срабатывает, если у производного типа есть атрибут прозрачности безопасности, не такой критический, как базовый тип или реализованный интерфейс. От критических базовых типов или реализованных критических интерфейсов могут производиться только критические типы, и от критических в плане безопасности базовых типов или реализованных интерфейсов могут производиться только критические в плане безопасности типы. |
| CA2147 |[CA2147: Прозрачные методы не могут использовать безопасность утверждений](../code-quality/ca2147-transparent-methods-may-not-use-security-asserts.md) | Коду, помеченному атрибутом SecurityTransparentAttribute, не предоставляются достаточные для утверждения разрешения. |
| CA2149 | [CA2149: Прозрачные методы не следует вызывать в машинном коде](../code-quality/ca2149-transparent-methods-must-not-call-into-native-code.md) | Это правило применяется в любом прозрачном методе, который напрямую вызывает машинный код (например, с помощью P/Invoke). Нарушение этого правила приводит к исключению MethodAccessException на уровне 2 модели прозрачности и вызову полного требования UnmanagedCode на уровне 1 модели прозрачности. |
| CA2151 |[CA2151: Поля с критическими типами должны быть критически важным для безопасности](../code-quality/ca2151-fields-with-critical-types-should-be-security-critical.md) | Для использования критических с точки зрения безопасности типов код, который ссылается на тип, должен быть либо критическим с точки зрения безопасности, либо надежным с точки зрения безопасности. Это верно даже в случае косвенной ссылки. Поэтому применять прозрачное для безопасности поле или поле, надежное с точки зрения безопасности, не рекомендуется, поскольку прозрачный код по-прежнему не сможет получить доступ к полю. |
| CA2200 | [CA2200: Исключение для сохранения сведений о стеке](../code-quality/ca2200-rethrow-to-preserve-stack-details.md) | В операторе throw повторно создается и явным образом задается исключение. Если исключение повторно создается заданием исключения в операторе throw, список вызовов метода между исходным методом, создавшим исключение, и текущим методом будет утерян. |
| CA2201 | [CA2201: Не вызывайте зарезервированные типы исключений](../code-quality/ca2201-do-not-raise-reserved-exception-types.md) | Из-за этого становится трудно обнаружить и отладить изначальную ошибку. |
| CA2202 | [CA2202: Не удаляйте объекты несколько раз](../code-quality/ca2202-do-not-dispose-objects-multiple-times.md) |Реализация метода содержит пути кода, которые могли стать причиной многократного вызова метода System.IDisposable.Dispose или эквивалентного метода Dispose (например, метода Close() для некоторых типов) для одного и того же объекта. |
| CA2204 | [CA2204: Литералы должны иметь правильное правописание](../code-quality/ca2204-literals-should-be-spelled-correctly.md) | Литеральная строка в теле метода содержит одно или несколько слов, не распознаваемых библиотекой системы проверки орфографии Майкрософт. |
| CA2205 | [CA2205: Используйте управляемые эквиваленты Win32 API](../code-quality/ca2205-use-managed-equivalents-of-win32-api.md) | Вызова операционной системы метод определен и доступен метод .NET, с эквивалентной функциональностью. |
| CA2207 | [CA2207: Инициализируйте статические поля типа значений встроенными средствами](../code-quality/ca2207-initialize-value-type-static-fields-inline.md) | Тип значения объявляет явный статический конструктор. Чтобы устранить нарушение данного правила, выполните инициализацию всех статических данных при их объявлении и удалите статический конструктор. |
| CA2208 |[CA2208: Правильно создавайте экземпляры аргументов исключений](../code-quality/ca2208-instantiate-argument-exceptions-correctly.md) | Вызывается конструктор по умолчанию (без параметров), принадлежащий к типу исключения ArgumentException или унаследованный от него, или неправильный аргумент строки передается параметризованному конструктору, принадлежащему к типу исключения ArgumentException или унаследованному от него. |
| CA2210 |[CA2210: Сборки должны иметь допустимые строгие имена](../code-quality/ca2210-assemblies-should-have-valid-strong-names.md) | Строгое имя защищает клиентов от случайной загрузки сборки, которая была подменена. Сборки без строгих имен следует развертывать лишь в крайне небольшом числе случаев. При обмене или распространении сборок без правильной подписи сборки могут быть подменены, среда CLR может не загрузить сборку или пользователь может быть вынужден отключить проверку на своем компьютере. |
| CA2211 |[CA2211: Неконстантные поля не должны быть видимыми](../code-quality/ca2211-non-constant-fields-should-not-be-visible.md) | Для статических полей, которые не являются константными и доступными только для чтения, невозможно обеспечить потокобезопасность. Доступ к подобным полям должен тщательно контролироваться, и для синхронизации доступа к такому объекту класса требуются дополнительные методы программирования. |
| CA2212 | [CA2212: Не следует помечать обслуживаемые компоненты атрибутом WebMethod](../code-quality/ca2212-do-not-mark-serviced-components-with-webmethod.md) |Метод в типе, унаследованном от System.EnterpriseServices.ServicedComponent, помечен атрибутом System.Web.Services.WebMethodAttribute. Так как атрибут WebMethodAttribute и метод ServicedComponent имеют разное поведение и предъявляют конфликтующие требования к контексту и потоку транзакций, в некоторых сценариях поведение метода будет неправильным. |
| CA2213 | [CA2213: следует высвобождать высвобождаемые поля](../code-quality/ca2213-disposable-fields-should-be-disposed.md) | Тип, реализующий System.IDisposable, объявляет поля, принадлежащие к типам, которые также реализуют IDisposable. Метод Dispose поля не вызывается методом Dispose объявляющего типа. |
| CA2214 | [CA2214: Не вызывайте переопределяемые методы в конструкторах](../code-quality/ca2214-do-not-call-overridable-methods-in-constructors.md) | Когда конструктор вызывает виртуальный метод, возможна ситуация, когда конструктор для экземпляра, вызывающего метод, не выполняется. |
| CA2215 | [CA2215: Методы Dispose должны вызывать метод dispose базового класса](../code-quality/ca2215-dispose-methods-should-call-base-class-dispose.md) | Если тип наследуется от удаляемого типа, он должен вызвать метод Dispose базового типа из собственного метода Dispose. |
| CA2216 |[CA2216: Высвобождаемые типы должны объявлять метод завершения](../code-quality/ca2216-disposable-types-should-declare-finalizer.md) | Тип, который реализует System.IDisposable и имеет поля, предусматривающие использование неуправляемых ресурсов, не реализует метод завершения, как описано в Object.Finalize. |
| CA2217 | [CA2217: Не следует помечать перечисления атрибутом FlagsAttribute](../code-quality/ca2217-do-not-mark-enums-with-flagsattribute.md) |Доступное для внешнего кода перечисление помечено атрибутом FlagsAttribute и имеет одно или несколько значений, которые не являются степенью двойки или сочетанием других определенных значений в перечислении. |
| CA2218 |[CA2218: Переопределяйте GetHashCode при переопределении Equals](../code-quality/ca2218-override-gethashcode-on-overriding-equals.md) | GetHashCode возвращает значение на основе текущего экземпляра, используемое для алгоритмов хэширования и структур данных, таких как хэш-таблица. Два равных объекта, принадлежащие к одному и тому же типу, должны возвращать один и тот же хэш-код. |
| CA2219 | [CA2219: Не вызывайте исключения в предложениях исключений](../code-quality/ca2219-do-not-raise-exceptions-in-exception-clauses.md) | Если исключение создается в предложении finally или fault, новое исключение скрывает активное исключение. Если исключение создается в предложении filter, среда выполнения перехватывает исключение без оповещения. Из-за этого становится трудно обнаружить и отладить изначальную ошибку. |
| CA2220 | [CA2220: Методы завершения должны вызывать метод завершения базового класса](../code-quality/ca2220-finalizers-should-call-base-class-finalizer.md) | Финализация должна распространятся посредством иерархии наследования. Для этого типы должны вызывать свой метод Finalize базового класса из собственного метода Finalize. |
| CA2221 |[CA2221: Методы завершения должны быть защищены](../code-quality/ca2221-finalizers-should-be-protected.md) | В методах завершения должен использоваться модификатор доступа из семейства. |
| CA2222 | [CA2222: Не уменьшайте видимость унаследованных членов](../code-quality/ca2222-do-not-decrease-inherited-member-visibility.md) |Не следует изменять модификатор доступа для унаследованных членов. Если сделать унаследованный член закрытым, то доступ вызывающих объектов к реализации метода базового класса все равно не будет запрещен. |
| CA2223 | [CA2223: Члены должны различаться не только возвращаемым типом](../code-quality/ca2223-members-should-differ-by-more-than-return-type.md) | Среда CLR позволяет использовать возвращаемые типы для различения совпадающих в остальном членов, однако эта функция не входит в спецификацию CLS и поддерживается не всеми языками программирования .NET. |
| CA2224 | [CA2224: Переопределяйте равенство при перегрузке оператора равенства](../code-quality/ca2224-override-equals-on-overloading-operator-equals.md) | Открытый тип реализует оператор равенства, но не переопределяет Object.Equals. |
| CA2225 | [CA2225: Оператор дополнения с именами](../code-quality/ca2225-operator-overloads-have-named-alternates.md) |Обнаружена перегрузка оператора, однако не найден ожидаемый именованный альтернативный метод. Именованный альтернативный член предоставляет те же функции, что и основной оператор, и его могут использовать разработчики, которые программируют на языках, не поддерживающих перегрузку операторов. |
| CA2226 | [CA2226: Операторы должны быть симметричны](../code-quality/ca2226-operators-should-have-symmetrical-overloads.md) | Тип реализует оператор равенства или неравенства, но не реализует противоположный оператор. |
| CA2227 |[CA2227: Свойства коллекции должны быть только для чтения](../code-quality/ca2227-collection-properties-should-be-read-only.md) |Свойство коллекции, допускающее запись, позволяет пользователю заменять одну коллекцию другой. Свойство только для чтения предотвращает замену коллекции, но по-прежнему допускает установку, настройку отдельных членов. |
| CA2228 | [CA2228: Не следует поставлять невыпущенные форматы ресурсов](../code-quality/ca2228-do-not-ship-unreleased-resource-formats.md) | Файлы ресурсов, которые были созданы с помощью предварительных версий платформы .NET Framework может стать недоступной в поддерживаемых версиях платформы .NET Framework. |
| CA2229 | [CA2229: реализуйте конструкторы сериализации](../code-quality/ca2229-implement-serialization-constructors.md) | Чтобы устранить нарушение этого правила, реализуйте конструктор сериализации. Для запечатанного класса конструктор должен быть закрытым, а в иных случаях — защищенным. |
| CA2230 | [CA2230: Используйте параметры для аргументов переменной](../code-quality/ca2230-use-params-for-variable-arguments.md) | Открытый или защищенный тип содержит открытый или защищенный метод, который использует соглашение о вызовах VarArgs вместо ключевого слова params. |
| CA2231 | [CA2231: перегрузите оператор равенства на переопределяющем типе ValueType.Equals](../code-quality/ca2231-overload-operator-equals-on-overriding-valuetype-equals.md) | Тип значения переопределяет Object.Equals, но не реализует оператор равенства. |
| CA2232 | [CA2232: Точки входа Марк Windows Forms меткой STAThread](../code-quality/ca2232-mark-windows-forms-entry-points-with-stathread.md) | Атрибут STAThreadAttribute указывает, что потоковой моделью COM для приложения является однопотоковое подразделение. Данный атрибут должен находиться в точке входа любого приложения, использующего Windows Forms; если он отсутствует, компоненты Windows могут работать неправильно. |
| CA2233 |[CA2233: Операции не должно быть переполнений](../code-quality/ca2233-operations-should-not-overflow.md) | Не следует выполнять арифметические операции без предварительной проверки операндов. Это гарантирует, что результат операции находится в диапазоне возможных значений для используемых типов данных. |
| CA2234 | [CA2234: Передавайте объекты System.Uri вместо строк](../code-quality/ca2234-pass-system-uri-objects-instead-of-strings.md) | Вызывается метод, имеющий параметр строки, имя которого содержит uri, URI, urn, URN, url или URL. Объявляющий тип метода содержит соответствующую перегрузку метода, которая имеет параметр System.Uri. |
| CA2235 | [CA2235. Пометьте все несериализуемые поля](../code-quality/ca2235-mark-all-non-serializable-fields.md) | Экземпляр поля несериализуемого типа объявлен в сериализуемом типе. |
| CA2236 | [CA2236: Вызывайте методы базового класса для типов ISerializable](../code-quality/ca2236-call-base-class-methods-on-iserializable-types.md) | Чтобы устранить нарушение этого правила, вызовите метод базового типа GetObjectData или конструктор сериализации из соответствующего метода производного типа или конструктора. |
| CA2237 | [CA2237. Пометьте типы ISerializable атрибутом SerializableAttribute](../code-quality/ca2237-mark-iserializable-types-with-serializableattribute.md) | Чтобы среда CLR распознавала тип как сериализуемый, он должен быть помечен атрибутом SerializableAttribute, даже если тип использует пользовательскую процедуру сериализации посредством реализации интерфейса ISerializable. |
| CA2238 |[CA2238: Правильно реализовывать методы сериализации](../code-quality/ca2238-implement-serialization-methods-correctly.md) | Метод, обрабатывающий событие сериализации, не имеет правильной сигнатуры, типа возвращаемого значения или отображения. |
| CA2239 | [CA2239: Предоставляйте методы десериализации для необязательных полей](../code-quality/ca2239-provide-deserialization-methods-for-optional-fields.md) | Тип имеет поле, помеченное атрибутом System.Runtime.Serialization.OptionalFieldAttribute, и не предоставляет методы обработки событий десериализации. |
| CA2240 | [CA2240: Правильно реализуйте ISerializable](../code-quality/ca2240-implement-iserializable-correctly.md) | Чтобы устранить нарушение данного правила, сделайте метод GetObjectData доступным для внешнего кода и переопределяемым и убедитесь, что все поля экземпляра включены в процесс сериализации или явно помечены атрибутом NonSerializedAttribute. |
| CA2241 | [CA2241: Предоставьте правильные аргументы методам форматирования](../code-quality/ca2241-provide-correct-arguments-to-formatting-methods.md) | Аргумент формата, переданный методу System.String.Format, не содержит элемент форматирования, соответствующий каждому аргументу объекта, или наоборот. |
| CA2242 |[CA2242: Правильно выполняйте проверку NaN](../code-quality/ca2242-test-for-nan-correctly.md) | Это выражение проверяет значение на соответствие Single.Nan или Double.Nan. Используйте Single.IsNan(Single) или Double.IsNan(Double) для проверки значения. |
| CA2243 |[CA2243: Синтаксический анализ строковых литералов атрибута должен правильно](../code-quality/ca2243-attribute-string-literals-should-parse-correctly.md) | Не удается правильно выполнить синтаксический анализ параметра строкового литерала атрибута для URL-адреса, идентификатора GUID или версии. |
| CA5122 | [CA5122. Объявления P/Invoke не могут быть надежными с точки зрения безопасности](../code-quality/ca5122-p-invoke-declarations-should-not-be-safe-critical.md) | Методы отмечаются как SecuritySafeCritical, если они выполняют критически важные для безопасности операции и являются безопасными для использования в прозрачном коде. Прозрачный код может никогда не вызывать машинный код напрямую с помощью P/Invoke. Поэтому, если метод P/Invoke отметить как надежный с точки зрения безопасности, это не приведет к тому, что прозрачный код будет вызывать его, и может ввести в заблуждение при анализе безопасности. |