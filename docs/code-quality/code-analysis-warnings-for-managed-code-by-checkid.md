---
title: Обзор правил качества кода
ms.date: 09/01/2020
ms.topic: reference
f1_keywords:
- CA1000
- CA1001
- CA1002
- CA1003
- CA1005
- CA1008
- CA1010
- CA1012
- CS1014
- CA1016
- CA1017
- CA1018
- CA1019
- CA1021
- CA1024
- CA1027
- CA1028
- CA1029
- CA1030
- CA1031
- CA1032
- CA1033
- CA1034
- CA1036
- CA1040
- CA1041
- CA1043
- CA1044
- CA1045
- CA1046
- CA1047
- CA1050
- CA1051
- CA1052
- CA1053
- CA1054
- CA1055
- CA1056
- CA1058
- CA1060
- CA1061
- CA1062
- CA1063
- CA1064
- CA1065
- CA1066
- CA1067
- CA1068
- CA1069
- CA1070
- CA1200
- CA1303
- CA1304
- CA1305
- CA1307
- CA1308
- CA1309
- CA1310
- CA1401
- CA1417
- CA1501
- CA1502
- CA1505
- CA1506
- CA1507
- CA1508
- CA1509
- CA1700
- CA1707
- CA1708
- CA1710
- CA1711
- CA1712
- CA1713
- CA1714
- CA1715
- CA1716
- CA1717
- CA1720
- CA1721
- CA1724
- CA1725
- CA1801
- CA1802
- CA1805
- CA1806
- CA1810
- CA1812
- CA1813
- CA1814
- CA1815
- CA1816
- CA1819
- CA1820
- CA1821
- CA1822
- CA1823
- CA1824
- CA1825
- CA1826
- CA1827
- CA1828
- CA1829
- CA1830
- CA1831
- CA1832
- CA1833
- CA1834
- CA1835
- CA1836
- CA1837
- CA1838
- CA2000
- CA2002
- CA2007
- CA2008
- CA2009
- CA2011
- CA2012
- CA2013
- CA2014
- CA2015
- CA2016
- CA2100
- CA2101
- CA2109
- CA2119
- CA2153
- CA2200
- CA2201
- CA2207
- CA2208
- CA2211
- CA2213
- CA2214
- CA2215
- CA2216
- CA2217
- CA2219
- CA2225
- CA2226
- CA2227
- CA2229
- CA2231
- CA2234
- CA2235
- CA2237
- CA2241
- CA2242
- CA2243
- CA2245
- CA2246
- CA2247
- CA2248
- CA2249
- CA2300
- CA2301
- CA2302
- CA2305
- CA2310
- CA2311
- CA2312
- CA2315
- CA2321
- CA2322
- CA2326
- CA2327
- CA2328
- CA2329
- CA2330
- CA2350
- CA2351
- CA2352
- CA2353
- CA2354
- CA2355
- CA2356
- CA2361
- CA2362
- CA3001
- CA3002
- CA3003
- CA3004
- CA3005
- CA3006
- CA3007
- CA3008
- CA3009
- CA3010
- CA3011
- CA3012
- CA3061
- CA3075
- CA3076
- CA3077
- CA5347
- CA5350
- CA5351
- CA5359
- CA5360
- CA5361
- CA5362
- CA5363
- CA5364
- CA5365
- CA5366
- CA5367
- CA5368
- CA5369
- CA5370
- CA5371
- CA5372
- CA5373
- CA5374
- CA5375
- CA5376
- CA5377
- CA5378
- CA5379
- CA5380
- CA5381
- CA5382
- CA5383
- CA5384
- CA5385
- CA5386
- CA5387
- CA5388
- CA5389
- CA5390
- CA5391
- CA5392
- CA5393
- CA5394
- CA5395
- CA5397
- CA5398
- CA5399
- CA5400
- CA5401
- CA5402
- CA5403
- IL3000
- IL3001
ms.assetid: 5cb221f6-dc59-4abf-9bfa-adbd6f907f96
author: mikadumont
ms.author: midumont
manager: jillfra
ms.workload:
- dotnet
ms.openlocfilehash: a298ab142ae6a44c1fb24b2cb1b752f6beb4a68e
ms.sourcegitcommit: 4ae5e9817ad13edd05425febb322b5be6d3c3425
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/11/2020
ms.locfileid: "90037241"
---
# <a name="code-quality-analysis-rules-by-rule-id"></a>Правила анализа качества кода по ИДЕНТИФИКАТОРу правила

В следующей таблице перечислены правила анализа качества кода по идентификатору правила.

| CheckId | Предупреждение | Описание |
|---------| - | - |
| CA1000 | [CA1000. Не объявляйте статические члены в универсальных типах](../code-quality/ca1000.md) | При вызове статического элемента универсального типа нужно указать аргумент этого типа. При вызове универсального экземпляра элемента, не поддерживающего вывод типа, для элемента нужно указать аргумент типа. В этих двух случаях синтаксис для определения аргумента типа различен, и его можно легко спутать. |
| CA1001 | [CA1001. Типы, которым принадлежат освобождаемые поля, должны быть освобождаемыми](../code-quality/ca1001.md) | В классе объявляется и реализуется поле экземпляра, которое принадлежит типу System.IDisposable, однако класс не реализует интерфейс IDisposable. Класс, в котором объявляется поле IDisposable, неявно владеет неуправляемым ресурсом и должен реализовывать интерфейс IDisposable. |
| CA1002 | [CA1002. Не предоставляйте универсальные списки](../code-quality/ca1002.md) | System. Collections. Generic. List< (of \<(T> ) >) — это универсальная коллекция, предназначенная для повышения производительности, а не для наследования. Поэтому виртуальные элементы в списке отсутствуют. Вместо этого для наследования следует предоставить универсальную коллекцию. |
| CA1003 | [CA1003. Используйте экземпляры обработчика универсальных событий](../code-quality/ca1003.md) |Тип содержит делегат, возвращающий значение void, сигнатура которого содержит два параметра (первый — объект, а второй — тип, который может быть назначен EventArgs), а включающая сборка предназначена для платформы Microsoft .NET Framework 2.0. |
| CA1005 | [CA1005. Не используйте слишком много параметров в универсальных типах](../code-quality/ca1005.md) | Чем больше параметров типов содержит универсальный тип, тем сложнее знать и запоминать, что представляет каждый параметр типа. Обычно очевидно с одним параметром типа, как в списке \<T> , и в некоторых случаях с двумя параметрами типа, как в словаре \<TKey, TValue> . Если же используется более двух параметров типов, многие пользователи начинают испытывать большие трудности. |
| CA1008 | [CA1008. Перечисляемые типы должны иметь нулевое значение](../code-quality/ca1008.md) | Значение по умолчанию неинициализированного перечисления, как и других типов значений, равно нулю. Перечисление без флагов в качестве атрибутов должно определять член с использованием нулевого значения так, чтобы значение по умолчанию было допустимым значением перечисления. Если перечисление с примененным атрибутом FlagsAttribute определяет член с нулевым значением, для него должно быть задано имя None, свидетельствующее о том, что в перечислении не были заданы значения. |
| CA1010 | [CA1010. Коллекции должны реализовать универсальный интерфейс](../code-quality/ca1010.md) | Чтобы расширить возможности использования коллекции, реализуйте один из универсальных интерфейсов коллекции. Затем данную коллекцию можно использовать для заполнения универсальных типов коллекции. |
| CA1012 | [CA1012. Абстрактные типы не должны иметь конструкторы](../code-quality/ca1012.md) | Конструкторы абстрактных типов могут быть вызваны только производными типами. Открытые конструкторы создают экземпляры типа. Невозможно создавать экземпляры абстрактного типа; абстрактный тип с открытым конструктором является недопустимым. |
| CA1014 | [CA1014. Пометьте сборки с помощью CLSCompliantAttribute](../code-quality/ca1014.md) | Спецификация среды CLS определяет ограничения по именованию, типам данных и правилам, которым должны соответствовать сборки, предназначенные для использования в нескольких языках программирования. Для всех сборок рекомендуется явным образом указывать совместимость с CLS с помощью атрибута <xref:System.CLSCompliantAttribute>. Если этот атрибут у сборки отсутствует, сборка несовместима. |
| CA1016 | [CA1016. Пометьте сборки с помощью AssemblyVersionAttribute](../code-quality/ca1016.md) | .NET использует номер версии для уникальной идентификации сборки и привязки к типам в сборках со строгими именами. Номер версии используется наряду с политикой версий и издателя. По умолчанию приложения выполняются только с версией сборки, которая использовалась для их построения. |
| CA1017 | [CA1017. Пометьте сборки с помощью ComVisibleAttribute](../code-quality/ca1017.md) |Атрибут ComVisibleAttribute определяет порядок обращения клиентов COM к управляемому коду. Для правильной разработки сборки должны явным образом указывать видимость COM. Можно задать видимость COM для всей сборки, а затем переопределить ее для отдельных типов и элементов типов. Если атрибут отсутствует, содержимое сборки будет видимым клиентам COM. |
| CA1018 | [CA1018. Пометьте атрибуты с помощью AttributeUsageAttribute](../code-quality/ca1018.md) | При определении настраиваемого атрибута его нужно пометить атрибутом AttributeUsageAttribute, чтобы указать, где можно применять этот настраиваемый атрибут в исходном коде. Допустимое положение атрибута в коде зависит от значения атрибута и его применения. |
| CA1019 | [CA1019. Определите методы доступа для аргументов атрибута](../code-quality/ca1019.md) | Атрибуты могут определять обязательные аргументы, которые должны быть указаны при применении атрибута к целевому объекту. Они также известны как позиционные аргументы, поскольку предоставляются для конструкторов атрибутов в качестве позиционных параметров. Для каждого обязательного аргумента атрибут должен предоставлять соответствующее свойство, доступное только для чтения, чтобы извлечь значение аргумента во время выполнения. Кроме того, атрибуты могут определять дополнительные параметры, известные как именованные аргументы. Эти аргументы предоставляются для конструкторов атрибутов по имени и должны иметь соответствующее свойство чтения/записи. |
| CA1021 | [CA1021. Не используйте параметры out](../code-quality/ca1021.md) | Для реализации передачи типов по ссылке (с помощью ключевого слова out или ref) от разработчика требуется опыт работы с указателями, понимание отличия между типами значения и ссылочными типами и умение работать с методами с несколькими возвращаемыми значениями. Кроме того, далеко не все понимают разницу между параметрами out и ref. |
| CA1024 | [CA1024. По возможности используйте свойства](../code-quality/ca1024.md) | Имя открытого или защищенного метода начинается с Get, он не принимает параметры и возвращает значение, не являющееся массивом. Возможно, этот метод лучше преобразовать в свойство. |
| CA1027 |[CA1027. Пометьте перечисляемые типы с помощью FlagsAttribute](../code-quality/ca1027.md) | Перечисление является типом значения, которое определяет набор связанных именованных констант. Атрибут FlagsAttribute применяется к перечислению, когда его именованные константы могут быть объединены осмысленным образом. |
| CA1028 | [CA1028. Хранилище перечисляемых типов должно относиться к типу Int32](../code-quality/ca1028.md) | Перечисление является типом значения, которое определяет набор связанных именованных констант. По умолчанию для хранения значения константы используется тип данных System.Int32. Этот базовый тип можно изменить, но это не требуется и в большинстве случаев не рекомендуется. |
| CA1030 | [CA1030. По возможности используйте события](../code-quality/ca1030.md) |Данное правило отслеживает методы с именами, которые, как правило, используются для событий. Если метод вызывается в ответ на четко определенное изменение состояния, то этот вызов должен осуществляться с помощью обработчика событий. Объекты, вызывающие методы, должны создавать события, а не вызывать методы напрямую. |
| CA1031 | [CA1031. Не перехватывайте типы общих исключений](../code-quality/ca1031.md) | Общие исключения не должны перехватываться. Нужно перехватить исключение более конкретного характера или повторно выдать общее исключение в последнем операторе блока catch. |
| CA1032 |[CA1032. Реализуйте стандартные конструкторы исключений](../code-quality/ca1032.md) | Для правильной обработки исключений необходимо предоставить полный набор конструкторов. |
| CA1033 | [CA1033. Методы интерфейса должны быть доступны для вызова дочерними типами](../code-quality/ca1033.md) | Незапечатанный тип, доступный для внешнего кода, предоставляет явную реализацию метода открытого интерфейса и не предоставляет доступный для внешнего кода альтернативный метод с тем же именем. |
| CA1034 | [CA1034. Вложенные типы не должны быть видимыми](../code-quality/ca1034.md) | Вложенный тип — это тип, объявленный внутри области другого типа. Вложенные типы удобно использовать для инкапсуляции закрытых сведений о реализациях содержащего их типа. В силу этого вложенные типы не должны быть видимыми для внешнего кода. |
| CA1036 | [CA1036. Переопределите методы в сопоставимых типах](../code-quality/ca1036.md) |Открытый или защищенный тип реализует интерфейс System.IComparable. Он не переопределяет метод Object.Equals и не перегружает языковой оператор равенства, неравенства, "больше" или "меньше". |
| CA1040 |[CA1040. Не используйте пустые интерфейсы](../code-quality/ca1040.md) | Интерфейсы определяют члены, предоставляющие поведение или соглашение об использовании. Функциональность, описанная интерфейсом, может быть использована любым типом вне зависимости от расположения типа в иерархии интерфейса. Тип реализует интерфейс путем предоставления реализаций для членов интерфейса. Пустой интерфейс не определяет никаких элементов, поэтому он не определяет контракт, который можно реализовать. |
| CA1041 | [CA1041. Укажите сообщение ObsoleteAttribute](../code-quality/ca1041.md) | Тип или элемент помечен атрибутом System.ObsoleteAttribute, для которого не указано свойство ObsoleteAttribute.Message. При компиляции типа или элемента, помеченного атрибутом ObsoleteAttribute, отображается текст свойства Message этого атрибута. Это предоставляет пользователю сведения об устаревшем типе или члене. |
| CA1043 | [CA1043. Используйте целый или строковый аргумент для индексаторов](../code-quality/ca1043.md) | Индексаторы (индексированные свойства) должны использовать для индекса целочисленные или строковые типы. Эти типы обычно используются для индексации структур данных и повышения удобства использования библиотеки. Тип Object следует использовать только в том случае, если во время разработки невозможно указать определенный целочисленный или строковый тип. |
| CA1044 | [CA1044. Свойства не должны быть доступными только для записи](../code-quality/ca1044.md) | Несмотря на то, что допустимо, а часто и необходимо иметь свойство, доступное только на чтение, рекомендации по разработке запрещают использование свойств, доступных только на запись. Это связано с тем, что если позволить пользователю задать значение, а затем запретить ему просматривать это значение, то таким образом не будет обеспечиваться какая-либо безопасность. Кроме того, при отсутствии доступа на чтение нельзя просмотреть состояние общих объектов, что снижает их полезность. |
| CA1045 |[CA1045. Не передавайте типы по ссылке](../code-quality/ca1045.md) | Для реализации передачи типов по ссылке (с помощью ключевого слова out или ref) от разработчика требуется опыт работы с указателями, понимание отличия между типами значения и ссылочными типами и умение работать с методами с несколькими возвращаемыми значениями. Архитекторы библиотек, которые разрабатывается для общей аудитории, не должны ждать, чтобы пользователи работали с главными рабочими `out` `ref` параметрами или. |
| CA1046 | [CA1046. Не перегружайте оператор равенства для ссылочных типов](../code-quality/ca1046.md) | Реализация оператора равенства по умолчанию почти всегда правильно работает для ссылочных типов. По умолчанию две ссылки равны, если они указывают на один объект. |
| CA1047 |[CA1047. Не объявляйте защищенные члены в запечатанных типах](../code-quality/ca1047.md) | Типы объявляют защищенный члены таким образом, чтобы наследующие типы могли получить доступ к члену или переопределить его. По определению наследовать запечатанные типы нельзя; это означает, что вызов защищенных методов для запечатанных типов невозможен. |
| CA1050 | [CA1050. Объявите типы в пространствах имен](../code-quality/ca1050.md) | Типы объявляются в пространствах имен во избежание конфликтов имен и с целью упорядочения связанных типов в иерархии объектов. |
| CA1051 | [CA1051. Не объявляйте видимые поля экземпляров](../code-quality/ca1051.md) | Поля главным образом следует использовать для данных реализации. Поля должны быть помечены как private или internal и должны быть представлены с помощью свойств. |
| CA1052 | [CA1052. Типы со статическими заполнителями должны быть запечатаны](../code-quality/ca1052.md) | Открытый или защищенный тип содержит только статические элементы и не объявлен с модификатором sealed (справочник по C#) (NotInheritable). Тип, для которого нельзя создавать унаследованные типы, должен быть помечен модификатором sealed, чтобы его нельзя было использовать как базовый тип. |
| CA1053 |[CA1053. Типы со статическими заполнителями не должны иметь конструкторы](../code-quality/ca1053.md) | В открытом или вложенном открытом типе объявляются только статические элементы и имеется открытый или защищенный конструктор по умолчанию. Конструктор не нужен, поскольку при вызове статических членов не требуется экземпляр типа. Для обеспечения безопасности перегруженная строка должна вызывать перегрузку универсального кода ресурса (URI), используя строковый аргумент. |
| CA1054 | [CA1054. Параметры URI не должны быть строками](../code-quality/ca1054.md) | Если метод принимает строковое представление универсального кода ресурса (URI), необходимо предоставить соответствующую перегрузку, принимающую экземпляр класса URI, который предоставляет эти услуги безопасным образом. |
| CA1055 | [CA1055. Возвращаемые значения URI не должны быть строками](../code-quality/ca1055.md) | В этом правиле предполагается, что метод возвращает универсальный код ресурса (URI). В строковых представлениях кода URI часто встречаются ошибки синтаксического анализа и кодирования, которые могут привести к уязвимостям системы безопасности. Класс System.Uri предоставляет аналогичные услуги более надежным и безопасным способом. |
| CA1056 | [CA1056. Свойства URI не должны быть строками](../code-quality/ca1056.md) | В этом правиле предполагается, что свойство является универсальным кодом ресурса (URI). В строковых представлениях кода URI часто встречаются ошибки синтаксического анализа и кодирования, которые могут привести к уязвимостям системы безопасности. Класс System.Uri предоставляет аналогичные услуги более надежным и безопасным способом. |
| CA1058 | [CA1058. Типы не должны расширять определенные базовые типы](../code-quality/ca1058.md) | Видимый извне тип расширяет некоторые базовые типы. Используйте только один вариант. |
| CA1060 | [CA1060: перемещение P/Invoke в класс NativeMethods](../code-quality/ca1060.md) | Методы PInvoke, например методы, помеченные атрибутом System.Runtime.InteropServices.DllImportAttribute, или методы, определенные с помощью ключевого слова Declare в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)], обращаются к неуправляемому коду. Эти методы должны относиться к классу NativeMethods, SafeNativeMethods или UnsafeNativeMethods. |
| CA1061 |[CA1061. Не скрывайте методы базовых классов](../code-quality/ca1061.md) | Метод в базовом типе скрыт методом с таким же именем в производном типе. Сигнатура параметра производного метода отличается только типами, которые являются более слабыми, чем соответствующие типы в сигнатуре параметра базового метода. |
| CA1062 | [CA1062. Проверьте аргументы или открытые методы](../code-quality/ca1062.md) | Все ссылочные аргументы, передаваемые в видимые для внешнего кода методы, должны проверяться на равенство значению NULL. |
| CA1063 | [CA1063. Правильно реализуйте IDisposable](../code-quality/ca1063.md) | Все типы IDisposable должны правильно реализовывать шаблон "Dispose". |
| CA1064 | [CA1064. Исключения должны быть общими](../code-quality/ca1064.md) | Внутреннее исключение видно только внутри своей внутренней области. После выхода исключения за пределы внутренней области для перехвата исключения можно использовать только базовое исключение. Если внутреннее исключение наследуется от <xref:System.Exception> , <xref:System.SystemException> или <xref:System.ApplicationException> , внешний код не будет иметь достаточных сведений, чтобы узнать, что делать с этим исключением. |
| CA1065 | [CA1065. Не вызывайте исключения в непредвиденных местах](../code-quality/ca1065.md) | Метод вызывает исключение, хотя не должен этого делать. |
| CA1066 | [CA1066: реализация IEquatable при переопределении Equals](../code-quality/ca1066.md) | Тип значения переопределяет <xref:System.Object.Equals%2A> метод, но не реализует <xref:System.IEquatable%601> . |
| CA1067 | [CA1067: переопределение Equals при реализации IEquatable](../code-quality/ca1067.md) | Тип реализует <xref:System.IEquatable%601> , но не переопределяет <xref:System.Object.Equals%2A> метод. |
| CA1068 | [CA1068: Параметры CancellationToken должны быть последними](../code-quality/ca1068.md) | Метод имеет параметр CancellationToken, который не является последним параметром. |
| CA1069 | [CA1069: перечисления не должны иметь повторяющихся значений](../code-quality/ca1069.md) | Перечисление содержит несколько членов, которым явным образом присвоено одно и то же значение константы. |
| CA1070 | [CA1070: не объявляйте поля событий как виртуальные](../code-quality/ca1070.md) | [Событие, похожее на поле](/dotnet/csharp/language-reference/language-specification/classes#field-like-events) , было объявлено как виртуальное. |
| CA1200 | [CA1200: Избегайте использования тегов cref с префиксом](../code-quality/ca1200.md) | Атрибут [cref](/dotnet/csharp/programming-guide/xmldoc/cref-attribute) в ТЕГЕ документации XML означает "ссылка на код". Он указывает, что текст внутри тега представляет собой элемент кода, например тип, метод или свойство. Старайтесь не использовать `cref` теги с префиксами, так как это не позволяет компилятору проверять ссылки. Это также предотвращает Поиск и обновление этих ссылок на символы во время рефакторинга в интегрированной среде разработки (IDE) Visual Studio. |
| CA1303 | [CA1303. Не передавайте литералы в качестве локализованных параметров](../code-quality/ca1303.md) | Метод, видимый извне, передает строковый литерал в качестве параметра в конструктор или метод .NET, и эта строка должна быть локализуемой. |
| CA1304 | [CA1304. Указывайте CultureInfo](../code-quality/ca1304.md) | Метод или конструктор вызывает член, имеющий перегрузку, которая принимает параметр System.Globalization.CultureInfo, вместо того чтобы вызвать перегрузку, принимающую параметр CultureInfo. Если объект CultureInfo или System.IFormatProvider не предоставляется, значение по умолчанию, поставляемое перегруженным членом, может не оказать ожидаемого воздействия во всех языковых стандартах. |
| CA1305 | [CA1305. Указывайте IFormatProvider](../code-quality/ca1305.md) | Метод или конструктор вызывает один или несколько членов, имеющих перегрузки, которые принимают параметр System.IFormatProvider, вместо того чтобы вызвать перегрузку, принимающую параметр IFormatProvider. Если объект System.Globalization.CultureInfo или IFormatProvider не предоставляется, значение по умолчанию, поставляемое перегруженным членом, может не оказать ожидаемого воздействия во всех языковых стандартах. |
| CA1307 | [CA1307. Используйте StringComparison, чтобы ясно указать намерение.](../code-quality/ca1307.md) | В операции сравнения строк используется перегрузка метода, которая не задает параметр StringComparison. |
| CA1308 |[CA1308. Нормализуйте строки в верхний регистр](../code-quality/ca1308.md) | Строки следует нормализовать в верхний регистр. Существует небольшая группа символов, которые после преобразования в нижний регистр не могут участвовать в круговом перемещении. |
| CA1309 | [CA1309. Используйте порядковый параметр StringComparison](../code-quality/ca1309.md) | Операция сравнения строк, не являющаяся лингвистической, не задает для параметра StringComparison ни значения Ordinal, ни значения OrdinalIgnoreCase. После явного задания для параметра значения StringComparison.Ordinal или StringComparison.OrdinalIgnoreCase код часто становится более надежным и правильным, кроме того, увеличивается скорость его выполнения. |
| CA1310 | [CA1310. Используйте StringComparison, чтобы правильно указать намерение.](../code-quality/ca1310.md) | Операция сравнения строк использует перегрузку метода, которая не задает параметр StringComparison и использует сравнение строк по умолчанию для определенного языка и региональных параметров. |
| CA1401 | [CA1401: методы P/Invoke не должны быть видимыми](../code-quality/ca1401.md) | Открытый или защищенный метод в открытом типе имеет атрибут System.Runtime.InteropServices.DllImportAttribute (также реализуется в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)] с помощью ключевого слова Declare). Такие методы не следует делать видимыми. |
| CA1417 | [CA1417: не используйте `OutAttribute` в строковых параметрах для P/Invoke](../code-quality/ca1417.md) | Строковые параметры, передаваемые по значению, `OutAttribute` могут дестабилизировать среду выполнения, если строка является интернированной строкой. |
| CA1501 | [CA1501. Избегайте излишнего наследования](../code-quality/ca1501.md) | Тип расположен глубже четырех уровней в иерархии наследования. Глубокие иерархии вложенных типов трудно отслеживать, понимать и поддерживать. |
| CA1502 | [CA1502. Избегайте чрезмерной сложности](../code-quality/ca1502.md) | Это правило измеряет число линейно независимых путей в методе, которое определяется числом и сложностью условных ветвей. |
| CA1505 | [CA1505. Избегайте кода, неудобного для поддержки](../code-quality/ca1505.md) | Тип или метод имеет низкий индекс обслуживаемости. Низкий индекс удобства поддержки означает, что тип или метод, вероятно, трудно поддерживать, поэтому их следует переработать. |
| CA1506 | [CA1506. Избегайте чрезмерной взаимозависимости классов](../code-quality/ca1506.md) | Данное правило измеряет взаимозависимость классов путем подсчета количества уникальных ссылок на типы, содержащихся в типе или методе. |
| CA1507 | [CA1507: Используйте nameof вместо строки](../code-quality/ca1507.md) | Строковый литерал используется в качестве аргумента, где `nameof` можно использовать выражение. |
| CA1508 | [CA1508: Избегайте появления неиспользуемого условного кода](../code-quality/ca1508.md) | Метод имеет условный код, который всегда вычисляется как `true` или `false` во время выполнения. Это приводит к неработающему коду в `false` ветви условия. |
| CA1509 | [CA1509: недопустимая запись в файле конфигурации метрик кода](../code-quality/ca1509.md) | Правила метрик кода, такие как [CA1501](ca1501.md), [CA1502](ca1502.md), [CA1505](ca1505.md) и [CA1506](ca1506.md), указали файл конфигурации с именем `CodeMetricsConfig.txt` , который имеет недопустимую запись. |
| CA1700 | [CA1700. Не присваивайте перечисляемым значениям имя Reserved](../code-quality/ca1700.md) | В данном правиле предполагается, что член перечисления, имя которого содержит слово "reserved", не используется в настоящее время, а является местозаполнителем, который будет в дальнейшем переименован или удален. Переименование или удаление элемента — это критическое изменение. |
| CA1707 | [CA1707. Идентификаторы не должны содержать символы подчеркивания](../code-quality/ca1707.md) | В соответствии с соглашением имена идентификаторов не могут содержать знак подчеркивания (_). Это правило позволяет проверить пространства имен, типы, элементы и параметры. |
| CA1708 | [CA1708. Идентификаторы должны отличаться не только прописными и строчными буквами](../code-quality/ca1708.md) | Идентификаторы пространств имен, типов, членов и параметров не могут отличаться только регистром знаков, поскольку языки программирования, поддерживаемые средой CLR, не обязательно учитывают регистр знаков. |
| CA1710 | [CA1710. Идентификаторы должны иметь правильные суффиксы](../code-quality/ca1710.md) |По правилам имена типов, расширяющих определенные базовые типы или реализующих определенные интерфейсы, а также типов, являющихся производными от первых, имеют суффикс, связанный с базовым типом или интерфейсом. |
| CA1711 | [CA1711. Идентификаторы не должны иметь неправильные суффиксы](../code-quality/ca1711.md) | В соответствии с соглашением об именовании, определенные зарезервированные суффиксы должны добавляться только к именам типов, которые расширяют некоторые базовые типы или реализуют определенные интерфейсы, а также производных от них типов. В именах других типов зарезервированные суффиксы использоваться не должны. |
| CA1712 | [CA1712. Не добавляйте имя типа перед перечисляемыми значениями](../code-quality/ca1712.md) | Имена членов перечисления не должны содержать префиксов в виде имени типа, поскольку предполагается, что сведения о типе предоставляются средствами разработки. |
| CA1713 | [CA1713. События не должны иметь префикс before или after](../code-quality/ca1713.md) | Имя события начинается с Before или After. Чтобы дать имена связанным событиям, возникающим в определенной последовательности, используйте настоящее или прошедшее время, чтобы обозначить положение события в последовательности действий. |
| CA1714 | [CA1714. У перечислений флагов должны быть имена во множественном числе](../code-quality/ca1714.md) | Открытое перечисление содержит атрибут System.FlagsAttribute, и имя перечисления не заканчивается на "s". Имена типов, помеченных атрибутом FlagsAttribute, используются во множественном числе, поскольку данный атрибут указывает на возможность задания нескольких значений. |
| CA1715 | [CA1715. Идентификаторы должны иметь правильные префиксы](../code-quality/ca1715.md) | Имя доступного для внешнего кода интерфейса не начинается с заглавной буквы "I". Имя параметра универсального типа в доступном для внешнего кода типе или методе не начинается с заглавной буквы "Т". |
| CA1716 | [CA1716. Идентификаторы не должны совпадать с ключевыми словами](../code-quality/ca1716.md) | Имя пространства имен или типа совпадает с ключевым словом, зарезервированным в языке программирования. Идентификаторы пространств имен и типов не должны совпадать с ключевыми словами, определенными в языках, поддерживаемых в среде CLR. |
| CA1717 | [CA1717. Только перечисления FlagsAttribute должны иметь имена во множественном числе](../code-quality/ca1717.md) | Согласно правилам именования множественное число имени перечисления указывает, что одновременно можно задать несколько значений перечисления. |
| CA1720 |[CA1720. Идентификаторы не должны содержать имена типов](../code-quality/ca1720.md) | Имя параметра в доступном для внешнего кода элементе содержит имя типа данных, или имя доступного для внешнего кода элемента содержит языковое имя типа данных. |
| CA1721 | [CA1721. Имена свойств не должны совпадать с именами методов get](../code-quality/ca1721.md) |Имя открытого или защищенного элемента начинается с Get и соответствует имени открытого или защищенного свойства и по другим параметрам. Методы Get и свойства должны иметь имена, позволяющие четко различать их функции. |
| CA1724 | [CA1724. Имена типов не должны совпадать с именами пространства имен](../code-quality/ca1724.md) | Имена типов не должны совпадать с именами пространств имен .NET. Нарушение этого правила приводит к уменьшению функциональности библиотеки. |
| CA1725 | [CA1725. Имена параметров должны соответствовать базовому объявлению](../code-quality/ca1725.md) | Согласованное именование параметров в иерархии переопределений увеличивает удобство использования переопределений метода. Если имя параметра в производном методе отличается от имени в базовом объявлении, может возникнуть путаница в определении того, чем является метод: переопределением базового метода или новой перегрузкой. |
| CA1801 | [CA1801. Проверьте неиспользуемые параметры](../code-quality/ca1801.md) | Сигнатура метода включает параметр, не использующийся в основной части метода. |
| CA1802 |[CA1802. По возможности используйте литералы](../code-quality/ca1802.md) |Поле объявляется статичным и доступным только для чтения (Shared и ReadOnly в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]) и инициализируется со значением, вычисляемым во время компиляции. Так как значение, назначенное целевому полю, вычисляемым во время компиляции, измените объявление на const (const в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)] ) поле, чтобы значение было вычислено во время компиляции, а не во время выполнения. |
| CA1805 | [CA1805: Не делайте лишних инициализаций](../code-quality/ca1805.md) | Среда выполнения .NET инициализирует все поля ссылочных типов значениями по умолчанию перед выполнением конструктора. В большинстве случаев явное инициализация поля значением по умолчанию является избыточным, что добавляет к затратам на обслуживание и может привести к снижению производительности (например, при увеличении размера сборки). |
| CA1806 | [CA1806. Не игнорируйте результаты метода](../code-quality/ca1806.md) | Создается, но никогда не используется новый объект, либо вызывается метод, который создает и возвращает новую строку, и такая новая строка никогда не используется, либо метод COM или P/Invoke возвращает HRESULT или код ошибки, который никогда не используется. |
| CA1810 | [CA1810. Инициализируйте статические поля ссылочных типов при объявлении](../code-quality/ca1810.md) | Если в типе объявляется явный статический конструктор, компилятор JIT добавляет проверку в каждый статический метод и конструктор экземпляров этого типа, чтобы убедиться, что статический конструктор уже вызывался ранее. Проверки статических конструкторов могут привести к снижению производительности. |
| CA1812 | [CA1812. Избегайте неиспользуемых внутренних классов](../code-quality/ca1812.md) | Экземпляр типа уровня сборки не создается кодом в сборке. |
| CA1813 | [CA1813. Избегайте незапечатанных атрибутов](../code-quality/ca1813.md) | .NET предоставляет методы для извлечения пользовательских атрибутов. По умолчанию эти методы осуществляют поиск иерархии наследования атрибутов. Если запечатать атрибут, поиск в иерархии наследования выполняться не будет, в результате чего может повыситься производительность. |
| CA1814 | [CA1814. Используйте массивы массивов вместо многомерных массивов](../code-quality/ca1814.md) | Массив массивов — это массив, элементы которого сами являются массивами. Массивы, которые составляют элементы, могут иметь различные размеры, что позволяет экономить пространство для некоторых наборов данных. |
| CA1815 | [CA1815. Переопределяйте операторы Equals и равенства для типов значений](../code-quality/ca1815.md) | В унаследованной реализации Equals для типов значений используется библиотека отражения и сравнивается содержимое всех полей. Отражение является процессом, требующим с точки зрения вычислений больших затрат, и сравнение каждого поля на равенство может быть лишним. Если предполагается, что пользователи будут сравнивать, сортировать экземпляры или использовать их в качестве ключей хэш-таблиц, тип значения должен реализовывать Equals. |
| CA1816 | [CA1816. Вызов GC.SuppressFinalize должен осуществляться правильно](../code-quality/ca1816.md) | Метод, являющийся реализацией Dispose, не вызывает GC.SuppressFinalize, либо метод, не являющийся реализацией Dispose, вызывает GC.SuppressFinalize, либо метод вызывает GC.SuppressFinalize и передает что-либо другое (Me в Visual Basic). |
| CA1819 | [CA1819. Свойства не должны возвращать массивы](../code-quality/ca1819.md) | Массивы, возвращаемые свойствами, не защищены от записи, даже если свойство доступно только для чтения. Чтобы защитить массив от изменений, свойство должно возвращать копию массива. Как правило, пользователи не понимают требований к производительности при вызове такого свойства. |
| CA1820 | [CA1820. Проверяйте наличие пустых строк, используя длину строки](../code-quality/ca1820.md) | Сравнивать строки с использованием свойства String.Length или метода String.IsNullOrEmpty значительно быстрее, чем с помощью Equals. |
| CA1821 | [CA1821. Удалите пустые методы завершения](../code-quality/ca1821.md) | Если возможно, старайтесь не использовать финализаторы, поскольку из-за отслеживания жизненного срока объектов снижается производительность программы. Пустой метод завершения создает дополнительную нагрузку на систему, не обеспечивая никаких преимуществ. |
| CA1822 |[CA1822. Пометьте члены как статические](../code-quality/ca1822.md) | Члены, не обращающиеся к данным экземпляра и не вызывающие методы экземпляра, можно пометить как статические (Shared в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]). Если пометить методы как статические, компилятор предоставит этим членам невиртуальные места вызова. Это обеспечивает значительное повышение производительности при работе с кодом, для которого важна высокая производительность системы. |
| CA1823 | [CA1823. Избегайте неиспользуемых частных полей](../code-quality/ca1823.md) | Обнаружены закрытые поля, доступ к которым, судя по всему, не предоставляется в сборке. |
| CA1824 |[CA1824. Помечайте сборки с помощью NeutralResourcesLanguageAttribute](../code-quality/ca1824.md) | Атрибут NeutralResourcesLanguage информирует диспетчер ресурсов о языке, который использовался для вывода ресурсов нейтральной культуры для сборки. При этом повышается эффективность поиска первого загружаемого ресурса и может сократиться рабочее множество. |
| CA1825 |[CA1825: Избегайте выделения массивов нулевой длины](../code-quality/ca1825.md) | Инициализация массива нулевой длины приводит к ненужному выделению памяти. Вместо этого используйте статический выделенный экземпляр пустого массива, вызвав метод <xref:System.Array.Empty%2A?displayProperty=nameWithType> . Выделение памяти является общим для всех вызовов этого метода. |
| CA1826 |[CA1826: Используйте свойство вместо метода Enumerable в LINQ](../code-quality/ca1826.md) | <xref:System.Linq.Enumerable> Метод LINQ использовался для типа, который поддерживает эквивалентное, более эффективное свойство. |
| CA1827 |[CA1827: Не используйте Count/LongCount, если можно использовать Any](../code-quality/ca1827.md) | <xref:System.Linq.Enumerable.Count%2A><xref:System.Linq.Enumerable.LongCount%2A>метод или был использован, когда <xref:System.Linq.Enumerable.Any%2A> метод был бы более эффективным. |
| CA1828 |[CA1828: Не используйте CountAsync/LongCountAsync, если можно использовать AnyAsync](../code-quality/ca1828.md) | <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A>метод или был использован, когда <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> метод был бы более эффективным. |
| CA1829 |[CA1829: Используйте свойство Length/Count вместо метода Enumerable.Count](../code-quality/ca1829.md) | <xref:System.Linq.Enumerable.Count%2A> Метод LINQ использовался для типа, который поддерживает эквивалентное, более эффективное `Length` или `Count` свойство. |
| CA1830 |[CA1830: предпочитать строго типизированные перегрузки методов Append и Insert в StringBuilder](../code-quality/ca1830.md) | <xref:System.Text.StringBuilder.Append%2A> и <xref:System.Text.StringBuilder.Insert%2A> предоставляют перегрузки для нескольких типов, кроме <xref:System.String> .  По возможности рекомендуется использовать строго типизированные перегрузки с использованием ToString () и перегрузки на основе строк. |
| CA1831 |[CA1831: при необходимости используйте AsSpan вместо индексаторов на основе диапазона для строки](../code-quality/ca1831.md) | При использовании индексатора диапазона для строки и неявного присваивания значения Реадонлиспан &lt; &gt; типу Char метод <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> будет использоваться вместо <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , который создает копию запрошенной части строки. |
| CA1832 |[CA1832: используйте AsSpan или AsMemory вместо индексаторов на основе диапазона для получения части массива ReadOnlySpan или ReadOnlyMemory](../code-quality/ca1832.md) | При использовании индексатора диапазонов для массива и неявного присваивания значения <xref:System.ReadOnlySpan%601> <xref:System.ReadOnlyMemory%601> типу или, метод <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> будет использоваться вместо <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , который создает копию запрошенной части массива. |
| CA1833 |[CA1833: используйте AsSpan или AsMemory вместо индексаторов на основе диапазона для получения части массива Span или Memory](../code-quality/ca1833.md) | При использовании индексатора диапазонов для массива и неявного присваивания значения <xref:System.Span%601> <xref:System.Memory%601> типу или, метод <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> будет использоваться вместо <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , который создает копию запрошенной части массива. |
| CA1834 |[CA1834: используйте StringBuilder.Append(char) для строк с одним символом.](../code-quality/ca1834.md) | <xref:System.Text.StringBuilder> имеет `Append` перегрузку, которая принимает в `char` качестве аргумента. Предпочитать вызов `char` перегрузки для повышения производительности. |
| CA1835 |[CA1835: предпочитать перегрузки на основе Мемори' для "ReadAsync" и "WriteAsync"](../code-quality/ca1835.md) | "Stream" имеет перегрузку "ReadAsync", которая принимает " &lt; байт памяти &gt; " в качестве первого аргумента, и перегрузка "WriteAsync", принимающая в &lt; &gt; качестве первого аргумента значение "реадонлимемори Byte". Предпочитать вызов перегрузок на основе памяти, что более эффективно. |
| CA1836 |[CA1836: предпочитать `IsEmpty` `Count` при доступности](../code-quality/ca1836.md) | Предпочитать `IsEmpty` свойство, которое более эффективно, чем `Count` , `Length` , <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> или, <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> чтобы определить, содержит ли объект какие-либо элементы или нет. |
| CA1837 | [CA1837: используйте `Environment.ProcessId` вместо `Process.GetCurrentProcess().Id`](../code-quality/ca1837.md) | `Environment.ProcessId` проще и быстрее, чем `Process.GetCurrentProcess().Id` . |
| CA1838 | [CA1838: Избегайте `StringBuilder` параметров для вызовов P/Invoke](../code-quality/ca1838.md) | При упаковке "StringBuilder" всегда создается собственная копия буфера, что приводит к многократному выделению для одной операции упаковки. |
| CA2000 | [CA2000. Ликвидируйте объекты перед потерей области](../code-quality/ca2000.md) | Необходимо явно удалить объект до того, как все ссылки на него окажутся вне области действия, так как может произойти исключительное событие, которое воспрепятствует выполнению метода завершения объекта. |
| CA2002 |[CA2002. Не блокируйте объекты с ненадежными удостоверениями](../code-quality/ca2002.md) |К объекту со слабой идентификацией может быть получен прямой доступ через границы домена приложения. Поток пытается получить блокировку объекта со слабой идентификацией, который может быть заблокирован вторым потоком в другом домене приложения, имеющим блокировку того же объекта. |
| CA2007 | [CA2007. Не следует напрямую ожидать Task](ca2007.md) | Асинхронный метод [ожидает](/dotnet/csharp/language-reference/keywords/await) <xref:System.Threading.Tasks.Task> непосредственного. Когда асинхронный метод ожидает <xref:System.Threading.Tasks.Task> непосредственного выполнения, продолжение происходит в том же потоке, в котором была создана задача. Такое поведение может быть дорогостоящим в плане производительности и может привести к взаимоблокировке потока пользовательского интерфейса. Рассмотрите возможность вызова <xref:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)?displayProperty=nameWithType> , чтобы сообщить о намерении к продолжению. |
| CA2008 | [CA2008. Не создавайте задачи без передачи TaskScheduler](ca2008.md) | Операция создания или продолжения задачи использует перегрузку метода, в которой не указан <xref:System.Threading.Tasks.TaskScheduler> параметр. |
| CA2009 | [CA2009: Не вызывайте ToImmutableCollection для значения ImmutableCollection](ca2009.md) | `ToImmutable` метод не обязательно был вызван для неизменяемой коллекции из <xref:System.Collections.Immutable> пространства имен. |
| CA2011 | [CA2011: не присваивайте свойство в методе задания](ca2011.md) | Свойству было случайно присвоено значение в собственном [методе доступа set](/dotnet/csharp/programming-guide/classes-and-structs/using-properties#the-set-accessor). |
| CA2012 | [CA2012: используйте ValueTasks правильно](ca2012.md) | Валуетаскс, возвращенные из вызовов членов, должны быть непосредственно ожидаются.  Попытки использовать ValueTask несколько раз или для прямого доступа к одному результату до его завершения могут привести к возникновению исключения или повреждения.  Пропуск такого ValueTask, скорее всего, указывает на функциональную ошибку и может привести к снижению производительности. |
| CA2013 | [CA2013: не используйте ReferenceEquals с типами значений](ca2013.md) | При сравнении значений с помощью <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> , если обжа и обжб являются типами значений, они упаковываются перед передачей в <xref:System.Object.ReferenceEquals%2A> метод. Это означает, что даже если оба обжа и Обжб представляют один и тот же экземпляр типа значения, <xref:System.Object.ReferenceEquals%2A> метод, тем не менее, возвращает значение false. |
| CA2014 | [CA2014: не используйте stackalloc в циклах.](ca2014.md) | Пространство стека, выделенное stackalloc, освобождается только в конце вызова текущего метода.  Использование в цикле может привести к неограниченному росту стека и появлению условий переполнения стека. |
| CA2015 | [CA2015: не определяйте методы завершения для типов, производных от Мемориманажер &lt; T&gt;](ca2015.md) | Добавление метода завершения к типу, производному от, <xref:System.Buffers.MemoryManager%601> может привести к освобождению памяти, пока она еще используется <xref:System.Span%601> . |
| CA2016 | [CA2016: Переадресовывать параметр CancellationToken методам, которые его принимают](ca2016.md) | Перешлите `CancellationToken` параметр методам, принимающим один из них, чтобы убедиться, что уведомления об отмене операций правильно распространены, или явно передать, `CancellationToken.None` чтобы указать намеренно не распространять маркер. |
| CA2100 | [CA2100. Проверьте запросы SQL на наличие уязвимостей системы безопасности](../code-quality/ca2100.md) | Метод задает свойство System.Data.IDbCommand.CommandText с использованием строки, созданной из строкового аргумента метода. Это правило предполагает, что строковый аргумент содержит введенные пользователем данные. Созданная из введенных пользователем данных командная строка SQL уязвима перед атаками путем внедрения кода SQL. |
| CA2101 |[CA2101: укажите маршалирование для строковых аргументов P/Invoke](../code-quality/ca2101.md) | Член вызова неуправляемого кода, разрешающий вызовы с частичным доверием, содержит строковый параметр и не выполняет явный маршалинг и преобразование этой строки. Это может стать причиной потенциальной уязвимости безопасности. |
| CA2109 | [CA2109. Проверьте видимые обработчики событий](../code-quality/ca2109.md) | Обнаружен открытый или защищенный метод обработки событий. Методы обработки событий следует раскрывать только в тех случаях, когда это совершенно необходимо. |
| CA2119 | [CA2119. Запечатайте методы, соответствующие частным интерфейсам](../code-quality/ca2119.md) | Наследуемый открытый тип предоставляет реализацию переопределяемого метода внутреннего (Friend в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]) интерфейса. Для устранения нарушения данного правила следует исключить возможность переопределения метода за пределами сборки. |
| CA2153 |[CA2153: Избегайте обработки исключений поврежденного состояния](../code-quality/ca2153.md) | Исключения поврежденного состояния (CSE) указывают на то, что в процессе существует повреждение памяти. Если перехватывать их вместо того, чтобы позволить процессу завершиться сбоем, это может привести к уязвимостям в системе безопасности, если злоумышленнику удастся поместить эксплойт в поврежденную область памяти. |
| CA2200 | [CA2200. Повторно порождайте исключения для сохранения сведений стека](../code-quality/ca2200.md) | В операторе throw повторно создается и явным образом задается исключение. Если исключение повторно создается заданием исключения в операторе throw, список вызовов метода между исходным методом, создавшим исключение, и текущим методом будет утерян. |
| CA2201 | [CA2201. Не порождайте исключения зарезервированных типов](../code-quality/ca2201.md) | Из-за этого становится трудно обнаружить и отладить изначальную ошибку. |
| CA2207 | [CA2207. Используйте встроенную инициализацию статических полей типов значений](../code-quality/ca2207.md) | Тип значения объявляет явный статический конструктор. Чтобы устранить нарушение данного правила, выполните инициализацию всех статических данных при их объявлении и удалите статический конструктор. |
| CA2208 |[CA2208. Правильно создавайте экземпляры исключений аргументов](../code-quality/ca2208.md) | Вызывается конструктор по умолчанию (без параметров), принадлежащий к типу исключения ArgumentException или унаследованный от него, или неправильный аргумент строки передается параметризованному конструктору, принадлежащему к типу исключения ArgumentException или унаследованному от него. |
| CA2211 |[CA2211. Поля, не являющиеся константами, не должны быть видимыми](../code-quality/ca2211.md) | Для статических полей, которые не являются константными и доступными только для чтения, невозможно обеспечить потокобезопасность. Доступ к подобным полям должен тщательно контролироваться, и для синхронизации доступа к такому объекту класса требуются дополнительные методы программирования. |
| CA2213 | [CA2213. Следует высвобождать высвобождаемые поля](../code-quality/ca2213.md) | Тип, реализующий System.IDisposable, объявляет поля, принадлежащие к типам, которые также реализуют IDisposable. Метод Dispose поля не вызывается методом Dispose объявляющего типа. |
| CA2214 | [CA2214. Не вызывайте переопределяемые методы в конструкторах](../code-quality/ca2214.md) | Когда конструктор вызывает виртуальный метод, возможна ситуация, когда конструктор для экземпляра, вызывающего метод, не выполняется. |
| CA2215 | [CA2215. Метод Dispose должен вызывать базовый класс Dispose](../code-quality/ca2215.md) | Если тип наследуется от удаляемого типа, он должен вызвать метод Dispose базового типа из собственного метода Dispose. |
| CA2216 |[CA2216. Высвобождаемые типы должны объявлять методы завершения](../code-quality/ca2216.md) | Тип, который реализует System.IDisposable и имеет поля, предусматривающие использование неуправляемых ресурсов, не реализует метод завершения, как описано в Object.Finalize. |
| CA2217 | [CA2217. Не помечайте перечисляемые типы с помощью FlagsAttribute](../code-quality/ca2217.md) |Доступное для внешнего кода перечисление помечено атрибутом FlagsAttribute и имеет одно или несколько значений, которые не являются степенью двойки или сочетанием других определенных значений в перечислении. |
| CA2219 | [CA2219. В предложениях с исключениями не должны порождаться исключения](../code-quality/ca2219.md) | Если исключение создается в предложении finally или fault, новое исключение скрывает активное исключение. Если исключение создается в предложении filter, среда выполнения перехватывает исключение без оповещения. Из-за этого становится трудно обнаружить и отладить изначальную ошибку. |
| CA2225 | [CA2225. Для перегрузок операторов существуют варианты с именами](../code-quality/ca2225.md) |Обнаружена перегрузка оператора, однако не найден ожидаемый именованный альтернативный метод. Именованный альтернативный член предоставляет те же функции, что и основной оператор, и его могут использовать разработчики, которые программируют на языках, не поддерживающих перегрузку операторов. |
| CA2226 | [CA2226. Перегрузки операторов должны быть симметричными](../code-quality/ca2226.md) | Тип реализует оператор равенства или неравенства, но не реализует противоположный оператор. |
| CA2227 |[CA2227. Свойства, возвращающие коллекции, должны быть доступными только для чтения](../code-quality/ca2227.md) |Свойство коллекции, допускающее запись, позволяет пользователю заменять одну коллекцию другой. Свойство только для чтения предотвращает замену коллекции, но по-прежнему допускает установку, настройку отдельных членов. |
| CA2229 | [CA2229. Реализуйте конструкторы сериализации](../code-quality/ca2229.md) | Чтобы устранить нарушение этого правила, реализуйте конструктор сериализации. Для запечатанного класса конструктор должен быть закрытым, а в иных случаях — защищенным. |
| CA2231 | [CA2231. Перегрузите оператор равенства на переопределяющем типе ValueType.Equals](../code-quality/ca2231.md) | Тип значения переопределяет Object.Equals, но не реализует оператор равенства. |
| CA2234 | [CA2234. Передавайте объекты System.Uri вместо строк](../code-quality/ca2234.md) | Вызывается метод, имеющий параметр строки, имя которого содержит uri, URI, urn, URN, url или URL. Объявляющий тип метода содержит соответствующую перегрузку метода, которая имеет параметр System.Uri. |
| CA2235 | [CA2235. Пометьте все несериализуемые поля](../code-quality/ca2235.md) | Экземпляр поля несериализуемого типа объявлен в сериализуемом типе. |
| CA2237 | [CA2237. Пометьте типы ISerializable атрибутом SerializableAttribute](../code-quality/ca2237.md) | Чтобы среда CLR распознавала тип как сериализуемый, он должен быть помечен атрибутом SerializableAttribute, даже если тип использует пользовательскую процедуру сериализации посредством реализации интерфейса ISerializable. |
| CA2241 | [CA2241. Задайте правильные аргументы для методов форматирования](../code-quality/ca2241.md) | Аргумент формата, переданный методу System.String.Format, не содержит элемент форматирования, соответствующий каждому аргументу объекта, или наоборот. |
| CA2242 |[CA2242. Правильно выполняйте проверку NaN](../code-quality/ca2242.md) | Это выражение проверяет значение на соответствие Single.Nan или Double.Nan. Используйте Single.IsNan(Single) или Double.IsNan(Double) для проверки значения. |
| CA2243 |[CA2243. Синтаксический разбор строковых литералов должен осуществляться правильно](../code-quality/ca2243.md) | Не удается правильно выполнить синтаксический анализ параметра строкового литерала атрибута для URL-адреса, идентификатора GUID или версии. |
| CA2244 | [CA2244: не повторяйте инициализацию индексируемых элементов](../code-quality/ca2244.md) | Инициализатор объекта имеет более одного инициализатора индексированных элементов с одинаковым индексом константы. Все, кроме последнего инициализатора, являются избыточными. |
| CA2245 | [CA2245: не назначайте свойство самому себе](../code-quality/ca2245.md) | Свойство было случайно назначено самому себе. |
| CA2246 | [CA2246: не присваивайте значения символу и его элементу в одном операторе](../code-quality/ca2246.md) | Не рекомендуется назначать символ и его член, то есть поле или свойство в одной и той же инструкции. Неясно, если доступ к члену был предназначен для использования старого значения символа до присваивания или нового значения из назначения в этой инструкции. |
| CA2247 | [CA2247: аргумент, переданный в конструктор TaskCompletionSource, должен быть TaskCreationOptions enum вместо TaskContinuationOptions Enum.](../code-quality/ca2247.md) | TaskCompletionSource имеет конструкторы, принимающие TaskCreationOptions, которые управляют базовой задачей, и конструкторы, которые принимают состояние объекта, сохраненное в задаче.  Случайная передача TaskContinuationOptions вместо TaskCreationOptions приведет к тому, что в вызове будут рассматриваться параметры как состояние. |
| CA2248 | [CA2248: укажите правильный аргумент enum для Enum.HasFlag](../code-quality/ca2248.md) | Тип перечисления, переданный в качестве аргумента в `HasFlag` вызов метода, отличается от вызывающего типа перечисления. |
| CA2249 | [CA2249. Попробуйте использовать String.Contains вместо String.IndexOf.](../code-quality/ca2249.md) | Вызовы, `string.IndexOf` где результат используется для проверки наличия и отсутствия подстроки, можно заменить на `string.Contains` . |
| CA2300 | [CA2300. Не используйте небезопасный десериализатор BinaryFormatter](../code-quality/ca2300.md) | Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами. |
| CA2301 | [CA2301. Не вызывайте BinaryFormatter.Deserialize, не задав предварительно BinaryFormatter.Binder](../code-quality/ca2301.md) | Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами. |
| CA2302 | [CA2302. Убедитесь, что BinaryFormatter.Binder задан перед вызовом BinaryFormatter.Deserialize](../code-quality/ca2302.md) | Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами. |
| CA2305 | [CA2305. Не используйте небезопасный десериализатор LosFormatter](../code-quality/ca2305.md) | Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами. |
| CA2310 | [CA2310. Не используйте небезопасный десериализатор NetDataContractSerializer](../code-quality/ca2310.md) | Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами. |
| CA2311 | [CA2311. Не десериализируйте, не задав предварительно NetDataContractSerializer.Binder](../code-quality/ca2311.md) | Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами. |
| CA2312 | [CA2312. Убедитесь, что NetDataContractSerializer.Binder задан перед десериализацией](../code-quality/ca2312.md) | Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами. |
| CA2315 | [CA2315. Не используйте небезопасный десериализатор ObjectStateFormatter](../code-quality/ca2315.md) | Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами. |
| CA2321 | [CA2321. Не десериализируйте с помощью JavaScriptSerializer, используя SimpleTypeResolver](../code-quality/ca2321.md) | Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами. |
| CA2322 | [CA2322. Убедитесь, что JavaScriptSerializer не был инициализирован с помощью SimpleTypeResolver до десериализации](../code-quality/ca2322.md) | Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами. |
| CA2326 | [CA2326. Не используйте значения TypeNameHandling, отличные от None](../code-quality/ca2326.md) | Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами. |
| CA2327 | [CA2327. Не используйте небезопасные JsonSerializerSettings](../code-quality/ca2327.md) | Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами. |
| CA2328 | [CA2328. Убедитесь в безопасности JsonSerializerSettings](../code-quality/ca2328.md) | Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами. |
| CA2329 | [CA2329. Не выполняйте десериализацию с помощью JsonSerializer, используя небезопасную конфигурацию](../code-quality/ca2329.md) | Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами. |
| CA2330 | [CA2330. Убедитесь, что в JsonSerializer есть безопасная конфигурация при десериализации](../code-quality/ca2330.md) | Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами. |
| CA2350 | [CA2350. Убедитесь, что входные данные DataTable.ReadXml() являются доверенными](ca2350.md) | При десериализации <xref:System.Data.DataTable> с ненадежными входными данными злоумышленник может создавать вредоносные входные данные для атаки типа "отказ в обслуживании". Могут возникнуть неизвестные уязвимости удаленного выполнения кода. |
| CA2351 | [CA2351. Убедитесь, что входные данные DataSet.ReadXml() являются доверенными](ca2351.md) | При десериализации <xref:System.Data.DataSet> с ненадежными входными данными злоумышленник может создавать вредоносные входные данные для атаки типа "отказ в обслуживании". Могут возникнуть неизвестные уязвимости удаленного выполнения кода. |
| CA2352 | [CA2352. Ненадежные данные DataSet или DataTable в сериализуемом типе могут быть уязвимыми для атак удаленного выполнения кода](ca2352.md) | Класс или структура, помеченная как, <xref:System.SerializableAttribute> содержит <xref:System.Data.DataSet> <xref:System.Data.DataTable> поле или или свойство, и не имеет <xref:System.CodeDom.Compiler.GeneratedCodeAttribute> . |
| CA2353 | [CA2353. Ненадежные данные DataSet или DataTable в сериализуемом типе](ca2353.md) | Класс или структура, помеченная атрибутом сериализации XML или атрибутом контракта данных, содержит <xref:System.Data.DataSet> <xref:System.Data.DataTable> поле или или свойство. |
| CA2354 | [CA2354. Ненадежные данные DataSet или DataTable в графе десериализованных объектов могут быть уязвимыми для атаки удаленного выполнения кода](ca2354.md) | Десериализация с помощью <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> сериализованного объекта, а граф объектов приведенного типа может включать <xref:System.Data.DataSet> или <xref:System.Data.DataTable> . |
| CA2355 | [CA2355. Ненадежные данные DataSet или DataTable в графе десериализованных объектов](ca2355.md) | Десериализация, когда граф объектов приведенного или указанного типа может включать <xref:System.Data.DataSet> или <xref:System.Data.DataTable> . |
| CA2356 | [CA2356: ненадежный набор данных или DataTable в графе веб-десериализованных объектов](ca2356.md) | Метод с <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> или <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> имеет параметр, который может ссылаться на <xref:System.Data.DataSet> или <xref:System.Data.DataTable> . |
| CA2361 | [CA2361. Проверка того, что автоматически сформированный класс, который содержит DataSet.ReadXml(), не используется с ненадежными данными](ca2361.md) | При десериализации <xref:System.Data.DataSet> с ненадежными входными данными злоумышленник может создавать вредоносные входные данные для атаки типа "отказ в обслуживании". Могут возникнуть неизвестные уязвимости удаленного выполнения кода. |
| CA2362 | [CA2362. Ненадежные данные DataSet или DataTable в автоматически созданном сериализуемом типе могут быть уязвимыми для атак удаленного выполнения кода](ca2362.md) | При десериализации ненадежных входных данных с <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> и граф десериализованных объектов содержит <xref:System.Data.DataSet> или <xref:System.Data.DataTable> , злоумышленник может создавать вредоносные полезные данные для выполнения атаки удаленного выполнения кода. |
| CA3001 | [CA3001. Проверьте код на наличие уязвимостей к внедрению кода SQL](../code-quality/ca3001.md) | При работе с ненадежными входными и командными командами SQL учитывать атак путем внедрения кода SQL. Атака путем внедрения кода SQL может выполнять вредоносные команды SQL, нарушая безопасность и целостность приложения. |
| CA3002 | [CA3002. Проверьте код на наличие уязвимостей к межсайтовым сценариям (XSS)](../code-quality/ca3002.md) | При работе с ненадежными входными данными из веб-запросов следует учитывать атаки с использованием межсайтовых сценариев (XSS). Атака XSS внедряет недоверенные входные данные в необработанные выходные данные HTML, позволяя злоумышленникам выполнять вредоносные сценарии или вредоносно изменять содержимое на веб-странице. |
| CA3003 | [CA3003. Проверьте код на наличие уязвимостей к внедрению пути к файлу](../code-quality/ca3003.md) | При работе с ненадежными входными данными из веб-запросов будьте учитывать, используя управляемые пользователем входные данные при указании путей к файлам. |
| CA3004 | [CA3004. Проверьте код на наличие уязвимостей к раскрытию информации](../code-quality/ca3004.md) | Раскрытие сведений об исключениях дает злоумышленникам сведения о внутренних компонентах приложения, которые могут помочь злоумышленникам найти другие уязвимости для использования. |
| CA3006 | [CA3006. Проверьте код на наличие уязвимостей к внедрению команд процесса](../code-quality/ca3006.md) | При работе с ненадежными входными данными будьте учитывать атак путем внедрения команд. Атака путем внедрения команды может выполнять вредоносные команды в базовой операционной системе, нарушая безопасность и целостность сервера. |
| CA3007 | [CA3007. Проверьте код на наличие уязвимостей к открытому перенаправлению](../code-quality/ca3007.md) | При работе с недоверенными входными данными будьте учитывать уязвимости открытых перенаправлений. Злоумышленник может воспользоваться уязвимостью с открытым перенаправлением, чтобы использовать веб-сайт для получения правильного URL-адреса, но перенаправить нежелательный посетитель на фишинг или другую вредоносную веб-страницу. |
| CA3008 | [CA3008. Проверьте код на наличие уязвимостей к внедрению кода XPath](../code-quality/ca3008.md) | При работе с недоверенными входными данными будьте учитывать атак путем внедрения XPath. Создание запросов XPath с использованием ненадежных входных данных может позволить злоумышленнику злонамеренно манипулировать запросом для возврата непредвиденного результата и, возможно, раскрывать содержимое запрашиваемого XML. |
| CA3009 | [CA3009. Проверьте код на наличие уязвимостей к внедрению кода XML](../code-quality/ca3009.md) | При работе с ненадежными входными данными учитывать атак путем внедрения кода XML. |
| CA3010 | [CA3010. Проверьте код на наличие уязвимостей к внедрению кода XAML](../code-quality/ca3010.md) | При работе с ненадежными входными данными будьте учитывать атак путем внедрения кода XAML. XAML — это язык разметки, непосредственно представляющий создание и выполнение объекта. Это означает, что элементы, созданные в XAML, могут взаимодействовать с системными ресурсами (например, сетевым доступом и операциями ввода-вывода файловой системы). |
| CA3011 | [CA3011. Проверьте код на наличие уязвимостей к внедрению DLL](../code-quality/ca3011.md) | При работе с недоверенными входными данными будьте учитывать при загрузке ненадежного кода. Если веб-приложение загружает ненадежный код, злоумышленник может внедрить вредоносные библиотеки DLL в процесс и выполнить вредоносный код. |
| CA3012 | [CA3012. Проверьте код на наличие уязвимостей к внедрению регулярных выражений](../code-quality/ca3012.md) | При работе с ненадежными входными данными будьте учитывать атак путем внедрения регулярных выражений. Злоумышленник может использовать внедрение Regex для злонамеренного изменения регулярного выражения, чтобы сделать регулярное выражение соответствующим, или сделать так, чтобы регулярное выражение использовало чрезмерное количество ПРОЦЕССОРов, что приводит к атаке типа "отказ в обслуживании". |
| CA3061 | [CA3061. Не добавлять схему по URL-адресу](../code-quality/ca3061.md) | Не используйте небезопасную перегрузку метода Add, так как она может вызвать опасные внешние ссылки. |
| CA3075 | [CA3075. Обработка небезопасных DTD](../code-quality/ca3075.md) | Если вы используете небезопасные экземпляры DTDProcessing или ссылаетесь на источники внешних сущностей, средство синтаксического анализа может принять недоверенные входные данные и раскрыть конфиденциальную информацию злоумышленникам. |
| CA3076 | [CA3076. Выполнение небезопасного скрипта XSLT](../code-quality/ca3076.md) | При небезопасном выполнении XSLT в приложениях .NET процессор может разрешить ненадежные ссылки URI, которые могут раскрыть конфиденциальную информацию злоумышленникам, что приведет к атакам типа "отказ в обслуживании" и межсайтовые атаки. |
| CA3077 | [CA3077. Небезопасная обработка в структуре API средств чтения документов и текста XML](../code-quality/ca3077.md) | При разработке API, производных от XMLDocument и XMLTextReader, обратите внимание на DtdProcessing. Использование небезопасных экземпляров DTDProcessing при ссылке на источники внешних сущностей или их разрешении, а также при задании небезопасных значений в XML может привести к раскрытию информации. |
| CA3147 | [CA3147. Присвоение метки ValidateAntiForgeryToken обработчикам команд](../code-quality/ca3147.md) | При проектировании контроллера MVC ASP.NET учитывать атаки с подделки межсайтовых запросов. Атака подделки межсайтовых запросов может отправить вредоносные запросы от пользователя, прошедшего проверку подлинности, на контроллер ASP.NET MVC. |
| CA5350 | [CA5350. Не используйте ненадежные алгоритмы шифрования](../code-quality/ca5350.md) | Ненадежные алгоритмы шифрования и функции хэширования еще используются сегодня по ряду причин, но они не должны использоваться для обеспечения конфиденциальности или целостности данных, которые они защищают. Это правило срабатывает при обнаружении в коде алгоритмов TripleDES, SHA1 или RIPEMD160.|
| CA5351 | [CA5351: не используйте ослабленные алгоритмы шифрования](../code-quality/ca5351.md) | Ослабленные алгоритмы шифрования не считаются безопасными, и их использование настоятельно не рекомендуется. Это правило срабатывает при обнаружении в коде хэш-алгоритма MD5 или алгоритмов шифрования RC2 или DES. |
| CA5358 | [CA5358. Не используйте небезопасные режимы шифрования](../code-quality/ca5358.md) | Не используйте небезопасные режимы шифрования |
| CA5359 | [CA5359 не отключают проверку сертификата](../code-quality/ca5359.md) | Сертификат может помочь при проверке подлинности удостоверения сервера. Клиенты должны проверить сертификат сервера, чтобы обеспечить отправку запросов на предполагаемый сервер. Если ServerCertificateValidationCallback всегда возвращает значение `true` , любой сертификат будет проходить проверку. |
| CA5360 | [CA5360 не вызывают опасные методы при десериализации](../code-quality/ca5360.md) | Небезопасная десериализация — это уязвимость, которая возникает, когда ненадежные данные используются для нарушения логики приложения, наноситься атаки типа "отказ в обслуживании" или даже для выполнения произвольного кода после десериализации. Пользователям-злоумышленникам часто могут быть нарушены эти функции десериализации, когда приложение десериализует ненадежные данные, которые находятся под их контролем. В частности, следует вызывать опасные методы в процессе десериализации. Успешная атака небезопасной десериализации может позволить злоумышленнику выполнять атаки, такие как атаки DoS, обход проверки подлинности и удаленный запуск программного кода. |
| CA5361 | [CA5361: не отключайте использование стойкого шифрования SChannel](../code-quality/ca5361.md) | Параметр `Switch.System.Net.DontEnableSchUseStrongCrypto` , чтобы `true` ослабить шифрование, используемое в исходящих подключениях протокола TLS. Более слабая криптография может нарушить конфиденциальность взаимодействия между приложением и сервером, что облегчит злоумышленникам еавесдроп конфиденциальные данные. |
| CA5362 | [CA5362 возможных циклических ссылок в графе десериализованных объектов](../code-quality/ca5362.md) | При десериализации ненадежных данных любой код, обрабатывающий десериализованный граф объекта, должен обрабатывать циклы ссылок без перехода в бесконечные циклы. Это включает в себя код, который является частью обратного вызова десериализации, и код, обрабатывающий граф объекта после завершения десериализации. В противном случае злоумышленник может выполнить атаку типа "отказ в обслуживании" с вредоносными данными, содержащими цикл ссылок. |
| CA5363 | [CA5363. Не отключать проверку запросов](../code-quality/ca5363.md) | Проверка запросов — это функция в ASP.NET, которая проверяет HTTP-запросы и определяет, содержат ли они потенциально опасное содержимое, которое может привести к атакам путем внедрения, включая межсайтовые сценарии. |
| CA5364 | [CA5364. Не используйте нерекомендуемые протоколы безопасности](../code-quality/ca5364.md) | Протокол TLS обеспечивает безопасность взаимодействия между компьютерами, чаще всего с помощью протокола HTTPS. Более старые версии протокола TLS менее безопасны, чем TLS 1,2 и TLS 1,3, и, скорее всего, будут подвержены новые уязвимости. Избегайте более старых версий протокола, чтобы снизить риск. |
| CA5365 | [CA5365 не отключают проверку заголовка HTTP](../code-quality/ca5365.md) | Проверка HTTP-заголовка позволяет кодировать символы возврата каретки и новой строки, \r и \n, которые находятся в заголовках ответа. Эта кодировка позволяет избежать атак путем внедрения, которые используют приложение, которое выводит недоверенные данные, содержащиеся в заголовке. |
| CA5366 | [CA5366. Использование XmlReader для чтения XML-данных](../code-quality/ca5366.md) | При использовании <xref:System.Data.DataSet> для чтения XML с ненадежными данными могут загружаться опасные внешние ссылки, которые должны быть ограничены с помощью <xref:System.Xml.XmlReader> защищенного распознавателя или с отключенной обработкой DTD. |
| CA5367 | [CA5367 не сериализуются типы с полями указателя](../code-quality/ca5367.md) | Это правило проверяет, существует ли сериализуемый класс с полем указателя или свойством. Элементы, которые не могут быть сериализованы, могут быть указателями, такими как статические члены или поля, помеченные атрибутом <xref:System.NonSerializedAttribute> . |
| CA5368 | [CA5368 Set ViewStateUserKey для классов, производных от страницы](../code-quality/ca5368.md) | Задание <xref:System.Web.UI.Page.ViewStateUserKey> свойства может помочь предотвратить атаки на приложение, позволяя назначить идентификатор переменной состояния представления для отдельных пользователей, чтобы злоумышленники не могли использовать эту переменную для создания атаки. В противном случае будут обнаружены уязвимости подделки запросов между сайтами. |
| CA5369 | [CA5369. Использование XmlReader для десериализации](../code-quality/ca5369.md) | Обработка ненадежных DTD и схем XML может разрешить загрузку опасных внешних ссылок, которые должны быть ограничены с помощью XmlReader с безопасным распознавателем или с отключенной обработкой встроенных схем DTD и XML. |
| CA5370 | [CA5370. Использование XmlReader для проверки модуля чтения](../code-quality/ca5370.md) | Обработка ненадежных DTD и схем XML может разрешить загрузку опасных внешних ссылок. Эту опасную загрузку можно ограничить с помощью XmlReader с безопасным распознавателем или с отключенной обработкой встроенных схем DTD и XML. |
| CA5371 | [CA5371. Использование XmlReader для чтения схемы](../code-quality/ca5371.md) | Обработка ненадежных DTD и схем XML может разрешить загрузку опасных внешних ссылок. Использование XmlReader с безопасным распознавателем или с отключенной обработкой схемы DTD и XML с поддержкой встроенных схем позволяет ограничивать это. |
| CA5372 | [CA5372. Использование XmlReader для XPathDocument](../code-quality/ca5372.md) | Обработка XML-кода из ненадежных данных может привести к загрузке опасных внешних ссылок, которые можно ограничить с помощью XmlReader с безопасным распознавателем или с отключенной обработкой DTD. |
| CA5373 | [CA5373. Не использовать устаревшую функцию формирования ключа](../code-quality/ca5373.md) | Это правило обнаруживает вызов методов формирования неслабых ключей <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> и `Rfc2898DeriveBytes.CryptDeriveKey` . <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> использовал слабый алгоритм PBKDF1. |
| CA5374 | [CA5374 не используют XslTransform](../code-quality/ca5374.md) | Это правило проверяет <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> , создан ли экземпляр в коде. <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> теперь является устаревшим и не должен использоваться. |
| CA5375 | [CA5375 не использовать подпись общего доступа учетной записи](../code-quality/ca5375.md) | SAS учетной записи может делегировать доступ к операциям чтения, записи и удаления в контейнерах больших двоичных объектов, таблицах, очередях и общих файловых ресурсах, которые не разрешены с помощью SAS службы. Однако он не поддерживает политики уровня контейнера и обладает меньшей гибкостью и контролирует предоставляемые разрешения. После получения вредоносных пользователей ваша учетная запись хранения будет легко скомпрометирована. |
| CA5376 | [CA5376 использовать Шаредакцесспротокол Хттпсонли](../code-quality/ca5376.md) | SAS — это конфиденциальные данные, которые нельзя переносить в виде обычного текста по протоколу HTTP. |
| CA5377 | [CA5377 использовать политику доступа на уровне контейнера](../code-quality/ca5377.md) | Политику доступа на уровне контейнера можно изменить или отозвать в любое время. Он обеспечивает большую гибкость и контроль над предоставляемыми разрешениями. |
| CA5378 | [CA5378. Не отключайте ServicePointManagerSecurityProtocols](../code-quality/ca5378.md) | Параметр `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` для `true` ограничения соединений (TLS) Windows Communication Framework с использованием TLS 1,0. Эта версия TLS будет устаревшей. |
| CA5379 | [CA5379 не используют алгоритм функции наследования слабых ключей](../code-quality/ca5379.md) | <xref:System.Security.Cryptography.Rfc2898DeriveBytes>Класс по умолчанию использует <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> алгоритм. Необходимо указать хэш-алгоритм для использования в некоторых перегрузках конструктора с <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> или выше. Обратите внимание, что <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> свойство имеет только `get` метод доступа и не имеет `overriden` модификатора. |
| CA5380 | [CA5380. Не добавлять сертификаты в корневое хранилище](../code-quality/ca5380.md) | Это правило обнаруживает код, который добавляет сертификат в хранилище сертификатов доверенных корневых центров сертификации. По умолчанию хранилище сертификатов доверенных корневых центров сертификации настроено с набором общедоступных центров сертификации, удовлетворяющих требованиям программы корневых сертификатов Майкрософт. |
| CA5381 | [CA5381. Убедиться, что сертификаты не добавлены в корневое хранилище](../code-quality/ca5381.md) | Это правило обнаруживает код, который потенциально добавляет сертификат в хранилище сертификатов доверенных корневых центров сертификации. По умолчанию хранилище сертификатов доверенных корневых центров сертификации настроено с набором общедоступных центров сертификации (ЦС), удовлетворяющих требованиям программы корневых сертификатов Майкрософт. |
| CA5382 | [CA5382 использовать безопасные файлы cookie в ASP.NET Core](../code-quality/ca5382.md) | Приложения, доступные по протоколу HTTPS, должны использовать безопасные файлы cookie, которые указывают браузеру, что файл cookie следует передавать только с помощью SSL (SSL). |
| CA5383 | [CA5383 Обеспечьте использование защищенных файлов cookie в ASP.NET Core](../code-quality/ca5383.md) | Приложения, доступные по протоколу HTTPS, должны использовать безопасные файлы cookie, которые указывают браузеру, что файл cookie следует передавать только с помощью SSL (SSL). |
| CA5384 | [CA5384 не используют алгоритм цифровых подписей (DSA)](../code-quality/ca5384.md) | DSA — это алгоритм слабого асимметричного шифрования. |
| CA5385 | [CA5385 использование алгоритма Ривест – Шамир – Адельман (RSA) с достаточным размером ключа](../code-quality/ca5385.md) | Ключ RSA, размер которого меньше 2048 бит, более уязвим для атак методом подбора. |
| CA5386 | [CA5386. Не встраивайте значение SecurityProtocolType](../code-quality/ca5386.md) | Протокол TLS обеспечивает безопасность взаимодействия между компьютерами, чаще всего с помощью протокола HTTPS. Протоколы версии TLS 1,0 и TLS 1,1 являются устаревшими, а TLS 1,2 и TLS 1,3 являются актуальными. В будущем протоколы TLS 1,2 и TLS 1,3 могут быть устаревшими. Чтобы обеспечить безопасность приложения, не следует прописано версию протокола и нацелить по крайней мере .NET Framework v 4.7.1. |
| CA5387 | [CA5387 не используют функцию формирования ключа с нестрогим наследованием с недостаточным числом итераций](../code-quality/ca5387.md) | Это правило проверяет, был ли криптографический ключ создан <xref:System.Security.Cryptography.Rfc2898DeriveBytes> с числом итераций менее 100 000. Более высокие числа итераций могут помочь в предотвращении атак из словарей, которые пытаются угадать созданный криптографический ключ. |
| CA5388 | [CA5388 обеспечивают достаточное число итераций при использовании функции формирования неслабых ключей](../code-quality/ca5388.md) | Это правило проверяет, был ли криптографический ключ создан <xref:System.Security.Cryptography.Rfc2898DeriveBytes> с числом итераций, которое может быть меньше 100 000. Более высокие числа итераций могут помочь в предотвращении атак из словарей, которые пытаются угадать созданный криптографический ключ. |
| CA5389 | [CA5389. Не добавлять путь к элементу архива в путь целевой файловой системы](../code-quality/ca5389.md) | Путь к файлу может быть относительным и может привести к доступу файловой системы за пределами ожидаемого целевого пути файловой системы, что приведет к изменению вредоносной настройки и удаленному выполнению кода с помощью метода компоновки и ожидания. |
| CA5390 | [CA5390 не жестко кодировать ключ шифрования](../code-quality/ca5390.md) | Для успешного выполнения симметричного алгоритма секретный ключ должен быть известен только отправителю и получателю. Если ключ жестко закодирован, его легко обнаружить. Даже при использовании скомпилированных двоичных файлов пользователи-злоумышленники могут легко их извлечь. После компрометации закрытого ключа текст шифра может быть расшифрован напрямую и больше не защищен. |
| CA5391 | [CA5391 использование маркеров подделки в ASP.NET Core контроллерах MVC](../code-quality/ca5391.md) | Обработка `POST` запроса, `PUT` , `PATCH` или `DELETE` без проверки маркера подделки может быть уязвима для атак с подделкой межсайтовых запросов. Атака подделки межсайтовых запросов может отправить вредоносные запросы от пользователя, прошедшего проверку подлинности, на ASP.NET Core контроллер MVC. |
| CA5392 | [CA5392 использовать атрибут Дефаултдллимпортсеарчпасс для вызовов P/Invoke](../code-quality/ca5392.md) | По умолчанию функции P/Invoke используют <xref:System.Runtime.InteropServices.DllImportAttribute> пробу нескольких каталогов, включая текущий рабочий каталог для загрузки библиотеки. Это может быть проблемой безопасности для некоторых приложений, что приводит к захвату библиотек DLL. |
| CA5393 | [CA5393 не используют ненадежное значение Дллимпортсеарчпас](../code-quality/ca5393.md) | В каталогах поиска DLL по умолчанию и каталогах сборок может быть вредоносная библиотека DLL. Или, в зависимости от места запуска приложения, в каталоге приложения может быть вредоносная библиотека DLL. |
| CA5394 | [CA5394 не используют небезопасные случайные](../code-quality/ca5394.md) | Использование криптографического слабого генератора случайных чисел может позволить злоумышленнику предсказать, какое значение с учетом безопасности будет создано. |
| CA5395 | [Атрибут CA5395 промахов Хттпверб для методов действия](../code-quality/ca5395.md) | Все методы действий, которые создают, изменяют, удаляют или иным образом изменяют данные, должны быть защищены с помощью атрибута защиты от подделки запросов между сайтами. Операция GET должна быть защищенной операцией, которая не имеет побочных эффектов и не изменяет сохраненные данные. |
| CA5396 | [CA5396 задайте для параметра HttpOnly значение true для HttpCookie](../code-quality/ca5396.md) | В качестве меры глубокой защиты убедитесь, что файлы cookie HTTP с защитой безопасности помечены как HttpOnly. Это означает, что веб-браузеры не должны запрещать скриптам доступ к файлам cookie. Внедренные вредоносные сценарии — это распространенный способ кражи файлов cookie. |
| CA5397 | [CA5397. Не используйте нерекомендуемые значения SslProtocols](../code-quality/ca5397.md) | Протокол TLS обеспечивает безопасность взаимодействия между компьютерами, чаще всего с помощью протокола HTTPS. Более старые версии протокола TLS менее безопасны, чем TLS 1,2 и TLS 1,3, и, скорее всего, будут подвержены новые уязвимости. Избегайте более старых версий протокола, чтобы снизить риск. |
| CA5398 | [CA5398. Избегайте жестко зафиксированных значений SslProtocols](../code-quality/ca5398.md) | Протокол TLS обеспечивает безопасность взаимодействия между компьютерами, чаще всего с помощью протокола HTTPS. Протоколы версии TLS 1,0 и TLS 1,1 являются устаревшими, а TLS 1,2 и TLS 1,3 являются актуальными. В будущем протоколы TLS 1,2 и TLS 1,3 могут быть устаревшими. Чтобы обеспечить безопасность приложения, Избегайте прописано версии протокола. |
| CA5399 | [CA5399 определенно отключить проверку списка отзыва сертификатов HttpClient](../code-quality/ca5399.md) | Отозванный сертификат больше не является доверенным. Она может использоваться злоумышленниками для передачи вредоносных данных или кражи конфиденциальных данных при взаимодействии по протоколу HTTPS. |
| CA5400 | [CA5400 убедитесь, что проверка списка отзыва сертификатов HttpClient не отключена.](../code-quality/ca5400.md) | Отозванный сертификат больше не является доверенным. Она может использоваться злоумышленниками для передачи вредоносных данных или кражи конфиденциальных данных при взаимодействии по протоколу HTTPS. |
| CA5401 | [CA5401 не используют Креатинкриптор с вектором инициализации, отличным от значения по умолчанию](../code-quality/ca5401.md) | Для предотвращения атак с использованием словаря симметричное шифрование всегда должно использовать неповторяемый вектор инициализации. |
| CA5402 | [CA5402 использовать Креатинкриптор с вектором инициализации по умолчанию](../code-quality/ca5402.md) | Для предотвращения атак с использованием словаря симметричное шифрование всегда должно использовать неповторяемый вектор инициализации. |
| CA5403 | [CA5403: Не используйте жестко заданный сертификат](../code-quality/ca5403.md) | `data`Параметр или `rawData` <xref:System.Security.Cryptography.X509Certificates.X509Certificate> <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> конструктора или жестко запрограммирован. |
| IL3000 | [IL3000 избегать доступа к пути к файлу сборки при публикации в виде одного файла](../code-quality/il3000.md) | Избегайте использования пути к файлу сборки при публикации в виде одного файла |
| IL3001 | [IL3001 избегать доступа к пути к файлу сборки при публикации в виде одного файла](../code-quality/il3001.md) | Избегайте доступа к пути к файлу сборки при публикации в виде одного файла |
