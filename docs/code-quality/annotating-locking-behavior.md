---
title: Аннотация поведения блокировки
ms.date: 11/04/2016
ms.topic: conceptual
f1_keywords:
- _Releases_nonreentrant_lock_
- _Lock_kind_mutex_
- _Lock_kind_critical_section_
- _Acquires_lock_
- _Releases_lock_
- _Has_lock_kind_
- _Releases_exclusive_lock_
- _Post_same_lock_
- _Requires_exclusive_lock_held_
- _Requires_shared_lock_held_
- _Lock_kind_semaphore_
- _Requires_lock_held_
- _Acquires_exclusive_lock_
- _Create_lock_level_
- _Acquires_nonreentrant_lock_
- _Releases_shared_lock_
- _Has_lock_level_
- _Lock_kind_spin_lock_
- _Requires_lock_not_held_
- _Acquires_shared_lock_
- _Requires_no_locks_held_
- _Lock_level_order_
- _Lock_kind_event_
ms.assetid: 07769c25-9b97-4ab7-b175-d1c450308d7a
author: mikeblome
ms.author: mblome
manager: wpickett
ms.workload:
- multiple
ms.openlocfilehash: 6590a07ec7fc67bef5f1b1cfd96e80105fa325ce
ms.sourcegitcommit: 94b3a052fb1229c7e7f8804b09c1d403385c7630
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62560471"
---
# <a name="annotating-locking-behavior"></a>Аннотация поведения блокировки
Во избежание ошибок параллелизма в многопоточных программах, всегда выполняйте соответствующую дисциплину блокировок и используйте заметки SAL.

 Ошибки параллелизма, как известно, трудно воспроизвести, распознать и отладить в силу случайного характера их проявления. Рассуждение о последовательности потоков в лучшем случае представляется трудным и становится непрактичным при разработке основной части кода с более чем несколькими потоками. Поэтому рекомендуется следовать дисциплине блокировки в многопоточных программах. Например, проработка порядка блокировки при множественном захвате блокировок помогает избежать взаимоблокировок, а приобретение защитной блокировки до получения доступа к общему ресурсу помогает избежать состояния гонок.

 К сожалению, простым на первый взгляд правилам блокировки удивительно сложно следовать на практике. Фундаментальное ограничение в современных языков программирования и компиляторы является то, что они не поддерживают непосредственно спецификации и анализ требований параллелизма. Программисты должны полагаться на неофициальные комментарии к коду для выражения своих намерений о том, как они используют блокировки.

 Заметки SAL параллелизма предназначены для помощи в определении побочных эффектов блокировки, ответственности за блокировку, владения данными, иерархии порядка блокировки и другого ожидаемого поведения блокировки. Выполняя неявные правила явно, заметки SAL параллелизма предоставляют последовательный способ для документирования того, как код использует правила блокировки. Заметки параллелизма также расширяют возможности средств анализа кода для поиска условий гонки, взаимоблокировки, несоответствующих операций синхронизации и других неявных ошибок параллелизма.

## <a name="general-guidelines"></a>Общие рекомендации
 Используя аннотации, вы можете формулировать договоры, которые неявно выражены определениями функций, между реализациями (вызываемыми объектами) и клиентами (вызывающими объектами), а также задавать инварианты и другие свойства программы, которые впоследствии могут повысить эффективность анализа.

 SAL поддерживает множество различных типов примитивов блокирования, таких как критические секции, мьютексы, спин-блокировки и другие объекты ресурсов. Многие заметки параллелизма занять выражение блокировки как параметр. По соглашению блокировку обозначается выражение пути базового объекта блокировки.

 Некоторые правила учета владения потоком, которые следует помнить постоянно:

- Спин-блокировки являются несчитающими блокировками, у которых есть определенный поток-владелец.

- Мьютексы и критические секции являются считающими блокировками, у которых есть определенный поток-владелец.

- Семафоры и события являются считающими блокировками, не имеющими определенного потока-владельца.

## <a name="locking-annotations"></a>Блокировки заметок
 В следующей таблице перечислены блокировки заметки.

|Комментарий|Описание|
|----------------|-----------------|
|`_Acquires_exclusive_lock_(expr)`|Добавляет заметки к функции и указывает, что функция после вызова увеличивает на единицу число монопольных блокировок объекта блокировок с именем `expr`.|
|`_Acquires_lock_(expr)`|Аннотирует функцию и указывает, что функция после вызова увеличивает на единицу число блокировок объекта блокировок с именем `expr`.|
|`_Acquires_nonreentrant_lock_(expr)`|Блокировка с именем `expr` получена.  Возникает ошибка, если блокировка уже захвачена.|
|`_Acquires_shared_lock_(expr)`|Аннотирует функцию и указывает, что функция после вызова увеличивает на единицу число общих блокировок объекта блокировок с именем `expr`.|
|`_Create_lock_level_(name)`|Оператор, который объявляет символ `name` символом уровня блокировки, благодаря чему он может быть использован в аннотациях `_Has_Lock_level_` и `_Lock_level_order_`.|
|`_Has_lock_kind_(kind)`|Добавляет заметки к любой объект, чтобы уточнить сведения о типе объекта ресурса. Иногда тип используется для различных типов ресурсов и перегруженный тип не является достаточным для различения семантических требований среди различных ресурсов. Ниже представлен список предварительно определенных параметров `kind`:<br /><br /> `_Lock_kind_mutex_`<br /> Код типа блокировки для мьютексов.<br /><br /> `_Lock_kind_event_`<br /> Код типа блокировки для событий.<br /><br /> `_Lock_kind_semaphore_`<br /> ИД типа блокировки семафоров.<br /><br /> `_Lock_kind_spin_lock_`<br /> ИД типа блокировки спин-блокировки.<br /><br /> `_Lock_kind_critical_section_`<br /> Код типа блокировки для критических разделов.|
|`_Has_lock_level_(name)`|Аннотирует объект блокировки и присваивает ему уровень блокировки `name`.|
|`_Lock_level_order_(name1, name2)`|Инструкцию, которая предоставляет блокировку, упорядочение `name1` и `name2`.|
|`_Post_same_lock_(expr1, expr2)`|Аннотирует функцию и указывает, что в состоянии выполнения две блокировки, `expr1` и `expr2`, рассматриваются таким образом, как если бы они были одним и тем же объектом блокировки.|
|`_Releases_exclusive_lock_(expr)`|Добавляет заметки к функции и указывает, что функция после вызова уменьшает на единицу число монопольных блокировок объекта блокировок с именем `expr`.|
|`_Releases_lock_(expr)`|Аннотирует функцию и указывает, что функция после вызова уменьшает на единицу число блокировок объекта блокировок с именем `expr`.|
|`_Releases_nonreentrant_lock_(expr)`|Блокировка с именем `expr` снята. Возникает ошибка, если блокировка на данный момент не захвачена.|
|`_Releases_shared_lock_(expr)`|Аннотирует функцию и указывает, что функция после вызова уменьшает на единицу число общих блокировок объекта блокировок с именем `expr`.|
|`_Requires_lock_held_(expr)`|Аннотирует функцию и указывает, что перед вызовом функции количество блокировок объекта с именем `expr` не менее единицы.|
|`_Requires_lock_not_held_(expr)`|Добавляет заметки к функции и указывает, что перед вызовом функции количество блокировок объекта с именем `expr` равно нулю.|
|`_Requires_no_locks_held_`|Аннотирует функцию и указывает, что количество блокировок на всех объектах блокировки равно нулю.|
|`_Requires_shared_lock_held_(expr)`|Аннотирует функцию и указывает, что перед вызовом функции количество общих блокировок объекта с именем `expr` не менее единицы.|
|`_Requires_exclusive_lock_held_(expr)`|Добавляет заметки к функции и указывает, что перед вызовом функции количество монопольных блокировок объекта с именем `expr` не менее единицы.|

## <a name="sal-intrinsics-for-unexposed-locking-objects"></a>Встроенные SAL для непредоставленных явно объектов блокировки
 Некоторые объекты блокировки не предоставляется реализация связанных функций блокировки.  В следующей таблице перечислены встроенные переменные SAL, которые содержат заметки для функций, действующих на эти защищенные объекты блокировки.

|Комментарий|Описание|
|----------------|-----------------|
|`_Global_cancel_spin_lock_`|Описывает отмену спин-блокировки.|
|`_Global_critical_region_`|Описывает критическую область.|
|`_Global_interlock_`|Описывает блокируемые операции.|
|`_Global_priority_region_`|Описывает область приоритета.|

## <a name="shared-data-access-annotations"></a>Заметки доступа к общим данным
 В следующей таблице перечисляются аннотации для доступа к разделяемым данным.

|Комментарий|Описание|
|----------------|-----------------|
|`_Guarded_by_(expr)`|Добавляет заметки к переменной и указывает на то, что при доступе к данной переменной количество блокировок объекта с именем `expr` не менее единицы.|
|`_Interlocked_`|Добавляет заметки к переменной и эквивалентно `_Guarded_by_(_Global_interlock_)`.|
|`_Interlocked_operand_`|Параметр функции аннотирования является целевой операнда одного из различных функций Interlocked.  Эти операнды должны иметь дополнительные свойства.|
|`_Write_guarded_by_(expr)`|Добавляет заметки к переменной и указывает на то, что при изменении данной переменной количество блокировок объекта с именем `expr` не менее единицы.|

## <a name="smart-lock-and-raii-annotations"></a>Smart Lock и RAII заметок
 Смарт-блокировки обычно wrap блокировки машинного кода и управления временем их существования. В следующей таблице перечислены заметок, которые могут использоваться с помощью смарт-блокировки и RAII, моделью программирования с поддержкой `move` семантику.

|Комментарий|Описание|
|----------------|-----------------|
|`_Analysis_assume_smart_lock_acquired_`|Сообщает анализатор предположить, что смарт-блокировка. Эта заметка ожидает блокировки ссылочным типом в качестве параметра.|
|`_Analysis_assume_smart_lock_released_`|Сообщает анализатор предположить, что смарт-блокировка была снята. Эта заметка ожидает блокировки ссылочным типом в качестве параметра.|
|`_Moves_lock_(target, source)`|Описывает `move constructor` операцию, которая передает состояние блокировки из `source` объект `target`. `target` Считается заново созданного объекта, поэтому любые состояния до потери и заменены `source` состояния. `source` Является также сброса в исходное состояние без блокировки целевого количества или присвоения псевдонимов, но псевдонимы, наведите на него указатель не изменяются.|
|`_Replaces_lock_(target, source)`|Описывает `move assignment operator` семантику, где целевой блокировка, прежде чем переносить состояние из источника. Его можно рассматривать как сочетание `_Moves_lock_(target, source)` предшествует `_Releases_lock_(target)`.|
|`_Swaps_locks_(left, right)`|Описывает стандартные `swap` поведение, которое предполагается, что объекты `left` и `right` exchange их состояние. Состояние обмен включает целевой объект счетчика и присвоения псевдонимов блокировки, при его наличии. Псевдонимы, которые указывают на `left` и `right` объекты остаются без изменений.|
|`_Detaches_lock_(detached, lock)`|Описывает сценарии, в котором тип оболочки блокировки позволяет отклонено с его ресурсов. Это похоже на то, как `std::unique_ptr` работает с его внутренний указатель: она позволяет программистам, чтобы извлечь указатель и оставить его контейнера интеллектуального указателя в чистом состоянии. Аналогичная логика поддерживается `std::unique_lock` и могут быть реализованы в оболочках блокировки. Отсоединенные блокировки сохраняет свое состояние (блокировки count и задание псевдонимов целевой объект, если таковые имеются), хотя оболочки сбрасывается до содержать ноль число блокировок и цель не присвоения псевдонимов, сохранив свои собственные псевдонимы. Нет операции на количества блокировок (освобождение и получение). Эта заметка ведет себя точно так, как `_Moves_lock_` за исключением того, что отсоединенных аргумент должен быть `return` вместо `this`.|

## <a name="see-also"></a>См. также

- [Использование аннотаций SAL для уменьшения количества дефектов в коде C/C++](../code-quality/using-sal-annotations-to-reduce-c-cpp-code-defects.md)
- [Основные сведения о языке SAL](../code-quality/understanding-sal.md)
- [Создание примечаний к параметрам и возвращаемым значениям функций](../code-quality/annotating-function-parameters-and-return-values.md)
- [Аннотация поведения функций](../code-quality/annotating-function-behavior.md)
- [Аннотация структур и классов](../code-quality/annotating-structs-and-classes.md)
- [Указание времени и места применения примечания](../code-quality/specifying-when-and-where-an-annotation-applies.md)
- [Встроенные функции](../code-quality/intrinsic-functions.md)
- [Рекомендации и примеры](../code-quality/best-practices-and-examples-sal.md)
- [Блог команды анализа кода](http://go.microsoft.com/fwlink/p/?LinkId=251197)