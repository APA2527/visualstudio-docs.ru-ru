---
title: C26430
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26430
helpviewer_keywords:
- C26430
ms.assetid: 3dca2626-8102-4eed-8ff3-73eb3d5c328c
author: mikeblome
ms.author: mblome
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 1bac005d57cda41546c8a33809f6c85dfdbb44a1
ms.sourcegitcommit: 94b3a052fb1229c7e7f8804b09c1d403385c7630
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62571824"
---
# <a name="c26430-testonallpaths"></a>C26430 TEST_ON_ALL_PATHS

«Символ не прошла проверку наличия значений NULL во всех путях.»

**C++ Core Guidelines**: F.23: Использовать not_null\<T > для указания, что «null» не является допустимым значением

Если код постоянно проверяет nullness указателя переменных следует этого согласованно и проверить указатели на всех путях. Иногда overaggressive проверку наличия значений NULL по-прежнему лучше, чем вероятность сбоя жесткого в одну из ветвей сложным. В идеале такой код должен быть переделан должны быть менее сложными (путем разделения на несколько функций) и полагаются на маркеры как gsl::not_null (см. в разделе библиотеки поддержки правил) для изоляции частей алгоритма, способный выполнить безопасное предположение о значениях допустимый указатель. Правило, TEST_ON_ALL_PATHS помогает найти места, где nullness проверок делятся несогласованные (таким образом допущения может потребоваться проверка) или проверьте фактических ошибок, где потенциальные значения null могут обходить nullness в некоторых путей кода.

## <a name="remarks"></a>Примечания

- Это правило ожидает, что код разыменовывает переменной указателя, таким образом, может быть оправдано nullness проверки (или применение ненулевое значение). Если имеется не разыменования, правило будет приостановлена.
  - Текущая реализация обрабатывает только обычные указатели (или их псевдонимов) и не обнаруживает интеллектуальные указатели, несмотря на то, что проверки nullness применимы к также интеллектуальные указатели.
  - Переменная помечен как проверенный наличия значений NULL, если он используется в следующих контекстах:
  - как выражение символ в условие ветви например «если (p) {...}»;
  - логические и побитовые операции;
  - операции сравнения, где один операнд является константного выражения, которое равно нулю.
  - Правило не содержит полные данные отслеживания потока и может выдавать неверные результаты в случаях, где используются дополнительные проверки (например при промежуточной переменной содержит значение null и далее используются для сравнения).
  - Проверяет неявные nullness предполагается, что при назначении значение указателя из:
  - Распределение выполняется с помощью оператора создает исключение, новый;
  - указатель, полученный из типа, помеченного атрибутом gsl::not_null.

## <a name="example"></a>Пример

Ошибка несогласованности тестирования выявляет логики

```cpp
void merge_states(const state *left, const state *right) // C26430
{
    if (*left && *right)
        converge(left, right);
    else
    {
        // ...
        if (!left && !right)                            // Logic error!
            discard(left, right);
    }
}
```

несогласованные тестирование показывает логическая ошибка — исправлено

```cpp
void merge_states(gsl::not_null<const state *> left, gsl::not_null<const state *> right)
{
    if (*left && *right)
        converge(left, right);
    else
    {
        // ...
        if (*left && *right)
            discard(left, right);
    }
}
```
