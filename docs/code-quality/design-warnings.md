---
title: Предупреждения конструктора
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.designrules
helpviewer_keywords:
- design warnings
- managed code analysis warnings, design warnings
- warnings, design
ms.assetid: 34e65a18-560c-423f-814f-519089e318cf
author: gewarren
ms.author: gewarren
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 7b20a61aabe519bfaeb562e4b41fb5d47e17dc43
ms.sourcegitcommit: 08c144d290da373df841f04fc799e3133540a541
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/17/2019
ms.locfileid: "72535915"
---
# <a name="design-warnings"></a>Предупреждения по принципам разработки

Предупреждения конструктора поддерживают соответствие [рекомендациям по проектированию .NET](/dotnet/standard/design-guidelines/).

## <a name="in-this-section"></a>Содержание

| Правило | Описание |
| - | - |
| [CA1000: не объявляйте статические элементы в универсальных типах](../code-quality/ca1000.md) | При вызове статического элемента универсального типа нужно указать аргумент этого типа. При вызове универсального экземпляра элемента, не поддерживающего вывод типа, для элемента нужно указать аргумент типа. В этих двух случаях синтаксис для определения аргумента типа различен, и его можно легко спутать. |
| [CA1001: типы, которым принадлежат освобождаемые поля, должны быть освобождаемыми](../code-quality/ca1001.md) | Класс объявляет и реализует поле экземпляра, которое является типом System. IDisposable, а класс не реализует IDisposable. Класс, в котором объявляется поле IDisposable, неявно владеет неуправляемым ресурсом и должен реализовывать интерфейс IDisposable. |
| [CA1002: не следует раскрывать универсальные списки](../code-quality/ca1002.md) | System. Collections. Generic. List < (из \< (T >) >) — это универсальная коллекция, предназначенная для повышения производительности, а не для наследования. Поэтому виртуальные элементы в списке отсутствуют. Вместо этого для наследования следует предоставить универсальную коллекцию. |
| [CA1003: используйте экземпляры обработчика универсальных событий](../code-quality/ca1003.md) | Тип содержит делегат, возвращающий значение void, сигнатура которого содержит два параметра (первый объект и второй тип, который может быть назначен EventArgs), а содержащая сборка предназначена для .NET Framework 2,0. |
| [CA1004: универсальные методы должны предоставлять параметр типа](../code-quality/ca1004.md) | Вывод – это то, как аргумент типа универсального метода определяется по типу аргумента, переданного методу, а не по явному указанию аргумента типа. Чтобы задействовать вывод, сигнатура параметра универсального метода должна включать параметр, тип которого совпадает с параметром типа для метода. В этом случае аргумент типа указывать не обязательно. При использовании вывода для всех параметров типа синтаксис вызова универсальных и неуниверсальных методов экземпляра идентичен. Это упрощает удобство использования универсальных методов. |
| [CA1005: не используйте слишком много параметров в универсальных типах](../code-quality/ca1005.md) | Чем больше параметров типов содержит универсальный тип, тем сложнее знать и запоминать, что представляет каждый параметр типа. Обычно очевидно с одним параметром типа, как в List \<T >, и в некоторых случаях с двумя параметрами типа, как в Dictionary \<TKey TValue >. Если же используется более двух параметров типов, многие пользователи начинают испытывать большие трудности. |
| [CA1006: не вкладывайте универсальные типы в сигнатуры членов](../code-quality/ca1006.md) | Аргумент вложенного типа также является аргументом универсального типа. Чтобы вызвать член, сигнатура которого содержит аргумент вложенного типа, пользователь должен создать экземпляр одного универсального типа и передать этот тип конструктору второго универсального типа. Это приводит к усложнению процедуры и синтаксиса, чего следует избегать. |
| [CA1007: используйте универсальные объекты, если это уместно](../code-quality/ca1007.md) | Видимый извне метод содержит ссылочный параметр типа System.Object. Использование универсального метода позволяет передавать в метод все типы без предварительного приведения к типу ссылочного параметра при условии выполнения некоторых ограничений. |
| [CA1008: перечисляемые типы должны иметь нулевое значение](../code-quality/ca1008.md) | Значение по умолчанию неинициализированного перечисления, как и других типов значений, равно нулю. Перечисление без флагов должно определять член, используя нулевое значение, чтобы значение по умолчанию было допустимым значением перечисления. Если перечисление с примененным атрибутом FlagsAttribute определяет член с нулевым значением, для него должно быть задано имя None, свидетельствующее о том, что в перечислении не были заданы значения. |
| [CA1009: правильно объявите обработчики событий](../code-quality/ca1009.md) | Методы обработчиков событий принимают два параметра. Первый параметр принадлежит типу System.Object и называется "sender". Это объект, вызвавший событие. Второй параметр принадлежит типу System.EventArgs и называется "e". Это данные, связанные с событием. Методы обработки событий не должны возвращать значение; в языке программирования C# оно обозначается типом возвращаемого значения void. |
| [CA1010: коллекции должны реализовывать универсальный интерфейс](../code-quality/ca1010.md) | Чтобы расширить возможности использования коллекции, реализуйте один из универсальных интерфейсов коллекции. Затем данную коллекцию можно использовать для заполнения универсальных типов коллекции. |
| [CA1011: попробуйте передать базовые типы в качестве параметров](../code-quality/ca1011.md) | Если в объявлении метода в качестве параметра указан базовый тип, любой тип, производный от базового, можно передать методу в качестве соответствующего аргумента. Если дополнительные функции, предоставляемые производным типом параметра, не требуются, то использование базового типа позволит более широко применять данный метод. |
| [CA1012: абстрактные типы не должны иметь конструкторы](../code-quality/ca1012.md) | Конструкторы абстрактных типов могут быть вызваны только производными типами. Открытые конструкторы создают экземпляры типа. Невозможно создавать экземпляры абстрактного типа; абстрактный тип с открытым конструктором является недопустимым. |
| [CA1013: перегружайте оператор равенства при перегрузке сложения и вычитания](../code-quality/ca1013.md) | Открытый или защищенный тип реализует операторы сложения или вычитания без реализации оператора равенства. |
| [CA1014: помечайте сборки атрибутом CLSCompliantAttribute](../code-quality/ca1014.md) | Спецификация среды CLS определяет ограничения по именованию, типам данных и правилам, которым должны соответствовать сборки, предназначенные для использования в нескольких языках программирования. Хороший дизайн определяет, что все сборки явно указывают на совместимость с CLS с помощью CLSCompliantAttribute. Если этот атрибут у сборки отсутствует, сборка несовместима. |
| [CA1016: помечать сборки атрибутом AssemblyVersionAttribute](../code-quality/ca1016.md) | .NET использует номер версии для уникальной идентификации сборки и привязки к типам в сборках со строгими именами. Номер версии используется наряду с политикой версий и издателя. По умолчанию приложения выполняются только с версией сборки, которая использовалась для их построения. |
| [CA1017: помечайте сборки атрибутом ComVisibleAttribute](../code-quality/ca1017.md) | Атрибут ComVisibleAttribute определяет порядок обращения клиентов COM к управляемому коду. Для правильной разработки сборки должны явным образом указывать видимость COM. Можно задать видимость COM для всей сборки, а затем переопределить ее для отдельных типов и элементов типов. Если атрибут отсутствует, содержимое сборки будет видимым клиентам COM. |
| [CA1018: помечайте атрибуты как AttributeUsageAttribute](../code-quality/ca1018.md) | При определении настраиваемого атрибута его нужно пометить атрибутом AttributeUsageAttribute, чтобы указать, где можно применять этот настраиваемый атрибут в исходном коде. Допустимое положение атрибута в коде зависит от значения атрибута и его применения. |
| [CA1019: необходимо определять методы доступа для аргументов атрибутов](../code-quality/ca1019.md) | Атрибуты могут определять обязательные аргументы, которые должны быть указаны при применении атрибута к целевому объекту. Они также известны как позиционные аргументы, поскольку предоставляются для конструкторов атрибутов в качестве позиционных параметров. Для каждого обязательного аргумента атрибут должен предоставлять соответствующее свойство, доступное только для чтения, чтобы извлечь значение аргумента во время выполнения. Кроме того, атрибуты могут определять дополнительные параметры, известные как именованные аргументы. Эти аргументы предоставляются для конструкторов атрибутов по имени и должны иметь соответствующее свойство чтения/записи. |
| [CA1020: не используйте пространства имен с несколькими типами](../code-quality/ca1020.md) | Убедитесь, что каждое из пространств имен имеет логическую организацию и что у вас есть допустимая причина для размещения типов в разреженном пространстве имен. |
| [CA1021: не используйте параметры out](../code-quality/ca1021.md) | Для реализации передачи типов по ссылке (с помощью ключевого слова out или ref) от разработчика требуется опыт работы с указателями, понимание отличия между типами значения и ссылочными типами и умение работать с методами с несколькими возвращаемыми значениями. Кроме того, далеко не все понимают разницу между параметрами out и ref. |
| [CA1023: индексы не должны быть многомерными](../code-quality/ca1023.md) | Для индексаторов (индексированных свойств) должен использоваться один индекс. Многомерные индексаторы могут крайне отрицательно сказаться на удобстве работы с библиотекой. |
| [CA1024: используйте свойства, если это уместно](../code-quality/ca1024.md) | Имя открытого или защищенного метода начинается с Get, он не принимает параметры и возвращает значение, не являющееся массивом. Возможно, этот метод лучше преобразовать в свойство. |
| [CA1025: замените повторяющиеся аргументы массивом параметров](../code-quality/ca1025.md) | Если точное число аргументов неизвестно и эти аргументы принадлежат одному типу или могут быть переданы как аргументы одного типа, используйте вместо повторяющихся аргументов массив параметров. |
| [CA1026: не следует использовать параметры по умолчанию](../code-quality/ca1026.md) | Методы, использующие параметры по умолчанию, разрешены по спецификации CLS; однако спецификация CLS разрешает компиляторам не учитывать значения, присвоенные этим параметрам. Для однородной работы с различными языками программирования следует заменять методы, использующие параметры по умолчанию, на перегрузки методов, предоставляющие параметры по умолчанию. |
| [CA1027: следует помечать перечисления атрибутом FlagsAttribute](../code-quality/ca1027.md) | Перечисление является типом значения, которое определяет набор связанных именованных констант. Атрибут FlagsAttribute применяется к перечислению, когда его именованные константы могут быть объединены осмысленным образом. |
| [CA1028: хранилище перечислений должно иметь тип Int32](../code-quality/ca1028.md) | Перечисление является типом значения, которое определяет набор связанных именованных констант. По умолчанию для хранения значения константы используется тип данных System.Int32. Несмотря на то, что этот базовый тип можно изменить, он не является обязательным и не рекомендуется для большинства сценариев. |
| [CA1030: используйте события, если это уместно](../code-quality/ca1030.md) | Данное правило отслеживает методы с именами, которые, как правило, используются для событий. Если метод вызывается в ответ на четко определенное изменение состояния, то этот вызов должен осуществляться с помощью обработчика событий. Объекты, вызывающие методы, должны создавать события, а не вызывать методы напрямую. |
| [CA1031: не перехватывайте типы общих исключений](../code-quality/ca1031.md) | Общие исключения не должны перехватываться. Перехватите более конкретное исключение или повторно создайте общее исключение в качестве последней инструкции в блоке catch. |
| [CA1032: реализуйте стандартные конструкторы исключения](../code-quality/ca1032.md) | Для правильной обработки исключений необходимо предоставить полный набор конструкторов. |
| [CA1033: методы интерфейса должны быть доступны для вызова дочерним типам](../code-quality/ca1033.md) | Незапечатанный тип, доступный для внешнего кода, предоставляет явную реализацию метода открытого интерфейса и не предоставляет доступный для внешнего кода альтернативный метод с тем же именем. |
| [CA1034: вложенные типы не должны быть видимыми](../code-quality/ca1034.md) | Вложенный тип — это тип, объявленный внутри области другого типа. Вложенные типы удобно использовать для инкапсуляции закрытых сведений о реализациях содержащего их типа. В силу этого вложенные типы не должны быть видимыми для внешнего кода. |
| [CA1035: в составе реализаций ICollection есть строго типизированные элементы](../code-quality/ca1035.md) | Это правило требует, чтобы реализации ICollection предоставляли строго типизированные элементы, поскольку тогда пользователям не придется приводить аргументы к типу Object при использовании функциональных возможностей интерфейса. В этом правиле предполагается, что тип, реализующий интерфейс ICollection, делает это для управления коллекцией экземпляров типа, более строгого, чем Object. |
| [CA1036: переопределяйте методы в сравнимых типах](../code-quality/ca1036.md) | Открытый или защищенный тип реализует интерфейс System.IComparable. Он не переопределяет метод Object.Equals и не перегружает языковой оператор равенства, неравенства, "больше" или "меньше". |
| [CA1038: перечислители должны быть строго типизированы](../code-quality/ca1038.md) | Это правило требует, чтобы реализации IEnumerator предоставляли строго типизированную версию свойства Current, поскольку тогда пользователям не придется приводить возвращаемое значение к строгому типу при использовании функциональных возможностей интерфейса. |
| [CA1039: списки обладают строгой типизацией](../code-quality/ca1039.md) | Это правило требует, чтобы реализации IList предоставляли строго типизированные элементы, поскольку тогда пользователям не придется приводить аргументы к типу System.Object при использовании функциональных возможностей интерфейса. |
| [CA1040: избегайте пустых интерфейсов](../code-quality/ca1040.md) | Интерфейсы определяют члены, предоставляющие поведение или соглашение об использовании. Функциональность, описанная интерфейсом, может быть использована любым типом вне зависимости от расположения типа в иерархии интерфейса. Тип реализует интерфейс путем предоставления реализаций для членов интерфейса. Пустой интерфейс не определяет никаких элементов, поэтому он не определяет контракт, который можно реализовать. |
| [CA1041: укажите сообщение ObsoleteAttribute](../code-quality/ca1041.md) | Тип или элемент помечен атрибутом System.ObsoleteAttribute, для которого не указано свойство ObsoleteAttribute.Message. При компиляции типа или члена, помеченного с помощью атрибута ObsoleteAttribute, отображается свойство Message атрибута, которое предоставляет пользователю сведения об устаревшем типе или члене. |
| [CA1043: используйте целый или строковый аргумент для индексаторов](../code-quality/ca1043.md) | Индексаторы (индексированные свойства) должны использовать для индекса целочисленные или строковые типы. Эти типы обычно используются для индексации структур данных и повышения удобства использования библиотеки. Тип Object следует использовать только в том случае, если во время разработки невозможно указать определенный целочисленный или строковый тип. |
| [CA1044: свойства не должны быть доступны только на запись](../code-quality/ca1044.md) | Несмотря на то, что допустимо, а часто и необходимо иметь свойство, доступное только на чтение, рекомендации по разработке запрещают использование свойств, доступных только на запись. Это связано с тем, что если позволить пользователю задать значение, а затем запретить ему просматривать это значение, то таким образом не будет обеспечиваться какая-либо безопасность. Кроме того, при отсутствии доступа на чтение нельзя просмотреть состояние общих объектов, что снижает их полезность. |
| [CA1045: не передавайте типы по ссылке](../code-quality/ca1045.md) | Для реализации передачи типов по ссылке (с помощью ключевого слова out или ref) от разработчика требуется опыт работы с указателями, понимание отличия между типами значения и ссылочными типами и умение работать с методами с несколькими возвращаемыми значениями. Архитекторам, разрабатывающим библиотеки для широкого использования, не следует рассчитывать, что пользователи прекрасно разбираются в использовании параметров out и ref. |
| [CA1046: не перегружайте оператор равенства для ссылочных типов](../code-quality/ca1046.md) | Реализация оператора равенства по умолчанию почти всегда правильно работает для ссылочных типов. По умолчанию две ссылки равны, если они указывают на один объект. |
| [CA1047: не объявляйте защищенные элементы в запечатанных типах](../code-quality/ca1047.md) | Типы объявляют защищенный члены таким образом, чтобы наследующие типы могли получить доступ к члену или переопределить его. По определению наследовать запечатанные типы нельзя; это означает, что вызов защищенных методов для запечатанных типов невозможен. |
| [CA1048: не объявляйте виртуальные элементы в запечатанных типах](../code-quality/ca1048.md) | Типы объявляют методы как виртуальные, чтобы наследующие типы могли переопределять реализацию виртуального метода. По определению наследовать запечатанный тип нельзя. При этом виртуальный метод запечатанного типа теряет смысл. |
| [CA1049: типы, которым принадлежат собственные ресурсы, должны быть высвобождаемыми](../code-quality/ca1049.md) | Типы, выделяющие неуправляемые ресурсы, должны реализовывать интерфейс IDisposable, чтобы вызывающие методы могли высвобождать эти ресурсы по требованию и сокращать время существования объектов, занимающих ресурсы. |
| [CA1050: объявляйте типы в пространствах имен](../code-quality/ca1050.md) | Типы объявляются в пространствах имен во избежание конфликтов имен и с целью упорядочения связанных типов в иерархии объектов. |
| [CA1051: не объявляйте видимые поля экземпляров](../code-quality/ca1051.md) | Поля главным образом следует использовать для данных реализации. Поля должны быть помечены как private или internal и должны быть представлены с помощью свойств. |
| [CA1052: типы со статическими заполнителями должны быть запечатаны](../code-quality/ca1052.md) | Открытый или защищенный тип содержит только статические члены и не объявляется с помощью модификатораC#sealed () или NotInheritable (Visual Basic). Тип, для которого нельзя создавать унаследованные типы, должен быть помечен модификатором sealed, чтобы его нельзя было использовать как базовый тип. |
| [CA1053: типы статических владельцев не должны иметь конструкторы](../code-quality/ca1053.md) | В открытом или вложенном открытом типе объявляются только статические элементы и имеется открытый или защищенный конструктор по умолчанию. Конструктор не нужен, поскольку при вызове статических членов не требуется экземпляр типа. Для обеспечения безопасности перегруженная строка должна вызывать перегрузку универсального кода ресурса (URI), используя строковый аргумент. |
| [CA1054: параметры URI не должны быть строками](../code-quality/ca1054.md) | Если метод принимает строковое представление универсального кода ресурса (URI), необходимо предоставить соответствующую перегрузку, принимающую экземпляр класса URI, который предоставляет эти услуги безопасным образом. |
| [CA1055: возвращаемые значения URI не должны быть строками](../code-quality/ca1055.md) | В этом правиле предполагается, что метод возвращает универсальный код ресурса (URI). В строковых представлениях кода URI часто встречаются ошибки синтаксического анализа и кодирования, которые могут привести к уязвимостям системы безопасности. Класс System.Uri предоставляет аналогичные услуги более надежным и безопасным способом. |
| [CA1056: свойства URI не должны быть строками](../code-quality/ca1056.md) | Это правило предполагает, что свойство представляет универсальный код ресурса (URI). В строковых представлениях кода URI часто встречаются ошибки синтаксического анализа и кодирования, которые могут привести к уязвимостям системы безопасности. Класс System.Uri предоставляет аналогичные услуги более надежным и безопасным способом. |
| [CA1057: перегрузки строковых параметров URI вызывают перегрузки System.Uri](../code-quality/ca1057.md) | Тип объявляет перегрузки метода, которые отличаются только заменой строкового параметра на параметр System.Uri. Эта перегрузка, которая принимает строковый параметр, не вызывает перегрузку, которая принимает параметр URI. |
| [CA1058: типы не должны расширять определенные базовые типы](../code-quality/ca1058.md) | Видимый извне тип расширяет некоторые базовые типы. Используйте только один вариант. |
| [CA1059: члены не должны предоставлять определенные устойчивые типы](../code-quality/ca1059.md) | Устойчивый тип – это тип, который имеет полную реализацию и экземпляр которого можно создать. Чтобы иметь возможность широкого использования этого элемента, замените конкретный тип предложенным интерфейсом. |
| [CA1060: переместите P/Invokes в класс NativeMethods](../code-quality/ca1060.md) | Методы вызова платформы, такие как помеченные <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> или методы, определенные с помощью ключевого слова Declare в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)], обращаются к неуправляемому коду. Эти методы должны относиться к классу NativeMethods, SafeNativeMethods или UnsafeNativeMethods. |
| [CA1061: не следует скрывать методы базового класса](../code-quality/ca1061.md) | Метод в базовом типе скрыт методом с таким же именем в производном типе. Сигнатура параметра производного метода отличается только типами, которые являются более слабыми, чем соответствующие типы в сигнатуре параметра базового метода. |
| [CA1062: проверьте аргументы открытых методов](../code-quality/ca1062.md) | Все ссылочные аргументы, передаваемые в видимые для внешнего кода методы, должны проверяться на равенство значению NULL. |
| [CA1063: следует правильно реализовывать IDisposable](../code-quality/ca1063.md) | Все типы IDisposable должны правильно реализовывать шаблон "Dispose". |
| [CA1064: исключения должны быть открытыми](../code-quality/ca1064.md) | Внутреннее исключение видно только внутри своей внутренней области. После выхода исключения за пределы внутренней области для перехвата исключения можно использовать только базовое исключение. Если внутреннее исключение наследуется от <xref:System.Exception?displayProperty=fullName>, <xref:System.SystemException?displayProperty=fullName> или <xref:System.ApplicationException?displayProperty=fullName>, внешний код не будет иметь достаточных сведений, чтобы узнать, что делать с этим исключением. |
| [CA1065: не вызывайте исключения в непредвиденных местах](../code-quality/ca1065.md) | Метод вызывает исключение, хотя не должен этого делать. |
| [CA1068: параметры CancellationToken должны быть получены последними](../code-quality/ca1068.md) | Метод имеет параметр CancellationToken, который не является последним параметром. |
| [CA2210: сборки должны иметь допустимые строгие имена](../code-quality/ca2210.md) | Строгое имя защищает клиентов от случайной загрузки сборки, которая была подменена. Сборки без строгих имен следует развертывать лишь в крайне небольшом числе случаев. При обмене или распространении сборок без правильной подписи сборки могут быть подменены, среда CLR может не загрузить сборку или пользователь может быть вынужден отключить проверку на своем компьютере. |
