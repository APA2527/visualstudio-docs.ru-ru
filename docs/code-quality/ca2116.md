---
title: 'CA2116: методы APTCA должны вызывать только методы APTCA'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- AptcaMethodsShouldOnlyCallAptcaMethods
- CA2116
helpviewer_keywords:
- AptcaMethodsShouldOnlyCallAptcaMethods
- CA2116
ms.assetid: 8b91637e-891f-4dde-857b-bf8012270ec4
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 9d12013c61a5ea14d6be1955132d5379f56a535a
ms.sourcegitcommit: 1efb6b219ade7c35068b79fbdc573a8771ac608d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/28/2020
ms.locfileid: "78168837"
---
# <a name="ca2116-aptca-methods-should-only-call-aptca-methods"></a>CA2116: методы APTCA должны вызывать только методы APTCA

|||
|-|-|
|TypeName|AptcaMethodsShouldOnlyCallAptcaMethods|
|CheckId|CA2116|
|Категория|Microsoft.Security|
|Критическое изменение|Прекращение|

## <a name="cause"></a>Причина
Метод в сборке с атрибутом <xref:System.Security.AllowPartiallyTrustedCallersAttribute?displayProperty=fullName> вызывает метод в сборке, не имеющей атрибута.

> [!NOTE]
> Это устаревшее правило недоступно в анализаторах FxCop. Дополнительные сведения см. в разделе [устаревшие правила](fxcop-rule-port-status.md#deprecated-rules).

## <a name="rule-description"></a>Описание правила

По умолчанию открытые или защищенные методы в сборках со строгими именами неявно защищаются с помощью [ссылки на запросы](/dotnet/framework/misc/link-demands) полного доверия. только полностью доверенные вызывающие объекты могут обращаться к сборке со строгим именем. Сборки со строгими именами, помеченные атрибутом <xref:System.Security.AllowPartiallyTrustedCallersAttribute> (APTCA), не имеют этой защиты. Атрибут отключает запрос компоновки, делая сборку доступным для вызывающих объектов, которые не имеют полного доверия, например кода, выполняемого из интрасети или Интернета.

Если атрибут APTCA имеется в полностью доверенной сборке, а сборка выполняет код в другой сборке, которая не допускает частично доверенных вызывающих объектов, возможно, используется уязвимость безопасности. Если два метода `M1` и `M2` отвечают следующим условиям, то вредоносные вызывающие объекты могут использовать метод `M1` для обхода неявного запроса ссылки с полным доверием, защищающего `M2`:

- `M1` — это открытый метод, объявленный в полностью доверенной сборке, имеющей атрибут APTCA.

- `M1` вызывает метод `M2` извне сборки `M1`.

- Сборка `M2`не имеет атрибута APTCA и, следовательно, не должна выполняться или от имени вызывающих объектов с частичным доверием.

Частично доверенный вызывающий объект `X` может вызывать метод `M1`, что приводит к `M1` вызову `M2`. Поскольку `M2` не имеет атрибута APTCA, его непосредственный вызывающий объект (`M1`) должен соответствовать запросу компоновки для полного доверия. `M1` имеет полное доверие и, следовательно, удовлетворяет этой проверке. Угроза безопасности заключается в том, что `X` не участвует в выполнении запроса компоновки, защищающего `M2` от ненадежных вызывающих объектов. Поэтому методы с атрибутом APTCA не должны вызывать методы, не имеющие атрибута.

## <a name="how-to-fix-violations"></a>Устранение нарушений
Если требуется атрибут АПКТА, используйте требование для защиты метода, который вызывает сборку с полным доверием. Точные требуемые разрешения зависят от функциональных возможностей, предоставляемых вашим методом. Если возможно, защитите метод с помощью запроса полного доверия, чтобы обеспечить недоступность базовой функциональности вызывающим объектам с частичным доверием. Если это невозможно, выберите набор разрешений, которые эффективно защищают предоставляемую функциональность.

## <a name="when-to-suppress-warnings"></a>Когда следует подавлять предупреждения
Чтобы безопасно отключить предупреждение из этого правила, необходимо убедиться, что функциональные возможности, предоставляемые методом, напрямую или косвенно разрешают вызывающим объектам доступ к конфиденциальным сведениям, операциям или ресурсам, которые могут быть использованы необратимым образом.

## <a name="example-1"></a>Пример 1
В следующем примере используются две сборки и тестовое приложение для демонстрации уязвимости системы безопасности, обнаруженной этим правилом. Первая сборка не имеет атрибута APTCA и не должна быть доступна для частично доверенных вызывающих объектов (представленных `M2` в предыдущем обсуждении).

[!code-csharp[FxCop.Security.NoAptca#1](../code-quality/codesnippet/CSharp/ca2116-aptca-methods-should-only-call-aptca-methods_1.cs)]

## <a name="example-2"></a>Пример 2
Вторая сборка является полностью доверенной и позволяет частично доверенным вызывающим объектам (представленным `M1` в предыдущем обсуждении).

[!code-csharp[FxCop.Security.YesAptca#1](../code-quality/codesnippet/CSharp/ca2116-aptca-methods-should-only-call-aptca-methods_2.cs)]

## <a name="example-3"></a>Пример 3
Тестовое приложение (представленное `X` в предыдущем обсуждении) является частично доверенным.

[!code-csharp[FxCop.Security.TestAptcaMethods#1](../code-quality/codesnippet/CSharp/ca2116-aptca-methods-should-only-call-aptca-methods_3.cs)]

В примере получается следующий вывод.

```txt
Demand for full trust:Request failed.
ClassRequiringFullTrust.DoWork was called.
```

## <a name="related-rules"></a>Связанные правила

- [CA2117: APTCA-типы должны расширять только базовые APTCA-типы](../code-quality/ca2117.md)

## <a name="see-also"></a>См. также:

- [Правила написания безопасного кода](/dotnet/standard/security/secure-coding-guidelines)
- [Использование библиотек из частично доверенного кода](/dotnet/framework/misc/using-libraries-from-partially-trusted-code)
- [Требования связывания](/dotnet/framework/misc/link-demands)
- [Данные и моделирование](/dotnet/framework/data/index)
