---
title: CA2116. APTCA-методы должны вызывать только APTCA-методы
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- AptcaMethodsShouldOnlyCallAptcaMethods
- CA2116
helpviewer_keywords:
- AptcaMethodsShouldOnlyCallAptcaMethods
- CA2116
ms.assetid: 8b91637e-891f-4dde-857b-bf8012270ec4
author: gewarren
ms.author: gewarren
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: f09817e9248fdc28f56ac0162e783bf72643ee5c
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/07/2019
ms.locfileid: "72021831"
---
# <a name="ca2116-aptca-methods-should-only-call-aptca-methods"></a>CA2116. APTCA-методы должны вызывать только APTCA-методы

|||
|-|-|
|TypeName|AptcaMethodsShouldOnlyCallAptcaMethods|
|CheckId|CA2116|
|Category|Microsoft.Security|
|Критическое изменение|Критическое|

## <a name="cause"></a>Причина:

Метод в сборке с атрибутом <xref:System.Security.AllowPartiallyTrustedCallersAttribute?displayProperty=fullName> вызывает метод в сборке, не имеющей атрибута.

## <a name="rule-description"></a>Описание правила

По умолчанию открытые или защищенные методы в сборках со строгими именами неявно защищаются с помощью [ссылки на запросы](/dotnet/framework/misc/link-demands) полного доверия. только полностью доверенные вызывающие объекты могут обращаться к сборке со строгим именем. Сборки со строгими именами, помеченные атрибутом <xref:System.Security.AllowPartiallyTrustedCallersAttribute> (APTCA), не имеют этой защиты. Атрибут отключает запрос компоновки, делая сборку доступным для вызывающих объектов, которые не имеют полного доверия, например кода, выполняемого из интрасети или Интернета.

Если атрибут APTCA имеется в полностью доверенной сборке, а сборка выполняет код в другой сборке, которая не допускает частично доверенных вызывающих объектов, возможно, используется уязвимость безопасности. Если два метода `M1` и `M2` соответствуют следующим условиям, вредоносные вызывающие объекты могут использовать метод `M1` для обхода неявного запроса ссылки с полным доверием, защищающего `M2`:

- `M1` — это открытый метод, объявленный в полностью доверенной сборке, имеющей атрибут APTCA.

- `M1` вызывает метод `M2` за пределами сборки `M1`.

- Сборка `M2` не имеет атрибута APTCA и, следовательно, не должна выполняться или от имени вызывающих объектов с частичным доверием.

Вызывающий объект с частичным доверием `X` может вызвать метод `M1`, в результате чего `M1` Вызовите `M2`. Поскольку `M2` не имеет атрибута APTCA, его непосредственный вызывающий объект (`M1`) должен соответствовать запросу компоновки для полного доверия. `M1` имеет полное доверие и, следовательно, удовлетворяет этой проверке. Угроза безопасности заключается в том, что `X` не участвует в выполнении запроса компоновки, защищающего `M2` от ненадежных вызывающих объектов. Поэтому методы с атрибутом APTCA не должны вызывать методы, не имеющие атрибута.

## <a name="how-to-fix-violations"></a>Устранение нарушений
Если требуется атрибут АПКТА, используйте требование для защиты метода, который вызывает сборку с полным доверием. Точные требуемые разрешения зависят от функциональных возможностей, предоставляемых вашим методом. Если возможно, защитите метод с помощью запроса полного доверия, чтобы обеспечить недоступность базовой функциональности вызывающим объектам с частичным доверием. Если это невозможно, выберите набор разрешений, которые эффективно защищают предоставляемую функциональность.

## <a name="when-to-suppress-warnings"></a>Когда следует подавлять предупреждения
Чтобы безопасно отключить предупреждение из этого правила, необходимо убедиться, что функциональные возможности, предоставляемые методом, напрямую или косвенно разрешают вызывающим объектам доступ к конфиденциальным сведениям, операциям или ресурсам, которые могут быть использованы необратимым образом.

## <a name="example-1"></a>Пример 1
В следующем примере используются две сборки и тестовое приложение для демонстрации уязвимости системы безопасности, обнаруженной этим правилом. Первая сборка не имеет атрибута APTCA и не должна быть доступна для частично доверенных вызывающих объектов (представленных `M2` в предыдущем обсуждении).

[!code-csharp[FxCop.Security.NoAptca#1](../code-quality/codesnippet/CSharp/ca2116-aptca-methods-should-only-call-aptca-methods_1.cs)]

## <a name="example-2"></a>Пример 2
Вторая сборка является полностью доверенной и позволяет частично доверенным вызывающим объектам (представленным `M1` в предыдущем обсуждении).

[!code-csharp[FxCop.Security.YesAptca#1](../code-quality/codesnippet/CSharp/ca2116-aptca-methods-should-only-call-aptca-methods_2.cs)]

## <a name="example-3"></a>Пример 3
Тестовое приложение (представленное `X` в предыдущем обсуждении) является частично доверенным.

[!code-csharp[FxCop.Security.TestAptcaMethods#1](../code-quality/codesnippet/CSharp/ca2116-aptca-methods-should-only-call-aptca-methods_3.cs)]

В этом примере выводятся следующие данные:

```txt
Demand for full trust:Request failed.
ClassRequiringFullTrust.DoWork was called.
```

## <a name="related-rules"></a>Связанные правила

- @NO__T 0CA2117: APTCA-типы должны расширять только базовые типы APTCA @ no__t – 0

## <a name="see-also"></a>См. также

- [Правила написания безопасного кода](/dotnet/standard/security/secure-coding-guidelines)
- [Использование библиотек из частично доверенного кода](/dotnet/framework/misc/using-libraries-from-partially-trusted-code)
- [Требования связывания](/dotnet/framework/misc/link-demands)
- [Данные и моделирование](/dotnet/framework/data/index)