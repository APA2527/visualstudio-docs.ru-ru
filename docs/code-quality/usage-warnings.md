---
title: предупреждения использования
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.usagerules
helpviewer_keywords:
- warnings, usage
- managed code analysis warnings, usage warnings
- usage warnings
ms.assetid: fe7dc2a3-289d-4bf7-a1e4-0947a81287c4
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: a0ff6ba1f654f3a9b909012f159cd3daaf2892f3
ms.sourcegitcommit: 3f491903e0c10db9a3f3fc0940f7b587fcbf9530
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/26/2020
ms.locfileid: "85382631"
---
# <a name="usage-warnings"></a>предупреждения использования

Предупреждения об использовании поддерживают правильное использование .NET.

## <a name="in-this-section"></a>В этом разделе

|Правило|Описание:|
|----------|-----------------|
|[CA1801. Проверьте неиспользуемые параметры](../code-quality/ca1801.md)|Сигнатура метода включает параметр, не использующийся в основной части метода.|
|[CA1806. Не игнорируйте результаты метода](../code-quality/ca1806.md)|Создается, но никогда не используется новый объект, либо вызывается метод, который создает и возвращает новую строку, и такая новая строка никогда не используется, либо метод COM или P/Invoke возвращает HRESULT или код ошибки, который никогда не используется.|
|[CA1816. Вызов GC.SuppressFinalize должен осуществляться правильно](../code-quality/ca1816.md)|Метод, являющийся реализацией Dispose, не вызывает GC.SuppressFinalize, либо метод, не являющийся реализацией Dispose, вызывает GC.SuppressFinalize, либо метод вызывает GC.SuppressFinalize и передает что-либо другое (Me в Visual Basic).|
|[CA2200. Повторно порождайте исключения для сохранения сведений стека](../code-quality/ca2200.md)|В операторе throw повторно создается и явным образом задается исключение. Если исключение повторно создается заданием исключения в операторе throw, список вызовов метода между исходным методом, создавшим исключение, и текущим методом будет утерян.|
|[CA2201. Не порождайте исключения зарезервированных типов](../code-quality/ca2201.md)|Это делает исходную ошибку трудной для обнаружения и отладки.|
|[CA2202. Не ликвидируйте объекты несколько раз](../code-quality/ca2202.md)|Реализация метода содержит пути кода, которые могли стать причиной многократного вызова метода System.IDisposable.Dispose или эквивалентного метода Dispose (например, метода Close() для некоторых типов) для одного и того же объекта.|
|[CA2204. Литералы должны иметь правильное правописание](../code-quality/ca2204.md)|Литеральная строка в теле метода содержит одно или несколько слов, не распознаваемых библиотекой системы проверки орфографии Майкрософт.|
|[CA2205. Используйте управляемые эквиваленты Win32 API](../code-quality/ca2205.md)|Определен метод вызова неуправляемого кода, и доступен метод .NET с аналогичной функциональностью.|
|[CA2207. Используйте встроенную инициализацию статических полей типов значений](../code-quality/ca2207.md)|Тип значения объявляет явный статический конструктор. Чтобы устранить нарушение данного правила, выполните инициализацию всех статических данных при их объявлении и удалите статический конструктор.|
|[CA2208. Правильно создавайте экземпляры исключений аргументов](../code-quality/ca2208.md)|Вызывается конструктор по умолчанию (без параметров), принадлежащий к типу исключения ArgumentException или унаследованный от него, или неправильный аргумент строки передается параметризованному конструктору, принадлежащему к типу исключения ArgumentException или унаследованному от него.|
|[CA2211. Поля, не являющиеся константами, не должны быть видимыми](../code-quality/ca2211.md)|Статические поля, не являющиеся константами или только для чтения, не являются потокобезопасными. Доступ к такому полю должен быть тщательно контролируемым и требует расширенных методов программирования для синхронизации доступа к объекту класса.|
|[CA2212. Не помечайте обслуживаемые компоненты с помощью WebMethod](../code-quality/ca2212.md)|Метод в типе, который наследует от System. EnterpriseServices. ServicedComponent, отмечается атрибутом System. Web. Services. WebMethodAttribute. Так как атрибут WebMethodAttribute и метод ServicedComponent имеют разное поведение и предъявляют конфликтующие требования к контексту и потоку транзакций, в некоторых сценариях поведение метода будет неправильным.|
|[CA2213. Следует высвобождать высвобождаемые поля](../code-quality/ca2213.md)|Тип, реализующий System.IDisposable, объявляет поля, принадлежащие к типам, которые также реализуют IDisposable. Метод Dispose поля не вызывается методом Dispose объявляющего типа.|
|[CA2214. Не вызывайте переопределяемые методы в конструкторах](../code-quality/ca2214.md)|Если конструктор вызывает виртуальный метод, возможно, конструктор для экземпляра, который вызывает метод, не выполнялся.|
|[CA2215. Метод Dispose должен вызывать базовый класс Dispose](../code-quality/ca2215.md)|Если тип наследуется от удаляемого типа, он должен вызвать метод Dispose базового типа из собственного метода Dispose.|
|[CA2216. Высвобождаемые типы должны объявлять методы завершения](../code-quality/ca2216.md)|Тип, реализующий System. IDisposable и имеющий поля, предлагающие использование неуправляемых ресурсов, не реализует метод завершения, как описано в Object. Finalize.|
|[CA2217. Не помечайте перечисляемые типы с помощью FlagsAttribute](../code-quality/ca2217.md)|Перечисление, видимое извне, помечается атрибутом FlagsAttribute и имеет одно или несколько значений, не являющихся степенями двух, или сочетанием других определенных значений в перечислении.|
|[CA2218. Переопределяйте GetHashCode при переопределении Equals](../code-quality/ca2218.md)|GetHashCode возвращает значение на основе текущего экземпляра, используемое для алгоритмов хэширования и структур данных, таких как хэш-таблица. Два равных объекта, принадлежащие к одному и тому же типу, должны возвращать один и тот же хэш-код.|
|[CA2219. В предложениях с исключениями не должны порождаться исключения](../code-quality/ca2219.md)|Если исключение создается в предложении finally или fault, новое исключение скрывает активное исключение. Если исключение создается в предложении filter, среда выполнения перехватывает исключение без оповещения. Это делает исходную ошибку трудной для обнаружения и отладки.|
|[CA2220. Методы завершения должны вызывать метод завершения базового класса](../code-quality/ca2220.md)|Финализация должна распространятся посредством иерархии наследования. Для этого типы должны вызывать свой метод Finalize базового класса из собственного метода Finalize.|
|[CA2221. Методы завершения должны быть защищенными](../code-quality/ca2221.md)|В методах завершения должен использоваться модификатор доступа из семейства.|
|[CA2222. Не уменьшайте видимость наследуемого члена](../code-quality/ca2222.md)|Не изменяйте модификатор доступа для наследуемых членов. Если сделать унаследованный член закрытым, то доступ вызывающих объектов к реализации метода базового класса все равно не будет запрещен.|
|[CA2223. Члены должны различаться не только возвращаемым типом](../code-quality/ca2223.md)|Среда CLR позволяет использовать возвращаемые типы для различения совпадающих в остальном членов, однако эта функция не входит в спецификацию CLS и поддерживается не всеми языками программирования .NET.|
|[CA2224. Переопределяйте Equals при перегрузке оператора равенства](../code-quality/ca2224.md)|Открытый тип реализует оператор равенства, но не переопределяет Object. Equals.|
|[CA2225. Для перегрузок операторов существуют варианты с именами](../code-quality/ca2225.md)|Обнаружена перегрузка оператора, однако не найден ожидаемый именованный альтернативный метод. Именованный альтернативный элемент предоставляет доступ к тем же функциональным возможностям, что и оператор, и предоставляется разработчикам, которые запрограммированы на языках, не поддерживающих перегруженные операторы.|
|[CA2226. Перегрузки операторов должны быть симметричными](../code-quality/ca2226.md)|Тип реализует оператор равенства или неравенства и не реализует противоположный оператор.|
|[CA2227. Свойства, возвращающие коллекции, должны быть доступными только для чтения](../code-quality/ca2227.md)|Свойство коллекции, допускающее запись, позволяет пользователю заменять одну коллекцию другой. Свойство только для чтения предотвращает замену коллекции, но по-прежнему допускает установку, настройку отдельных членов.|
|[CA2228. Не поставляйте предварительные форматы ресурсов](../code-quality/ca2228.md)|Файлы ресурсов, созданные с помощью предварительных версий .NET, могут не использоваться поддерживаемыми версиями .NET.|
|[CA2229. Реализуйте конструкторы сериализации](../code-quality/ca2229.md)|Чтобы устранить нарушение этого правила, реализуйте конструктор сериализации. Для запечатанного класса конструктор должен быть закрытым, а в иных случаях — защищенным.|
|[CA2230. Используйте параметры для аргументов переменной](../code-quality/ca2230.md)|Открытый или защищенный тип содержит открытый или защищенный метод, который использует соглашение о вызовах VarArgs вместо ключевого слова params.|
|[CA2231. Перегрузите оператор равенства на переопределяющем типе ValueType.Equals](../code-quality/ca2231.md)|Тип значения переопределяет `Object.Equals` , но не реализует оператор равенства.|
|[CA2232. Отметьте точки входа Windows Forms меткой STAThread](../code-quality/ca2232.md)|Атрибут STAThreadAttribute указывает, что потоковой моделью COM для приложения является однопотоковое подразделение. Данный атрибут должен находиться в точке входа любого приложения, использующего Windows Forms; если он отсутствует, компоненты Windows могут работать неправильно.|
|[CA2233. В операциях не должно быть переполнений](../code-quality/ca2233.md)|Арифметические операции не следует выполнять без предварительной проверки операндов, чтобы убедиться, что результат операции выходит за пределы диапазона возможных значений для используемых типов данных.|
|[CA2234. Передавайте объекты System.Uri вместо строк](../code-quality/ca2234.md)|Вызывается метод, имеющий параметр строки, имя которого содержит uri, URI, urn, URN, url или URL.  Объявляющий тип метода содержит соответствующую перегрузку метода, которая имеет параметр System.Uri.|
|[CA2235. Пометьте все несериализуемые поля](../code-quality/ca2235.md)|Экземпляр поля несериализуемого типа объявлен в сериализуемом типе.|
|[CA2236. Вызывайте методы базового класса для типов ISerializable](../code-quality/ca2236.md)|Чтобы устранить нарушение этого правила, вызовите метод базового типа GetObjectData или конструктор сериализации из соответствующего метода производного типа или конструктора.|
|[CA2237. Пометьте типы ISerializable атрибутом SerializableAttribute](../code-quality/ca2237.md)|Для распознавания общеязыковой средой выполнения в качестве сериализуемых типы должны быть помечены атрибутом SerializableAttribute, даже если тип использует пользовательскую подпрограммы сериализации посредством реализации интерфейса ISerializable.|
|[CA2238. Правильно реализуйте методы сериализации](../code-quality/ca2238.md)|Метод, обрабатывающий событие сериализации, не имеет правильной сигнатуры, типа возвращаемого значения или отображения.|
|[CA2239. Обеспечьте наличие методов десериализации в необязательных полях](../code-quality/ca2239.md)|Тип имеет поле, помеченное атрибутом System. Runtime. Serialization. OptionalFieldAttribute, а тип не предоставляет методы обработки событий отмены сериализации.|
|[CA2240. Правильно реализуйте ISerializable](../code-quality/ca2240.md)|Чтобы устранить нарушение этого правила, сделайте метод GetObjectData видимым и переопределяемым и убедитесь, что все поля экземпляра включены в процесс сериализации или явно помечены атрибутом NonSerializedAttribute.|
|[CA2241. Задайте правильные аргументы для методов форматирования](../code-quality/ca2241.md)|Аргумент формата, переданный в System. String. Format, не содержит элемент форматирования, соответствующий аргументу объекта, или наоборот.|
|[CA2242. Правильно выполняйте проверку NaN](../code-quality/ca2242.md)|Это выражение проверяет значение на соответствие Single.Nan или Double.Nan. Используйте Single.IsNan(Single) или Double.IsNan(Double) для проверки значения.|
|[CA2243. Синтаксический разбор строковых литералов должен осуществляться правильно](../code-quality/ca2243.md)|Параметр строкового литерала атрибута не анализируется правильно для URL-адреса, идентификатора GUID или версии.|
|[CA2244: не повторяйте инициализацию индексируемых элементов](../code-quality/ca2244.md)|Инициализатор объекта имеет более одного инициализатора индексированных элементов с одинаковым индексом константы. Все, кроме последнего инициализатора, являются избыточными.|
|[CA2245: не назначайте свойство самому себе](../code-quality/ca2245.md)|Свойство было случайно назначено самому себе.|
|[CA2246: не присваивайте значения символу и его элементу в одном операторе](../code-quality/ca2246.md)|Не рекомендуется назначать символ и его член, то есть поле или свойство в одной и той же инструкции. Неясно, если доступ к члену был предназначен для использования старого значения символа до присваивания или нового значения из назначения в этой инструкции.|
|[CA2247: аргумент, переданный в конструктор TaskCompletionSource, должен быть TaskCreationOptions enum вместо TaskContinuationOptions Enum](../code-quality/ca2246.md)|TaskCompletionSource имеет конструкторы, принимающие TaskCreationOptions, которые управляют базовой задачей, и конструкторы, которые принимают состояние объекта, сохраненное в задаче.  Случайная передача TaskContinuationOptions вместо TaskCreationOptions приведет к тому, что в вызове будут рассматриваться параметры как состояние.|
|[CA2248: укажите правильный аргумент Enum в "Enum. HasFlag"](../code-quality/ca2248.md)|Тип перечисления, переданный в качестве аргумента в `HasFlag` вызов метода, отличается от вызывающего типа перечисления.|
