---
title: предупреждения использования
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.usagerules
helpviewer_keywords:
- warnings, usage
- managed code analysis warnings, usage warnings
- usage warnings
ms.assetid: fe7dc2a3-289d-4bf7-a1e4-0947a81287c4
author: gewarren
ms.author: gewarren
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: e607da01d160212eea03b1fe81dfb2fbf4ede3f6
ms.sourcegitcommit: 034c503ae04e22cf840ccb9770bffd012e40fb2d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/14/2019
ms.locfileid: "72305683"
---
# <a name="usage-warnings"></a>предупреждения использования

Предупреждения об использовании поддерживают правильное использование .NET.

## <a name="in-this-section"></a>в этом разделе

|Правило|Описание|
|----------|-----------------|
|@NO__T 0CA1801: Проверьте неиспользуемые параметры @ no__t-0|Сигнатура метода включает параметр, не использующийся в основной части метода.|
|@NO__T 0CA1806: Не пропускать результаты метода @ no__t-0|Создается, но никогда не используется новый объект, либо вызывается метод, который создает и возвращает новую строку, и такая новая строка никогда не используется, либо метод COM или P/Invoke возвращает HRESULT или код ошибки, который никогда не используется.|
|@NO__T 0CA1816: Вызовите GC. SuppressFinalize правильно @ no__t-0|Метод, являющийся реализацией Dispose, не вызывает сборщик Мусора. SuppressFinalize; или метод, не являющийся реализацией Dispose вызывает сборщик Мусора. SuppressFinalize; или вызовы методов сборки Мусора. SuppressFinalize и передает что-то другое (Me в Visual Basic).|
|@NO__T 0CA2200: Повторное создание для сохранения сведений о стеке @ no__t-0|В операторе throw повторно создается и явным образом задается исключение. Если исключение повторно создается заданием исключения в операторе throw, список вызовов метода между исходным методом, создавшим исключение, и текущим методом будет утерян.|
|@NO__T 0CA2201: Не вызывайте зарезервированные типы исключений @ no__t-0|Это делает исходную ошибку трудной для обнаружения и отладки.|
|@NO__T 0CA2202: Не удалять объекты несколько раз @ no__t-0|Реализация метода содержит пути кода, которые могли стать причиной многократного вызова метода System.IDisposable.Dispose или эквивалентного метода Dispose (например, метода Close() для некоторых типов) для одного и того же объекта.|
|@NO__T 0CA2204: Литералы должны быть правильно написаны @ no__t-0|Литеральная строка в теле метода содержит одно или несколько слов, не распознаваемых библиотекой системы проверки орфографии Майкрософт.|
|@NO__T 0CA2205: Использование управляемых эквивалентов Win32 API @ no__t-0|Определен метод вызова неуправляемого кода, и доступен метод .NET с аналогичной функциональностью.|
|@NO__T 0CA2207: Инициализируйте статические поля типа значения во встроенном @ no__t-0|Тип значения объявляет явный статический конструктор. Чтобы устранить нарушение данного правила, выполните инициализацию всех статических данных при их объявлении и удалите статический конструктор.|
|@NO__T 0CA2208: Правильное создание экземпляров исключений аргументов @ no__t-0|Вызывается конструктор по умолчанию (без параметров), принадлежащий к типу исключения ArgumentException или унаследованный от него, или неправильный аргумент строки передается параметризованному конструктору, принадлежащему к типу исключения ArgumentException или унаследованному от него.|
|@NO__T 0CA2211: Неконстантные поля не должны быть видимыми @ no__t-0|Статические поля, не являющиеся константами или только для чтения, не являются потокобезопасными. Доступ к такому полю должен быть тщательно контролируемым и требует расширенных методов программирования для синхронизации доступа к объекту класса.|
|@NO__T 0CA2212: Не помечать обслуживаемые компоненты с помощью WebMethod @ no__t-0|Метод в типе, который наследует от System. EnterpriseServices. ServicedComponent, отмечается атрибутом System. Web. Services. WebMethodAttribute. Так как атрибут WebMethodAttribute и метод ServicedComponent имеют разное поведение и предъявляют конфликтующие требования к контексту и потоку транзакций, в некоторых сценариях поведение метода будет неправильным.|
|[CA2213: следует высвобождать высвобождаемые поля](../code-quality/ca2213-disposable-fields-should-be-disposed.md)|Тип, реализующий System.IDisposable, объявляет поля, принадлежащие к типам, которые также реализуют IDisposable. Метод Dispose поля не вызывается методом Dispose объявляющего типа.|
|@NO__T 0CA2214: Не Вызывайте переопределяемые методы в конструкторах @ no__t-0|Если конструктор вызывает виртуальный метод, возможно, конструктор для экземпляра, который вызывает метод, не выполнялся.|
|@NO__T 0CA2215: Методы Dispose должны вызывать базовый класс Dispose @ no__t-0|Если тип наследуется от удаляемого типа, он должен вызвать метод Dispose базового типа из собственного метода Dispose.|
|@NO__T 0CA2216: Удаляемые типы должны объявлять финализатор @ no__t-0|Тип, реализующий System. IDisposable и имеющий поля, предлагающие использование неуправляемых ресурсов, не реализует метод завершения, как описано в Object. Finalize.|
|@NO__T 0CA2217: Не помечать перечисления атрибутом FlagsAttribute @ no__t-0|Перечисление, видимое извне, помечается атрибутом FlagsAttribute и имеет одно или несколько значений, не являющихся степенями двух, или сочетанием других определенных значений в перечислении.|
|@NO__T 0CA2218: Переопределить GetHashCode при переопределении Equals @ no__t-0|GetHashCode возвращает значение на основе текущего экземпляра, используемое для алгоритмов хэширования и структур данных, таких как хэш-таблица. Два равных объекта, принадлежащие к одному и тому же типу, должны возвращать один и тот же хэш-код.|
|@NO__T 0CA2219: Не вызывайте исключения в предложениях исключений @ no__t-0|Если исключение создается в предложении finally или fault, новое исключение скрывает активное исключение. Если исключение создается в предложении filter, среда выполнения перехватывает исключение без оповещения. Это делает исходную ошибку трудной для обнаружения и отладки.|
|@NO__T 0CA2220: Методы завершения должны вызывать метод завершения базового класса @ no__t-0|Финализация должна распространятся посредством иерархии наследования. Для этого типы должны вызывать свой метод Finalize базового класса из собственного метода Finalize.|
|@NO__T 0CA2221: Методы завершения должны быть защищены @ no__t-0|В методах завершения должен использоваться модификатор доступа из семейства.|
|@NO__T 0CA2222: Не уменьшайте видимость унаследованного члена @ no__t-0|Не изменяйте модификатор доступа для наследуемых членов. Если сделать унаследованный член закрытым, то доступ вызывающих объектов к реализации метода базового класса все равно не будет запрещен.|
|@NO__T 0CA2223: Члены должны отличаться больше, чем возвращаемый тип @ no__t-0|Среда CLR позволяет использовать типы возвращаемого значения для различения совпадающих в остальном членов, однако эта функция не входит в спецификацию CLS и поддерживается не всеми языками программирования .NET.|
|@NO__T 0CA2224: Переопределить Equals при перегрузке оператора равным @ no__t-0|Открытый тип реализует оператор равенства, но не переопределяет Object. Equals.|
|@NO__T 0CA2225: Перегрузки операторов имеют именованные варианты @ no__t-0|Обнаружена перегрузка оператора, однако не найден ожидаемый именованный альтернативный метод. Именованный альтернативный элемент предоставляет доступ к тем же функциональным возможностям, что и оператор, и предоставляется разработчикам, которые запрограммированы на языках, не поддерживающих перегруженные операторы.|
|@NO__T 0CA2226: Операторы должны иметь симметричную перегрузку @ no__t-0|Тип реализует оператор равенства или неравенства и не реализует противоположный оператор.|
|@NO__T 0CA2227: Свойства коллекции должны быть доступны только для чтения @ no__t-0|Свойство коллекции, допускающее запись, позволяет пользователю заменять одну коллекцию другой. Свойство только для чтения предотвращает замену коллекции, но по-прежнему допускает установку, настройку отдельных членов.|
|@NO__T 0CA2228: Не поставлять невыпущенные форматы ресурсов @ no__t-0|Файлы ресурсов, созданные с помощью предварительных версий .NET, могут не использоваться поддерживаемыми версиями .NET.|
|[CA2229: реализуйте конструкторы сериализации](../code-quality/ca2229-implement-serialization-constructors.md)|Чтобы устранить нарушение этого правила, реализуйте конструктор сериализации. Для запечатанного класса конструктор должен быть закрытым, а в иных случаях — защищенным.|
|@NO__T 0CA2230: Использовать параметры для переменных аргументов @ no__t-0|Открытый или защищенный тип содержит открытый или защищенный метод, который использует соглашение о вызовах VarArgs вместо ключевого слова params.|
|[CA2231: перегрузите оператор равенства на переопределяющем типе ValueType.Equals](../code-quality/ca2231-overload-operator-equals-on-overriding-valuetype-equals.md)|Тип значения переопределяет `Object.Equals`, но не реализует оператор равенства.|
|@NO__T 0CA2232: Пометьте Windows Forms точки входа с помощью STAThread @ no__t-0|Атрибут STAThreadAttribute указывает, что потоковой моделью COM для приложения является однопотоковое подразделение. Данный атрибут должен находиться в точке входа любого приложения, использующего Windows Forms; если он отсутствует, компоненты Windows могут работать неправильно.|
|@NO__T 0CA2233: Операции не должны переполнены @ no__t-0|Арифметические операции не следует выполнять без предварительной проверки операндов, чтобы убедиться, что результат операции выходит за пределы диапазона возможных значений для используемых типов данных.|
|@NO__T 0CA2234: Передавать объекты System. URI вместо строк @ no__t-0|Вызывается метод, имеющий параметр строки, имя которого содержит uri, URI, urn, URN, url или URL.  Объявляющий тип метода содержит соответствующую перегрузку метода, которая имеет параметр System.Uri.|
|[CA2235. Пометьте все несериализуемые поля](../code-quality/ca2235-mark-all-non-serializable-fields.md)|Экземпляр поля несериализуемого типа объявлен в сериализуемом типе.|
|@NO__T 0CA2236: Вызов методов базового класса для типов ISerializable @ no__t-0|Чтобы устранить нарушение этого правила, вызовите метод базового типа GetObjectData или конструктор сериализации из соответствующего метода производного типа или конструктора.|
|[CA2237. Пометьте типы ISerializable с SerializableAttribute @ no__t-0|Для распознавания общеязыковой средой выполнения в качестве сериализуемых типы должны быть помечены атрибутом SerializableAttribute, даже если тип использует пользовательскую подпрограммы сериализации посредством реализации интерфейса ISerializable.|
|@NO__T 0CA2238: Правильно реализуйте методы сериализации @ no__t-0|Метод, обрабатывающий событие сериализации, не имеет правильной сигнатуры, типа возвращаемого значения или отображения.|
|@NO__T 0CA2239: Укажите методы десериализации для необязательных полей @ no__t-0|Тип имеет поле, помеченное атрибутом System. Runtime. Serialization. OptionalFieldAttribute, а тип не предоставляет методы обработки событий отмены сериализации.|
|@NO__T 0CA2240: Правильно реализуйте ISerializable @ no__t-0|Чтобы устранить нарушение этого правила, сделайте метод GetObjectData видимым и переопределяемым и убедитесь, что все поля экземпляра включены в процесс сериализации или явно помечены атрибутом NonSerializedAttribute.|
|@NO__T 0CA2241: Укажите правильные аргументы для методов форматирования @ no__t-0|Аргумент формата, переданный в System. String. Format, не содержит элемент форматирования, соответствующий аргументу объекта, или наоборот.|
|@NO__T 0CA2242: Правильно протестируйте NaN @ no__t-0|Это выражение проверяет значение на соответствие Single.Nan или Double.Nan. Используйте Single.IsNan(Single) или Double.IsNan(Double) для проверки значения.|
|@NO__T 0CA2243: Строковые литералы атрибутов должны анализироваться правильно @ no__t-0|Параметр строкового литерала атрибута не анализируется правильно для URL-адреса, идентификатора GUID или версии.|