---
title: Правила использования
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.usagerules
helpviewer_keywords:
- rules, usage
- managed code analysis rules, usage rules
- usage rules
ms.assetid: fe7dc2a3-289d-4bf7-a1e4-0947a81287c4
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 45dd58978bb37dd66023d8a28b9babf017bec262
ms.sourcegitcommit: 566144d59c376474c09bbb55164c01d70f4b621c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/19/2020
ms.locfileid: "90806191"
---
# <a name="usage-rules"></a>Правила использования

Правила использования поддерживают правильное использование .NET.

## <a name="in-this-section"></a>в этом разделе

|Правило|Описание|
|----------|-----------------|
|[CA1801. Проверьте неиспользуемые параметры](../code-quality/ca1801.md)|Сигнатура метода включает параметр, не использующийся в основной части метода.|
|[CA1816. Вызов GC.SuppressFinalize должен осуществляться правильно](../code-quality/ca1816.md)|Метод, являющийся реализацией Dispose, не вызывает GC.SuppressFinalize, либо метод, не являющийся реализацией Dispose, вызывает GC.SuppressFinalize, либо метод вызывает GC.SuppressFinalize и передает что-либо другое (Me в Visual Basic).|
|[CA2200. Повторно порождайте исключения для сохранения сведений стека](../code-quality/ca2200.md)|В операторе throw повторно создается и явным образом задается исключение. Если исключение повторно создается заданием исключения в операторе throw, список вызовов метода между исходным методом, создавшим исключение, и текущим методом будет утерян.|
|[CA2201. Не порождайте исключения зарезервированных типов](../code-quality/ca2201.md)|Это делает исходную ошибку трудной для обнаружения и отладки.|
|[CA2202. Не ликвидируйте объекты несколько раз](../code-quality/ca2202.md)|Реализация метода содержит пути кода, которые могли стать причиной многократного вызова метода System.IDisposable.Dispose или эквивалентного метода Dispose (например, метода Close() для некоторых типов) для одного и того же объекта.|
|[CA2207. Используйте встроенную инициализацию статических полей типов значений](../code-quality/ca2207.md)|Тип значения объявляет явный статический конструктор. Чтобы устранить нарушение данного правила, выполните инициализацию всех статических данных при их объявлении и удалите статический конструктор.|
|[CA2208. Правильно создавайте экземпляры исключений аргументов](../code-quality/ca2208.md)|Вызывается конструктор по умолчанию (без параметров), принадлежащий к типу исключения ArgumentException или унаследованный от него, или неправильный аргумент строки передается параметризованному конструктору, принадлежащему к типу исключения ArgumentException или унаследованному от него.|
|[CA2211. Поля, не являющиеся константами, не должны быть видимыми](../code-quality/ca2211.md)|Статические поля, не являющиеся константами или только для чтения, не являются потокобезопасными. Доступ к такому полю должен быть тщательно контролируемым и требует расширенных методов программирования для синхронизации доступа к объекту класса.|
|[CA2213. Следует высвобождать высвобождаемые поля](../code-quality/ca2213.md)|Тип, реализующий System.IDisposable, объявляет поля, принадлежащие к типам, которые также реализуют IDisposable. Метод Dispose поля не вызывается методом Dispose объявляющего типа.|
|[CA2214. Не вызывайте переопределяемые методы в конструкторах](../code-quality/ca2214.md)|Если конструктор вызывает виртуальный метод, возможно, конструктор для экземпляра, который вызывает метод, не выполнялся.|
|[CA2215. Метод Dispose должен вызывать базовый класс Dispose](../code-quality/ca2215.md)|Если тип наследуется от удаляемого типа, он должен вызвать метод Dispose базового типа из собственного метода Dispose.|
|[CA2216. Высвобождаемые типы должны объявлять методы завершения](../code-quality/ca2216.md)|Тип, реализующий System. IDisposable и имеющий поля, предлагающие использование неуправляемых ресурсов, не реализует метод завершения, как описано в Object. Finalize.|
|[CA2217. Не помечайте перечисляемые типы с помощью FlagsAttribute](../code-quality/ca2217.md)|Перечисление, видимое извне, помечается атрибутом FlagsAttribute и имеет одно или несколько значений, не являющихся степенями двух, или сочетанием других определенных значений в перечислении.|
|[CA2219. В предложениях с исключениями не должны порождаться исключения](../code-quality/ca2219.md)|Если исключение создается в предложении finally или fault, новое исключение скрывает активное исключение. Если исключение создается в предложении filter, среда выполнения перехватывает исключение без оповещения. Это делает исходную ошибку трудной для обнаружения и отладки.|
|[CA2225. Для перегрузок операторов существуют варианты с именами](../code-quality/ca2225.md)|Обнаружена перегрузка оператора, однако не найден ожидаемый именованный альтернативный метод. Именованный альтернативный элемент предоставляет доступ к тем же функциональным возможностям, что и оператор, и предоставляется разработчикам, которые запрограммированы на языках, не поддерживающих перегруженные операторы.|
|[CA2226. Перегрузки операторов должны быть симметричными](../code-quality/ca2226.md)|Тип реализует оператор равенства или неравенства и не реализует противоположный оператор.|
|[CA2227. Свойства, возвращающие коллекции, должны быть доступными только для чтения](../code-quality/ca2227.md)|Свойство коллекции, допускающее запись, позволяет пользователю заменять одну коллекцию другой. Свойство только для чтения предотвращает замену коллекции, но по-прежнему допускает установку, настройку отдельных членов.|
|[CA2229. Реализуйте конструкторы сериализации](../code-quality/ca2229.md)|Чтобы устранить нарушение этого правила, реализуйте конструктор сериализации. Для запечатанного класса конструктор должен быть закрытым, а в иных случаях — защищенным.|
|[CA2231. Перегрузите оператор равенства на переопределяющем типе ValueType.Equals](../code-quality/ca2231.md)|Тип значения переопределяет `Object.Equals` , но не реализует оператор равенства.|
|[CA2232. Отметьте точки входа Windows Forms меткой STAThread](../code-quality/ca2232.md)|Атрибут STAThreadAttribute указывает, что потоковой моделью COM для приложения является однопотоковое подразделение. Данный атрибут должен находиться в точке входа любого приложения, использующего Windows Forms; если он отсутствует, компоненты Windows могут работать неправильно.|
|[CA2233. В операциях не должно быть переполнений](../code-quality/ca2233.md)|Арифметические операции не следует выполнять без предварительной проверки операндов, чтобы убедиться, что результат операции выходит за пределы диапазона возможных значений для используемых типов данных.|
|[CA2234. Передавайте объекты System.Uri вместо строк](../code-quality/ca2234.md)|Вызывается метод, имеющий параметр строки, имя которого содержит uri, URI, urn, URN, url или URL.  Объявляющий тип метода содержит соответствующую перегрузку метода, которая имеет параметр System.Uri.|
|[CA2235. Пометьте все несериализуемые поля](../code-quality/ca2235.md)|Экземпляр поля несериализуемого типа объявлен в сериализуемом типе.|
|[CA2236. Вызывайте методы базового класса для типов ISerializable](../code-quality/ca2236.md)|Чтобы устранить нарушение этого правила, вызовите метод базового типа GetObjectData или конструктор сериализации из соответствующего метода производного типа или конструктора.|
|[CA2237. Пометьте типы ISerializable атрибутом SerializableAttribute](../code-quality/ca2237.md)|Для распознавания общеязыковой средой выполнения в качестве сериализуемых типы должны быть помечены атрибутом SerializableAttribute, даже если тип использует пользовательскую подпрограммы сериализации посредством реализации интерфейса ISerializable.|
|[CA2238. Правильно реализуйте методы сериализации](../code-quality/ca2238.md)|Метод, обрабатывающий событие сериализации, не имеет правильной сигнатуры, типа возвращаемого значения или отображения.|
|[CA2239. Обеспечьте наличие методов десериализации в необязательных полях](../code-quality/ca2239.md)|Тип имеет поле, помеченное атрибутом System. Runtime. Serialization. OptionalFieldAttribute, а тип не предоставляет методы обработки событий отмены сериализации.|
|[CA2240. Правильно реализуйте ISerializable](../code-quality/ca2240.md)|Чтобы устранить нарушение этого правила, сделайте метод GetObjectData видимым и переопределяемым и убедитесь, что все поля экземпляра включены в процесс сериализации или явно помечены атрибутом NonSerializedAttribute.|
|[CA2241. Задайте правильные аргументы для методов форматирования](../code-quality/ca2241.md)|Аргумент формата, переданный в System. String. Format, не содержит элемент форматирования, соответствующий аргументу объекта, или наоборот.|
|[CA2242. Правильно выполняйте проверку NaN](../code-quality/ca2242.md)|Это выражение проверяет значение на соответствие Single.Nan или Double.Nan. Используйте Single.IsNan(Single) или Double.IsNan(Double) для проверки значения.|
|[CA2243. Синтаксический разбор строковых литералов должен осуществляться правильно](../code-quality/ca2243.md)|Параметр строкового литерала атрибута не анализируется правильно для URL-адреса, идентификатора GUID или версии.|
|[CA2244: не повторяйте инициализацию индексируемых элементов](../code-quality/ca2244.md)|Инициализатор объекта имеет более одного инициализатора индексированных элементов с одинаковым индексом константы. Все, кроме последнего инициализатора, являются избыточными.|
|[CA2245: не назначайте свойство самому себе](../code-quality/ca2245.md)|Свойство было случайно назначено самому себе.|
|[CA2246: не присваивайте значения символу и его элементу в одном операторе](../code-quality/ca2246.md)|Не рекомендуется назначать символ и его член, то есть поле или свойство в одной и той же инструкции. Неясно, если доступ к члену был предназначен для использования старого значения символа до присваивания или нового значения из назначения в этой инструкции.|
|[CA2247: аргумент, переданный в конструктор TaskCompletionSource, должен быть перечислением TaskCreationOptions, а не TaskContinuationOptions](../code-quality/ca2246.md)|TaskCompletionSource имеет конструкторы, принимающие TaskCreationOptions, которые управляют базовой задачей, и конструкторы, которые принимают состояние объекта, сохраненное в задаче.  Случайная передача TaskContinuationOptions вместо TaskCreationOptions приведет к тому, что в вызове будут рассматриваться параметры как состояние.|
|[CA2248: укажите правильный аргумент Enum в "Enum. HasFlag"](../code-quality/ca2248.md)|Тип перечисления, переданный в качестве аргумента в `HasFlag` вызов метода, отличается от вызывающего типа перечисления.|
|[CA2249. Попробуйте использовать String.Contains вместо String.IndexOf.](../code-quality/ca2249.md)|Вызовы, `string.IndexOf` где результат используется для проверки наличия или отсутствия подстроки, можно заменить на `string.Contains` .|
