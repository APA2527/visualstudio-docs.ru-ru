---
title: CA1045. Не передавайте типы по ссылке
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- CA1045
- DoNotPassTypesByReference
helpviewer_keywords:
- CA1045
- DoNotPassTypesByReference
ms.assetid: bcc3900a-e092-4bb8-896f-cb83f6289968
author: gewarren
ms.author: gewarren
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: c6a8fda526647a1a9f7f999928cb08978a61bd04
ms.sourcegitcommit: 0c2523d975d48926dd2b35bcd2d32a8ae14c06d8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/24/2019
ms.locfileid: "71235782"
---
# <a name="ca1045-do-not-pass-types-by-reference"></a>CA1045. Не передавайте типы по ссылке

|||
|-|-|
|TypeName|DoNotPassTypesByReference|
|CheckId|CA1045|
|Категория|Microsoft. Design|
|Критическое изменение|Критическое|

## <a name="cause"></a>Причина:
Открытый или защищенный метод в открытом типе имеет `ref` параметр, принимающий тип-примитив, ссылочный тип или тип значения, не являющийся одним из встроенных типов.

## <a name="rule-description"></a>Описание правила
Передача типов по ссылке (с `out` помощью `ref`или) требует взаимодействия с указателями, понимание того, как типы значений и ссылочные типы различаются, и обрабатывает методы с несколькими возвращаемыми значениями. Кроме того, различие между `out` параметрами `ref` и не является широко понятным.

Когда ссылочный тип передается по ссылке, метод намеревается использовать параметр для возврата другого экземпляра объекта. (Передача ссылочного типа по ссылке также называется использованием двойного указателя, указателя на указатель или двойного косвенного обращения.) При использовании соглашения о вызовах по умолчанию, которое передает "по значению", параметр, который принимает ссылочный тип, уже получает указатель на объект. Указатель, а не объект, на который он указывает, передается по значению. Передача по значению означает, что метод не может изменить указатель, чтобы он указывал на новый экземпляр ссылочного типа, но может изменить содержимое объекта, на который он указывает. Для большинства приложений это достаточно и дает вам необходимое поведение.

Если метод должен возвращать другой экземпляр, используйте для этого возвращаемое значение метода. См. <xref:System.String?displayProperty=fullName> класс для различных методов, которые работают с строками и возвращают новый экземпляр строки. Эта модель позволяет вызывающему объекту решить, сохраняется ли исходный объект.

Хотя возвращаемые значения являются наиболее распространенными и часто используются, правильное `out` применение `ref` и параметры требуют промежуточных навыков проектирования и программирования. Архитекторы библиотек, которые разрабатывается для общей аудитории, не должны ждать, `out` чтобы `ref` пользователи работали с главными рабочими параметрами или.

> [!NOTE]
> При работе с параметрами, которые являются большими структурами, дополнительные ресурсы, необходимые для копирования этих структур, могут вызвать воздействие на производительность при передаче по значению. В таких случаях можно использовать `ref` параметры или. `out`

## <a name="how-to-fix-violations"></a>Устранение нарушений
Чтобы устранить нарушение этого правила, вызванное типом значения, метод должен вернуть объект в качестве возвращаемого значения. Если метод должен возвращать несколько значений, перепроектирование его для возврата одного экземпляра объекта, содержащего значения.

Чтобы устранить нарушение этого правила, вызванное ссылочным типом, убедитесь, что требуемое поведение возвращает новый экземпляр ссылки. Если это так, метод должен использовать его возвращаемое значение для этого.

## <a name="when-to-suppress-warnings"></a>Когда следует подавлять предупреждения
Можно спокойно отключить предупреждение из этого правила. Однако такая схема может вызвать проблемы с удобством использования.

## <a name="example"></a>Пример
В следующей библиотеке показаны две реализации класса, которые создают ответы на отзыв пользователя. Первая реализация (`BadRefAndOut`) заставляет пользователя библиотеки управлять тремя возвращаемыми значениями. Вторая реализация (`RedesignedRefAndOut`) упрощает взаимодействие с пользователем, возвращая экземпляр класса контейнера (`ReplyData`), который управляет данными как единым целым.

[!code-csharp[FxCop.Design.NoRefOrOut#1](../code-quality/codesnippet/CSharp/ca1045-do-not-pass-types-by-reference_1.cs)]

## <a name="example"></a>Пример
В следующем приложении показана работа пользователя. Вызов переработанной библиотеки (`UseTheSimplifiedClass` метода) более прост, и сведения, возвращаемые методом, легко управляются. Выходные данные двух методов идентичны.

[!code-csharp[FxCop.Design.TestNoRefOrOut#1](../code-quality/codesnippet/CSharp/ca1045-do-not-pass-types-by-reference_2.cs)]

## <a name="example"></a>Пример
В следующем примере библиотеки показано, `ref` как используются параметры для ссылочных типов, и демонстрируется лучший способ реализации этой функции.

[!code-csharp[FxCop.Design.RefByRefNo#1](../code-quality/codesnippet/CSharp/ca1045-do-not-pass-types-by-reference_3.cs)]

## <a name="example"></a>Пример
Следующее приложение вызывает каждый метод в библиотеке, чтобы продемонстрировать поведение.

[!code-csharp[FxCop.Design.TestRefByRefNo#1](../code-quality/codesnippet/CSharp/ca1045-do-not-pass-types-by-reference_4.cs)]

В этом примере выводятся следующие данные:

```txt
Changing pointer - passed by value:
12345
12345
Changing pointer - passed by reference:
12345
12345 ABCDE
Passing by return value:
12345 ABCDE
```

## <a name="related-rules"></a>Связанные правила
[CA1021: Избегайте параметров out](../code-quality/ca1021-avoid-out-parameters.md)