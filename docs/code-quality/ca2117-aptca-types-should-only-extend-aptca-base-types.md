---
title: CA2117. APTCA-типы должны расширять только базовые APTCA-типы
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- CA2117
- AptcaTypesShouldOnlyExtendAptcaBaseTypes
helpviewer_keywords:
- AptcaTypesShouldOnlyExtendAptcaBaseTypes
- CA2117
ms.assetid: c505b586-2f1e-47cb-98ee-a5afcbeda70f
author: gewarren
ms.author: gewarren
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 832d2c9fc1d4b9138a7cd1bc39868b3c4bf1b814
ms.sourcegitcommit: 0c2523d975d48926dd2b35bcd2d32a8ae14c06d8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/24/2019
ms.locfileid: "71232644"
---
# <a name="ca2117-aptca-types-should-only-extend-aptca-base-types"></a>CA2117. APTCA-типы должны расширять только базовые APTCA-типы

|||
|-|-|
|TypeName|AptcaTypesShouldOnlyExtendAptcaBaseTypes|
|CheckId|CA2117|
|Категория|Microsoft.Security|
|Критическое изменение|Критическое|

## <a name="cause"></a>Причина:

Открытый или защищенный тип в сборке с <xref:System.Security.AllowPartiallyTrustedCallersAttribute?displayProperty=fullName> атрибутом наследуется от типа, объявленного в сборке, не имеющей атрибута.

## <a name="rule-description"></a>Описание правила

По умолчанию открытые или защищенные типы в сборках со строгими именами неявно защищаются с помощью [InheritanceDemand](xref:System.Security.Permissions.SecurityAction#System_Security_Permissions_SecurityAction_InheritanceDemand) для полного доверия. Сборки со строгими именами, помеченные <xref:System.Security.AllowPartiallyTrustedCallersAttribute> атрибутом (APTCA), не имеют такой защиты. Атрибут отключает требование наследования. Предоставленные типы, объявленные в сборке без требования наследования, наследуются типами, которые не имеют полного доверия.

Если атрибут APTCA существует в полностью доверенной сборке, а тип в сборке наследуется от типа, который не допускает частично доверенных вызывающих объектов, то может использоваться уязвимость безопасности. Если два типа `T1` и `T2` отвечают приведенным ниже условиям, то вредоносные вызывающие `T1` объекты могут использовать этот тип для обхода неявного `T2`требования наследования с полным доверием, защищающего:

- `T1`— Это открытый тип, объявленный в полностью доверенной сборке, имеющей атрибут APTCA.

- `T1`наследуется от типа `T2` вне его сборки.

- `T2`не имеет атрибута APTCA и, следовательно, не должны наследоваться типами в частично доверенных сборках.

Частично доверенный тип `X` может наследовать `T1`от класса, который предоставляет ему доступ к унаследованным `T2`членам, объявленным в. Поскольку `T2` не имеет атрибута APTCA, его непосредственный производный тип`T1`() должен соответствовать требованию наследования для полного доверия. `T1` имеет полное доверие и, следовательно, удовлетворяет этой проверке. Угроза безопасности заключается в том `X` , что не участвует в выполнении требования наследования, которое `T2` защищает от недоверенного подкласса. По этой причине типы с атрибутом APTCA не должны расширять типы, которые не имеют атрибута.

Другой проблемой безопасности, и, возможно, более распространенной, является то, что производный тип (`T1`) может с помощью ошибки программиста предоставлять защищенные члены из типа, которому требуется полное доверие (`T2`). При возникновении этой уязвимости ненадежные вызывающие объекты получают доступ к информации, которая должна быть доступна только для полностью доверенных типов.

## <a name="how-to-fix-violations"></a>Устранение нарушений

Если тип, сообщаемый нарушением, находится в сборке, для которой не требуется атрибут APTCA, удалите его.

Если атрибут APTCA является обязательным, добавьте требование наследования для полного доверия к типу. Требование наследования защищает от наследования недоверенными типами.

Можно устранить нарушение, добавив атрибут APTCA в сборки базовых типов, о которых сообщает нарушение. Не выполняя проверку безопасности всего кода в сборках и всего кода, который зависит от сборок.

## <a name="when-to-suppress-warnings"></a>Когда следует подавлять предупреждения

Чтобы безопасно отключить предупреждение из этого правила, необходимо убедиться, что защищенные члены, предоставляемые вашим типом, не прямо или косвенно разрешают ненадежным вызывающим объектам доступ к конфиденциальной информации, операциям или ресурсам, которые могут использоваться необратимым образом.

## <a name="example"></a>Пример

В следующем примере используются две сборки и тестовое приложение для демонстрации уязвимости системы безопасности, обнаруженной этим правилом. Первая сборка не имеет атрибута APTCA и не должна наследоваться частично доверенными типами (представленными `T2` в предыдущем обсуждении).

[!code-csharp[FxCop.Security.NoAptcaInherit#1](../code-quality/codesnippet/CSharp/ca2117-aptca-types-should-only-extend-aptca-base-types_1.cs)]

Вторая сборка, представленная `T1` в предыдущем обсуждении, является полностью доверенной и позволяет частично доверенным вызывающим объектам.

[!code-csharp[FxCop.Security.YesAptcaInherit#1](../code-quality/codesnippet/CSharp/ca2117-aptca-types-should-only-extend-aptca-base-types_2.cs)]

Тип теста, представленный `X` в предыдущем обсуждении, находится в сборке с частичным доверием.

[!code-csharp[FxCop.Security.TestAptcaInherit#1](../code-quality/codesnippet/CSharp/ca2117-aptca-types-should-only-extend-aptca-base-types_3.cs)]

В этом примере выводятся следующие данные:

```txt
Meet at the shady glen 2/22/2003 12:00:00 AM!
From Test: sunny meadow
Meet at the sunny meadow 2/22/2003 12:00:00 AM!
```

## <a name="related-rules"></a>Связанные правила

[CA2116: Методы APTCA должны вызывать только методы APTCA](../code-quality/ca2116-aptca-methods-should-only-call-aptca-methods.md)

## <a name="see-also"></a>См. также

- [Правила написания безопасного кода](/dotnet/standard/security/secure-coding-guidelines)
- [Использование библиотек из частично доверенного кода](/dotnet/framework/misc/using-libraries-from-partially-trusted-code)
