---
title: Предупреждения безопасности
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security warnings
- managed code analysis warnings, security warnings
- warnings, security
ms.assetid: 60d4e8ea-230a-494f-aa6a-b91db77540e4
author: gewarren
ms.author: gewarren
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: bf1f318d8138bb455e965d7df44ae45e192904e3
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/07/2019
ms.locfileid: "72018763"
---
# <a name="security-warnings"></a>Предупреждения, связанные с безопасностью

Предупреждения безопасности поддерживают более безопасные библиотеки и приложения. Эти предупреждения помогают устранить уязвимости в программе. Если отключить любое из этих предупреждений, следует четко обозначить в коде причину этого отключения, а также оповестить сотрудника, отвечающего за безопасность проекта разработки.

## <a name="in-this-section"></a>Содержание раздела

|Правило|Описание|
|----------|-----------------|
|@NO__T 0CA2100: Обзор запросов SQL для уязвимостей безопасности @ no__t-0|Метод задает свойство System.Data.IDbCommand.CommandText с использованием строки, созданной из строкового аргумента метода. Это правило предполагает, что строковый аргумент содержит введенные пользователем данные. Созданная из введенных пользователем данных командная строка SQL уязвима перед атаками путем внедрения кода SQL.|
|@NO__T 0CA2102: Перехват исключений, не являющихся CLSCompliant, в общих обработчиках @ no__t-0|Элемент в сборке, не помеченной атрибутом RuntimeCompatibilityAttribute или помеченной атрибутом RuntimeCompatibility(WrapNonExceptionThrows = false), содержит блок catch, который обрабатывает исключения System.Exception, однако непосредственно за этим блоком не следует общий блок catch.|
|@NO__T 0CA2103: Проверка императивной безопасности @ no__t-0|Метод использует принудительную безопасность и может обеспечить создание разрешения с помощью сведений о состоянии или возвращаемых значений, которые могут измениться в период активности требования. Поэтому по возможности следует использовать декларативную безопасность.|
|@NO__T 0CA2104: Не объявляйте изменяемые ссылочные типы только для чтения @ no__t-0|Видимый извне тип содержит видимое извне и доступное только для чтение поле, являющееся изменяемым ссылочным типом. Изменяемый тип — это тип, экземпляр которого может быть изменен.|
|@NO__T 0CA2105: Поля массива не должны быть доступны только для чтения @ no__t-0|При применении модификатора "только для чтения" (ReadOnly в Visual Basic) к полю, содержащему массив, это поле нельзя изменить, связав его с другим массивом. Однако элементы массива, хранящегося в доступном только для чтения поле, можно будет изменить.|
|@NO__T 0CA2106: Безопасные утверждения @ no__t-0|Метод подтверждает разрешения без выполнения проверок безопасности для вызывающего объекта. Подтверждение разрешений безопасности без выполнения проверок безопасности может привести к возникновению в коде уязвимости системы безопасности, которой могут воспользоваться злоумышленники.|
|@NO__T 0CA2107: Проверка запрета и разрешение только на использование @ no__t-0|С помощью методов PermitOnly и CodeAccessPermission. Deny действия безопасности следует использовать только те, которые имеют опыт работы с безопасностью .NET. Код, который использует эти действия безопасности, должен быть тщательно проанализирован на предмет безопасности.|
|@NO__T 0CA2108: Проверка декларативной безопасности для типов значений @ no__t-0|Открытый или защищенный тип значения защищен средствами доступа к данным или требованиями ссылки.|
|@NO__T 0CA2109: Просмотр видимых обработчиков событий @ no__t-0|Обнаружен открытый или защищенный метод обработки событий. Методы обработки событий следует раскрывать только в тех случаях, когда это совершенно необходимо.|
|@NO__T 0CA2111: Указатели не должны быть видимыми @ no__t-0|Указатель не является закрытым, внутренним или доступным только для чтения. Вредоносный код может изменить значение указателя, что приведет к предоставлению доступа к произвольным областям памяти или сбоям приложения или системы.|
|@NO__T 0CA2112: Защищенные типы не должны предоставлять поля @ no__t-0|Открытый или защищенный тип содержит открытые поля и защищен требованиями ссылки. Если код имеет доступ к экземпляру типа, защищенного запросом компоновки, то для получения доступа к полям типа коду не требуется удовлетворять запросу компоновки.|
|@NO__T 0CA2114: Безопасность метода должна быть надмножеством типа @ no__t-0|Метод не должен обладать декларативной безопасностью для одного и того же действия, как на уровне метода, так и на уровне типа.|
|@NO__T 0CA2115: Вызовите GC. KeepAlive при использовании собственных ресурсов @ no__t-0|Данное правило обнаруживает ошибки, которые могут возникать из-за завершения неуправляемых ресурсов, по-прежнему используемых в машинном коде.|
|@NO__T 0CA2116: Методы APTCA должны вызывать только методы APTCA @ no__t-0|Если в полностью доверенной сборке присутствует атрибут APTCA (AllowPartiallyTrustedCallers) и она выполняет код в другой сборке, для которой не разрешены частично доверенные вызовы, возможно возникновение уязвимости безопасности.|
|@NO__T 0CA2117: APTCA-типы должны расширять только базовые типы APTCA @ no__t – 0|Если в полностью доверенной сборке присутствует атрибут APTCA (AllowPartiallyTrustedCallers), а тип в сборке унаследован от типа, для которого не разрешены частично доверенные вызовы, возможно возникновение уязвимости безопасности.|
|@NO__T 0CA2118: Проверка использования SuppressUnmanagedCodeSecurityAttribute @ no__t-0|Атрибут SuppressUnmanagedCodeSecurityAttribute изменяет поведение системы безопасности, определенное по умолчанию, для элементов, выполняющих неуправляемый код за счет COM-взаимодействия или вызова неуправляемого кода. Этот атрибут служит в основном для повышения производительности; однако, прирост производительности сопряжен со значительными рисками безопасности.|
|@NO__T 0CA2119: Запечатайте методы, которые соответствуют частным интерфейсам @ no__t-0|Наследуемый открытый тип предоставляет реализацию переопределяемого метода внутреннего (Friend в Visual Basic) интерфейса. Для устранения нарушения данного правила следует исключить возможность переопределения метода за пределами сборки.|
|@NO__T 0CA2120: Безопасные конструкторы сериализации @ no__t-0|Для этого типа предусмотрен конструктор, который принимает объекты System.Runtime.Serialization.SerializationInfo и System.Runtime.Serialization.StreamingContext (сигнатура конструктора сериализации). Этот конструктор не защищен проверкой безопасности, однако один или несколько обычных конструкторов этого типа защищены.|
|@NO__T 0CA2121: Статические конструкторы должны быть частными](../code-quality/ca2121.md)|Система вызывает статический конструктор перед созданием первого экземпляра типа или ссылкой на любые статические члены. Если статический конструктор не является закрытым, он может быть вызван кодом, находящимся за пределами системы. В зависимости от операций, выполняемых в конструкторе, это может стать причиной непредвиденного поведения|
|@NO__T 0CA2122: Не следует косвенно предоставлять методы с запросами компоновки @ no__t-0|У открытого или защищенного члена есть требования ссылки, и он вызывается членом, который не выполняет какие-либо проверки безопасности. Запрос компоновки проверяет разрешения только непосредственно вызывающего метода.|
|@NO__T 0CA2123: Запросы на переопределение ссылок должны быть идентичны базовым @ no__t-0|Это правило сравнивает метод с его базовым методом (который является интерфейсом или виртуальным методом другого типа), а затем сравнивает запросы ссылок для каждого из них. Если это правило нарушается, то вредоносный вызывающий объект может обойти запрос ссылок путем вызова небезопасного метода.|
|@NO__T 0CA2124: Переносить уязвимые предложения finally во внешнее предложение try @ no__t-0|Открытый или защищенный метод содержит блок try/finally. Блок finally сбрасывает состояние безопасности и не заключен в блок finally.|
|@NO__T 0CA2126: Требования компоновки типа должны требовать наследование требований @ no__t-0|Открытый незапечатанный тип защищен требованием ссылки и имеет переопределяемый метод. Ни тип, ни метод не защищены требованием наследования.|
|@NO__T 0CA2130: Критические константы безопасности должны быть прозрачными @ no__t-0|Принудительная прозрачность не применяется для постоянных значений, чтобы во время выполнения не требовалась подстановка значений. Константные поля должны быть прозрачными для системы безопасности, чтобы анализаторы кода не предполагали, что прозрачный для системы безопасности код не может получить доступ к константе.|
|@NO__T 0CA2131: Критические для безопасности типы не могут участвовать в эквивалентности типов @ no__t-0|Тип участвует в эквивалентности типов, а либо сам тип, либо элемент или поле типа, помечается атрибутом атрибутом SecurityCriticalAttribute. Это правило применяется ко всем критическим типам или к типам, содержащим критические методы или поля, участвующие в эквивалентности типов. Когда среда CLR обнаруживает такой тип, она не загружает его и выдает исключение TypeLoadException во время выполнения. Обычно это правило срабатывает, только если пользователи реализуют эквивалентность типов вручную вместо того, чтобы позволить tlbimp и компиляторам обработать эквивалентность типов.|
|@NO__T 0CA2132: Конструкторы по умолчанию должны иметь по крайней мере такие же критические, как конструкторы по умолчанию базового типа @ no__t-0|Типы и члены с атрибутом SecurityCriticalAttribute не могут использоваться в коде приложений Silverlight. Критичные в плане безопасности типы и элементы могут использоваться только надежным кодом в среде .NET Framework для библиотеки классов Silverlight. Поскольку открытая или защищенная конструкция в производном классе должна иметь ту же или большую прозрачность, чем ее базовый класс, класс в приложении не может быть производным от класса, помеченного как SecurityCritical.|
|@NO__T 0CA2133: Делегаты должны быть привязаны к методам с одинаковой прозрачностью @ no__t-0|Это предупреждение вызывается методом, который привязывает делегат, помеченный атрибутом SecurityCriticalAttribute, к методу, который является прозрачным или помечен атрибутом SecuritySafeCriticalAttribute. Предупреждение также запускает метод, который привязывает прозрачный или безопасный делегат к критическому методу.|
|@NO__T 0CA2134: Методы должны иметь постоянную прозрачность при переопределении базовых методов @ no__t-0|Это правило применяется, когда метод, помеченный атрибутом SecurityCriticalAttribute, переопределяет прозрачный метод или метод, помеченный атрибутом SecuritySafeCriticalAttribute. Это правило также применяется, когда прозрачный метод или метод, помеченный атрибутом SecurityCriticalAttribute, переопределяет метод, помеченный атрибутом SecuritySafeCriticalAttribute. Это правило применяется при переопределении виртуального метода или реализации интерфейса.|
|@NO__T 0CA2135: Сборки уровня 2 не должны содержать LinkDemands @ no__t-0|Требования LinkDemand являются устаревшими в наборе правил безопасности уровня 2. Вместо использования требования LinkDemand для обеспечения безопасности во время JIT-компиляции пометьте методы, типы и поля атрибутом SecurityCriticalAttribute.|
|@NO__T 0CA2136: Элементы не должны иметь конфликтующие аннотации прозрачности @ no__t-0|Атрибуты прозрачности применяются из элементов кода большей области к элементам меньшей области. Атрибуты прозрачности элементов кода с большей областью имеют приоритет по сравнению с атрибутами прозрачности элементов кода, которые содержатся в первом элементе. Например, класс, помеченный атрибутом SecurityCriticalAttribute, не может содержать метод, помеченный атрибутом SecuritySafeCriticalAttribute.|
|@NO__T 0CA2137: Прозрачные методы должны содержать только проверяемый IL @ no__t-0|Метод содержит непроверяемый код или возвращает тип по ссылке. Это правило срабатывает при попытках прозрачного кода безопасности выполнить непроверяемый MSIL. Однако это правило не содержит полную проверку IL, и вместо нее использует эвристику для выявления большинства нарушений проверки MSIL.|
|@NO__T 0CA2138: Прозрачные методы не должны вызывать методы с атрибутом SuppressUnmanagedCodeSecurity @ no__t-0|Прозрачный с точки зрения безопасности метод вызывает метод, помеченный атрибутом SuppressUnmanagedCodeSecurityAttribute.|
|@NO__T 0CA2139: Прозрачные методы не могут использовать атрибут HandleProcessCorruptingExceptions @ no__t-0|Это правило срабатывает для любого прозрачного метода и пытается обработать поврежденное исключение с помощью атрибута HandleProcessCorruptedStateExceptionsAttribute. Исключение, приводящее к повреждению процесса, представляет собой классификацию исключения CLR версии 4,0, например <xref:System.AccessViolationException>. Атрибут HandleProcessCorruptedStateExceptionsAttribute может использоваться только критичными в плане безопасности методами и будет игнорироваться при применении для прозрачного метода.|
|@NO__T 0CA2140: Прозрачный код не должен ссылаться на критически важные элементы безопасности @ no__t-0|Методы, помеченные атрибутом SecurityTransparentAttribute, вызывают закрытые элементы, помеченные как SecurityCritical. Это правило анализирует все методы и типы в сборке, которая является смешанной прозрачной и критической, и помечает все вызовы из прозрачного кода в неоткрытый критически важный код, не помеченный как SecurityTreatAsSafe.|
|[CA2141: прозрачные методы не должны удовлетворять требования LinkDemand](../code-quality/ca2141.md)|Прозрачный с точки зрения безопасности метод вызывает метод в сборке, не помеченной атрибутом AllowPartiallyTrustedCallersAttribute (APTCA), либо прозрачный с точки зрения безопасности метод удовлетворяет требованию LinkDemand по типу или методу.|
|@NO__T 0CA2142: Прозрачный код не должен быть защищен с помощью LinkDemand @ no__t-0|Это правило срабатывает для прозрачных методов, для доступа к которым требуется LinkDemand. Прозрачный для системы безопасности код не должен отвечать за проверку безопасности операции и поэтому не должен требовать разрешений.|
|@NO__T 0CA2143: Прозрачные методы не должны использовать требования безопасности @ no__t-0|Прозрачный для системы безопасности код не должен отвечать за проверку безопасности операции и поэтому не должен требовать разрешений. Прозрачный для системы безопасности код должен использовать полные требования для принятия решений по безопасности, и критичный в плане безопасности код не должен полагаться на прозрачный код, чтобы создать полное требование.|
|@NO__T 0CA2144: Прозрачный код не должен загружать сборки из массивов байтов @ no__t-0|Проверка безопасности для прозрачного кода не так тщательна, как проверка безопасности для критического кода, поскольку прозрачный код не может выполнять действия, требующие особых мер безопасности. Сборки, загруженные из массива байтов, могут остаться незамеченными в прозрачном коде, и этот массив байтов может содержать критичный или, что более важно, критичный в плане безопасности код, который подлежит аудиту.|
|@NO__T 0CA2145: Прозрачные методы не должны быть дополнены атрибутом SuppressUnmanagedCodeSecurityAttribute @ no__t-0|Методы, оснащенные атрибутом SuppressUnmanagedCodeSecurityAttribute, имеют неявную проверку LinkDemand, применяемую к любому вызывающему их методу. Для этой проверки LinkDemand требуется, чтобы вызывающий код был критическим с точки зрения безопасности. Пометка метода, который использует SuppressUnmanagedCodeSecurity с атрибутом SecurityCriticalAttribute, делает это требование более очевидным для тех, кто вызывает этот метод.|
|@NO__T 0CA2146: Типы должны быть не менее важными, чем их базовые типы и интерфейсы @ no__t-0|Это правило срабатывает, если у производного типа есть атрибут прозрачности безопасности, не такой критический, как базовый тип или реализованный интерфейс. От критических базовых типов или реализованных критических интерфейсов могут производиться только критические типы, и от критических в плане безопасности базовых типов или реализованных интерфейсов могут производиться только критические в плане безопасности типы.|
|@NO__T 0CA2147: Прозрачные методы не могут использовать утверждения безопасности @ no__t-0|Это правило позволяет проанализировать все методы и типы в сборке, которая является либо на 100% прозрачной, либо смешанной (прозрачной и критической), и пометить декларативное и императивное использование Assert.|
|@NO__T 0CA2149: Прозрачные методы не должны вызывать машинный код @ no__t-0|Это правило срабатывает для любого прозрачного метода, который вызывает непосредственно в машинный код, например с помощью P/Invoke. Нарушение этого правила приводит к исключению MethodAccessException на уровне 2 модели прозрачности и вызову полного требования UnmanagedCode на уровне 1 модели прозрачности.|
|@NO__T 0CA2151: Поля с критическими типами должны быть критически важными для безопасности @ no__t-0|Для использования критических с точки зрения безопасности типов код, который ссылается на тип, должен быть либо критическим с точки зрения безопасности, либо надежным с точки зрения безопасности. Это верно даже в случае косвенной ссылки. Поэтому применять прозрачное для безопасности поле или поле, надежное с точки зрения безопасности, не рекомендуется, поскольку прозрачный код по-прежнему не сможет получить доступ к полю.|
|@NO__T 0CA2153: Избегайте обработки исключений поврежденного состояния @ no__t-0|[Исключения сбоя состояния (CSE)](https://msdn.microsoft.com/magazine/dd419661.aspx) указывают на то, что в процессе имеется повреждение памяти. Если перехватывать их вместо того, чтобы позволить процессу завершиться сбоем, это может привести к уязвимостям в системе безопасности, если злоумышленнику удастся поместить эксплойт в поврежденную область памяти.|
|@NO__T 0CA2300: Не используйте небезопасный десериализатор BinaryFormatter @ no__t-0|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|@NO__T 0CA2301: Не вызывайте BinaryFormatter. десериализацию без первого задания BinaryFormatter. BINDER @ no__t-0|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|@NO__T 0CA2302: Убедитесь, что BinaryFormatter. BINDER задан перед вызовом BinaryFormatter. десериализация @ no__t-0|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|@NO__T 0CA2305: Не используйте небезопасный десериализатор Лосформаттер @ no__t-0|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|@NO__T 0CA2310: Не используйте небезопасный десериализатор NetDataContractSerializer @ no__t-0|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|@NO__T 0CA2311: Не выполнять десериализацию без предварительного задания NetDataContractSerializer. BINDER @ no__t-0|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|@NO__T 0CA2312: Убедитесь, что NetDataContractSerializer. BINDER задан до десериализации @ no__t-0|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|@NO__T 0CA2315: Не используйте небезопасный десериализатор Обжектстатеформаттер @ no__t-0|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|@NO__T 0CA2321: Не выполнять десериализацию с помощью JavaScriptSerializer, используя Симплетипересолвер @ no__t-0|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|@NO__T 0CA2322: Убедитесь, что JavaScriptSerializer не инициализирован с помощью Симплетипересолвер перед десериализацией @ no__t-0|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|@NO__T 0CA2326: Не используйте значения Типенамехандлинг, отличные от None @ no__t-0|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|@NO__T 0CA2327: Не используйте небезопасные JsonSerializerSettings @ no__t-0|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|@NO__T 0CA2328: Убедитесь, что JsonSerializerSettings являются безопасными @ no__t-0|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|@NO__T 0CA2329: Не выполнять десериализацию с помощью JsonSerializer с использованием небезопасной конфигурации @ no__t-0|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|@NO__T 0CA2330: Убедитесь, что JsonSerializer имеет безопасную конфигурацию при десериализации @ no__t-0|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|@NO__T 0CA3001: Проверка кода на наличие уязвимостей введения SQL @ no__t-0|При работе с ненадежными входными и командными командами SQL учитывать атак путем внедрения кода SQL. Атака путем внедрения кода SQL может выполнять вредоносные команды SQL, нарушая безопасность и целостность приложения.|
|@NO__T 0CA3002: Проверка кода на наличие уязвимостей XSS @ no__t-0|При работе с ненадежными входными данными из веб-запросов следует учитывать атаки с использованием межсайтовых сценариев (XSS). Атака XSS внедряет недоверенные входные данные в необработанные выходные данные HTML, позволяя злоумышленникам выполнять вредоносные сценарии или вредоносно изменять содержимое на веб-странице.|
|@NO__T 0CA3003: Проверка кода на наличие уязвимостей при внедрении пути к файлам @ no__t-0|При работе с ненадежными входными данными из веб-запросов будьте учитывать, используя управляемые пользователем входные данные при указании путей к файлам.|
|@NO__T 0CA3004: Проверка кода на наличие уязвимостей раскрытия информации @ no__t-0|Раскрытие сведений об исключениях дает злоумышленникам сведения о внутренних компонентах приложения, которые могут помочь злоумышленникам найти другие уязвимости для использования.|
|@NO__T 0CA3006: Проверка кода на наличие уязвимостей при внедрении команды Process @ no__t-0|При работе с ненадежными входными данными будьте учитывать атак путем внедрения команд. Атака путем внедрения команды может выполнять вредоносные команды в базовой операционной системе, нарушая безопасность и целостность сервера.|
|@NO__T 0CA3007: Проверьте код для уязвимостей Open Redirect @ no__t-0|При работе с недоверенными входными данными будьте учитывать уязвимости открытых перенаправлений. Злоумышленник может воспользоваться уязвимостью с открытым перенаправлением, чтобы использовать веб-сайт для получения правильного URL-адреса, но перенаправить нежелательный посетитель на фишинг или другую вредоносную веб-страницу.|
|@NO__T 0CA3008: Проверка кода на наличие уязвимостей при внедрении XPath @ no__t-0|При работе с недоверенными входными данными будьте учитывать атак путем внедрения XPath. Создание запросов XPath с использованием ненадежных входных данных может позволить злоумышленнику злонамеренно манипулировать запросом для возврата непредвиденного результата и, возможно, раскрывать содержимое запрашиваемого XML.|
|@NO__T 0CA3009: Проверка кода на наличие уязвимостей при внедрении XML @ no__t-0|При работе с ненадежными входными данными учитывать атак путем внедрения кода XML.|
|@NO__T 0CA3010: Проверка кода на наличие уязвимостей при внедрении XAML @ no__t-0|При работе с ненадежными входными данными будьте учитывать атак путем внедрения кода XAML. XAML — это язык разметки, непосредственно представляющий создание и выполнение объекта. Это означает, что элементы, созданные в XAML, могут взаимодействовать с системными ресурсами (например, сетевым доступом и операциями ввода-вывода файловой системы).|
|@NO__T 0CA3011: Проверка кода на наличие уязвимостей при внедрении библиотеки DLL @ no__t-0|При работе с недоверенными входными данными будьте учитывать при загрузке ненадежного кода. Если веб-приложение загружает ненадежный код, злоумышленник может внедрить вредоносные библиотеки DLL в процесс и выполнить вредоносный код.|
|@NO__T 0CA3012: Проверка кода на наличие уязвимостей введения регулярного выражения @ no__t-0|При работе с ненадежными входными данными будьте учитывать атак путем внедрения регулярных выражений. Злоумышленник может использовать внедрение Regex для злонамеренного изменения регулярного выражения, чтобы сделать регулярное выражение соответствующим, или сделать так, чтобы регулярное выражение использовало чрезмерное количество ПРОЦЕССОРов, что приводит к атаке типа "отказ в обслуживании".|
|@NO__T 0CA3061: Не добавлять схему по URL-адресу @ no__t-0|Не используйте небезопасную перегрузку метода Add, так как она может вызвать опасные внешние ссылки.|
|@NO__T 0CA3075: Небезопасная обработка DTD @ no__t-0|Если вы используете небезопасные экземпляры DTDProcessing или ссылаетесь на источники внешних сущностей, средство синтаксического анализа может принять недоверенные входные данные и раскрыть конфиденциальную информацию злоумышленникам.|
|@NO__T 0CA3076: Небезопасное выполнение скрипта XSLT @ no__t-0|При небезопасном выполнении XSLT в приложениях .NET обработчик может разрешить недоверенные ссылки URI, раскрывающие конфиденциальную информацию злоумышленникам, что приведет к атакам типа "отказ в обслуживании" и межсайтовым атакам.|
|@NO__T 0CA3077: Небезопасная обработка в конструкторе API, XML-документ и средство чтения текста XML @ no__t-0|При разработке API, производных от XMLDocument и XMLTextReader, обратите внимание на DtdProcessing. Использование небезопасных экземпляров DTDProcessing при ссылке на источники внешних сущностей или их разрешении, а также при задании небезопасных значений в XML может привести к раскрытию информации.|
|@NO__T 0CA3147: Помечайте обработчики команд с помощью ValidateAntiForgeryToken @ no__t-0|При проектировании контроллера MVC ASP.NET учитывать атаки с подделки межсайтовых запросов. Атака подделки межсайтовых запросов может отправить вредоносные запросы от пользователя, прошедшего проверку подлинности, на контроллер ASP.NET MVC.|
|[CA5122. Объявления P/Invoke не могут быть надежными с точки зрения безопасности](../code-quality/ca5122.md)|Методы отмечаются как SecuritySafeCritical, если они выполняют критически важные для безопасности операции и являются безопасными для использования в прозрачном коде. Прозрачный код может никогда не вызывать машинный код напрямую с помощью P/Invoke. Поэтому, если метод P/Invoke отметить как надежный с точки зрения безопасности, это не приведет к тому, что прозрачный код будет вызывать его, и может ввести в заблуждение при анализе безопасности.|
|@NO__T 0CA5361: Не отключайте использование стойкого шифрования SChannel @ no__t-0|Установка `Switch.System.Net.DontEnableSchUseStrongCrypto` в `true` ослабляет шифрование, используемое в исходящих подключениях протокола TLS. Более слабая криптография может нарушить конфиденциальность взаимодействия между приложением и сервером, что облегчит злоумышленникам еавесдроп конфиденциальные данные.|
|@NO__T 0CA5363: Не отключайте проверку запроса @ no__t-0|Проверка запросов — это функция в ASP.NET, которая проверяет HTTP-запросы и определяет, содержат ли они потенциально опасное содержимое, которое может привести к атакам путем внедрения, включая межсайтовые сценарии.|
|@NO__T 0CA5364: Не используйте устаревшие протоколы безопасности @ no__t-0|Протокол TLS обеспечивает безопасность взаимодействия между компьютерами, чаще всего с помощью протокола HTTPS. Более старые версии протокола TLS менее безопасны, чем TLS 1,2 и TLS 1,3, и, скорее всего, будут подвержены новые уязвимости. Избегайте более старых версий протокола, чтобы снизить риск.|
|@NO__T 0CA5369: Использовать XmlReader для десериализации @ no__t-0|Обработка ненадежных DTD и схем XML может разрешить загрузку опасных внешних ссылок, которые должны быть ограничены с помощью XmlReader с безопасным распознавателем или с отключенной обработкой встроенных схем DTD и XML.|
|@NO__T 0CA5370: Использование XmlReader для проверки модуля чтения @ no__t-0|Обработка ненадежных DTD и схем XML может разрешить загрузку опасных внешних ссылок. Эту опасную загрузку можно ограничить с помощью XmlReader с безопасным распознавателем или с отключенной обработкой встроенных схем DTD и XML.|
|@NO__T 0CA5371: Использовать XmlReader для чтения схемы @ no__t-0|Обработка ненадежных DTD и схем XML может разрешить загрузку опасных внешних ссылок. Использование XmlReader с безопасным распознавателем или с отключенной обработкой схемы DTD и XML с поддержкой встроенных схем позволяет ограничивать это.|
|@NO__T 0CA5372: Использование XmlReader для XPathDocument @ no__t-0|Обработка XML-кода из ненадежных данных может привести к загрузке опасных внешних ссылок, которые можно ограничить с помощью XmlReader с безопасным распознавателем или с отключенной обработкой DTD.|
|@NO__T 0CA5373: Не использовать устаревшую функцию формирования ключа @ no__t-0|Это правило обнаруживает вызов методов формирования неслабых ключей <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> и `Rfc2898DeriveBytes.CryptDeriveKey`. <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> использовал слабый алгоритм PBKDF1.|
|@NO__T 0CA5378: Не отключайте Сервицепоинтманажерсекуритипротоколс @ no__t-0|Установка `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` в `true` ограничивает подключения Windows Communication Framework (TLS) с использованием TLS 1,0. Эта версия TLS будет устаревшей.|
|@NO__T 0CA5380: Не добавлять сертификаты в корневое хранилище @ no__t-0|Это правило обнаруживает код, который добавляет сертификат в хранилище сертификатов доверенных корневых центров сертификации. По умолчанию хранилище сертификатов доверенных корневых центров сертификации настроено с набором общедоступных центров сертификации, удовлетворяющих требованиям программы корневых сертификатов Майкрософт.|
|@NO__T 0CA5381: Убедитесь, что сертификаты не добавлены в корневое хранилище @ no__t-0|Это правило обнаруживает код, который потенциально добавляет сертификат в хранилище сертификатов доверенных корневых центров сертификации. По умолчанию хранилище сертификатов доверенных корневых центров сертификации настроено с набором общедоступных центров сертификации (ЦС), удовлетворяющих требованиям программы корневых сертификатов Майкрософт.|
|@NO__T 0CA5386: Избегайте прописано Секуритипротоколтипе value @ no__t-0|Протокол TLS обеспечивает безопасность взаимодействия между компьютерами, чаще всего с помощью протокола HTTPS. Протоколы версии TLS 1,0 и TLS 1,1 являются устаревшими, а TLS 1,2 и TLS 1,3 являются актуальными. В будущем протоколы TLS 1,2 и TLS 1,3 могут быть устаревшими. Чтобы обеспечить безопасность приложения, не следует прописано версию протокола и нацелить по крайней мере .NET Framework v 4.7.1.|
|@NO__T 0CA5389: Не добавляйте путь к элементу архива в путь к целевой файловой системе @ no__t-0|Путь к файлу может быть относительным и может привести к доступу файловой системы за пределами ожидаемого целевого пути файловой системы, что приведет к изменению вредоносной настройки и удаленному выполнению кода с помощью метода компоновки и ожидания.|
|@NO__T 0CA5397: Не используйте устаревшие значения SslProtocols @ no__t-0|ранспорт Layer Security (TLS) обеспечивает безопасность взаимодействия между компьютерами, чаще всего с протоколом HTTPS. Более старые версии протокола TLS менее безопасны, чем TLS 1,2 и TLS 1,3, и, скорее всего, будут подвержены новые уязвимости. Избегайте более старых версий протокола, чтобы снизить риск.|
|@NO__T 0CA5398: Не используйте жестко закодированные значения SslProtocols @ no__t-0|Протокол TLS обеспечивает безопасность взаимодействия между компьютерами, чаще всего с помощью протокола HTTPS. Протоколы версии TLS 1,0 и TLS 1,1 являются устаревшими, а TLS 1,2 и TLS 1,3 являются актуальными. В будущем протоколы TLS 1,2 и TLS 1,3 могут быть устаревшими. Чтобы обеспечить безопасность приложения, Избегайте прописано версии протокола.|
