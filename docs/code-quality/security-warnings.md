---
title: Предупреждения безопасности
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security warnings
- managed code analysis warnings, security warnings
- warnings, security
ms.assetid: 60d4e8ea-230a-494f-aa6a-b91db77540e4
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 9b5a03c9cb7ae7c5a5c81bd452dbb04d8db4c09d
ms.sourcegitcommit: ed17ca9ae5f92c229c4e46233bcfe0a49d29ec43
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/10/2020
ms.locfileid: "88052626"
---
# <a name="security-warnings"></a>Предупреждения, связанные с безопасностью

Предупреждения безопасности поддерживают более безопасные библиотеки и приложения. Эти предупреждения помогают устранить уязвимости в программе. Если отключить любое из этих предупреждений, следует четко обозначить в коде причину этого отключения, а также оповестить сотрудника, отвечающего за безопасность проекта разработки.

## <a name="in-this-section"></a>Содержание раздела

|Правило|Описание|
|----------|-----------------|
|[CA2100. Проверьте запросы SQL на наличие уязвимостей системы безопасности](../code-quality/ca2100.md)|Метод задает свойство System.Data.IDbCommand.CommandText с использованием строки, созданной из строкового аргумента метода. Это правило предполагает, что строковый аргумент содержит введенные пользователем данные. Созданная из введенных пользователем данных командная строка SQL уязвима перед атаками путем внедрения кода SQL.|
|[CA2102. Перехватывайте исключения, не являющиеся CLSCompliant, с помощью общих обработчиков](../code-quality/ca2102.md)|Элемент в сборке, не помеченной атрибутом RuntimeCompatibilityAttribute или помеченной атрибутом RuntimeCompatibility(WrapNonExceptionThrows = false), содержит блок catch, который обрабатывает исключения System.Exception, однако непосредственно за этим блоком не следует общий блок catch.|
|[CA2103. Проверьте принудительную безопасность](../code-quality/ca2103.md)|Метод использует принудительную безопасность и может обеспечить создание разрешения с помощью сведений о состоянии или возвращаемых значений, которые могут измениться в период активности требования. Поэтому по возможности следует использовать декларативную безопасность.|
|[CA2104. Не объявляйте изменяющиеся ссылочные типы только для чтения](../code-quality/ca2104.md)|Видимый извне тип содержит видимое извне и доступное только для чтение поле, являющееся изменяемым ссылочным типом. Изменяемый тип — это тип, экземпляр которого может быть изменен.|
|[CA2105. Поля массивов не должны быть доступны только для чтения](../code-quality/ca2105.md)|При применении модификатора "только для чтения" (ReadOnly в Visual Basic) к полю, содержащему массив, это поле нельзя изменить, связав его с другим массивом. Однако элементы массива, хранящегося в доступном только для чтения поле, можно будет изменить.|
|[CA2106. Обеспечьте безопасность утверждений](../code-quality/ca2106.md)|Метод подтверждает разрешения без выполнения проверок безопасности для вызывающего объекта. Подтверждение разрешений безопасности без выполнения проверок безопасности может привести к возникновению в коде уязвимости системы безопасности, которой могут воспользоваться злоумышленники.|
|[CA2107. Проверьте использование Deny и Permit Only](../code-quality/ca2107.md)|С помощью методов PermitOnly и CodeAccessPermission. Deny действия безопасности следует использовать только те, которые имеют опыт работы с безопасностью .NET. Код, который использует эти действия безопасности, должен быть тщательно проанализирован на предмет безопасности.|
|[CA2108. Проверьте объявляемые параметры безопасности типов значений](../code-quality/ca2108.md)|Открытый или защищенный тип значения защищен средствами доступа к данным или требованиями ссылки.|
|[CA2109. Проверьте видимые обработчики событий](../code-quality/ca2109.md)|Обнаружен открытый или защищенный метод обработки событий. Методы обработки событий следует раскрывать только в тех случаях, когда это совершенно необходимо.|
|[CA2111. Указатели не должны быть видимыми](../code-quality/ca2111.md)|Указатель не является закрытым, внутренним или доступным только для чтения. Вредоносный код может изменить значение указателя, что приведет к предоставлению доступа к произвольным областям памяти или сбоям приложения или системы.|
|[CA2112. Защищенные типы не должны предоставлять поля](../code-quality/ca2112.md)|Открытый или защищенный тип содержит открытые поля и защищен требованиями ссылки. Если код имеет доступ к экземпляру типа, защищенного запросом компоновки, то для получения доступа к полям типа коду не требуется удовлетворять запросу компоновки.|
|[CA2114. Безопасность метода должна быть надмножеством типа](../code-quality/ca2114.md)|Метод не должен обладать декларативной безопасностью для одного и того же действия, как на уровне метода, так и на уровне типа.|
|[CA2115. Вызывайте GC.KeepAlive при использовании собственных ресурсов](../code-quality/ca2115.md)|Данное правило обнаруживает ошибки, которые могут возникать из-за завершения неуправляемых ресурсов, по-прежнему используемых в машинном коде.|
|[CA2116. APTCA-методы должны вызывать только APTCA-методы](../code-quality/ca2116.md)|Если в полностью доверенной сборке присутствует атрибут APTCA (AllowPartiallyTrustedCallers) и она выполняет код в другой сборке, для которой не разрешены частично доверенные вызовы, возможно возникновение уязвимости безопасности.|
|[CA2117. APTCA-типы должны расширять только базовые APTCA-типы](../code-quality/ca2117.md)|Если в полностью доверенной сборке присутствует атрибут APTCA (AllowPartiallyTrustedCallers), а тип в сборке унаследован от типа, для которого не разрешены частично доверенные вызовы, возможно возникновение уязвимости безопасности.|
|[CA2118. Проверьте использование атрибута SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2118.md)|Атрибут SuppressUnmanagedCodeSecurityAttribute изменяет поведение системы безопасности, определенное по умолчанию, для элементов, выполняющих неуправляемый код за счет COM-взаимодействия или вызова неуправляемого кода. Этот атрибут служит в основном для повышения производительности; однако, прирост производительности сопряжен со значительными рисками безопасности.|
|[CA2119. Запечатайте методы, соответствующие частным интерфейсам](../code-quality/ca2119.md)|Наследуемый открытый тип предоставляет реализацию переопределяемого метода внутреннего (Friend в Visual Basic) интерфейса. Для устранения нарушения данного правила следует исключить возможность переопределения метода за пределами сборки.|
|[CA2120. Обеспечьте безопасность конструкторов сериализации](../code-quality/ca2120.md)|Для этого типа предусмотрен конструктор, который принимает объекты System.Runtime.Serialization.SerializationInfo и System.Runtime.Serialization.StreamingContext (сигнатура конструктора сериализации). Этот конструктор не защищен проверкой безопасности, однако один или несколько обычных конструкторов этого типа защищены.|
|[CA2121. Статические конструкторы должны быть частными](../code-quality/ca2121.md)|Система вызывает статический конструктор перед созданием первого экземпляра типа или ссылкой на любые статические члены. Если статический конструктор не является закрытым, он может быть вызван кодом, находящимся за пределами системы. В зависимости от операций, выполняемых в конструкторе, это может стать причиной непредвиденного поведения|
|[CA2122. Не используйте косвенное представление методов с требованиями ссылки](../code-quality/ca2122.md)|У открытого или защищенного члена есть требования ссылки, и он вызывается членом, который не выполняет какие-либо проверки безопасности. Запрос компоновки проверяет разрешения только непосредственно вызывающего метода.|
|[CA2123. Переопределяющие требования ссылки должны быть идентичны базовым](../code-quality/ca2123.md)|Это правило сравнивает метод с его базовым методом (который является интерфейсом или виртуальным методом другого типа), а затем сравнивает запросы ссылок для каждого из них. Если это правило нарушается, то вредоносный вызывающий объект может обойти запрос ссылок путем вызова небезопасного метода.|
|[CA2124. Ограничьте уязвимые предложения finally во внешних блоках try](../code-quality/ca2124.md)|Открытый или защищенный метод содержит блок try/finally. Блок finally сбрасывает состояние безопасности и не заключен в блок finally.|
|[CA2126. Для требований ссылок на тип необходимы требования наследования](../code-quality/ca2126.md)|Открытый незапечатанный тип защищен требованием ссылки и имеет переопределяемый метод. Ни тип, ни метод не защищены требованием наследования.|
|[CA2130. Важные константы безопасности должны быть прозрачными](../code-quality/ca2130.md)|Принудительная прозрачность не применяется для постоянных значений, чтобы во время выполнения не требовалась подстановка значений. Константные поля должны быть прозрачными для системы безопасности, чтобы анализаторы кода не предполагали, что прозрачный для системы безопасности код не может получить доступ к константе.|
|[CA2131. Критические для безопасности типы не могут участвовать в эквивалентности типов](../code-quality/ca2131.md)|Тип участвует в эквивалентности типов, а либо сам тип, либо элемент или поле типа, помечается атрибутом атрибутом SecurityCriticalAttribute. Это правило применяется ко всем критическим типам или к типам, содержащим критические методы или поля, участвующие в эквивалентности типов. Когда среда CLR обнаруживает такой тип, она не загружает его и выдает исключение TypeLoadException во время выполнения. Обычно это правило срабатывает, только если пользователи реализуют эквивалентность типов вручную вместо того, чтобы позволить tlbimp и компиляторам обработать эквивалентность типов.|
|[CA2132. Конструкторы по умолчанию должны быть по меньшей мере такими же критическими, как конструкторы по умолчанию базового типа](../code-quality/ca2132.md)|Типы и члены с атрибутом SecurityCriticalAttribute не могут использоваться в коде приложений Silverlight. Критичные в плане безопасности типы и элементы могут использоваться только надежным кодом в среде .NET Framework для библиотеки классов Silverlight. Поскольку открытая или защищенная конструкция в производном классе должна иметь ту же или большую прозрачность, чем ее базовый класс, класс в приложении не может быть производным от класса, помеченного как SecurityCritical.|
|[CA2133. Делегаты должны быть привязаны к методам с соответствующей прозрачностью](../code-quality/ca2133.md)|Это предупреждение вызывается методом, который привязывает делегат, помеченный атрибутом SecurityCriticalAttribute, к методу, который является прозрачным или помечен атрибутом SecuritySafeCriticalAttribute. Предупреждение также запускает метод, который привязывает прозрачный или безопасный делегат к критическому методу.|
|[CA2134. Методы должны сохранять одинаковую прозрачность при переопределении базовых методов](../code-quality/ca2134.md)|Это правило применяется, когда метод, помеченный атрибутом SecurityCriticalAttribute, переопределяет прозрачный метод или метод, помеченный атрибутом SecuritySafeCriticalAttribute. Это правило также применяется, когда прозрачный метод или метод, помеченный атрибутом SecurityCriticalAttribute, переопределяет метод, помеченный атрибутом SecuritySafeCriticalAttribute. Это правило применяется при переопределении виртуального метода или реализации интерфейса.|
|[CA2135. Сборки уровня 2 не должны содержать LinkDemands](../code-quality/ca2135.md)|Требования LinkDemand являются устаревшими в наборе правил безопасности уровня 2. Вместо использования требования LinkDemand для обеспечения безопасности во время JIT-компиляции пометьте методы, типы и поля атрибутом SecurityCriticalAttribute.|
|[CA2136. Члены не должны иметь противоречащие заметки прозрачности](../code-quality/ca2136.md)|Атрибуты прозрачности применяются из элементов кода большей области к элементам меньшей области. Атрибуты прозрачности элементов кода с большей областью имеют приоритет по сравнению с атрибутами прозрачности элементов кода, которые содержатся в первом элементе. Например, класс, помеченный атрибутом SecurityCriticalAttribute, не может содержать метод, помеченный атрибутом SecuritySafeCriticalAttribute.|
|[CA2137. Прозрачные методы должны содержать только поддающийся проверке промежуточный язык](../code-quality/ca2137.md)|Метод содержит непроверяемый код или возвращает тип по ссылке. Это правило срабатывает при попытках прозрачного кода безопасности выполнить непроверяемый MSIL. Однако это правило не содержит полную проверку IL, и вместо нее использует эвристику для выявления большинства нарушений проверки MSIL.|
|[CA2138. Прозрачные методы не должны вызывать методы с атрибутом SuppressUnmanagedCodeSecurity](../code-quality/ca2138.md)|Прозрачный с точки зрения безопасности метод вызывает метод, помеченный атрибутом SuppressUnmanagedCodeSecurityAttribute.|
|[CA2139. Прозрачные методы могут не использовать атрибут HandleProcessCorruptingExceptions](../code-quality/ca2139.md)|Это правило срабатывает для любого прозрачного метода и пытается обработать поврежденное исключение с помощью атрибута HandleProcessCorruptedStateExceptionsAttribute. Исключение, приводящее к повреждению процесса, представляет собой классификацию исключения CLR версии 4,0 исключений, таких как <xref:System.AccessViolationException> . Атрибут HandleProcessCorruptedStateExceptionsAttribute может использоваться только критичными в плане безопасности методами и будет игнорироваться при применении для прозрачного метода.|
|[CA2140. Прозрачный код не должен ссылаться на критические для безопасности элементы](../code-quality/ca2140.md)|Методы, помеченные атрибутом SecurityTransparentAttribute, вызывают закрытые элементы, помеченные как SecurityCritical. Это правило анализирует все методы и типы в сборке, которая является смешанной прозрачной и критической, и помечает все вызовы из прозрачного кода в неоткрытый критически важный код, не помеченный как SecurityTreatAsSafe.|
|[CA2141: прозрачные методы не должны удовлетворять требования LinkDemand](../code-quality/ca2141.md)|Прозрачный с точки зрения безопасности метод вызывает метод в сборке, не помеченной атрибутом AllowPartiallyTrustedCallersAttribute (APTCA), либо прозрачный с точки зрения безопасности метод удовлетворяет требованию LinkDemand по типу или методу.|
|[CA2142. Прозрачный код не должен быть защищен проверками LinkDemands](../code-quality/ca2142.md)|Это правило срабатывает для прозрачных методов, для доступа к которым требуется LinkDemand. Прозрачный для системы безопасности код не должен отвечать за проверку безопасности операции и поэтому не должен требовать разрешений.|
|[CA2143. Прозрачные методы не должны использовать требования безопасности](../code-quality/ca2143.md)|Прозрачный для системы безопасности код не должен отвечать за проверку безопасности операции и поэтому не должен требовать разрешений. Прозрачный для системы безопасности код должен использовать полные требования для принятия решений по безопасности, и критичный в плане безопасности код не должен полагаться на прозрачный код, чтобы создать полное требование.|
|[CA2144. Прозрачный код не должен выполнять загрузку сборок из массивов байтов](../code-quality/ca2144.md)|Проверка безопасности для прозрачного кода не так тщательна, как проверка безопасности для критического кода, поскольку прозрачный код не может выполнять действия, требующие особых мер безопасности. Сборки, загруженные из массива байтов, могут остаться незамеченными в прозрачном коде, и этот массив байтов может содержать критичный или, что более важно, критичный в плане безопасности код, который подлежит аудиту.|
|[CA2145. Прозрачные методы не должны быть отмечены атрибутом SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2145.md)|Методы, оснащенные атрибутом SuppressUnmanagedCodeSecurityAttribute, имеют неявную проверку LinkDemand, применяемую к любому вызывающему их методу. Для этой проверки LinkDemand требуется, чтобы вызывающий код был критическим с точки зрения безопасности. Пометка метода, который использует SuppressUnmanagedCodeSecurity с атрибутом SecurityCriticalAttribute, делает это требование более очевидным для тех, кто вызывает этот метод.|
|[CA2146. Типы должны быть по крайней мере настолько же критическими, как их базовые типы и интерфейсы](../code-quality/ca2146.md)|Это правило срабатывает, если у производного типа есть атрибут прозрачности безопасности, не такой критический, как базовый тип или реализованный интерфейс. От критических базовых типов или реализованных критических интерфейсов могут производиться только критические типы, и от критических в плане безопасности базовых типов или реализованных интерфейсов могут производиться только критические в плане безопасности типы.|
|[CA2147. Прозрачные методы могут не использовать утверждения безопасности](../code-quality/ca2147.md)|Это правило позволяет проанализировать все методы и типы в сборке, которая является либо на 100% прозрачной, либо смешанной (прозрачной и критической), и пометить декларативное и императивное использование Assert.|
|[CA2149. Прозрачные методы не должны вызывать машинный код](../code-quality/ca2149.md)|Это правило срабатывает для любого прозрачного метода, который вызывает непосредственно в машинный код, например с помощью P/Invoke. Нарушение этого правила приводит к исключению MethodAccessException на уровне 2 модели прозрачности и вызову полного требования UnmanagedCode на уровне 1 модели прозрачности.|
|[CA2151. Поля с критическими типами должны быть критическими с точки зрения безопасности](../code-quality/ca2151.md)|Для использования критических с точки зрения безопасности типов код, который ссылается на тип, должен быть либо критическим с точки зрения безопасности, либо надежным с точки зрения безопасности. Это верно даже в случае косвенной ссылки. Поэтому применять прозрачное для безопасности поле или поле, надежное с точки зрения безопасности, не рекомендуется, поскольку прозрачный код по-прежнему не сможет получить доступ к полю.|
|[CA2153. Не используйте обработку исключений поврежденного состояния](../code-quality/ca2153.md)|[Исключения сбоя состояния (CSE)](https://msdn.microsoft.com/magazine/dd419661.aspx) указывают на то, что в процессе имеется повреждение памяти. Если перехватывать их вместо того, чтобы позволить процессу завершиться сбоем, это может привести к уязвимостям в системе безопасности, если злоумышленнику удастся поместить эксплойт в поврежденную область памяти.|
|[CA2300. Не используйте небезопасный десериализатор BinaryFormatter](../code-quality/ca2300.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2301. Не вызывайте BinaryFormatter.Deserialize, не задав предварительно BinaryFormatter.Binder](../code-quality/ca2301.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2302. Убедитесь, что BinaryFormatter.Binder задан перед вызовом BinaryFormatter.Deserialize](../code-quality/ca2302.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2305. Не используйте небезопасный десериализатор LosFormatter](../code-quality/ca2305.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2310. Не используйте небезопасный десериализатор NetDataContractSerializer](../code-quality/ca2310.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2311. Не десериализируйте, не задав предварительно NetDataContractSerializer.Binder](../code-quality/ca2311.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2312. Убедитесь, что NetDataContractSerializer.Binder задан перед десериализацией](../code-quality/ca2312.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2315. Не используйте небезопасный десериализатор ObjectStateFormatter](../code-quality/ca2315.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2321. Не десериализируйте с помощью JavaScriptSerializer, используя SimpleTypeResolver](../code-quality/ca2321.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2322. Убедитесь, что JavaScriptSerializer не был инициализирован с помощью SimpleTypeResolver до десериализации](../code-quality/ca2322.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2326. Не используйте значения TypeNameHandling, отличные от None](../code-quality/ca2326.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2327. Не используйте небезопасные JsonSerializerSettings](../code-quality/ca2327.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2328. Убедитесь в безопасности JsonSerializerSettings](../code-quality/ca2328.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2329. Не выполняйте десериализацию с помощью JsonSerializer, используя небезопасную конфигурацию](../code-quality/ca2329.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2330. Убедитесь, что в JsonSerializer есть безопасная конфигурация при десериализации](../code-quality/ca2330.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные, чтобы включить непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2350. Убедитесь, что входные данные DataTable.ReadXml() являются доверенными](ca2350.md)|При десериализации <xref:System.Data.DataTable> с ненадежными входными данными злоумышленник может создавать вредоносные входные данные для атаки типа "отказ в обслуживании". Могут возникнуть неизвестные уязвимости удаленного выполнения кода.|
|[CA2351. Убедитесь, что входные данные DataSet.ReadXml() являются доверенными](ca2351.md)|При десериализации <xref:System.Data.DataSet> с ненадежными входными данными злоумышленник может создавать вредоносные входные данные для атаки типа "отказ в обслуживании". Могут возникнуть неизвестные уязвимости удаленного выполнения кода.|
|[CA2352. Ненадежные данные DataSet или DataTable в сериализуемом типе могут быть уязвимыми для атак удаленного выполнения кода](ca2352.md)|Класс или структура, помеченная как, <xref:System.SerializableAttribute> содержит <xref:System.Data.DataSet> <xref:System.Data.DataTable> поле или или свойство, и не имеет <xref:System.CodeDom.Compiler.GeneratedCodeAttribute> .|
|[CA2353. Ненадежные данные DataSet или DataTable в сериализуемом типе](ca2353.md)|Класс или структура, помеченная атрибутом сериализации XML или атрибутом контракта данных, содержит <xref:System.Data.DataSet> <xref:System.Data.DataTable> поле или или свойство.|
|[CA2354. Ненадежные данные DataSet или DataTable в графе десериализованных объектов могут быть уязвимыми для атаки удаленного выполнения кода](ca2354.md)|Десериализация с помощью <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> сериализованного объекта, а граф объектов приведенного типа может включать <xref:System.Data.DataSet> или <xref:System.Data.DataTable> .|
|[CA2355. Ненадежные данные DataSet или DataTable в графе десериализованных объектов](ca2355.md)|Десериализация, когда граф объектов приведенного или указанного типа может включать <xref:System.Data.DataSet> или <xref:System.Data.DataTable> .|
|[CA2356: ненадежный набор данных или DataTable в графе веб-десериализованных объектов](ca2356.md)|Метод с <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> или <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> имеет параметр, который может ссылаться на <xref:System.Data.DataSet> или <xref:System.Data.DataTable> .|
|[CA2361: Убедитесь, что автоматически сформированный класс содержит DataSet. ReadXml () не используется с ненадежными данными](ca2361.md)|При десериализации <xref:System.Data.DataSet> с ненадежными входными данными злоумышленник может создавать вредоносные входные данные для атаки типа "отказ в обслуживании". Могут возникнуть неизвестные уязвимости удаленного выполнения кода.|
|[CA2362: ненадежный набор данных или DataTable в автоматически созданном сериализуемым типе может быть уязвим для атак удаленного выполнения кода](ca2362.md)|При десериализации ненадежных входных данных с <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> и граф десериализованных объектов содержит <xref:System.Data.DataSet> или <xref:System.Data.DataTable> , злоумышленник может создавать вредоносные полезные данные для выполнения атаки удаленного выполнения кода.|
|[CA3001. Проверьте код на наличие уязвимостей к внедрению кода SQL](../code-quality/ca3001.md)|При работе с ненадежными входными и командными командами SQL учитывать атак путем внедрения кода SQL. Атака путем внедрения кода SQL может выполнять вредоносные команды SQL, нарушая безопасность и целостность приложения.|
|[CA3002. Проверьте код на наличие уязвимостей к межсайтовым сценариям (XSS)](../code-quality/ca3002.md)|При работе с ненадежными входными данными из веб-запросов следует учитывать атаки с использованием межсайтовых сценариев (XSS). Атака XSS внедряет недоверенные входные данные в необработанные выходные данные HTML, позволяя злоумышленникам выполнять вредоносные сценарии или вредоносно изменять содержимое на веб-странице.|
|[CA3003. Проверьте код на наличие уязвимостей к внедрению пути к файлу](../code-quality/ca3003.md)|При работе с ненадежными входными данными из веб-запросов будьте учитывать, используя управляемые пользователем входные данные при указании путей к файлам.|
|[CA3004. Проверьте код на наличие уязвимостей к раскрытию информации](../code-quality/ca3004.md)|Раскрытие сведений об исключениях дает злоумышленникам сведения о внутренних компонентах приложения, которые могут помочь злоумышленникам найти другие уязвимости для использования.|
|[CA3006. Проверьте код на наличие уязвимостей к внедрению команд процесса](../code-quality/ca3006.md)|При работе с ненадежными входными данными будьте учитывать атак путем внедрения команд. Атака путем внедрения команды может выполнять вредоносные команды в базовой операционной системе, нарушая безопасность и целостность сервера.|
|[CA3007. Проверьте код на наличие уязвимостей к открытому перенаправлению](../code-quality/ca3007.md)|При работе с недоверенными входными данными будьте учитывать уязвимости открытых перенаправлений. Злоумышленник может воспользоваться уязвимостью с открытым перенаправлением, чтобы использовать веб-сайт для получения правильного URL-адреса, но перенаправить нежелательный посетитель на фишинг или другую вредоносную веб-страницу.|
|[CA3008. Проверьте код на наличие уязвимостей к внедрению кода XPath](../code-quality/ca3008.md)|При работе с недоверенными входными данными будьте учитывать атак путем внедрения XPath. Создание запросов XPath с использованием ненадежных входных данных может позволить злоумышленнику злонамеренно манипулировать запросом для возврата непредвиденного результата и, возможно, раскрывать содержимое запрашиваемого XML.|
|[CA3009. Проверьте код на наличие уязвимостей к внедрению кода XML](../code-quality/ca3009.md)|При работе с ненадежными входными данными учитывать атак путем внедрения кода XML.|
|[CA3010. Проверьте код на наличие уязвимостей к внедрению кода XAML](../code-quality/ca3010.md)|При работе с ненадежными входными данными будьте учитывать атак путем внедрения кода XAML. XAML — это язык разметки, непосредственно представляющий создание и выполнение объекта. Это означает, что элементы, созданные в XAML, могут взаимодействовать с системными ресурсами (например, сетевым доступом и операциями ввода-вывода файловой системы).|
|[CA3011. Проверьте код на наличие уязвимостей к внедрению DLL](../code-quality/ca3011.md)|При работе с недоверенными входными данными будьте учитывать при загрузке ненадежного кода. Если веб-приложение загружает ненадежный код, злоумышленник может внедрить вредоносные библиотеки DLL в процесс и выполнить вредоносный код.|
|[CA3012. Проверьте код на наличие уязвимостей к внедрению регулярных выражений](../code-quality/ca3012.md)|При работе с ненадежными входными данными будьте учитывать атак путем внедрения регулярных выражений. Злоумышленник может использовать внедрение Regex для злонамеренного изменения регулярного выражения, чтобы сделать регулярное выражение соответствующим, или сделать так, чтобы регулярное выражение использовало чрезмерное количество ПРОЦЕССОРов, что приводит к атаке типа "отказ в обслуживании".|
|[CA3061. Не добавлять схему по URL-адресу](../code-quality/ca3061.md)|Не используйте небезопасную перегрузку метода Add, так как она может вызвать опасные внешние ссылки.|
|[CA3075. Обработка небезопасных DTD](../code-quality/ca3075.md)|Если вы используете небезопасные экземпляры DTDProcessing или ссылаетесь на источники внешних сущностей, средство синтаксического анализа может принять недоверенные входные данные и раскрыть конфиденциальную информацию злоумышленникам.|
|[CA3076. Выполнение небезопасного скрипта XSLT](../code-quality/ca3076.md)|При небезопасном выполнении XSLT в приложениях .NET процессор может разрешить ненадежные ссылки URI, которые могут раскрыть конфиденциальную информацию злоумышленникам, что приведет к атакам типа "отказ в обслуживании" и межсайтовые атаки.|
|[CA3077. Небезопасная обработка в структуре API средств чтения документов и текста XML](../code-quality/ca3077.md)|При разработке API, производных от XMLDocument и XMLTextReader, обратите внимание на DtdProcessing. Использование небезопасных экземпляров DTDProcessing при ссылке на источники внешних сущностей или их разрешении, а также при задании небезопасных значений в XML может привести к раскрытию информации.|
|[CA3147. Присвоение метки ValidateAntiForgeryToken обработчикам команд](../code-quality/ca3147.md)|При проектировании контроллера MVC ASP.NET учитывать атаки с подделки межсайтовых запросов. Атака подделки межсайтовых запросов может отправить вредоносные запросы от пользователя, прошедшего проверку подлинности, на контроллер ASP.NET MVC.|
|[Объявления CA5122 P/Invoke не должны быть безопасными](../code-quality/ca5122.md)|Методы отмечаются как SecuritySafeCritical, если они выполняют критически важные для безопасности операции и являются безопасными для использования в прозрачном коде. Прозрачный код может никогда не вызывать машинный код напрямую с помощью P/Invoke. Поэтому, если метод P/Invoke отметить как надежный с точки зрения безопасности, это не приведет к тому, что прозрачный код будет вызывать его, и может ввести в заблуждение при анализе безопасности.|
|[CA5359: не отключайте проверку сертификатов](../code-quality/ca5359.md)|Сертификат может помочь при проверке подлинности удостоверения сервера. Клиенты должны проверить сертификат сервера, чтобы обеспечить отправку запросов на предполагаемый сервер. Если ServerCertificateValidationCallback всегда возвращает значение `true` , любой сертификат будет проходить проверку.|
|[CA5360: не вызывайте опасные методы десериализации](../code-quality/ca5360.md)|Небезопасная десериализация — это уязвимость, которая возникает, когда ненадежные данные используются для нарушения логики приложения, наноситься атаки типа "отказ в обслуживании" или даже для выполнения произвольного кода после десериализации. Пользователям-злоумышленникам часто могут быть нарушены эти функции десериализации, когда приложение десериализует ненадежные данные, которые находятся под их контролем. В частности, следует вызывать опасные методы в процессе десериализации. Успешная атака небезопасной десериализации может позволить злоумышленнику выполнять атаки, такие как атаки DoS, обход проверки подлинности и удаленный запуск программного кода.|
|[CA5361. Не отключайте стойкое шифрование в защищенном канале](../code-quality/ca5361.md)|Параметр `Switch.System.Net.DontEnableSchUseStrongCrypto` , чтобы `true` ослабить шифрование, используемое в исходящих подключениях протокола TLS. Более слабая криптография может нарушить конфиденциальность взаимодействия между приложением и сервером, что облегчит злоумышленникам еавесдроп конфиденциальные данные.|
|[CA5362: потенциальный цикл ссылок в графе десериализованных объектов](../code-quality/ca5362.md)|При десериализации ненадежных данных любой код, обрабатывающий десериализованный граф объекта, должен обрабатывать циклы ссылок без перехода в бесконечные циклы. Это включает в себя код, который является частью обратного вызова десериализации, и код, обрабатывающий граф объекта после завершения десериализации. В противном случае злоумышленник может выполнить атаку типа "отказ в обслуживании" с вредоносными данными, содержащими цикл ссылок.|
|[CA5363. Не отключать проверку запросов](../code-quality/ca5363.md)|Проверка запросов — это функция в ASP.NET, которая проверяет HTTP-запросы и определяет, содержат ли они потенциально опасное содержимое, которое может привести к атакам путем внедрения, включая межсайтовые сценарии.|
|[CA5364. Не используйте нерекомендуемые протоколы безопасности](../code-quality/ca5364.md)|Протокол TLS обеспечивает безопасность взаимодействия между компьютерами, чаще всего с помощью протокола HTTPS. Более старые версии протокола TLS менее безопасны, чем TLS 1,2 и TLS 1,3, и, скорее всего, будут подвержены новые уязвимости. Избегайте более старых версий протокола, чтобы снизить риск.|
|[CA5365: не отключайте проверку заголовков HTTP](../code-quality/ca5365.md)|Проверка HTTP-заголовка позволяет кодировать символы возврата каретки и новой строки, \r и \n, которые находятся в заголовках ответа. Эта кодировка позволяет избежать атак путем внедрения, которые используют приложение, которое выводит недоверенные данные, содержащиеся в заголовке.|
|[CA5366: используйте XmlReader для чтения XML из набора данных](../code-quality/ca5366.md)|При использовании <xref:System.Data.DataSet> для чтения XML с ненадежными данными могут загружаться опасные внешние ссылки, которые должны быть ограничены с помощью <xref:System.Xml.XmlReader> защищенного распознавателя или с отключенной обработкой DTD.|
|[CA5367: не сериализуйте типы с полями указателей](../code-quality/ca5367.md)|Это правило проверяет, существует ли сериализуемый класс с полем указателя или свойством. Элементы, которые не могут быть сериализованы, могут быть указателями, такими как статические члены или поля, помеченные атрибутом <xref:System.NonSerializedAttribute> .|
|[CA5368: задайте ViewStateUserKey для классов, производных от Page](../code-quality/ca5368.md)|Задание <xref:System.Web.UI.Page.ViewStateUserKey> свойства может помочь предотвратить атаки на приложение, позволяя назначить идентификатор переменной состояния представления для отдельных пользователей, чтобы злоумышленники не могли использовать эту переменную для создания атаки. В противном случае будут обнаружены уязвимости подделки запросов между сайтами.|
|[CA5369. Использование XmlReader для десериализации](../code-quality/ca5369.md)|Обработка ненадежных DTD и схем XML может разрешить загрузку опасных внешних ссылок, которые должны быть ограничены с помощью XmlReader с безопасным распознавателем или с отключенной обработкой встроенных схем DTD и XML.|
|[CA5370. Использование XmlReader для проверки модуля чтения](../code-quality/ca5370.md)|Обработка ненадежных DTD и схем XML может разрешить загрузку опасных внешних ссылок. Эту опасную загрузку можно ограничить с помощью XmlReader с безопасным распознавателем или с отключенной обработкой встроенных схем DTD и XML.|
|[CA5371. Использование XmlReader для чтения схемы](../code-quality/ca5371.md)|Обработка ненадежных DTD и схем XML может разрешить загрузку опасных внешних ссылок. Использование XmlReader с безопасным распознавателем или с отключенной обработкой схемы DTD и XML с поддержкой встроенных схем позволяет ограничивать это.|
|[CA5372. Использование XmlReader для XPathDocument](../code-quality/ca5372.md)|Обработка XML-кода из ненадежных данных может привести к загрузке опасных внешних ссылок, которые можно ограничить с помощью XmlReader с безопасным распознавателем или с отключенной обработкой DTD.|
|[CA5373. Не использовать устаревшую функцию формирования ключа](../code-quality/ca5373.md)|Это правило обнаруживает вызов методов формирования неслабых ключей <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> и `Rfc2898DeriveBytes.CryptDeriveKey` . <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName>использовал слабый алгоритм PBKDF1.|
|[CA5374: не используйте XslTransform](../code-quality/ca5374.md)|Это правило проверяет <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> , создан ли экземпляр в коде. <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType>теперь является устаревшим и не должен использоваться.|
|[CA5375: не используйте подписанный URL-адрес учетной записи](../code-quality/ca5375.md)|SAS учетной записи может делегировать доступ к операциям чтения, записи и удаления в контейнерах больших двоичных объектов, таблицах, очередях и общих файловых ресурсах, которые не разрешены с помощью SAS службы. Однако он не поддерживает политики уровня контейнера и обладает меньшей гибкостью и контролирует предоставляемые разрешения. После получения вредоносных пользователей ваша учетная запись хранения будет легко скомпрометирована.|
|[CA5376: используйте SharedAccessProtocol HttpsOnly](../code-quality/ca5376.md)|SAS — это конфиденциальные данные, которые нельзя переносить в виде обычного текста по протоколу HTTP.|
|[CA5377: используйте политику доступа на уровне контейнера](../code-quality/ca5377.md)|Политику доступа на уровне контейнера можно изменить или отозвать в любое время. Он обеспечивает большую гибкость и контроль над предоставляемыми разрешениями.|
|[CA5378. Не отключайте ServicePointManagerSecurityProtocols](../code-quality/ca5378.md)|Параметр `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` для `true` ограничения соединений (TLS) Windows Communication Framework с использованием TLS 1,0. Эта версия TLS будет устаревшей.|
|[CA5379: не используйте слабый алгоритм функции формирования ключа](../code-quality/ca5379.md)|<xref:System.Security.Cryptography.Rfc2898DeriveBytes>Класс по умолчанию использует <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> алгоритм. Необходимо указать хэш-алгоритм для использования в некоторых перегрузках конструктора с <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> или выше. Обратите внимание, что <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> свойство имеет только `get` метод доступа и не имеет `overriden` модификатора.|
|[CA5380. Не добавлять сертификаты в корневое хранилище](../code-quality/ca5380.md)|Это правило обнаруживает код, который добавляет сертификат в хранилище сертификатов доверенных корневых центров сертификации. По умолчанию хранилище сертификатов доверенных корневых центров сертификации настроено с набором общедоступных центров сертификации, удовлетворяющих требованиям программы корневых сертификатов Майкрософт.|
|[CA5381. Убедиться, что сертификаты не добавлены в корневое хранилище](../code-quality/ca5381.md)|Это правило обнаруживает код, который потенциально добавляет сертификат в хранилище сертификатов доверенных корневых центров сертификации. По умолчанию хранилище сертификатов доверенных корневых центров сертификации настроено с набором общедоступных центров сертификации (ЦС), удовлетворяющих требованиям программы корневых сертификатов Майкрософт.|
|[CA5382: используйте защищенные файлы cookie в ASP.NET Core](../code-quality/ca5382.md)|Приложения, доступные по протоколу HTTPS, должны использовать защищенные файлы cookie, которые указывают браузеру, что файл cookie следует передавать только с помощью протокола TLS.|
|[CA5383: убедитесь в использовании защищенных файлов cookie в ASP.NET Core](../code-quality/ca5383.md)|Приложения, доступные по протоколу HTTPS, должны использовать защищенные файлы cookie, которые указывают браузеру, что файл cookie следует передавать только с помощью протокола TLS.|
|[CA5384: не используйте алгоритм DSA](../code-quality/ca5384.md)|DSA — это алгоритм слабого асимметричного шифрования.|
|[CA5385: используйте алгоритм шифрования RSA с достаточным размером ключа](../code-quality/ca5385.md)|Ключ RSA, размер которого меньше 2048 бит, более уязвим для атак методом подбора.|
|[CA5386. Не встраивайте значение SecurityProtocolType](../code-quality/ca5386.md)|Протокол TLS обеспечивает безопасность взаимодействия между компьютерами, чаще всего с помощью протокола HTTPS. Протоколы версии TLS 1,0 и TLS 1,1 являются устаревшими, а TLS 1,2 и TLS 1,3 являются актуальными. В будущем протоколы TLS 1,2 и TLS 1,3 могут быть устаревшими. Чтобы обеспечить безопасность приложения, не следует прописано версию протокола и нацелить по крайней мере .NET Framework v 4.7.1.|
|[CA5387: не используйте ненадежную функцию формирования ключа с недостаточным числом итераций](../code-quality/ca5387.md)|Это правило проверяет, был ли криптографический ключ создан <xref:System.Security.Cryptography.Rfc2898DeriveBytes> с числом итераций менее 100 000. Более высокие числа итераций могут помочь в предотвращении атак из словарей, которые пытаются угадать созданный криптографический ключ.|
|[CA5388: обеспечьте достаточное число итераций при использовании ненадежной функции формирования ключа](../code-quality/ca5388.md)|Это правило проверяет, был ли криптографический ключ создан <xref:System.Security.Cryptography.Rfc2898DeriveBytes> с числом итераций, которое может быть меньше 100 000. Более высокие числа итераций могут помочь в предотвращении атак из словарей, которые пытаются угадать созданный криптографический ключ.|
|[CA5389. Не добавлять путь к элементу архива в путь целевой файловой системы](../code-quality/ca5389.md)|Путь к файлу может быть относительным и может привести к доступу файловой системы за пределами ожидаемого целевого пути файловой системы, что приведет к изменению вредоносной настройки и удаленному выполнению кода с помощью метода компоновки и ожидания.|
|[CA5390: не используйте жестко заданный ключ шифрования](../code-quality/ca5390.md)|Для успешного выполнения симметричного алгоритма секретный ключ должен быть известен только отправителю и получателю. Если ключ жестко закодирован, его легко обнаружить. Даже при использовании скомпилированных двоичных файлов пользователи-злоумышленники могут легко их извлечь. После компрометации закрытого ключа текст шифра может быть расшифрован напрямую и больше не защищен.|
|[CA5391: используйте маркеры защиты от подделки в контроллерах MVC ASP.NET Core](../code-quality/ca5391.md)|Обработка `POST` запроса, `PUT` , `PATCH` или `DELETE` без проверки маркера подделки может быть уязвима для атак с подделкой межсайтовых запросов. Атака подделки межсайтовых запросов может отправить вредоносные запросы от пользователя, прошедшего проверку подлинности, на ASP.NET Core контроллер MVC.|
|[CA5392: используйте атрибут DefaultDllImportSearchPaths для методов P/Invoke](../code-quality/ca5392.md)|По умолчанию функции P/Invoke используют <xref:System.Runtime.InteropServices.DllImportAttribute> пробу нескольких каталогов, включая текущий рабочий каталог для загрузки библиотеки. Это может быть проблемой безопасности для некоторых приложений, что приводит к захвату библиотек DLL.|
|[CA5393: не используйте небезопасное значение DllImportSearchPath](../code-quality/ca5393.md)|В каталогах поиска DLL по умолчанию и каталогах сборок может быть вредоносная библиотека DLL. Или, в зависимости от места запуска приложения, в каталоге приложения может быть вредоносная библиотека DLL.|
|[CA5394: не используйте небезопасные генераторы случайных чисел](../code-quality/ca5394.md)|Использование криптографического слабого генератора случайных чисел может позволить злоумышленнику предсказать, какое значение с учетом безопасности будет создано.|
|[CA5395: отсутствует атрибут HttpVerb для методов действия](../code-quality/ca5395.md)|Все методы действий, которые создают, изменяют, удаляют или иным образом изменяют данные, должны быть защищены с помощью атрибута защиты от подделки запросов между сайтами. Операция GET должна быть защищенной операцией, которая не имеет побочных эффектов и не изменяет сохраненные данные.|
|[CA5396: установите для параметра HttpOnly объекта HttpCookie значение true](../code-quality/ca5396.md)|В качестве меры глубокой защиты убедитесь, что файлы cookie HTTP с защитой безопасности помечены как HttpOnly. Это означает, что веб-браузеры не должны запрещать скриптам доступ к файлам cookie. Внедренные вредоносные сценарии — это распространенный способ кражи файлов cookie.|
|[CA5397. Не используйте нерекомендуемые значения SslProtocols](../code-quality/ca5397.md)|Протокол TLS обеспечивает безопасность взаимодействия между компьютерами, чаще всего с помощью протокола HTTPS. Более старые версии протокола TLS менее безопасны, чем TLS 1,2 и TLS 1,3, и, скорее всего, будут подвержены новые уязвимости. Избегайте более старых версий протокола, чтобы снизить риск.|
|[CA5398. Избегайте жестко зафиксированных значений SslProtocols](../code-quality/ca5398.md)|Протокол TLS обеспечивает безопасность взаимодействия между компьютерами, чаще всего с помощью протокола HTTPS. Протоколы версии TLS 1,0 и TLS 1,1 являются устаревшими, а TLS 1,2 и TLS 1,3 являются актуальными. В будущем протоколы TLS 1,2 и TLS 1,3 могут быть устаревшими. Чтобы обеспечить безопасность приложения, Избегайте прописано версии протокола.|
|[CA5399: явно отключите проверку списка отзыва сертификатов HttpClient](../code-quality/ca5399.md)|Отозванный сертификат больше не является доверенным. Она может использоваться злоумышленниками для передачи вредоносных данных или кражи конфиденциальных данных при взаимодействии по протоколу HTTPS.|
|[CA5400: убедитесь, что проверка списка отзыва сертификатов HttpClient не отключена](../code-quality/ca5400.md)|Отозванный сертификат больше не является доверенным. Она может использоваться злоумышленниками для передачи вредоносных данных или кражи конфиденциальных данных при взаимодействии по протоколу HTTPS.|
|[CA5401: не используйте CreateEncryptor с вектором инициализации, отличным от значения по умолчанию](../code-quality/ca5401.md)|Для предотвращения атак с использованием словаря симметричное шифрование всегда должно использовать неповторяемый вектор инициализации.|
|[CA5402: используйте CreateEncryptor с вектором инициализации по умолчанию](../code-quality/ca5402.md)|Для предотвращения атак с использованием словаря симметричное шифрование всегда должно использовать неповторяемый вектор инициализации.|
