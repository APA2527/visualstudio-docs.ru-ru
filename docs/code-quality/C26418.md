---
title: C26418 | Документация Майкрософт
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26418
helpviewer_keywords:
- C26418
ms.assetid: d2c84a40-8a5d-4018-92c2-6498cdd9b541
author: corob-msft
ms.author: corob
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 12582069cefc1a3fb956726d054a33f63310c41e
ms.sourcegitcommit: 68f893f6e472df46f323db34a13a7034dccad25a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/15/2020
ms.locfileid: "77260806"
---
# <a name="c26418-no_value_or_const_ref_shared_ptr"></a>C26418 NO_VALUE_OR_CONST_REF_SHARED_PTR
"Параметр общего указателя не копируется или не перемещается. Вместо этого используйте T * или T & ".

Основные рекомендации: R. 36. получение const shared_ptr\<мини-приложения > & параметр, чтобы выразить, что он может хранить счетчик ссылок на объект **C++**

Если параметр общего указателя передается по значению или ссылке на постоянный объект, то ожидается, что функция будет управлять временем существования целевого объекта, не влияя на вызывающий объект. Код должен либо скопировать, либо переместить параметр общего указателя в другой объект общего указателя или передать его дальше другому коду, вызвав функции, которые принимают общие указатели. Если это не так, то может быть целесообразным простой указатель или ссылка.

## <a name="remarks"></a>Примечания
- Эта проверка распознает std:: shared_pointer и определяемые пользователем типы, которые, скорее всего, ведут себя как общие указатели. Для определяемых пользователем общих указателей требуются следующие признаки:
- перегруженные операторы разыменования или доступа к членам (открытые и не удаленные);
- Конструктор копий или оператор присваивания копирования (открытый и неудаленный);
- Открытый деструктор, не являющийся ни удаленным, ни установленным по умолчанию. Пустые деструкторы по-прежнему считаются определяемыми пользователем.

## <a name="example"></a>Пример
ненужная сложность интерфейса

```cpp
template<class T>
std::string to_string(const std::shared_ptr<T> &e) // C26418, also C26415 SMART_PTR_NOT_NEEDED
{
    return !e ? null_string : e->to_string();
}
```

## <a name="example"></a>Пример
ненужная сложность интерфейса — упрощенная

```cpp
template<class T>
std::string to_string(const T *e)
{
    return !e ? null_string : e->to_string();
}
```
