---
title: C26400
ms.date: 08/02/2017
ms.topic: conceptual
f1_keywords:
- C26400
helpviewer_keywords:
- C26400
ms.assetid: b27e1c6d-8b52-40b3-9760-b93afef19c7a
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: ea1e4a708765a173231689cd9c2037a4a20158af
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/07/2019
ms.locfileid: "72016617"
---
# <a name="c26400-no_raw_pointer_assignment"></a>C26400 NO_RAW_POINTER_ASSIGNMENT

Эта проверка позволяет применить параметр *rule I. 11: Никогда не переносите владение необработанным указателем (T @ no__t-0)* , который является подмножеством правила *R. 3: Необработанный указатель (a T @ no__t-0) не является владельцем.* В частности, он предупреждает о любом вызове оператора `new`, который сохраняет результат в переменной необработанного типа указателя. Он также предупреждает о вызовах функций, которые возвращают `gsl::owner<T>`, если их результаты назначены необработанным указателям. Идея здесь заключается в том, что следует четко указать владение ресурсами памяти. Дополнительные сведения см. в [ C++ разделе Основные рекомендации](http://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r-resource-management).

Самый простой способ исправить это — использовать объявление `auto`, если ресурс был назначен немедленно в объявлении переменной. Если это невозможно, мы рекомендуем использовать тип `gsl::owner<T>`. Объявления `auto`, инициализированные оператором `new`, являются "владельцыми", так как предполагается, что результат любого выделения неявно является указателем владельца. Мы переносите это допущение в переменную `auto` и обрабатывают его как `owner<T>`.

Если эта проверка помечает вызов функции, которая возвращает `owner<T>`, это может быть указанием допустимой ошибки в коде. По сути, он указывает на место, где код утечекет явное понятие владения (и, возможно, сам ресурс).

## <a name="remarks"></a>Примечания

Это правило в настоящее время проверяет только локальные переменные. Если распределение назначается формальному параметру, глобальной переменной, члену класса и т. д., он не отмечается. Подходящее покрытие таких сценариев является частью будущей работы.

## <a name="example-1-simple-allocation"></a>Пример 1: Простое выделение

```cpp
char *buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // C26400
```

## <a name="example-2-simple-allocation-fixed-with-gslownert"></a>Пример 2: Простое выделение (исправлено с помощью GSL:: owner @ no__t-0T >)

```cpp
gsl::owner<char*> buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // OK

Example 3: Simple allocation (fixed with auto)
auto buffer = useCache ? GetCache() : new char[bufferSize]; // OK
```
