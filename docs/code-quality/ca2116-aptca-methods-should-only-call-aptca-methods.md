---
title: CA2116. APTCA-методы должны вызывать только APTCA-методы
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- AptcaMethodsShouldOnlyCallAptcaMethods
- CA2116
helpviewer_keywords:
- AptcaMethodsShouldOnlyCallAptcaMethods
- CA2116
ms.assetid: 8b91637e-891f-4dde-857b-bf8012270ec4
author: gewarren
ms.author: gewarren
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: f09817e9248fdc28f56ac0162e783bf72643ee5c
ms.sourcegitcommit: 0c2523d975d48926dd2b35bcd2d32a8ae14c06d8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/24/2019
ms.locfileid: "71232688"
---
# <a name="ca2116-aptca-methods-should-only-call-aptca-methods"></a>CA2116. APTCA-методы должны вызывать только APTCA-методы

|||
|-|-|
|TypeName|AptcaMethodsShouldOnlyCallAptcaMethods|
|CheckId|CA2116|
|Категория|Microsoft.Security|
|Критическое изменение|Критическое|

## <a name="cause"></a>Причина:

Метод в сборке с <xref:System.Security.AllowPartiallyTrustedCallersAttribute?displayProperty=fullName> атрибутом вызывает метод в сборке, не имеющей атрибута.

## <a name="rule-description"></a>Описание правила

По умолчанию открытые или защищенные методы в сборках со строгими именами неявно защищаются с помощью [ссылки на запросы](/dotnet/framework/misc/link-demands) полного доверия. только полностью доверенные вызывающие объекты могут обращаться к сборке со строгим именем. Сборки со строгими именами, помеченные <xref:System.Security.AllowPartiallyTrustedCallersAttribute> атрибутом (APTCA), не имеют такой защиты. Атрибут отключает запрос компоновки, делая сборку доступным для вызывающих объектов, которые не имеют полного доверия, например кода, выполняемого из интрасети или Интернета.

Если атрибут APTCA имеется в полностью доверенной сборке, а сборка выполняет код в другой сборке, которая не допускает частично доверенных вызывающих объектов, возможно, используется уязвимость безопасности. Если два метода `M1` и `M2` отвечают приведенным ниже условиям, то вредоносные вызывающие `M1` объекты могут использовать метод для обхода неявного запроса `M2`ссылки с полным доверием, защищающего:

- `M1`— Это открытый метод, объявленный в полностью доверенной сборке, имеющей атрибут APTCA.

- `M1`вызывает метод `M2` вне `M1`сборки.

- `M2`не имеет атрибута APTCA и, следовательно, не должен выполняться или от имени вызывающих объектов с частичным доверием.

Вызывающий объект `X` с частичным доверием может вызвать метод `M2`, вызывающий `M1` вызов метода `M1`. Поскольку `M2` не имеет атрибута APTCA, его непосредственный вызывающий`M1`объект () должен соответствовать запросу компоновки для полного доверия. `M1` имеет полное доверие и, следовательно, удовлетворяет этой проверке. Угроза безопасности заключается в том `X` , что не участвует в выполнении запроса компоновки, который защищает `M2` от ненадежных вызывающих объектов. Поэтому методы с атрибутом APTCA не должны вызывать методы, не имеющие атрибута.

## <a name="how-to-fix-violations"></a>Устранение нарушений
Если требуется атрибут АПКТА, используйте требование для защиты метода, который вызывает сборку с полным доверием. Точные требуемые разрешения зависят от функциональных возможностей, предоставляемых вашим методом. Если возможно, защитите метод с помощью запроса полного доверия, чтобы обеспечить недоступность базовой функциональности вызывающим объектам с частичным доверием. Если это невозможно, выберите набор разрешений, которые эффективно защищают предоставляемую функциональность.

## <a name="when-to-suppress-warnings"></a>Когда следует подавлять предупреждения
Чтобы безопасно отключить предупреждение из этого правила, необходимо убедиться, что функциональные возможности, предоставляемые методом, напрямую или косвенно разрешают вызывающим объектам доступ к конфиденциальным сведениям, операциям или ресурсам, которые могут быть использованы необратимым образом.

## <a name="example-1"></a>Пример 1
В следующем примере используются две сборки и тестовое приложение для демонстрации уязвимости системы безопасности, обнаруженной этим правилом. Первая сборка не имеет атрибута APTCA и не должна быть доступна для частично доверенных вызывающих объектов (представленных `M2` в предыдущем обсуждении).

[!code-csharp[FxCop.Security.NoAptca#1](../code-quality/codesnippet/CSharp/ca2116-aptca-methods-should-only-call-aptca-methods_1.cs)]

## <a name="example-2"></a>Пример 2
Вторая сборка является полностью доверенной и позволяет частично доверенным вызывающим объектам ( `M1` представленным в предыдущем обсуждении).

[!code-csharp[FxCop.Security.YesAptca#1](../code-quality/codesnippet/CSharp/ca2116-aptca-methods-should-only-call-aptca-methods_2.cs)]

## <a name="example-3"></a>Пример 3
Тестовое приложение (представленное `X` в предыдущем обсуждении) является частично доверенным.

[!code-csharp[FxCop.Security.TestAptcaMethods#1](../code-quality/codesnippet/CSharp/ca2116-aptca-methods-should-only-call-aptca-methods_3.cs)]

В этом примере выводятся следующие данные:

```txt
Demand for full trust:Request failed.
ClassRequiringFullTrust.DoWork was called.
```

## <a name="related-rules"></a>Связанные правила

- [CA2117: APTCA-типы должны расширять только базовые APTCA-типы](../code-quality/ca2117-aptca-types-should-only-extend-aptca-base-types.md)

## <a name="see-also"></a>См. также

- [Правила написания безопасного кода](/dotnet/standard/security/secure-coding-guidelines)
- [Использование библиотек из частично доверенного кода](/dotnet/framework/misc/using-libraries-from-partially-trusted-code)
- [Требования связывания](/dotnet/framework/misc/link-demands)
- [Данные и моделирование](/dotnet/framework/data/index)