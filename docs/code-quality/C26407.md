---
title: C26407
ms.date: 07/21/2017
ms.topic: conceptual
f1_keywords:
- C26407
helpviewer_keywords:
- C26407
ms.assetid: 5539907a-bfa0-40db-82a6-b860c97209e1
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 771f3e45403141e1e77da2dc941f3e08831577c2
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/07/2019
ms.locfileid: "72011831"
---
# <a name="c26407-dont_heap_allocate_unnecessarily"></a>C26407 DONT_HEAP_ALLOCATE_UNNECESSARILY
Чтобы избежать ненужного использования указателей, мы пытаемся обнаружить распространенные закономерности локальных распределений, например, когда результат вызова оператора New хранится в локальной переменной и впоследствии явно удален. Это поддерживает правило R. 5: *Предпочитать объекты с заданной областью, не выделяйте кучу без необходимости*. Предлагаемое исправление предназначено для использования типа RAII вместо необработанного указателя и позволяет ему работать с ресурсами. Если выделением является один объект, то он может быть очевидно ненужным, а локальная переменная типа объекта будет работать лучше.

## <a name="remarks"></a>Примечания
- Чтобы уменьшить число предупреждений, этот шаблон определяется только для указателей владельца. Поэтому сначала необходимо пометить владельцев надлежащим образом. Это можно легко расширить, чтобы охватить необработанные указатели, если мы получаем отзывы клиентов о поддержке такого сценария.
- Термин объекта с областью действия может оказаться неверной задачей, но общая идея состоит в том, что мы рекомендуем использовать локальную переменную, время существования которой управляется автоматически, или интеллектуальный объект, который эффективно управляет динамическими ресурсами. Смарт-объекты, конечно же, могут выделять память в куче, но не являются явными в коде.
- Если предупреждение срабатывает при выделении массива (которое обычно требуется для динамических буферов), можно использовать стандартные контейнеры или `std::unique_pointer<T[]>`.
- Шаблон обнаруживается только для локальных переменных, поэтому мы не будем предупреждать о тех случаях, когда выделение назначается, скажем, к глобальной переменной, а затем удаляется в той же самой функции.

## <a name="example-1-unnecessary-object-allocation-on-heap"></a>Пример 1: Ненужное выделение объекта в куче

```cpp
auto tracer = new Tracer();
ScanObjects(tracer);
delete tracer;  // C26407
```

## <a name="example-2-unnecessary-object-allocation-on-heap-fixed-with-local-object"></a>Пример 2: Ненужное выделение объекта в куче (с фиксированным локальным объектом)

```cpp
Tracer tracer;  // OK
ScanObjects(&tracer);
```

## <a name="example-3-unnecessary-buffer-allocation-on-heap"></a>Пример 3. Ненужное выделение буфера в куче

```cpp
auto value = new char[maxValueSize];
if (ReadSetting(name, value, maxValueSize))
    CheckValue(value);
delete[] value; // C26407
```

## <a name="example-4-unnecessary-buffer-allocation-on-the-heap-fixed-with-container"></a>Пример 4. Ненужное выделение буфера в куче (с фиксированным контейнером)

```cpp
auto value = std::vector<char>(maxValueSize); // OK
if (ReadSetting(name, value.data(), maxValueSize))
    CheckValue(value.data());
```
