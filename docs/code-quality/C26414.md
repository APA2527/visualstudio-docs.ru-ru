---
title: C26414
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26414
helpviewer_keywords:
- C26414
ms.assetid: dd875d0c-6752-4491-a533-3e8831795fbc
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 8ced283edb792ee917706974070dce407cc29f5a
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/07/2019
ms.locfileid: "72011674"
---
# <a name="c26414-reset_local_smart_ptr"></a>C26414 RESET_LOCAL_SMART_PTR

"Перемещение, копирование, переназначение или сброс локального смарт-указателя".

**C++ Основные рекомендации**: R. 5: Предпочитать объекты с заданной областью, не выделяйте кучу без необходимости

Интеллектуальные указатели удобны для управления динамическими ресурсами, но они не всегда требуются. Например, создание локального динамического буфера может быть легко (иногда более эффективно) управляется стандартными контейнерами. Для отдельных объектов может потребоваться динамическое выделение ресурсов (например, если такие объекты никогда не находились в своей функции Creator) и их можно заменить локальными переменными. Смарт-указатели становятся удобными, когда сценарий требует смены владельца, т. е. повторного назначения динамического ресурса несколько раз или в нескольких путях. Сюда также входят случаи, когда ресурсы получаются из внешнего кода, а смарт-указатели используются для расширения времени существования ресурса.

## <a name="remarks"></a>Примечания

- В дополнение к стандартным шаблонам std:: unique_pointer и std:: shared_pointer эта проверка распознает определяемые пользователем типы, которые, скорее всего, должны быть смарт-указателями. Такие типы должны определять следующие операции:
  - перегруженные операторы разыменования или доступа к членам, которые являются открытыми и не помечены как удаленные;
  - Открытый деструктор, не являющийся ни удаленным, ни установленным по умолчанию. Сюда входят деструкторы, которые явно определены как пустые.
  - Тип Microsoft:: WRL:: ComPtr ведет себя как общий указатель, но часто используется в специфических сценариях, на которые влияет управление жизненным циклом COM. Чтобы избежать чрезмерного шума, этот тип фильтруется.
  - Эта проверка выполняет поиск явных локальных выделений, назначенных смарт-указателям, чтобы определить, являются ли переменные с областью в качестве альтернативы. Помимо прямых вызовов оператора New, Специальные функции, такие как std:: make_unique и std:: make_shared, также считаются прямыми выделениями.

## <a name="example"></a>Пример

динамический буфер

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::make_unique<char[]>(f.size()); // C26414
    f.unpack(buffer.get());
    // ...
}
```

динамический буфер — заменяется контейнером

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::vector<char>(f.size());
    f.unpack(buffer.data());
    // ...
}
```
