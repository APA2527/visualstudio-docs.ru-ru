---
title: C26411
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26411
helpviewer_keywords:
- C26411
ms.assetid: 5134e51e-8b92-4ee7-94c3-022e318a0e24
author: mikeblome
ms.author: mblome
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: f5b32327ad74d89b5351cbdaaa4efeebb7ec3379
ms.sourcegitcommit: 94b3a052fb1229c7e7f8804b09c1d403385c7630
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62572084"
---
# <a name="c26411--noreftouniqueptr"></a>C26411  NO_REF_TO_UNIQUE_PTR

Передача по ссылке уникальный указатель предполагается, что ее ресурсов может быть выпущен или передаваемых внутри целевой функции. Если функция использует ее параметр только для доступа к ресурсу, его можно безопасно передавать необработанный указатель или ссылка.

## <a name="remarks"></a>Примечания

- Ограничения от предупреждений [C26410](C26410.md) применимы здесь также.

- Эвристический алгоритм для определения доступа «выпуск» или «сброс» на уникальный указатель является довольно наивный: мы обнаруживает только вызовы операторы присваивания и функции с именем «Сброс» (без учета регистра). Очевидно, что эта функция не охватывает все возможные случаи смарт-указатель изменений (например, std::swap или любые специальные неконстантной функции в пользовательских смарт-указатель). Предполагается, что это предупреждение будет создавать много ложных срабатываний для пользовательских типов, а также в некоторых сценариях, посвященные стандартный уникальных указателей. Будет улучшена эвристика, как мы реализуем больше проверок, посвященные интеллектуальные указатели.

- Тот факт, что смарт-указатели – часто шаблоны привносит интересных ограничения, связанные с тот факт, что компилятор не требуется обрабатывать код шаблона в шаблонах, если он не используется. В некоторых базах минимальный код, которые ограниченное использование интерфейсов смарт-указатель средство проверки может привести к непредвиденным результатам, из-за неспособности правильно определить семантику типа шаблона (так как некоторые важные функции никогда не может использоваться). Для стандартной `unique_pointer`, это ограничение будет устранен, распознавая имя типа. Они могут быть добавлены в будущем для охвата более известны интеллектуальные указатели.

- Лямбда-выражения с помощью неявного записи по ссылке может привести к неожиданным предупреждения о ссылки на уникальный указатели. В настоящее время все параметры записанный эталонный в лямбда-выражений выводятся, независимо от того, сбрасываются или нет. Эвристика здесь будут расширены для сопоставления поля лямбда-выражения с параметрами лямбда-выражения в будущем выпуске.

## <a name="example-unnecessary-reference"></a>Пример Ненужные ссылки

```cpp
void TraceValid(std::unique_ptr<Slot> &slot)    // C26411
{
    if (!IsDamaged(slot.get()))
        std::cout << *slot.get();
}

void ReleaseValid(std::unique_ptr<Slot> &slot)  // OK
{
    if (!IsDamaged(slot.get()))
        slot.reset(nullptr);
}
```